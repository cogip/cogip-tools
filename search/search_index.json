{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This repository provides all Python tools developed by the COGIP robotic team. The team is developing a robot for Eurobot, French robotic contest.</p> <p>All the tools are used during the game itself, or for development, debugging and monitoring of the robot and other test platforms.</p>"},{"location":"#robot-software-architecture","title":"Robot Software Architecture","text":"<p>The main components of the robot are:</p> <ul> <li>a STM32 that runs <code>mcu-firmware</code>,</li> <li>a Raspberry Pi 4 that controls a camera, a touchscreen and a Lidar.</li> </ul> <p>The robot is associated with a central beacon having an upper view of the game area, composed of a Raspberry Pi 4, a camera and a touchscreen.</p> <p></p> <p>Tools running on the robot's Raspberry Pi 4 are:</p> <ul> <li><code>Server</code> connecting all components through a SocketIO server.</li> <li><code>Dashboard</code> a web server providing a dashboard to control and monitor the robot.</li> <li><code>Planner</code> in charge of the game strategy.</li> <li><code>Copilot</code> driving the robot moves by communicating     with <code>mcu-firmware</code> (on STM32) using Protobuf messages over a serial port.</li> <li><code>Detector</code> generating obstacles based on Lidar data.</li> <li><code>Robotcam</code> reading and analyzing images from the camera.</li> </ul> <p>Tools running on the central beacon's Raspberry Pi 4 are:</p> <ul> <li><code>Server Beacon</code> connecting all beacon components through a SocketIO server,   and connected to the SocketIO server of all robots.     It also runs a web server providing a <code>Dashboard</code> to control and monitor the robot.</li> <li><code>Dashboard</code>, a web server providing a dashboard to control and monitor the beacon, and display the dashboard of all robots.</li> <li><code>Beaconcam</code> reading and analyzing images of the game area from the camera.</li> </ul> <p>Beacon services will be redesigned and are not yet available. Robots can run standalone.</p> <p><code>Monitor</code> is running on a PC connected to the SocketIO server.</p> <p><code>Camera</code> provides different commands to get information about cameras, calibrate them and detect Aruco tags.</p> <p>The touchscreens display the <code>Dashboard</code> using an web browser embedded in the Raspberry Pi.</p>"},{"location":"#emulation-software-architecture","title":"Emulation Software Architecture","text":"<p>During development, an emulation environment is also available. In this case, all robot and beacon components are running on the development PC.</p> <p></p> <p>In this mode, fake Lidar data are provided by the <code>Monitor</code>.</p>"},{"location":"install/","title":"Setup","text":"<p>There are two ways to setup the environment to develop and run the tools.</p> <ul> <li> <p>The Manual method requires to configure the environment on the development computer and to run tools one by one. This method also briefly explains how to build the firmware for the real MCU.</p> </li> <li> <p>The Docker method provides a complete Docker Compose stack that configure, compile and run each tool using only one command.</p> </li> </ul> <p>To prepare SDCards for Raspberry Pi SDCards for robots and beacon, refer to the Raspberry Pi OS section.</p>"},{"location":"install/#common-setup","title":"Common Setup","text":""},{"location":"install/#os","title":"OS","text":"<p>Linux only.</p> <p>Tested on Ubuntu 24.04 (with Xorg instead of Wayland for proper display of the Monitor).</p>"},{"location":"install/#debian-packages","title":"Debian packages","text":"<pre><code>sudo apt install git build-essential\n</code></pre>"},{"location":"install/#git-submodules","title":"Git Submodules","text":"<p>The tools depend on the compatible version of cogip/mcu-firmware which also depends on a specific version of RIOT-OS/RIOT. So to avoid struggle in finding the correct versions of the dependencies, we use git submodules to fix the versions of <code>mcu-firmware</code> and <code>RIOT</code>. Do not forget to fetch the submodules after <code>git clone</code>:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"install/#manual-method","title":"Manual Method","text":""},{"location":"install/#debian-packages_1","title":"Debian packages","text":"<pre><code>sudo apt install libxcb-xinerama0 socat protobuf-compiler build-essential swig cmake pkg-config libserial-dev\n</code></pre>"},{"location":"install/#build-mcu-firmware","title":"Build mcu-firmware","text":"<p>See the <code>Requirements</code> section of <code>submodules/mcu-firmware/README.md</code> to setup the build environment.</p> <p>Use the following command to build the native version of the firmware:</p>"},{"location":"install/#native-build","title":"Native build","text":"<pre><code>make -C submodules/mcu-firmware/applications/cup2023 BOARD=cogip-native\n</code></pre>"},{"location":"install/#arm-build","title":"ARM build","text":"<p>Use the following command to build the ARM version of the firmware:</p> <pre><code>make -C submodules/mcu-firmware/applications/cup2023 BOARD=cogip-board-ng\n</code></pre>"},{"location":"install/#installation","title":"Installation","text":"<p>All tools can be installed on the development PC.</p> <p>Python installation is managed by uv, so it is independent from Python version provided by the OS.</p> <ul> <li>Install uv following the official documentation, like with the following command:</li> </ul> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Read carefully advices to make uv accessible on your PATH.</p> <ul> <li>Install the package in dev/editable mode (default mode for uv):</li> </ul> <pre><code>uv sync\n</code></pre>"},{"location":"install/#linting-and-formatting","title":"Linting and Formatting","text":"<p>While installing the <code>dev</code> environment, <code>ruff</code> and <code>pre-commit</code> package have been installed.</p> <p>To run <code>ruff</code> manually, just run:</p> <pre><code>uv run ruff check [--fix]\nuv run ruff format\n</code></pre> <p>To enable pre-commit hooks prevent committing code not respecting linting and formatting rules, run:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#packaging-and-deployment","title":"Packaging and Deployment","text":"<p>This section explains how to build a new binary package and deploy it on a Raspberry Pi.</p> <p>A Docker Compose service is provided to build a binary distribution package for linux/arm64 platform.</p> <pre><code>docker compose up --build build_wheel\n</code></pre> <p>This will produce <code>dist/cogip_tools-1.0.0-cp312-abi3-linux_aarch64.whl</code>.</p> <p>This package can be copied to the Raspberry Pi and installed to deploy the Python tools:</p> <pre><code>uv pip install cogip_tools-1.0.0-cp312-abi3-linux_aarch64.whl\n</code></pre> <p>Docker image for linux/arm64</p> <p>The <code>build_wheel</code> service is based on a image built from a Ubuntu image. If this image was already pulled for the <code>linux/amd64</code> platform, the <code>linux/arm64</code> may not be pulled automatically. If the <code>docker compose</code> command is failing for this reason, the required image can be pulled manually: <code>bash docker pull --platform \"linux/arm64\" debian:12</code></p>"},{"location":"install/#docker-method","title":"Docker Method","text":""},{"location":"install/#docker-installation","title":"Docker Installation","text":"<p>See Docker installation instructions.</p>"},{"location":"install/#virtual-can-interface-setup","title":"Virtual CAN Interface Setup","text":"<p><code>Firmware</code> communicates with <code>Copilot</code> using a CAN interface. In emulation mode, a virtual CAN interface (<code>vcan</code>) must be configured on host for each robot before running the Compose stack.</p> <p>Configure <code>vcan1</code> using the two following files:</p> <ul> <li><code>/etc/systemd/network/80-vcan.network</code></li> </ul> <pre><code>[Match]\nName=vcan*\n\n[CAN]\nBitRate=500000\nDataBitRate=1000000\nSamplePoint=87.5%\nFDMode=yes\n</code></pre> <ul> <li><code>/etc/systemd/network/vcan1.netdev</code></li> </ul> <pre><code>[NetDev]\nName=vcan1\nKind=vcan\nMTUBytes=72\nDescription=Virtual CAN1 network interface\n</code></pre> <p>Up to 5 robots are supported, so 5 vcan interfaces are required. Create a <code>vcanX.netdev</code> for each interfaces from <code>vcan1</code> to <code>vcan5</code>.</p> <p>Restart systemd-networkd service to setup:</p> <pre><code>sudo systemctl restart systemd-networkd\n</code></pre> <p>Check <code>vcan</code> interfaces are up:</p> <pre><code>$ networkctl | grep vcan\n  3 vcan1           can      carrier     configured\n  3 vcan2           can      carrier     configured\n  3 vcan3           can      carrier     configured\n  3 vcan4           can      carrier     configured\n  3 vcan5           can      carrier     configured\n\n$ ip address show dev vcan1\n3: vcan0: &lt;NOARP,UP,LOWER_UP&gt; mtu 72 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/can\n</code></pre>"},{"location":"install/#x-server","title":"X Server","text":"<p>The <code>Monitor</code> is working with X11 but does not behave correctly with Wayland.</p> <p>To allow the <code>Monitor</code> process running in a Docker container to access the X Server running on the host, you need to run the following command in a terminal:</p> <p><code>$ xhost +local:</code></p>"},{"location":"install/#configuration","title":"Configuration","text":"<p>The configuration of the tools is done by setting environment variables in the <code>.env</code> file.</p> <p>All variables supported by the tools are forwarded inside Docker containers.</p>"},{"location":"install/#usergroup-ids-mapping","title":"User/Group IDs Mapping","text":"<p>The user/group ID used inside Docker containers to run COGIP tools must match those of the host system to ensure that shared memory segments created by the tools are owned by the same user/group as on the host.</p> <p>Default UID/GID is <code>1000</code>, change them if needed in the <code>.env</code> file:</p> <pre><code>UID=1001\nGID=1001\n</code></pre>"},{"location":"install/#compose-profiles","title":"Compose Profiles","text":"<p>Several profiles are defined to select which containers to run:</p> <ul> <li><code>beacon</code>: for the beacon container</li> <li><code>robotX</code>: for robot X containers (1 &lt;= X &lt;= 4)</li> <li><code>monitorX</code>: for <code>Monitor</code> container of robot X (1 &lt;= X &lt;= 4)</li> </ul> <p>Profiles are set in the <code>.env</code> file:</p> <p><code>COMPOSE_PROFILES=beacon,robot1,robot2</code></p>"},{"location":"install/#build-images","title":"Build Images","text":"<p>Build Docker images:</p> <p><code>docker compose build</code></p>"},{"location":"install/#run-all-tools","title":"Run All Tools","text":"<p>Start the Compose stack:</p> <p><code>docker compose up</code></p> <p>Use <code>--build</code> option to build images and start the stack:</p> <p><code>docker compose up --build</code></p>"},{"location":"install/#automatic-restart-on-changes","title":"Automatic Restart on Changes","text":"<p>To automatically restart the services on Python source files changes or rebuild C++ extensions on C++ source files changes, use the <code>--watch</code> option:</p> <p><code>docker compose up --build --watch</code></p>"},{"location":"install/#dashboards-access","title":"Dashboards Access","text":"<p>The <code>Beacon Dashboard</code> (if enabled in <code>.env</code>) is accessible using a web browser at <code>http://localhost:8080</code>.</p> <p>The <code>Dashboard</code> for robot X (if enabled in <code>.env</code>) is accessible using a web browser at <code>http://localhost:808X</code>.</p>"},{"location":"install/#running-monitor","title":"Running Monitor","text":"<p>Instead of running <code>Monitor</code> from the Compose stack, it can be launched for robot X (if enabled in <code>.env</code>) with:</p> <pre><code>uv run cogip-monitor http://localhost:809X\n</code></pre>"},{"location":"raspios/","title":"Raspberry Pi OS Customization","text":"<p>The <code>raspios</code> directory provides a series of scripts to build and flash a custom Raspberry Pi OS images running COGIP tools on the Pi 4 embedded in the beacon and robots.</p> <p>It works by creating a Docker image based on Raspberry Pi OS Lite, use Dockerfiles to install/configure/remove softwares and services, extract and build the customized image, and flash it on a SDCard.</p>"},{"location":"raspios/#network-configuration","title":"Network Configuration","text":"<p>Default network configuration is represented on the following schema:</p> <p></p>"},{"location":"raspios/#requirements","title":"Requirements","text":"<ul> <li>Docker</li> </ul> <p>See Docker installation instructions.</p> <ul> <li>ARM Emulation</li> </ul> <pre><code>$ sudo apt-get install binfmt-support qemu-user-static zerofree\n$ docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n</code></pre>"},{"location":"raspios/#configuration","title":"Configuration","text":"<p>Two configuration profiles are provided:   - <code>cup</code>: a configuration for the cup, to setup robots and beacon   - <code>dev</code>: a configuration for development environment without beacon Select a profile by setting the <code>PROFILE</code> variable to either <code>cup</code> or <code>dev</code>.</p> <p>The following variables must be set before running any script:   - ROBOT_ID   - PUBLIC_WLAN_SSID   - PUBLIC_WLAN_PSK Those variables are set to <code>NOT_SET</code> by default and will be checked will loading the config files.</p> <p><code>ROBOT_ID</code> possible values:   - 0:   for the beacon   - 1-9: for the robots</p> <p>The PSK value can be generated from the WiFi password using the following command:</p> <pre><code>$ wpa_passphrase MYSSID passphrase\nnetwork={\n        ssid=\"MYSSID\"\n        #psk=\"passphrase\"\n        psk=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d\n}\n</code></pre> <p>The micro SD card device can be customized using related environment variables Example for micro-SD card to SD card adapter on <code>/dev/mmcblk0</code> (default values):</p> <pre><code>SDCARD_DEV=/dev/mmcblk0\nSDCARD_DEV_BOOT=${SDCARD_DEV}p1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}p2\n</code></pre> <p>Example for micro-SD card to USB adapter on <code>/dev/sda</code>:</p> <pre><code>SDCARD_DEV=/dev/sda\nSDCARD_DEV_BOOT=${SDCARD_DEV}1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}2\n</code></pre> <p>Customized variables can be set in the environment or in a local, not-committed <code>.env</code> file in the <code>raspios</code> directory.</p> <p>Example of a complete <code>.env</code> file:</p> <pre><code>PROFILE=dev\nROBOT_ID=1\nPUBLIC_WLAN_SSID=MYSSID\nPUBLIC_WLAN_PSK=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d\nSDCARD_DEV=/dev/sda\nSDCARD_DEV_BOOT=${SDCARD_DEV}1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}2\n</code></pre>"},{"location":"raspios/#stage-0","title":"Stage 0","text":"<p>First stage builds a docker image from original Raspios image.</p> <pre><code>$ ./stage0_base_image.sh\n</code></pre>"},{"location":"raspios/#stage-1","title":"Stage 1","text":"<p>Build a customized docker image:  - install required Debian and Python packages  - configure required services  - install COGIP tools</p> <pre><code>$ ./stage1_customize_image.sh\n</code></pre>"},{"location":"raspios/#stage-1b-under-development","title":"Stage 1b (under development)","text":"<p>This stage is optional and allow to build a custom kernel image. It is not working yet so not documented.</p>"},{"location":"raspios/#stage-2","title":"Stage 2","text":"<p>Create the custom filesystem image.</p> <pre><code>$ ./stage2_create_image.sh\n</code></pre>"},{"location":"raspios/#stage-3","title":"Stage 3","text":"<p>Flash the filesystem image on SDCard.</p> <pre><code>$ ./stage3_flash_image.sh\n</code></pre>"},{"location":"developers/dashboard/","title":"Dashboard documentation","text":"<p>The dashboard is written with vanilla JS, CSS and HTML (and love). We made the choice to not used any frameworks like Angular or Vue.js... because dashboard is a very small web site.</p> <p>This dashboard uses only two externals frameworks, which are TailwindCSS and Socket.io.</p> <p>Socket.io is useful to dynamically receive events from Copilot and display them.</p> <p>TailwindCSS is a utility-first CSS framework packed with classes like flex, pt-4, text-center and rotate-90 that can be composed to build any design.</p> <p>The manipulation below needs to be done each time we add or remove a class in html, css or js files in server.</p> <p>This command line has to be executed in <code>cogip-tools/cogip/tools/dashboard</code>.</p> <ol> <li> <p>Install npm    <code>sudo apt install npm</code></p> </li> <li> <p>Install PurgeCSS as CLI (you may need to be super user)    <code>npm install</code></p> </li> <li> <p>Run command to generate css file according to what we use in our html, js and css files    <code>npx tailwindcss -i cogip/tools/dashboard/static/css/input.css -o cogip/tools/dashboard/static/css/prod/output.css --watch --minify</code></p> </li> </ol> <p>Useful documentation:</p> <p>- https://purgecss.com/CLI.html</p>"},{"location":"developers/developers/","title":"Developer's Documentation","text":"<p>This documentation provides information for developers who would like to contribute to the project. It tries to explain how modules are organized and how <code>PySide6</code> and <code>Qt3D</code> are used.</p> <p>COGIP tools are developed in Python 3.12+, using <code>Pyside6</code>, the Qt for Python package.</p> <p>The 3D view is based on the <code>Qt3D framework</code>. To have a better understanding of the code, it is important to understand Qt concepts like Signals and Slots, and the Qt3D Entity Component System (ECS).</p> <p>Here are some interesting blogs and docs to understand the Qt3D architecture:</p> <ul> <li>https://doc.qt.io/qt-6/qt3d-overview.html#qt-3d-architecture</li> <li>https://www.kdab.com/overview-qt3d-2-0-part-1/</li> <li>https://www.kdab.com/overview-qt3d-2-0-part-2/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-1-guido-piasenza/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-2-guido-piasenza/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-3-guido-piasenza/</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cogip<ul> <li>models<ul> <li>actuators</li> <li>artifacts</li> <li>models</li> </ul> </li> <li>scservo_sdk<ul> <li>group_sync_read</li> <li>group_sync_write</li> <li>port_handler</li> <li>protocol_packet_handler</li> <li>scscl</li> <li>scservo_def</li> <li>sms_sts</li> </ul> </li> <li>tools<ul> <li>beaconcam<ul> <li>__main__</li> <li>app</li> <li>camera</li> <li>codecs</li> <li>main</li> <li>server</li> <li>settings</li> </ul> </li> <li>camera<ul> <li>__main__</li> <li>arguments</li> <li>calibrate</li> <li>capture</li> <li>detect</li> <li>info</li> <li>utils</li> </ul> </li> <li>cansend<ul> <li>__main__</li> </ul> </li> <li>copilot<ul> <li>__main__</li> <li>controller</li> <li>copilot</li> <li>menu</li> <li>pbcom</li> <li>pid</li> <li>sio_events</li> </ul> </li> <li>cpp_cython_example<ul> <li>__main__</li> </ul> </li> <li>cpp_logger_example<ul> <li>__main__</li> </ul> </li> <li>cpp_nanobind_example<ul> <li>__main__</li> </ul> </li> <li>cpp_shm_example<ul> <li>__main__</li> </ul> </li> <li>dashboard<ul> <li>__main__</li> <li>app</li> <li>dashboard</li> <li>routes<ul> <li>beacon</li> </ul> </li> </ul> </li> <li>detector<ul> <li>__main__</li> <li>detector</li> <li>gui</li> <li>menu</li> <li>properties</li> <li>sio_events</li> <li>web</li> </ul> </li> <li>lidar_ld19<ul> <li>__main__</li> <li>gui</li> <li>web</li> </ul> </li> <li>mcu_logger<ul> <li>__main__</li> </ul> </li> <li>monitor<ul> <li>__main__</li> <li>actuators</li> <li>artifacts</li> <li>asset</li> <li>chartsview</li> <li>dynobstacle</li> <li>gameview</li> <li>help</li> <li>impact</li> <li>line</li> <li>main</li> <li>mainwindow</li> <li>obstacle</li> <li>path</li> <li>properties</li> <li>robot</li> <li>robot_manual</li> <li>robot_order</li> <li>robots</li> <li>sensor</li> <li>socketiocontroller</li> <li>table</li> <li>wizard</li> </ul> </li> <li>planner<ul> <li>__main__</li> <li>actions<ul> <li>action_align</li> <li>action_build_tribune_x1</li> <li>action_build_tribune_x2</li> <li>action_build_tribune_x3</li> <li>action_capture_tribune</li> <li>action_drop_banner</li> <li>action_parking</li> <li>actions</li> <li>camera_calibration</li> <li>pami</li> <li>pid_position_test</li> <li>pid_speed_test</li> <li>test_align_bottom</li> <li>test_align_bottom_banner</li> <li>test_approval</li> <li>test_back_and_forth</li> <li>test_drop_banner</li> <li>test_game_1</li> <li>test_game_2</li> <li>test_squares</li> <li>test_tribunes_1x2</li> <li>test_tribunes_1x3</li> <li>test_tribunes_2x1</li> <li>test_tribunes_2x2</li> <li>test_tribunes_2x3</li> <li>test_tribunes_4x1</li> <li>test_visit_starting_areas</li> </ul> </li> <li>actuators</li> <li>avoidance<ul> <li>avoidance</li> <li>process</li> </ul> </li> <li>cameras</li> <li>camp</li> <li>context</li> <li>menu</li> <li>planner</li> <li>pose</li> <li>positions</li> <li>properties</li> <li>scservos</li> <li>sio_events</li> <li>table</li> <li>wizard</li> </ul> </li> <li>robotcam<ul> <li>__main__</li> <li>app</li> <li>camera</li> <li>main</li> <li>server</li> <li>settings</li> </ul> </li> <li>scservo<ul> <li>__main__</li> <li>common</li> <li>ping</li> <li>read</li> <li>reg_write</li> <li>sync_write</li> <li>wheel</li> <li>write</li> </ul> </li> <li>server<ul> <li>__main__</li> <li>app</li> <li>context</li> <li>namespaces<ul> <li>beacon</li> <li>copilot</li> <li>dashboard</li> <li>detector</li> <li>monitor</li> <li>planner</li> <li>robotcam</li> </ul> </li> <li>server</li> </ul> </li> <li>server_beacon<ul> <li>__main__</li> <li>app</li> <li>menu</li> <li>namespaces<ul> <li>dashboard</li> </ul> </li> <li>robot</li> <li>server</li> </ul> </li> <li>ydlidar_g2<ul> <li>__main__</li> <li>gui</li> <li>web</li> </ul> </li> </ul> </li> <li>utils<ul> <li>argenum</li> <li>asyncloop</li> <li>lidartablemodel</li> <li>logger</li> <li>singleton</li> <li>threadloop</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cogip/models/actuators/","title":"actuators","text":""},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ActuatorBase","title":"<code>ActuatorBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ActuatorBase(BaseModel):\n    \"\"\"Base model for actuators\"\"\"\n\n    enabled: bool = Field(\n        False,\n        title=\"Enabled\",\n        description=\"An actuator is enabled if it has been initialized with its current value\",\n    )\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ActuatorsKindEnum","title":"<code>ActuatorsKindEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining actuators kind</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ActuatorsKindEnum(IntEnum):\n    \"\"\"Enum defining actuators kind\"\"\"\n\n    servo = 0\n    positional_actuator = 1\n    bool_sensor = 2\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.BoolSensor","title":"<code>BoolSensor</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining bool sensor state</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class BoolSensor(BaseModel):\n    \"\"\"Model defining bool sensor state\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.bool_sensor] = ActuatorsKindEnum.bool_sensor\n    id: Annotated[\n        BoolSensorEnum,\n        Field(\n            title=\"Id\",\n            description=\"Bool sensor identifier\",\n        ),\n    ]\n    state: Annotated[\n        bool,\n        Field(\n            title=\"State\",\n            description=\"Bool sensor state\",\n        ),\n    ] = False\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.BoolSensorEnum","title":"<code>BoolSensorEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining bool sensors IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class BoolSensorEnum(IntEnum):\n    \"\"\"Enum defining bool sensors IDs\"\"\"\n\n    UNDEFINED = 0\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuator","title":"<code>PositionalActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>PositionalActuatorCommand</code></p> <p>Full model for positional actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuator(ActuatorBase, PositionalActuatorCommand):\n    \"Full model for positional actuators\"\n\n    pass\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorCommand","title":"<code>PositionalActuatorCommand</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining a command to send to positional actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuatorCommand(BaseModel):\n    \"\"\"Model defining a command to send to positional actuators\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.positional_actuator] = ActuatorsKindEnum.positional_actuator\n    id: PositionalActuatorEnum = Field(..., title=\"Id\", description=\"Positional Actuator identifier\")\n    command: int = Field(\n        0,\n        ge=-100,\n        le=999,\n        title=\"Position Command\",\n        description=\"Current positional actuator position command\",\n    )\n    speed: int = Field(\n        100,\n        ge=1,\n        le=100,\n        title=\"Speed\",\n        description=\"Speed\",\n    )\n    timeout: int = Field(\n        2000,\n        ge=100,\n        le=5000,\n        title=\"Timeout\",\n        description=\"Timeout\",\n    )\n\n    @field_validator(\"kind\", mode=\"before\")\n    @classmethod\n    def validate_kind(cls, v: str) -&gt; ActuatorsKindEnum:\n        try:\n            value = ActuatorsKindEnum[v]\n        except KeyError:\n            try:\n                value = ActuatorsKindEnum(v)\n            except Exception:\n                raise ValueError(\"Not a ActuatorsKindEnum\")\n        if value != ActuatorsKindEnum.positional_actuator:\n            raise ValueError(\"Not ActuatorsKindEnum.positional_actuator value\")\n        return value\n\n    @field_validator(\"id\", mode=\"before\")\n    @classmethod\n    def validate_id(cls, v: str) -&gt; PositionalActuatorEnum:\n        try:\n            return PositionalActuatorEnum[v]\n        except KeyError:\n            try:\n                return PositionalActuatorEnum(v)\n            except Exception:\n                raise ValueError(\"Not a PositionalActuatorEnum\")\n\n    def pb_copy(self, message: PB_PositionalActuatorCommand) -&gt; None:\n        \"\"\"Copy values to Protobuf message\"\"\"\n        message.id = self.id\n        message.command = self.command\n        message.speed = self.speed\n        message.timeout = self.timeout\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorCommand.pb_copy","title":"<code>pb_copy(message)</code>","text":"<p>Copy values to Protobuf message</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>def pb_copy(self, message: PB_PositionalActuatorCommand) -&gt; None:\n    \"\"\"Copy values to Protobuf message\"\"\"\n    message.id = self.id\n    message.command = self.command\n    message.speed = self.speed\n    message.timeout = self.timeout\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorEnum","title":"<code>PositionalActuatorEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining positional actuators IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuatorEnum(IntEnum):\n    \"\"\"Enum defining positional actuators IDs\"\"\"\n\n    MOTOR_LIFT = 0\n</code></pre>"},{"location":"reference/cogip/models/artifacts/","title":"artifacts","text":""},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionArea","title":"<code>ConstructionArea</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Model for construction area. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionArea(Pose):\n    \"\"\"\n    Model for construction area.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    id: ConstructionAreaID\n    length: float\n    width: float = 450\n    tribune_level: int = 0\n    enabled: bool = True\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionAreaID","title":"<code>ConstructionAreaID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify construction areas.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionAreaID(IntEnum):\n    \"\"\"\n    Enum to identify construction areas.\n    \"\"\"\n\n    LocalBottomSmall = auto()\n    LocalBottomLarge1 = auto()\n    LocalBottomLarge2 = auto()\n    LocalBottomLarge3 = auto()\n    OppositeBottomSmall = auto()\n    OppositeSideLarge1 = auto()\n    OppositeSideLarge2 = auto()\n    OppositeSideLarge3 = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionAreaLarge","title":"<code>ConstructionAreaLarge</code>","text":"<p>               Bases: <code>ConstructionArea</code></p> <p>Model for large construction area. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionAreaLarge(ConstructionArea):\n    \"\"\"\n    Model for large construction area.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    length: float = 450\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionAreaSmall","title":"<code>ConstructionAreaSmall</code>","text":"<p>               Bases: <code>ConstructionArea</code></p> <p>Model for small construction area. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionAreaSmall(ConstructionArea):\n    \"\"\"\n    Model for small construction area.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    length: float = 150\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.FixedObstacle","title":"<code>FixedObstacle</code>","text":"<p>               Bases: <code>Vertex</code></p> <p>Model for fixed obstacles.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class FixedObstacle(Vertex):\n    \"\"\"\n    Model for fixed obstacles.\n    \"\"\"\n\n    id: FixedObstacleID\n    length: float\n    width: float\n    enabled: bool = True\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.FixedObstacleID","title":"<code>FixedObstacleID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify fixed obstacles.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class FixedObstacleID(IntEnum):\n    \"\"\"\n    Enum to identify fixed obstacles.\n    \"\"\"\n\n    Ramp = auto()\n    Scene = auto()\n    PitArea = auto()\n    PamiStartArea = auto()\n    Pami5Path = auto()\n    OpponentRamp = auto()\n    OpponentScene = auto()\n    OpponentPitArea = auto()\n    Backstage = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.Tribune","title":"<code>Tribune</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Model for raw material stock. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class Tribune(Pose):\n    \"\"\"\n    Model for raw material stock.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    id: TribuneID\n    length: float = 400.0\n    width: float = 100.0\n    column_count: int = 4\n    platform_count: int = 2\n    levels: int = 0\n    construction_area: ConstructionAreaID | None = None\n    private: bool = False\n    enabled: bool = True\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.TribuneID","title":"<code>TribuneID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify raw material stock.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class TribuneID(IntEnum):\n    \"\"\"\n    Enum to identify raw material stock.\n    \"\"\"\n\n    LocalCenter = auto()\n    LocalTop = auto()\n    LocalTopTraining = auto()\n    LocalBottom = auto()\n    LocalTopSide = auto()\n    LocalBottomSide = auto()\n    OppositeCenter = auto()\n    OppositeTop = auto()\n    OppositeBottom = auto()\n    OppositeTopSide = auto()\n    OppositeBottomSide = auto()\n</code></pre>"},{"location":"reference/cogip/models/models/","title":"models","text":"<p>This module contains all data models used in the monitor.</p> <p>The models are based on Pydantic models, allowing them to be loaded from/exported to JSON strings/files. All values are automatically verified and converted to the expected data type, an exception being raised if impossible.</p>"},{"location":"reference/cogip/models/models/#cogip.models.models.CameraExtrinsicParameters","title":"<code>CameraExtrinsicParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing camera extrinsic properties</p> Source code in <code>cogip/models/models.py</code> <pre><code>class CameraExtrinsicParameters(BaseModel):\n    \"\"\"Model representing camera extrinsic properties\"\"\"\n\n    x: float\n    y: float\n    z: float\n    angle: float\n\n    @property\n    def tvec(self) -&gt; ArrayLike:\n        return np.array([self.x, self.y, self.z])\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynObstacleRect","title":"<code>DynObstacleRect</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dynamic rectangle obstacle created by the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X coordinate of the obstacle center</p> <code>y</code> <code>float</code> <p>Y coordinate of the obstacle center</p> <code>angle</code> <code>float</code> <p>Orientation of the obstacle</p> <code>length_x</code> <code>float</code> <p>length along X axis</p> <code>length_y</code> <code>float</code> <p>length along Y axis</p> <code>bb</code> <code>list[Vertex]</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class DynObstacleRect(BaseModel):\n    \"\"\"\n    A dynamic rectangle obstacle created by the robot.\n\n    Attributes:\n        x: X coordinate of the obstacle center\n        y: Y coordinate of the obstacle center\n        angle: Orientation of the obstacle\n        length_x: length along X axis\n        length_y: length along Y axis\n        bb: bounding box\n    \"\"\"\n\n    x: float\n    y: float\n    angle: float\n    length_x: float\n    length_y: float\n    bb: list[Vertex] = []\n\n    def contains(self, point: Vertex) -&gt; bool:\n        half_length_x = self.length_x / 2\n        half_length_y = self.length_y / 2\n\n        return (self.x - half_length_x &lt;= point.x &lt;= self.x + half_length_x) and (\n            self.y - half_length_y &lt;= point.y &lt;= self.y + half_length_y\n        )\n\n    def create_bounding_box(self, bb_radius: float, nb_vertices: int = 4):\n        half_length_x = self.length_x / 2\n        half_length_y = self.length_y / 2\n\n        self.bb = [\n            Vertex(x=self.x - half_length_x - bb_radius, y=self.y + half_length_y + bb_radius),\n            Vertex(x=self.x + half_length_x + bb_radius, y=self.y + half_length_y + bb_radius),\n            Vertex(x=self.x + half_length_x + bb_radius, y=self.y - half_length_y - bb_radius),\n            Vertex(x=self.x - half_length_x - bb_radius, y=self.y - half_length_y - bb_radius),\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        Hash function to allow this class to be used as a key in a dict.\n        \"\"\"\n        return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynObstacleRect.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash function to allow this class to be used as a key in a dict.</p> Source code in <code>cogip/models/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash function to allow this class to be used as a key in a dict.\n    \"\"\"\n    return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynRoundObstacle","title":"<code>DynRoundObstacle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dynamic round obstacle created by the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Center X position</p> <code>y</code> <code>float</code> <p>Center Y position</p> <code>radius</code> <code>float</code> <p>Radius of the obstacle</p> <code>bb</code> <code>list[Vertex]</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class DynRoundObstacle(BaseModel):\n    \"\"\"\n    A dynamic round obstacle created by the robot.\n\n    Attributes:\n        x: Center X position\n        y: Center Y position\n        radius: Radius of the obstacle\n        bb: bounding box\n    \"\"\"\n\n    x: float\n    y: float\n    radius: float\n    bb: list[Vertex] = []\n\n    def contains(self, point: Vertex) -&gt; bool:\n        return (point.x - self.x) * (point.x - self.x) + (point.y - self.y) * (point.y - self.y) &lt;= self.radius**2\n\n    def create_bounding_box(self, bb_radius, nb_vertices):\n        self.bb = [\n            Vertex(\n                x=self.x + bb_radius * math.cos(tmp := (i * 2 * math.pi) / nb_vertices),\n                y=self.y + bb_radius * math.sin(tmp),\n            )\n            for i in reversed(range(nb_vertices))\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        Hash function to allow this class to be used as a key in a dict.\n        \"\"\"\n        return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynRoundObstacle.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash function to allow this class to be used as a key in a dict.</p> Source code in <code>cogip/models/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash function to allow this class to be used as a key in a dict.\n    \"\"\"\n    return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.MenuEntry","title":"<code>MenuEntry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents one entry in a firmware's shell menu</p> <p>Attributes:</p> Name Type Description <code>cmd</code> <code>str</code> <p>Command name</p> <code>desc</code> <code>str</code> <p>Description of the command</p> <p>Examples:</p> <p>The following line shows how to initialize this class from a JSON string received on the serial port:</p> <pre><code>MenuEntry.model_validate_json(\"{\\\"cmd\\\": \\\"_state\\\", \\\"desc\\\": \\\"Print current state\\\"}\")\n</code></pre> Source code in <code>cogip/models/models.py</code> <pre><code>class MenuEntry(BaseModel):\n    \"\"\"\n    Represents one entry in a firmware's shell menu\n\n    Attributes:\n        cmd: Command name\n        desc: Description of the command\n\n    Examples:\n        The following line shows how to initialize this class from a JSON\n        string received on the serial port:\n        ```py\n        MenuEntry.model_validate_json(\"{\\\\\"cmd\\\\\": \\\\\"_state\\\\\", \\\\\"desc\\\\\": \\\\\"Print current state\\\\\"}\")\n        ```\n    \"\"\"\n\n    cmd: str\n    desc: str\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Obstacle","title":"<code>Obstacle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains the properties of an obstacle added on the table.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int</code> <p>X position</p> <code>y</code> <code>int</code> <p>Y position</p> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>length</code> <code>int</code> <p>Length</p> <code>width</code> <code>int</code> <p>Width</p> <code>height</code> <code>int</code> <p>Height</p> <code>bb</code> <code>int</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Obstacle(BaseModel):\n    \"\"\"\n    Contains the properties of an obstacle added on the table.\n\n    Attributes:\n        x: X position\n        y: Y position\n        rotation: Rotation\n        length: Length\n        width: Width\n        height: Height\n        bb: bounding box\n    \"\"\"\n\n    x: int = 0\n    y: int = 1000\n    rotation: int = 0\n    length: int = 200\n    width: int = 200\n    height: int = 600\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose","title":"<code>PathPose</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Class representing a position in a path.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>X coordinate</p> <code>y</code> <p>Y coordinate</p> <code>O</code> <p>0-orientation</p> <code>max_speed_linear</code> <code>int</code> <p>max linear speed in percentage of the robot max linear speed</p> <code>max_speed_angular</code> <code>int</code> <p>max angular speed in percentage of the robot max angular speed</p> <code>allow_reverse</code> <code>bool</code> <p>reverse mode</p> <code>bypass_anti_blocking</code> <code>bool</code> <p>send pose_reached if robot is blocked</p> <code>timeout_ms</code> <code>int</code> <p>max time is milliseconds to reach the pose, the robot stops if timeout is reached, 0 for no timeout</p> <code>bypass_final_orientation</code> <code>bool</code> <p>do not set orientation pose order</p> <code>is_intermediate</code> <code>bool</code> <p>whether this pose is an intermediate pose in a path</p> Source code in <code>cogip/models/models.py</code> <pre><code>class PathPose(Pose):\n    \"\"\"\n    Class representing a position in a path.\n\n    Attributes:\n        x: X coordinate\n        y: Y coordinate\n        O: 0-orientation\n        max_speed_linear: max linear speed in percentage of the robot max linear speed\n        max_speed_angular: max angular speed in percentage of the robot max angular speed\n        allow_reverse: reverse mode\n        bypass_anti_blocking: send pose_reached if robot is blocked\n        timeout_ms: max time is milliseconds to reach the pose, the robot stops if timeout is reached, 0 for no timeout\n        bypass_final_orientation: do not set orientation pose order\n        is_intermediate: whether this pose is an intermediate pose in a path\n    \"\"\"\n\n    max_speed_linear: int = 66\n    max_speed_angular: int = 66\n    allow_reverse: bool = True\n    bypass_anti_blocking: bool = False\n    timeout_ms: int = 0\n    bypass_final_orientation: bool = False\n    is_intermediate: bool = False\n\n    @property\n    def pose(self) -&gt; Pose:\n        return Pose(**self.model_dump())\n\n    def copy_pb(self, pb_path_pose: PB_PathPose) -&gt; None:\n        \"\"\"\n        Copy data in a Protobuf message.\n\n        Arguments:\n            pb_path_pose: Protobuf message to fill\n        \"\"\"\n        pb_path_pose.pose.x = int(self.x)\n        pb_path_pose.pose.y = int(self.y)\n        pb_path_pose.pose.O = int(self.O)  # noqa\n        pb_path_pose.max_speed_ratio_linear = self.max_speed_linear\n        pb_path_pose.max_speed_ratio_angular = self.max_speed_angular\n        pb_path_pose.allow_reverse = self.allow_reverse\n        pb_path_pose.bypass_anti_blocking = self.bypass_anti_blocking\n        pb_path_pose.timeout_ms = self.timeout_ms\n        pb_path_pose.bypass_final_orientation = self.bypass_final_orientation\n        pb_path_pose.is_intermediate = self.is_intermediate\n\n    def to_shared(self, shared_pose_order: SharedPoseOrder | None) -&gt; None:\n        \"\"\"\n        Copy data in a Protobuf message.\n\n        Arguments:\n            pb_path_pose: Protobuf message to fill\n        \"\"\"\n        if shared_pose_order is None:\n            return\n        shared_pose_order.x = int(self.x)\n        shared_pose_order.y = int(self.y)\n        shared_pose_order.angle = int(self.O)  # noqa\n        shared_pose_order.max_speed_linear = self.max_speed_linear\n        shared_pose_order.max_speed_angular = self.max_speed_angular\n        shared_pose_order.allow_reverse = self.allow_reverse\n        shared_pose_order.bypass_anti_blocking = self.bypass_anti_blocking\n        shared_pose_order.bypass_final_orientation = self.bypass_final_orientation\n        shared_pose_order.timeout_ms = self.timeout_ms\n        shared_pose_order.is_intermediate = self.is_intermediate\n\n    @classmethod\n    def from_shared(cls, shared_pose: SharedPose | SharedPoseOrder) -&gt; \"PathPose\":\n        \"\"\"\n        Create a PathPose from a SharedPoseOrder.\n\n        Arguments:\n            shared_pose_order: SharedPoseOrder to convert\n\n        Returns:\n            A PathPose instance with the data from the SharedPoseOrder.\n        \"\"\"\n        path_pose = cls(\n            x=shared_pose.x,\n            y=shared_pose.y,\n            O=shared_pose.angle,  # noqa\n        )\n        if isinstance(shared_pose, SharedPoseOrder):\n            path_pose.max_speed_linear = shared_pose.max_speed_linear\n            path_pose.max_speed_angular = shared_pose.max_speed_angular\n            path_pose.allow_reverse = shared_pose.allow_reverse\n            path_pose.bypass_anti_blocking = shared_pose.bypass_anti_blocking\n            path_pose.timeout_ms = shared_pose.timeout_ms\n            path_pose.bypass_final_orientation = shared_pose.bypass_final_orientation\n            path_pose.is_intermediate = shared_pose.is_intermediate\n\n        return path_pose\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.copy_pb","title":"<code>copy_pb(pb_path_pose)</code>","text":"<p>Copy data in a Protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>pb_path_pose</code> <code>PB_PathPose</code> <p>Protobuf message to fill</p> required Source code in <code>cogip/models/models.py</code> <pre><code>def copy_pb(self, pb_path_pose: PB_PathPose) -&gt; None:\n    \"\"\"\n    Copy data in a Protobuf message.\n\n    Arguments:\n        pb_path_pose: Protobuf message to fill\n    \"\"\"\n    pb_path_pose.pose.x = int(self.x)\n    pb_path_pose.pose.y = int(self.y)\n    pb_path_pose.pose.O = int(self.O)  # noqa\n    pb_path_pose.max_speed_ratio_linear = self.max_speed_linear\n    pb_path_pose.max_speed_ratio_angular = self.max_speed_angular\n    pb_path_pose.allow_reverse = self.allow_reverse\n    pb_path_pose.bypass_anti_blocking = self.bypass_anti_blocking\n    pb_path_pose.timeout_ms = self.timeout_ms\n    pb_path_pose.bypass_final_orientation = self.bypass_final_orientation\n    pb_path_pose.is_intermediate = self.is_intermediate\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.from_shared","title":"<code>from_shared(shared_pose)</code>  <code>classmethod</code>","text":"<p>Create a PathPose from a SharedPoseOrder.</p> <p>Parameters:</p> Name Type Description Default <code>shared_pose_order</code> <p>SharedPoseOrder to convert</p> required <p>Returns:</p> Type Description <code>PathPose</code> <p>A PathPose instance with the data from the SharedPoseOrder.</p> Source code in <code>cogip/models/models.py</code> <pre><code>@classmethod\ndef from_shared(cls, shared_pose: SharedPose | SharedPoseOrder) -&gt; \"PathPose\":\n    \"\"\"\n    Create a PathPose from a SharedPoseOrder.\n\n    Arguments:\n        shared_pose_order: SharedPoseOrder to convert\n\n    Returns:\n        A PathPose instance with the data from the SharedPoseOrder.\n    \"\"\"\n    path_pose = cls(\n        x=shared_pose.x,\n        y=shared_pose.y,\n        O=shared_pose.angle,  # noqa\n    )\n    if isinstance(shared_pose, SharedPoseOrder):\n        path_pose.max_speed_linear = shared_pose.max_speed_linear\n        path_pose.max_speed_angular = shared_pose.max_speed_angular\n        path_pose.allow_reverse = shared_pose.allow_reverse\n        path_pose.bypass_anti_blocking = shared_pose.bypass_anti_blocking\n        path_pose.timeout_ms = shared_pose.timeout_ms\n        path_pose.bypass_final_orientation = shared_pose.bypass_final_orientation\n        path_pose.is_intermediate = shared_pose.is_intermediate\n\n    return path_pose\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.to_shared","title":"<code>to_shared(shared_pose_order)</code>","text":"<p>Copy data in a Protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>pb_path_pose</code> <p>Protobuf message to fill</p> required Source code in <code>cogip/models/models.py</code> <pre><code>def to_shared(self, shared_pose_order: SharedPoseOrder | None) -&gt; None:\n    \"\"\"\n    Copy data in a Protobuf message.\n\n    Arguments:\n        pb_path_pose: Protobuf message to fill\n    \"\"\"\n    if shared_pose_order is None:\n        return\n    shared_pose_order.x = int(self.x)\n    shared_pose_order.y = int(self.y)\n    shared_pose_order.angle = int(self.O)  # noqa\n    shared_pose_order.max_speed_linear = self.max_speed_linear\n    shared_pose_order.max_speed_angular = self.max_speed_angular\n    shared_pose_order.allow_reverse = self.allow_reverse\n    shared_pose_order.bypass_anti_blocking = self.bypass_anti_blocking\n    shared_pose_order.bypass_final_orientation = self.bypass_final_orientation\n    shared_pose_order.timeout_ms = self.timeout_ms\n    shared_pose_order.is_intermediate = self.is_intermediate\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>Vertex</code></p> <p>A position of the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>X position</p> <code>y</code> <p>Y position</p> <code>O</code> <code>float | None</code> <p>Rotation</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Pose(Vertex):\n    \"\"\"\n    A position of the robot.\n\n    Attributes:\n        x: X position\n        y: Y position\n        O: Rotation\n    \"\"\"\n\n    O: float | None = 0.0  # noqa\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.RobotState","title":"<code>RobotState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>This contains information about robot state, like mode, cycle, positions, speed, path and obstacles. It is given by the firmware through the serial port.</p> <p>Attributes:</p> Name Type Description <code>pose_order</code> <code>Pose</code> <p>Position to reach</p> <code>cycle</code> <code>int</code> <p>Current cycle</p> <code>speed_current</code> <code>Speed</code> <p>Current speed</p> <code>speed_order</code> <code>Speed</code> <p>Speed order</p> <code>path</code> <code>Speed</code> <p>Computed path</p> Source code in <code>cogip/models/models.py</code> <pre><code>class RobotState(BaseModel):\n    \"\"\"\n    This contains information about robot state,\n    like mode, cycle, positions, speed, path and obstacles.\n    It is given by the firmware through the serial port.\n\n    Attributes:\n        pose_order: Position to reach\n        cycle: Current cycle\n        speed_current: Current speed\n        speed_order: Speed order\n        path: Computed path\n    \"\"\"\n\n    pose_current: Pose = Pose()\n    pose_order: Pose = Pose()\n    cycle: int = 0\n    speed_current: Speed = Speed()\n    speed_order: Speed = Speed()\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.ShellMenu","title":"<code>ShellMenu</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a firmware's shell menu.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the menu</p> <code>entries</code> <code>list[MenuEntry]</code> <p>List of the menu entries</p> <p>Examples:</p> <p>The following line shows how to initialize this class from a JSON string received on the serial port:</p> <pre><code>ShellMenu.model_validate_json(\n    \"{\\\"name\\\": \\\"planner\\\",\"\n    \" \\\"entries\\\": [\"\n    \"    {\\\"cmd\\\": \\\"_help_json\\\", \\\"desc\\\": \\\"Display available commands in JSON format\\\"},\"\n    \"    {\\\"cmd\\\": \\\"_state\\\", \\\"desc\\\": \\\"Print current state\\\"}\n    \"]}\"\n)\n</code></pre> Source code in <code>cogip/models/models.py</code> <pre><code>class ShellMenu(BaseModel):\n    \"\"\"\n    Represents a firmware's shell menu.\n\n    Attributes:\n        name: Name of the menu\n        entries: List of the menu entries\n\n    Examples:\n        The following line shows how to initialize this class from a JSON\n        string received on the serial port:\n        ```py\n        ShellMenu.model_validate_json(\n            \"{\\\\\"name\\\\\": \\\\\"planner\\\\\",\"\n            \" \\\\\"entries\\\\\": [\"\n            \"    {\\\\\"cmd\\\\\": \\\\\"_help_json\\\\\", \\\\\"desc\\\\\": \\\\\"Display available commands in JSON format\\\\\"},\"\n            \"    {\\\\\"cmd\\\\\": \\\\\"_state\\\\\", \\\\\"desc\\\\\": \\\\\"Print current state\\\\\"}\n            \"]}\"\n        )\n        ```\n    \"\"\"\n\n    name: str\n    entries: list[MenuEntry]\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Speed","title":"<code>Speed</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A speed value.</p> <p>Attributes:</p> Name Type Description <code>distance</code> <code>float</code> <p>Linear speed</p> <code>angle</code> <code>float</code> <p>Angular speed</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Speed(BaseModel):\n    \"\"\"\n    A speed value.\n\n    Attributes:\n        distance: Linear speed\n        angle: Angular speed\n    \"\"\"\n\n    distance: float = 0.0\n    angle: float = 0.0\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Vertex","title":"<code>Vertex</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a point in 2D/3D coordinates.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X position</p> <code>y</code> <code>float</code> <p>Y position</p> <code>z</code> <code>float</code> <p>Z position (optional)</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Vertex(BaseModel):\n    \"\"\"\n    Represents a point in 2D/3D coordinates.\n\n    Attributes:\n        x: X position\n        y: Y position\n        z: Z position (optional)\n    \"\"\"\n\n    x: float = 0.0\n    y: float = 0.0\n    z: float = 0.0\n\n    def __hash__(self):\n        return hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"reference/cogip/scservo_sdk/group_sync_read/","title":"group_sync_read","text":""},{"location":"reference/cogip/scservo_sdk/group_sync_write/","title":"group_sync_write","text":""},{"location":"reference/cogip/scservo_sdk/port_handler/","title":"port_handler","text":""},{"location":"reference/cogip/scservo_sdk/protocol_packet_handler/","title":"protocol_packet_handler","text":"<p>               Bases: <code>object</code></p> Source code in <code>cogip/scservo_sdk/protocol_packet_handler.py</code> <pre><code>class protocol_packet_handler(object):\n    def __init__(self, portHandler, protocol_end):\n        #self.scs_setend(protocol_end)# SCServo bit end(STS/SMS=0, SCS=1)\n        self.portHandler = portHandler\n        self.scs_end = protocol_end\n\n    def scs_getend(self):\n        return self.scs_end\n\n    def scs_setend(self, e):\n        self.scs_end = e\n\n    def scs_tohost(self, a, b):\n        if (a &amp; (1&lt;&lt;b)):\n            return -(a &amp; ~(1&lt;&lt;b))\n        else:\n            return a\n\n    def scs_toscs(self, a, b):\n        if (a&lt;0):\n            return (-a | (1&lt;&lt;b))\n        else:\n            return a\n\n    def scs_makeword(self, a, b):\n        if self.scs_end==0:\n            return (a &amp; 0xFF) | ((b &amp; 0xFF) &lt;&lt; 8)\n        else:\n            return (b &amp; 0xFF) | ((a &amp; 0xFF) &lt;&lt; 8)\n\n    def scs_makedword(self, a, b):\n        return (a &amp; 0xFFFF) | (b &amp; 0xFFFF) &lt;&lt; 16\n\n    def scs_loword(self, l):\n        return l &amp; 0xFFFF\n\n    def scs_hiword(self, h):\n        return (h &gt;&gt; 16) &amp; 0xFFFF\n\n    def scs_lobyte(self, w):\n        if self.scs_end==0:\n            return w &amp; 0xFF\n        else:\n            return (w &gt;&gt; 8) &amp; 0xFF\n\n    def scs_hibyte(self, w):\n        if self.scs_end==0:\n            return (w &gt;&gt; 8) &amp; 0xFF\n        else:\n            return w &amp; 0xFF\n\n    def getProtocolVersion(self):\n        return 1.0\n\n    def getTxRxResult(self, result):\n        if result == COMM_SUCCESS:\n            return \"[TxRxResult] Communication success!\"\n        elif result == COMM_PORT_BUSY:\n            return \"[TxRxResult] Port is in use!\"\n        elif result == COMM_TX_FAIL:\n            return \"[TxRxResult] Failed transmit instruction packet!\"\n        elif result == COMM_RX_FAIL:\n            return \"[TxRxResult] Failed get status packet from device!\"\n        elif result == COMM_TX_ERROR:\n            return \"[TxRxResult] Incorrect instruction packet!\"\n        elif result == COMM_RX_WAITING:\n            return \"[TxRxResult] Now receiving status packet!\"\n        elif result == COMM_RX_TIMEOUT:\n            return \"[TxRxResult] There is no status packet!\"\n        elif result == COMM_RX_CORRUPT:\n            return \"[TxRxResult] Incorrect status packet!\"\n        elif result == COMM_NOT_AVAILABLE:\n            return \"[TxRxResult] Protocol does not support this function!\"\n        else:\n            return \"\"\n\n    def getRxPacketError(self, error):\n        if error &amp; ERRBIT_VOLTAGE:\n            return \"[ServoStatus] Input voltage error!\"\n\n        if error &amp; ERRBIT_ANGLE:\n            return \"[ServoStatus] Angle sen error!\"\n\n        if error &amp; ERRBIT_OVERHEAT:\n            return \"[ServoStatus] Overheat error!\"\n\n        if error &amp; ERRBIT_OVERELE:\n            return \"[ServoStatus] OverEle error!\"\n\n        if error &amp; ERRBIT_OVERLOAD:\n            return \"[ServoStatus] Overload error!\"\n\n        return \"\"\n\n    def txPacket(self, txpacket):\n        checksum = 0\n        total_packet_length = txpacket[PKT_LENGTH] + 4  # 4: HEADER0 HEADER1 ID LENGTH\n\n        if self.portHandler.is_using:\n            return COMM_PORT_BUSY\n        self.portHandler.is_using = True\n\n        # check max packet length\n        if total_packet_length &gt; TXPACKET_MAX_LEN:\n            self.portHandler.is_using = False\n            return COMM_TX_ERROR\n\n        # make packet header\n        txpacket[PKT_HEADER0] = 0xFF\n        txpacket[PKT_HEADER1] = 0xFF\n\n        # add a checksum to the packet\n        for idx in range(2, total_packet_length - 1):  # except header, checksum\n            checksum += txpacket[idx]\n\n        txpacket[total_packet_length - 1] = ~checksum &amp; 0xFF\n\n        #print \"[TxPacket] %r\" % txpacket\n\n        # tx packet\n        self.portHandler.clearPort()\n        written_packet_length = self.portHandler.writePort(txpacket)\n        if total_packet_length != written_packet_length:\n            self.portHandler.is_using = False\n            return COMM_TX_FAIL\n\n        return COMM_SUCCESS\n\n    def rxPacket(self):\n        rxpacket = []\n\n        result = COMM_TX_FAIL\n        checksum = 0\n        rx_length = 0\n        wait_length = 6  # minimum length (HEADER0 HEADER1 ID LENGTH ERROR CHKSUM)\n\n        while True:\n            rxpacket.extend(self.portHandler.readPort(wait_length - rx_length))\n            rx_length = len(rxpacket)\n            if rx_length &gt;= wait_length:\n                # find packet header\n                for idx in range(0, (rx_length - 1)):\n                    if (rxpacket[idx] == 0xFF) and (rxpacket[idx + 1] == 0xFF):\n                        break\n\n                if idx == 0:  # found at the beginning of the packet\n                    if (rxpacket[PKT_ID] &gt; 0xFD) or (rxpacket[PKT_LENGTH] &gt; RXPACKET_MAX_LEN) or (\n                            rxpacket[PKT_ERROR] &gt; 0x7F):\n                        # unavailable ID or unavailable Length or unavailable Error\n                        # remove the first byte in the packet\n                        del rxpacket[0]\n                        rx_length -= 1\n                        continue\n\n                    # re-calculate the exact length of the rx packet\n                    if wait_length != (rxpacket[PKT_LENGTH] + PKT_LENGTH + 1):\n                        wait_length = rxpacket[PKT_LENGTH] + PKT_LENGTH + 1\n                        continue\n\n                    if rx_length &lt; wait_length:\n                        # check timeout\n                        if self.portHandler.isPacketTimeout():\n                            if rx_length == 0:\n                                result = COMM_RX_TIMEOUT\n                            else:\n                                result = COMM_RX_CORRUPT\n                            break\n                        else:\n                            continue\n\n                    # calculate checksum\n                    for i in range(2, wait_length - 1):  # except header, checksum\n                        checksum += rxpacket[i]\n                    checksum = ~checksum &amp; 0xFF\n\n                    # verify checksum\n                    if rxpacket[wait_length - 1] == checksum:\n                        result = COMM_SUCCESS\n                    else:\n                        result = COMM_RX_CORRUPT\n                    break\n\n                else:\n                    # remove unnecessary packets\n                    del rxpacket[0: idx]\n                    rx_length -= idx\n\n            else:\n                # check timeout\n                if self.portHandler.isPacketTimeout():\n                    if rx_length == 0:\n                        result = COMM_RX_TIMEOUT\n                    else:\n                        result = COMM_RX_CORRUPT\n                    break\n\n        self.portHandler.is_using = False\n        return rxpacket, result\n\n    def txRxPacket(self, txpacket):\n        rxpacket = None\n        error = 0\n\n        # tx packet\n        result = self.txPacket(txpacket)\n        if result != COMM_SUCCESS:\n            return rxpacket, result, error\n\n        # (ID == Broadcast ID) == no need to wait for status packet or not available\n        if (txpacket[PKT_ID] == BROADCAST_ID):\n            self.portHandler.is_using = False\n            return rxpacket, result, error\n\n        # set packet timeout\n        if txpacket[PKT_INSTRUCTION] == INST_READ:\n            self.portHandler.setPacketTimeout(txpacket[PKT_PARAMETER0 + 1] + 6)\n        else:\n            self.portHandler.setPacketTimeout(6)  # HEADER0 HEADER1 ID LENGTH ERROR CHECKSUM\n\n        # rx packet\n        while True:\n            rxpacket, result = self.rxPacket()\n            if result != COMM_SUCCESS or txpacket[PKT_ID] == rxpacket[PKT_ID]:\n                break\n\n        if result == COMM_SUCCESS and txpacket[PKT_ID] == rxpacket[PKT_ID]:\n            error = rxpacket[PKT_ERROR]\n\n        return rxpacket, result, error\n\n    def ping(self, scs_id):\n        model_number = 0\n        error = 0\n\n        txpacket = [0] * 6\n\n        if scs_id &gt;= BROADCAST_ID:\n            return model_number, COMM_NOT_AVAILABLE, error\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = 2\n        txpacket[PKT_INSTRUCTION] = INST_PING\n\n        rxpacket, result, error = self.txRxPacket(txpacket)\n\n        if result == COMM_SUCCESS:\n            data_read, result, error = self.readTxRx(scs_id, 3, 2)  # Address 3 : Model Number\n            if result == COMM_SUCCESS:\n                model_number = self.scs_makeword(data_read[0], data_read[1])\n\n        return model_number, result, error\n\n    def action(self, scs_id):\n        txpacket = [0] * 6\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = 2\n        txpacket[PKT_INSTRUCTION] = INST_ACTION\n\n        _, result, _ = self.txRxPacket(txpacket)\n\n        return result\n\n    def readTx(self, scs_id, address, length):\n\n        txpacket = [0] * 8\n\n        if scs_id &gt;= BROADCAST_ID:\n            return COMM_NOT_AVAILABLE\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = 4\n        txpacket[PKT_INSTRUCTION] = INST_READ\n        txpacket[PKT_PARAMETER0 + 0] = address\n        txpacket[PKT_PARAMETER0 + 1] = length\n\n        result = self.txPacket(txpacket)\n\n        # set packet timeout\n        if result == COMM_SUCCESS:\n            self.portHandler.setPacketTimeout(length + 6)\n\n        return result\n\n    def readRx(self, scs_id, length):\n        result = COMM_TX_FAIL\n        error = 0\n\n        rxpacket = None\n        data = []\n\n        while True:\n            rxpacket, result = self.rxPacket()\n\n            if result != COMM_SUCCESS or rxpacket[PKT_ID] == scs_id:\n                break\n\n        if result == COMM_SUCCESS and rxpacket[PKT_ID] == scs_id:\n            error = rxpacket[PKT_ERROR]\n\n            data.extend(rxpacket[PKT_PARAMETER0 : PKT_PARAMETER0+length])\n\n        return data, result, error\n\n    def readTxRx(self, scs_id, address, length):\n        txpacket = [0] * 8\n        data = []\n\n        if scs_id &gt;= BROADCAST_ID:\n            return data, COMM_NOT_AVAILABLE, 0\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = 4\n        txpacket[PKT_INSTRUCTION] = INST_READ\n        txpacket[PKT_PARAMETER0 + 0] = address\n        txpacket[PKT_PARAMETER0 + 1] = length\n\n        rxpacket, result, error = self.txRxPacket(txpacket)\n        if result == COMM_SUCCESS:\n            error = rxpacket[PKT_ERROR]\n\n            data.extend(rxpacket[PKT_PARAMETER0 : PKT_PARAMETER0+length])\n\n        return data, result, error\n\n    def read1ByteTx(self, scs_id, address):\n        return self.readTx(scs_id, address, 1)\n\n    def read1ByteRx(self, scs_id):\n        data, result, error = self.readRx(scs_id, 1)\n        data_read = data[0] if (result == COMM_SUCCESS) else 0\n        return data_read, result, error\n\n    def read1ByteTxRx(self, scs_id, address):\n        data, result, error = self.readTxRx(scs_id, address, 1)\n        data_read = data[0] if (result == COMM_SUCCESS) else 0\n        return data_read, result, error\n\n    def read2ByteTx(self, scs_id, address):\n        return self.readTx(scs_id, address, 2)\n\n    def read2ByteRx(self, scs_id):\n        data, result, error = self.readRx(scs_id, 2)\n        data_read = self.scs_makeword(data[0], data[1]) if (result == COMM_SUCCESS) else 0\n        return data_read, result, error\n\n    def read2ByteTxRx(self, scs_id, address):\n        data, result, error = self.readTxRx(scs_id, address, 2)\n        data_read = self.scs_makeword(data[0], data[1]) if (result == COMM_SUCCESS) else 0\n        return data_read, result, error\n\n    def read4ByteTx(self, scs_id, address):\n        return self.readTx(scs_id, address, 4)\n\n    def read4ByteRx(self, scs_id):\n        data, result, error = self.readRx(scs_id, 4)\n        data_read = self.scs_makedword(self.scs_makeword(data[0], data[1]),\n                                  self.scs_makeword(data[2], data[3])) if (result == COMM_SUCCESS) else 0\n        return data_read, result, error\n\n    def read4ByteTxRx(self, scs_id, address):\n        data, result, error = self.readTxRx(scs_id, address, 4)\n        data_read = self.scs_makedword(self.scs_makeword(data[0], data[1]),\n                                  self.scs_makeword(data[2], data[3])) if (result == COMM_SUCCESS) else 0\n        return data_read, result, error\n\n    def writeTxOnly(self, scs_id, address, length, data):\n        txpacket = [0] * (length + 7)\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = length + 3\n        txpacket[PKT_INSTRUCTION] = INST_WRITE\n        txpacket[PKT_PARAMETER0] = address\n\n        txpacket[PKT_PARAMETER0 + 1: PKT_PARAMETER0 + 1 + length] = data[0: length]\n\n        result = self.txPacket(txpacket)\n        self.portHandler.is_using = False\n\n        return result\n\n    def writeTxRx(self, scs_id, address, length, data):\n        txpacket = [0] * (length + 7)\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = length + 3\n        txpacket[PKT_INSTRUCTION] = INST_WRITE\n        txpacket[PKT_PARAMETER0] = address\n\n        txpacket[PKT_PARAMETER0 + 1: PKT_PARAMETER0 + 1 + length] = data[0: length]\n        rxpacket, result, error = self.txRxPacket(txpacket)\n\n        return result, error\n\n    def write1ByteTxOnly(self, scs_id, address, data):\n        data_write = [data]\n        return self.writeTxOnly(scs_id, address, 1, data_write)\n\n    def write1ByteTxRx(self, scs_id, address, data):\n        data_write = [data]\n        return self.writeTxRx(scs_id, address, 1, data_write)\n\n    def write2ByteTxOnly(self, scs_id, address, data):\n        data_write = [self.scs_lobyte(data), self.scs_hibyte(data)]\n        return self.writeTxOnly(scs_id, address, 2, data_write)\n\n    def write2ByteTxRx(self, scs_id, address, data):\n        data_write = [self.scs_lobyte(data), self.scs_hibyte(data)]\n        return self.writeTxRx(scs_id, address, 2, data_write)\n\n    def write4ByteTxOnly(self, scs_id, address, data):\n        data_write = [self.scs_lobyte(self.scs_loword(data)),\n                      self.scs_hibyte(self.scs_loword(data)),\n                      self.scs_lobyte(self.scs_hiword(data)),\n                      self.scs_hibyte(self.scs_hiword(data))]\n        return self.writeTxOnly(scs_id, address, 4, data_write)\n\n    def write4ByteTxRx(self, scs_id, address, data):\n        data_write = [self.scs_lobyte(self.scs_loword(data)),\n                      self.scs_hibyte(self.scs_loword(data)),\n                      self.scs_lobyte(self.scs_hiword(data)),\n                      self.scs_hibyte(self.scs_hiword(data))]\n        return self.writeTxRx(scs_id, address, 4, data_write)\n\n    def regWriteTxOnly(self, scs_id, address, length, data):\n        txpacket = [0] * (length + 7)\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = length + 3\n        txpacket[PKT_INSTRUCTION] = INST_REG_WRITE\n        txpacket[PKT_PARAMETER0] = address\n\n        txpacket[PKT_PARAMETER0 + 1: PKT_PARAMETER0 + 1 + length] = data[0: length]\n\n        result = self.txPacket(txpacket)\n        self.portHandler.is_using = False\n\n        return result\n\n    def regWriteTxRx(self, scs_id, address, length, data):\n        txpacket = [0] * (length + 7)\n\n        txpacket[PKT_ID] = scs_id\n        txpacket[PKT_LENGTH] = length + 3\n        txpacket[PKT_INSTRUCTION] = INST_REG_WRITE\n        txpacket[PKT_PARAMETER0] = address\n\n        txpacket[PKT_PARAMETER0 + 1: PKT_PARAMETER0 + 1 + length] = data[0: length]\n\n        _, result, error = self.txRxPacket(txpacket)\n\n        return result, error\n\n    def syncReadTx(self, start_address, data_length, param, param_length):\n        txpacket = [0] * (param_length + 8)\n        # 8: HEADER0 HEADER1 ID LEN INST START_ADDR DATA_LEN CHKSUM\n\n        txpacket[PKT_ID] = BROADCAST_ID\n        txpacket[PKT_LENGTH] = param_length + 4  # 7: INST START_ADDR DATA_LEN CHKSUM\n        txpacket[PKT_INSTRUCTION] = INST_SYNC_READ\n        txpacket[PKT_PARAMETER0 + 0] = start_address\n        txpacket[PKT_PARAMETER0 + 1] = data_length\n\n        txpacket[PKT_PARAMETER0 + 2: PKT_PARAMETER0 + 2 + param_length] = param[0: param_length]\n\n        # print(txpacket)\n        result = self.txPacket(txpacket)\n        return result\n\n    def syncReadRx(self, data_length, param_length):\n        wait_length = (6 + data_length) * param_length\n        self.portHandler.setPacketTimeout(wait_length)\n        rxpacket = []\n        rx_length = 0\n        while True:\n            rxpacket.extend(self.portHandler.readPort(wait_length - rx_length))\n            rx_length = len(rxpacket)\n            if rx_length &gt;= wait_length:\n                result = COMM_SUCCESS\n                break\n            else:\n                # check timeout\n                if self.portHandler.isPacketTimeout():\n                    if rx_length == 0:\n                        result = COMM_RX_TIMEOUT\n                    else:\n                        result = COMM_RX_CORRUPT\n                    break\n        self.portHandler.is_using = False\n        return result, rxpacket\n\n    def syncWriteTxOnly(self, start_address, data_length, param, param_length):\n        txpacket = [0] * (param_length + 8)\n        # 8: HEADER0 HEADER1 ID LEN INST START_ADDR DATA_LEN ... CHKSUM\n\n        txpacket[PKT_ID] = BROADCAST_ID\n        txpacket[PKT_LENGTH] = param_length + 4  # 4: INST START_ADDR DATA_LEN ... CHKSUM\n        txpacket[PKT_INSTRUCTION] = INST_SYNC_WRITE\n        txpacket[PKT_PARAMETER0 + 0] = start_address\n        txpacket[PKT_PARAMETER0 + 1] = data_length\n\n        txpacket[PKT_PARAMETER0 + 2: PKT_PARAMETER0 + 2 + param_length] = param[0: param_length]\n\n        _, result, _ = self.txRxPacket(txpacket)\n\n        return result\n</code></pre>"},{"location":"reference/cogip/scservo_sdk/scscl/","title":"scscl","text":"<p>               Bases: <code>protocol_packet_handler</code></p> Source code in <code>cogip/scservo_sdk/scscl.py</code> <pre><code>class scscl(protocol_packet_handler):\n    def __init__(self, portHandler):\n        protocol_packet_handler.__init__(self, portHandler, 1)\n        self.groupSyncWrite = GroupSyncWrite(self, SCSCL_GOAL_POSITION_L, 6)\n\n    def WritePos(self, scs_id, position, time, speed):\n        txpacket = [self.scs_lobyte(position), self.scs_hibyte(position), self.scs_lobyte(time), self.scs_hibyte(time), self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.writeTxRx(scs_id, SCSCL_GOAL_POSITION_L, len(txpacket), txpacket)\n\n    def ReadPos(self, scs_id):\n        scs_present_position, scs_comm_result, scs_error = self.read2ByteTxRx(scs_id, SCSCL_PRESENT_POSITION_L)\n        return scs_present_position, scs_comm_result, scs_error\n\n    def ReadSpeed(self, scs_id):\n        scs_present_speed, scs_comm_result, scs_error = self.read2ByteTxRx(scs_id, SCSCL_PRESENT_SPEED_L)\n        return self.scs_tohost(scs_present_speed, 15), scs_comm_result, scs_error\n\n    def ReadPosSpeed(self, scs_id):\n        scs_present_position_speed, scs_comm_result, scs_error = self.read4ByteTxRx(scs_id, SCSCL_PRESENT_POSITION_L)\n        scs_present_position = self.scs_loword(scs_present_position_speed)\n        scs_present_speed = self.scs_hiword(scs_present_position_speed)\n        return scs_present_position, self.scs_tohost(scs_present_speed, 15), scs_comm_result, scs_error\n\n    def ReadMoving(self, scs_id):\n        moving, scs_comm_result, scs_error = self.read1ByteTxRx(scs_id, SCSCL_MOVING)\n        return moving, scs_comm_result, scs_error\n\n    def SyncWritePos(self, scs_id, position, time, speed):\n        txpacket = [self.scs_lobyte(position), self.scs_hibyte(position), self.scs_lobyte(time), self.scs_hibyte(time), self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.groupSyncWrite.addParam(scs_id, txpacket)\n\n    def RegWritePos(self, scs_id, position, time, speed):\n        txpacket = [self.scs_lobyte(position), self.scs_hibyte(position), self.scs_lobyte(time), self.scs_hibyte(time), self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.regWriteTxRx(scs_id, SCSCL_GOAL_POSITION_L, len(txpacket), txpacket)\n\n    def RegAction(self):\n        return self.action(BROADCAST_ID)\n\n    def ServoMode(self, scs_id):\n        txpacket = [self.scs_lobyte(20), self.scs_hibyte(20)]\n        self.writeTxRx(scs_id, SCSCL_MIN_ANGLE_LIMIT_L, len(txpacket), txpacket)\n        txpacket = [self.scs_lobyte(1003), self.scs_hibyte(1003)]\n        return self.writeTxRx(scs_id, SCSCL_MAX_ANGLE_LIMIT_L, len(txpacket), txpacket)\n\n    def PWMMode(self, scs_id):\n        txpacket = [0, 0, 0, 0]\n        return self.writeTxRx(scs_id, SCSCL_MIN_ANGLE_LIMIT_L, len(txpacket), txpacket)\n\n    def WritePWM(self, scs_id, time):\n        return self.write2ByteTxRx(scs_id, SCSCL_GOAL_TIME_L, self.scs_toscs(time, 10))\n\n    def LockEprom(self, scs_id):\n        return self.write1ByteTxRx(scs_id, SCSCL_LOCK, 1)\n\n    def unLockEprom(self, scs_id):\n        return self.write1ByteTxRx(scs_id, SCSCL_LOCK, 0)\n</code></pre>"},{"location":"reference/cogip/scservo_sdk/scservo_def/","title":"scservo_def","text":""},{"location":"reference/cogip/scservo_sdk/sms_sts/","title":"sms_sts","text":"<p>               Bases: <code>protocol_packet_handler</code></p> Source code in <code>cogip/scservo_sdk/sms_sts.py</code> <pre><code>class sms_sts(protocol_packet_handler):\n    def __init__(self, portHandler):\n        protocol_packet_handler.__init__(self, portHandler, 0)\n        self.groupSyncWrite = GroupSyncWrite(self, SMS_STS_ACC, 7)\n\n    def WritePosEx(self, scs_id, position, speed, acc):\n        txpacket = [acc, self.scs_lobyte(position), self.scs_hibyte(position), 0, 0, self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.writeTxRx(scs_id, SMS_STS_ACC, len(txpacket), txpacket)\n\n    def ReadPos(self, scs_id):\n        scs_present_position, scs_comm_result, scs_error = self.read2ByteTxRx(scs_id, SMS_STS_PRESENT_POSITION_L)\n        return self.scs_tohost(scs_present_position, 15), scs_comm_result, scs_error\n\n    def ReadSpeed(self, scs_id):\n        scs_present_speed, scs_comm_result, scs_error = self.read2ByteTxRx(scs_id, SMS_STS_PRESENT_SPEED_L)\n        return self.scs_tohost(scs_present_speed, 15), scs_comm_result, scs_error\n\n    def ReadPosSpeed(self, scs_id):\n        scs_present_position_speed, scs_comm_result, scs_error = self.read4ByteTxRx(scs_id, SMS_STS_PRESENT_POSITION_L)\n        scs_present_position = self.scs_loword(scs_present_position_speed)\n        scs_present_speed = self.scs_hiword(scs_present_position_speed)\n        return self.scs_tohost(scs_present_position, 15), self.scs_tohost(scs_present_speed, 15), scs_comm_result, scs_error\n\n    def ReadMoving(self, scs_id):\n        moving, scs_comm_result, scs_error = self.read1ByteTxRx(scs_id, SMS_STS_MOVING)\n        return moving, scs_comm_result, scs_error\n\n    def SyncWritePosEx(self, scs_id, position, speed, acc):\n        txpacket = [acc, self.scs_lobyte(position), self.scs_hibyte(position), 0, 0, self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.groupSyncWrite.addParam(scs_id, txpacket)\n\n    def RegWritePosEx(self, scs_id, position, speed, acc):\n        txpacket = [acc, self.scs_lobyte(position), self.scs_hibyte(position), 0, 0, self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.regWriteTxRx(scs_id, SMS_STS_ACC, len(txpacket), txpacket)\n\n    def RegAction(self):\n        return self.action(BROADCAST_ID)\n\n    def WheelMode(self, scs_id):\n        return self.write1ByteTxRx(scs_id, SMS_STS_MODE, 1)\n\n    def WriteSpec(self, scs_id, speed, acc):\n        speed = self.scs_toscs(speed, 15)\n        txpacket = [acc, 0, 0, 0, 0, self.scs_lobyte(speed), self.scs_hibyte(speed)]\n        return self.writeTxRx(scs_id, SMS_STS_ACC, len(txpacket), txpacket)\n\n    def LockEprom(self, scs_id):\n        return self.write1ByteTxRx(scs_id, SMS_STS_LOCK, 1)\n\n    def unLockEprom(self, scs_id):\n        return self.write1ByteTxRx(scs_id, SMS_STS_LOCK, 0)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/beaconcam/app/","title":"app","text":""},{"location":"reference/cogip/tools/beaconcam/app/#cogip.tools.beaconcam.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/beaconcam/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = CameraServer()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler","title":"<code>CameraHandler</code>","text":"<p>Camera handler.</p> <p>Handle camera initialization, sample detection.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>class CameraHandler:\n    \"\"\"\n    Camera handler.\n\n    Handle camera initialization, sample detection.\n    \"\"\"\n\n    _camera_device: Path = None  # Camera device\n    _camera_codec: VideoCodec = None  # Video codec\n    _camera_frame_width: int = None  # Camera frame width\n    _camera_frame_height: int = None  # Camera frame height\n    _camera_capture: cv2.VideoCapture = None  # OpenCV video capture\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _frame_rate: float = 6  # Number of images processed by seconds\n    _exiting: bool = False  # Exit requested if True\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO client and connect to server.\n        \"\"\"\n        self.settings = Settings()\n        signal.signal(signal.SIGTERM, self.exit_handler)\n\n        self.record_filename: Path | None = None\n        self.record_writer: cv2.VideoWriter | None = None\n\n        self.sio = socketio.Client(logger=False, engineio_logger=False)\n        self.register_sio_events()\n        Thread(\n            target=lambda: polling2.poll(\n                self.sio_connect,\n                step=1,\n                ignore_exceptions=(socketio.exceptions.ConnectionError),\n                poll_forever=True,\n            )\n        ).start()\n\n    @staticmethod\n    def exit_handler(signum, frame):\n        \"\"\"\n        Function called when TERM signal is received.\n        \"\"\"\n        CameraHandler._exiting = True\n        raise ExitSignal()\n\n    def sio_connect(self) -&gt; bool:\n        \"\"\"\n        Connect to SocketIO server.\n        Returning True stops polling for connection to succeed.\n        \"\"\"\n        if self._exiting:\n            return True\n\n        self.sio.connect(str(self.settings.socketio_server_url), namespaces=[\"/beaconcam\"])\n        return True\n\n    def open_camera(self):\n        \"\"\"\n        Initialize camera and aruco markers detection parameters.\n        \"\"\"\n        self._camera_capture = cv2.VideoCapture(str(self.settings.camera_device), cv2.CAP_V4L2)\n        if not self._camera_capture.isOpened():\n            logger.error(f\"Camera handler: Cannot open camera device {self.settings.camera_device}\")\n            self._camera_capture.release()\n            self._camera_capture = None\n            return\n\n        fourcc = cv2.VideoWriter_fourcc(*self.settings.camera_codec.value)\n        ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n        if not ret:\n            logger.warning(f\"Video codec {self.settings.camera_codec} not supported\")\n            self.settings.camera_codec = None\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n        if not ret:\n            logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n            self.settings.camera_width = None\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n        if not ret:\n            logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n            self.settings.camera_height = None\n\n    def close_camera(self) -&gt; None:\n        \"\"\"\n        Release camera device.\n        \"\"\"\n        if self._camera_capture:\n            try:\n                self._camera_capture.release()\n                logger.info(\"Camera handler: Camera closed.\")\n            except Exception as exc:  # noqa\n                logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n        self._camera_capture = None\n\n    def open_last_frame(self, size: int) -&gt; None:\n        \"\"\"\n        Open the shared memory used to exchange last frame with the server.\n\n        Arguments:\n            size: Size of the shared memory\n        \"\"\"\n        if not self._last_frame:\n            try:\n                self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n                logger.info(\"Camera handler: shared memory for last_frame created.\")\n            except FileExistsError as exc:\n                logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n                self._last_frame = None\n\n    def close_last_frame(self) -&gt; None:\n        \"\"\"\n        Close last frame shared memory.\n        \"\"\"\n        if self._last_frame:\n            try:\n                self._last_frame.close()\n                self._last_frame.unlink()\n                logger.info(\"Camera handler: Shared memory for last frame closed.\")\n            except Exception as exc:\n                logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n        self._last_frame = None\n\n    def camera_handler(self) -&gt; None:\n        \"\"\"\n        Read and process frames from camera.\n        \"\"\"\n        interval = 1.0 / self._frame_rate\n\n        try:\n            while not self._exiting:\n                start = time.time()\n\n                if not self._camera_capture:\n                    self.open_camera()\n\n                if not self._camera_capture:\n                    logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                    sleep(1)\n                    continue\n\n                try:\n                    self.process_image()\n                except ExitSignal:\n                    break\n                except Exception as exc:\n                    logger.warning(f\"Unknown exception: {exc}\")\n                    self.close_camera()\n                    sleep(1)\n                    continue\n\n                now = time.time()\n                duration = now - start\n                if duration &gt; interval:\n                    logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n                else:\n                    wait = interval - duration\n                    time.sleep(wait)\n\n        except (KeyboardInterrupt, ExitSignal):\n            pass\n\n        logger.info(\"Camera handler: Exiting.\")\n\n        self.close_last_frame()\n        self.close_camera()\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def process_image(self) -&gt; None:\n        \"\"\"\n        Read one frame from camera, process it, send samples to cogip-server\n        and generate image to stream.\n        \"\"\"\n        image_color: np.ndarray\n        ret, image_color = self._camera_capture.read()\n        if not ret:\n            raise Exception(\"Camera handler: Cannot read frame.\")\n\n        image_stream: np.ndarray = image_color\n\n        # Encode the frame in BMP format (larger but faster than JPEG)\n        encoded_image: np.ndarray\n        ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n        if not ret:\n            raise Exception(\"Can't encode frame.\")\n\n        frame = encoded_image.tobytes()\n        self.open_last_frame(len(frame))\n\n        if self._last_frame:\n            self._last_frame.buf[0 : len(frame)] = frame\n\n        if self.record_writer:\n            self.record_writer.write(image_stream)\n\n    def start_video_record(self):\n        if self.record_writer:\n            self.stop_video_record()\n        records_dir = Path.home() / \"records\"\n        records_dir.mkdir(exist_ok=True)\n        # Keep only 20 last records\n        for old_record in sorted(records_dir.glob(\"*.mp4\"))[:-20]:\n            old_record.unlink()\n        timestamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n        self.record_filename = records_dir / f\"beacon_{timestamp}.mp4\"\n\n        logger.info(f\"Start recording video in {self.record_filename}\")\n        self.record_writer = cv2.VideoWriter(\n            str(self.record_filename),\n            cv2.VideoWriter_fourcc(*\"mp4v\"),\n            self._frame_rate,\n            (self.settings.camera_width, self.settings.camera_height),\n        )\n\n    def stop_video_record(self):\n        if self.record_writer:\n            logger.info(\"Stop recording video\")\n            self.record_writer.release()\n            self.record_filename = None\n            self.record_writer = None\n\n    def register_sio_events(self) -&gt; None:\n        @self.sio.event(namespace=\"/beaconcam\")\n        def connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Camera handler: connected to server\")\n            self.sio.emit(\"connected\", namespace=\"/beaconcam\")\n\n        @self.sio.event(namespace=\"/beaconcam\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            logger.info(\"Camera handler: connection to server failed.\")\n\n        @self.sio.event(namespace=\"/beaconcam\")\n        def disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Camera handler: disconnected from server\")\n\n        @self.sio.on(\"start_video_record\", namespace=\"/beaconcam\")\n        def start_video_record():\n            self.start_video_record()\n\n        @self.sio.on(\"stop_video_record\", namespace=\"/beaconcam\")\n        def stop_video_record():\n            self.stop_video_record()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO client and connect to server.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO client and connect to server.\n    \"\"\"\n    self.settings = Settings()\n    signal.signal(signal.SIGTERM, self.exit_handler)\n\n    self.record_filename: Path | None = None\n    self.record_writer: cv2.VideoWriter | None = None\n\n    self.sio = socketio.Client(logger=False, engineio_logger=False)\n    self.register_sio_events()\n    Thread(\n        target=lambda: polling2.poll(\n            self.sio_connect,\n            step=1,\n            ignore_exceptions=(socketio.exceptions.ConnectionError),\n            poll_forever=True,\n        )\n    ).start()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.camera_handler","title":"<code>camera_handler()</code>","text":"<p>Read and process frames from camera.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def camera_handler(self) -&gt; None:\n    \"\"\"\n    Read and process frames from camera.\n    \"\"\"\n    interval = 1.0 / self._frame_rate\n\n    try:\n        while not self._exiting:\n            start = time.time()\n\n            if not self._camera_capture:\n                self.open_camera()\n\n            if not self._camera_capture:\n                logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                sleep(1)\n                continue\n\n            try:\n                self.process_image()\n            except ExitSignal:\n                break\n            except Exception as exc:\n                logger.warning(f\"Unknown exception: {exc}\")\n                self.close_camera()\n                sleep(1)\n                continue\n\n            now = time.time()\n            duration = now - start\n            if duration &gt; interval:\n                logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n            else:\n                wait = interval - duration\n                time.sleep(wait)\n\n    except (KeyboardInterrupt, ExitSignal):\n        pass\n\n    logger.info(\"Camera handler: Exiting.\")\n\n    self.close_last_frame()\n    self.close_camera()\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.close_camera","title":"<code>close_camera()</code>","text":"<p>Release camera device.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def close_camera(self) -&gt; None:\n    \"\"\"\n    Release camera device.\n    \"\"\"\n    if self._camera_capture:\n        try:\n            self._camera_capture.release()\n            logger.info(\"Camera handler: Camera closed.\")\n        except Exception as exc:  # noqa\n            logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n    self._camera_capture = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.close_last_frame","title":"<code>close_last_frame()</code>","text":"<p>Close last frame shared memory.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def close_last_frame(self) -&gt; None:\n    \"\"\"\n    Close last frame shared memory.\n    \"\"\"\n    if self._last_frame:\n        try:\n            self._last_frame.close()\n            self._last_frame.unlink()\n            logger.info(\"Camera handler: Shared memory for last frame closed.\")\n        except Exception as exc:\n            logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n    self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.exit_handler","title":"<code>exit_handler(signum, frame)</code>  <code>staticmethod</code>","text":"<p>Function called when TERM signal is received.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>@staticmethod\ndef exit_handler(signum, frame):\n    \"\"\"\n    Function called when TERM signal is received.\n    \"\"\"\n    CameraHandler._exiting = True\n    raise ExitSignal()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.open_camera","title":"<code>open_camera()</code>","text":"<p>Initialize camera and aruco markers detection parameters.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def open_camera(self):\n    \"\"\"\n    Initialize camera and aruco markers detection parameters.\n    \"\"\"\n    self._camera_capture = cv2.VideoCapture(str(self.settings.camera_device), cv2.CAP_V4L2)\n    if not self._camera_capture.isOpened():\n        logger.error(f\"Camera handler: Cannot open camera device {self.settings.camera_device}\")\n        self._camera_capture.release()\n        self._camera_capture = None\n        return\n\n    fourcc = cv2.VideoWriter_fourcc(*self.settings.camera_codec.value)\n    ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {self.settings.camera_codec} not supported\")\n        self.settings.camera_codec = None\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n        self.settings.camera_width = None\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n        self.settings.camera_height = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.open_last_frame","title":"<code>open_last_frame(size)</code>","text":"<p>Open the shared memory used to exchange last frame with the server.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the shared memory</p> required Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def open_last_frame(self, size: int) -&gt; None:\n    \"\"\"\n    Open the shared memory used to exchange last frame with the server.\n\n    Arguments:\n        size: Size of the shared memory\n    \"\"\"\n    if not self._last_frame:\n        try:\n            self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n            logger.info(\"Camera handler: shared memory for last_frame created.\")\n        except FileExistsError as exc:\n            logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n            self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.process_image","title":"<code>process_image()</code>","text":"<p>Read one frame from camera, process it, send samples to cogip-server and generate image to stream.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def process_image(self) -&gt; None:\n    \"\"\"\n    Read one frame from camera, process it, send samples to cogip-server\n    and generate image to stream.\n    \"\"\"\n    image_color: np.ndarray\n    ret, image_color = self._camera_capture.read()\n    if not ret:\n        raise Exception(\"Camera handler: Cannot read frame.\")\n\n    image_stream: np.ndarray = image_color\n\n    # Encode the frame in BMP format (larger but faster than JPEG)\n    encoded_image: np.ndarray\n    ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n    if not ret:\n        raise Exception(\"Can't encode frame.\")\n\n    frame = encoded_image.tobytes()\n    self.open_last_frame(len(frame))\n\n    if self._last_frame:\n        self._last_frame.buf[0 : len(frame)] = frame\n\n    if self.record_writer:\n        self.record_writer.write(image_stream)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.sio_connect","title":"<code>sio_connect()</code>","text":"<p>Connect to SocketIO server. Returning True stops polling for connection to succeed.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def sio_connect(self) -&gt; bool:\n    \"\"\"\n    Connect to SocketIO server.\n    Returning True stops polling for connection to succeed.\n    \"\"\"\n    if self._exiting:\n        return True\n\n    self.sio.connect(str(self.settings.socketio_server_url), namespaces=[\"/beaconcam\"])\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/codecs/","title":"codecs","text":""},{"location":"reference/cogip/tools/beaconcam/codecs/#cogip.tools.beaconcam.codecs.VideoCodec","title":"<code>VideoCodec</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Video codecs supported by our cameras</p> Source code in <code>cogip/tools/beaconcam/codecs.py</code> <pre><code>class VideoCodec(str, Enum):\n    \"\"\"Video codecs supported by our cameras\"\"\"\n\n    mjpg = \"MJPG\"\n    yuyv = \"YUYV\"\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/main/","title":"main","text":""},{"location":"reference/cogip/tools/beaconcam/main/#cogip.tools.beaconcam.main.main","title":"<code>main()</code>","text":"<p>Launch COGIP Beacon Camera.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-beaconcam</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/beaconcam/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Launch COGIP Beacon Camera.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-beaconcam` script using this function as entrypoint.\n    \"\"\"\n    settings = Settings()\n\n    # Start Camera handler process\n    p = Process(target=start_camera_handler)\n    p.start()\n\n    # Start web server\n    uvicorn.run(\n        \"cogip.tools.beaconcam.app:app\",\n        host=\"0.0.0.0\",\n        port=8100,\n        workers=settings.nb_workers,\n        log_level=\"warning\",\n    )\n\n    p.terminate()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/","title":"server","text":""},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer","title":"<code>CameraServer</code>","text":"<p>Camera web server.</p> <p>Handle FastAPI server to stream camera video and SocketIO client.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>class CameraServer:\n    \"\"\"\n    Camera web server.\n\n    Handle FastAPI server to stream camera video and SocketIO client.\n    \"\"\"\n\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application and SocketIO client.\n        \"\"\"\n        self.settings = Settings()\n        CameraServer._exiting = False\n\n        self.app = FastAPI(title=\"COGIP Beacon Camera Streamer\", debug=False)\n        self.register_endpoints()\n\n        UvicornServer.handle_exit = self.handle_exit\n\n        self.records_dir = Path.home() / \"records\"\n        self.records_dir.mkdir(exist_ok=True)\n        # Keep only 100 last records\n        for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n            old_record.unlink()\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        CameraServer._exiting = True\n\n        if CameraServer._last_frame:\n            try:\n                CameraServer._last_frame.close()\n                logger.info(\"Camera server: Detached shared memory for last frame.\")\n            except FileNotFoundError:\n                pass\n\n        CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def camera_connect(self) -&gt; bool:\n        if self._exiting:\n            return True\n\n        try:\n            CameraServer._last_frame = SharedMemory(name=\"last_frame\")\n        except Exception:\n            CameraServer._last_frame = None\n            logger.warning(\"Camera server: Failed to attach to shared memory last_frame, retrying in 1s.\")\n            return False\n        logger.info(\"Camera server: Attached to shared memory last_frame.\")\n        return True\n\n    async def camera_streamer(self):\n        \"\"\"\n        Frame generator.\n        Yield frames produced by [camera_handler][cogip.tools.beaconcam.camera.CameraHandler.camera_handler].\n        \"\"\"\n        while not self._exiting:\n            yield b\"--frame\\r\\n\"\n            yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n            yield bytes(self._last_frame.buf)\n            yield b\"\\r\\n\"\n\n    def register_endpoints(self) -&gt; None:\n        @self.app.on_event(\"startup\")\n        async def startup_event():\n            \"\"\"\n            Function called at FastAPI server startup.\n            \"\"\"\n            # Poll in background to wait for camera server connection through shared memory.\n            Thread(\n                target=lambda: polling2.poll(\n                    self.camera_connect,\n                    step=1,\n                    poll_forever=True,\n                )\n            ).start()\n\n        @self.app.on_event(\"shutdown\")\n        async def shutdown_event():\n            \"\"\"\n            Function called at FastAPI server shutdown.\n            \"\"\"\n            pass\n\n        @self.app.get(\"/\")\n        def index():\n            \"\"\"\n            Camera stream.\n            \"\"\"\n            stream = self.camera_streamer() if CameraServer._last_frame else \"\"\n            return StreamingResponse(stream, media_type=\"multipart/x-mixed-replace;boundary=frame\")\n\n        @self.app.get(\"/snapshot\", status_code=200)\n        async def snapshot(camp: Camp.Colors):\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"beacon-snapshot-{timestamp}-{camp.name}\"\n\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            record_filename_full = self.records_dir / f\"{basename}_full.jpg\"\n            cv2.imwrite(str(record_filename_full), frame)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application and SocketIO client.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application and SocketIO client.\n    \"\"\"\n    self.settings = Settings()\n    CameraServer._exiting = False\n\n    self.app = FastAPI(title=\"COGIP Beacon Camera Streamer\", debug=False)\n    self.register_endpoints()\n\n    UvicornServer.handle_exit = self.handle_exit\n\n    self.records_dir = Path.home() / \"records\"\n    self.records_dir.mkdir(exist_ok=True)\n    # Keep only 100 last records\n    for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n        old_record.unlink()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.camera_streamer","title":"<code>camera_streamer()</code>  <code>async</code>","text":"<p>Frame generator. Yield frames produced by camera_handler.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>async def camera_streamer(self):\n    \"\"\"\n    Frame generator.\n    Yield frames produced by [camera_handler][cogip.tools.beaconcam.camera.CameraHandler.camera_handler].\n    \"\"\"\n    while not self._exiting:\n        yield b\"--frame\\r\\n\"\n        yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n        yield bytes(self._last_frame.buf)\n        yield b\"\\r\\n\"\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    CameraServer._exiting = True\n\n    if CameraServer._last_frame:\n        try:\n            CameraServer._last_frame.close()\n            logger.info(\"Camera server: Detached shared memory for last frame.\")\n        except FileNotFoundError:\n            pass\n\n    CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/settings/","title":"settings","text":""},{"location":"reference/cogip/tools/camera/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/camera/__main__/#cogip.tools.camera.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Camera Tools.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-camera</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/camera/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Camera Tools.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-camera` script using this function as entrypoint.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"reference/cogip/tools/camera/arguments/","title":"arguments","text":""},{"location":"reference/cogip/tools/camera/arguments/#cogip.tools.camera.arguments.CameraName","title":"<code>CameraName</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Supported cameras</p> Source code in <code>cogip/tools/camera/arguments.py</code> <pre><code>class CameraName(ArgEnum):\n    \"\"\"Supported cameras\"\"\"\n\n    hbv = Path(\"/dev/v4l/by-id/usb-HBV_HD_CAMERA_HBV_HD_CAMERA-video-index0\")\n    sonix = Path(\"/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_2.0_Camera_SN0001-video-index0\")\n</code></pre>"},{"location":"reference/cogip/tools/camera/arguments/#cogip.tools.camera.arguments.VideoCodec","title":"<code>VideoCodec</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Video codecs supported by our cameras</p> Source code in <code>cogip/tools/camera/arguments.py</code> <pre><code>class VideoCodec(ArgEnum):\n    \"\"\"Video codecs supported by our cameras\"\"\"\n\n    mjpg = \"MJPG\"\n    yuyv = \"YUYV\"\n</code></pre>"},{"location":"reference/cogip/tools/camera/calibrate/","title":"calibrate","text":""},{"location":"reference/cogip/tools/camera/calibrate/#cogip.tools.camera.calibrate.cmd_calibrate","title":"<code>cmd_calibrate(ctx, id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480, charuco_rows=13, charuco_cols=8, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=False)</code>","text":"<p>Calibrate camera using images captured by the 'capture' command</p> Source code in <code>cogip/tools/camera/calibrate.py</code> <pre><code>def cmd_calibrate(\n    ctx: typer.Context,\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 13,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 8,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = False,\n):\n    \"\"\"Calibrate camera using images captured by the 'capture' command\"\"\"\n    obj = ctx.ensure_object(dict)\n    debug = obj.get(\"debug\", False)\n    capture_path = Path(__file__).parent  # Directory to store captured frames\n    capture_path /= f\"cameras/{id}/{camera_name.name}_{camera_codec.name}_{camera_width}x{camera_height}/images\"\n    params_filename = get_camera_intrinsic_params_filename(id, camera_name, camera_codec, camera_width, camera_height)\n\n    if not capture_path.exists():\n        logger.error(f\"Captured images directory not found: {capture_path}\")\n        return\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_rows, charuco_cols),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    if charuco_legacy:\n        board.setLegacyPattern(True)\n\n    captured_images = list(capture_path.glob(\"image_*.jpg\"))\n    if (nb_img := len(captured_images)) &lt; 10:\n        logger.error(f\"Not enough images: {nb_img} &lt; 10\")\n        return\n\n    object_points = []\n    image_points: list[cv2.typing.MatLike] = []\n\n    board_detector = cv2.aruco.CharucoDetector(board)\n\n    for im in sorted(captured_images)[0:]:\n        frame = cv2.imread(str(im))\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        char_corners, char_ids, _, _ = board_detector.detectBoard(gray)\n        if char_corners is None or len(char_corners) == 0:\n            logger.info(f\"{im}: KO\")\n            continue\n        logger.info(f\"{im}: OK\")\n        frame_obj_points, frame_img_points = board.matchImagePoints(char_corners, char_ids)\n        object_points.append(frame_obj_points)\n        image_points.append(frame_img_points)\n\n        if debug:\n            cv2.aruco.drawDetectedCornersCharuco(frame, char_corners, char_ids)\n            cv2.imshow(\"img\", frame)\n            cv2.waitKey(1000)\n\n    ret, camera_matrix, dist_coefs, _, _ = cv2.calibrateCamera(\n        object_points,\n        image_points,\n        (camera_width, camera_height),\n        None,\n        None,\n    )\n\n    logger.debug(f\"Camera calibration status: {ret}\")\n    logger.debug(\"- camera matrix:\")\n    logger.debug(camera_matrix)\n    logger.debug(\"- dist coefs:\")\n    logger.debug(dist_coefs)\n\n    save_camera_intrinsic_params(camera_matrix, dist_coefs, params_filename)\n    logger.info(f\"Calibration parameters stored in: {params_filename}\")\n</code></pre>"},{"location":"reference/cogip/tools/camera/capture/","title":"capture","text":""},{"location":"reference/cogip/tools/camera/capture/#cogip.tools.camera.capture.cmd_capture","title":"<code>cmd_capture(id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480, max_frames=120, capture_interval=10, charuco_rows=8, charuco_cols=13, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=False)</code>","text":"<p>Capture images to be used by the 'calibrate' command</p> Source code in <code>cogip/tools/camera/capture.py</code> <pre><code>def cmd_capture(\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n    max_frames: Annotated[\n        int,\n        typer.Option(\n            help=\"Maximum number of frames to read before exiting\",\n            envvar=\"CAMERA_MAX_FRAMES\",\n        ),\n    ] = 120,\n    capture_interval: Annotated[\n        int,\n        typer.Option(\n            help=\"Capture an image every 'capture_interval' frames\",\n            envvar=\"CAMERA_CAPTURE_INTERVAL\",\n        ),\n    ] = 10,\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 8,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 13,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = False,\n):\n    \"\"\"Capture images to be used by the 'calibrate' command\"\"\"\n    exit_key = 27  # use this key (Esc) to exit before max_frames\n    captures_frames: list[cv2.typing.MatLike] = []  # Captured frames\n    capture_path = Path(__file__).parent  # Directory to store captured frames\n    capture_path /= f\"cameras/{id}/{camera_name.name}_{camera_codec.name}_{camera_width}x{camera_height}/images\"\n    charuco_window_name = \"Charuco Board\"\n    preview_window_name = \"Detection Preview - Press Esc to exit\"\n\n    cv2.namedWindow(charuco_window_name, cv2.WINDOW_NORMAL | cv2.WINDOW_GUI_EXPANDED)\n    cv2.namedWindow(preview_window_name, cv2.WINDOW_NORMAL | cv2.WINDOW_GUI_EXPANDED)\n\n    if not Path(camera_name.val).exists():\n        logger.error(f\"Camera not found: {camera_name.val}\")\n        return\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_rows, charuco_cols),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    if charuco_legacy:\n        board.setLegacyPattern(True)\n    board_image = board.generateImage((charuco_rows * charuco_square_length, charuco_cols * charuco_square_length))\n    cv2.imshow(charuco_window_name, board_image)\n\n    cap = cv2.VideoCapture(str(camera_name.val), cv2.CAP_V4L2)\n    fourcc = cv2.VideoWriter_fourcc(*camera_codec.val)\n    ret = cap.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {camera_codec.val} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {camera_width} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {camera_height} not supported\")\n\n    i = capture_interval\n    while True:\n        _, frame = cap.read()\n\n        board_detector = cv2.aruco.CharucoDetector(board)\n\n        k = cv2.waitKey(1)\n        if k == exit_key:\n            break\n        elif i == 0:\n            i = capture_interval\n            captures_frames.append(frame)\n            logger.info(f\"Frame captured: {len(captures_frames)}\")\n            if len(captures_frames) == max_frames:\n                break\n        i -= 1\n\n        detected_frame = frame.copy()\n        _, _, marker_corners, marker_ids = board_detector.detectBoard(frame)\n        cv2.aruco.drawDetectedMarkers(detected_frame, marker_corners, marker_ids)\n\n        cv2.imshow(preview_window_name, detected_frame)\n\n    logger.info(f\"Writing captured frames in: {capture_path}\")\n    shutil.rmtree(capture_path, ignore_errors=True)\n    capture_path.mkdir(parents=True, exist_ok=True)\n    for n, frame in enumerate(captures_frames):\n        filename = capture_path / f\"image_{n:03}.jpg\"\n        cv2.imwrite(str(filename), frame)\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/","title":"detect","text":""},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.cmd_detect","title":"<code>cmd_detect(id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480, robot_position=None)</code>","text":"<p>Detect Aruco tags and estimate their positions</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def cmd_detect(\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n    robot_position: Annotated[\n        Optional[int],  # noqa\n        typer.Option(\n            help=\"Define the robot position\",\n            envvar=\"CAMERA_ROBOT_POSITION\",\n            min=1,\n            max=6,\n        ),\n    ] = None,\n):\n    \"\"\"Detect Aruco tags and estimate their positions\"\"\"\n    exit_key = 27  # use this key (Esc) to exit before max_frames\n\n    if not camera_name.val.exists():\n        logger.error(f\"Camera not found: {camera_name.val}\")\n        return\n\n    # Load intrinsic parameters (mandatory)\n    intrinsic_params_filename = get_camera_intrinsic_params_filename(\n        id, camera_name, camera_codec, camera_width, camera_height\n    )\n\n    if not intrinsic_params_filename.exists():\n        logger.error(f\"Intrinsic parameters file not found: {intrinsic_params_filename}\")\n        return\n\n    camera_matrix, dist_coefs = load_camera_intrinsic_params(intrinsic_params_filename)\n\n    # Load extrinsic parameters (optional)\n    extrinsic_params_filename = get_camera_extrinsic_params_filename(\n        id, camera_name, camera_codec, camera_width, camera_height\n    )\n\n    if not extrinsic_params_filename.exists():\n        logger.warning(f\"Extrinsic parameters file not found: {extrinsic_params_filename}\")\n        return\n\n    extrinsic_params = load_camera_extrinsic_params(extrinsic_params_filename)\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n    parameters = cv2.aruco.DetectorParameters()\n    detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)\n\n    cap = cv2.VideoCapture(str(camera_name.val), apiPreference=cv2.CAP_V4L2)\n    fourcc = cv2.VideoWriter_fourcc(*camera_codec.val)\n    ret = cap.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {camera_codec.val} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {camera_width} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {camera_height} not supported\")\n\n    cv2.namedWindow(\"Marker Detection\", cv2.WINDOW_NORMAL | cv2.WINDOW_GUI_EXPANDED)\n\n    while True:\n        _, frame = cap.read()\n\n        dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        # Detect marker corners\n        marker_corners, marker_ids, _ = detector.detectMarkers(dst)\n\n        # Draw detected markers\n        cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n        # Classify detected markers by id and size\n        corners_by_id = {}\n        corners_by_size = {}\n        if marker_ids is not None:\n            for id, corners in zip(marker_ids, marker_corners):\n                size = marker_sizes.get(id[0])\n                if not size:\n                    continue\n                if id[0] not in corners_by_id:\n                    corners_by_id[id[0]] = []\n                corners_by_id[id[0]].append(corners)\n                if size not in corners_by_size:\n                    corners_by_size[size] = []\n                corners_by_size[size].append((id[0], corners))\n\n        # Handle table markers\n        table_markers = {\n            id: corners[0]  # There can be only one marker of each id\n            for id, corners in corners_by_id.items()\n            if id in [20, 21, 22, 23]\n        }\n        handle_table_markers(\n            table_markers,\n            camera_matrix,\n            dist_coefs,\n            get_robot_position(robot_position),\n        )\n\n        # Handle solar panel markers\n        solar_panel_markers = []\n        if 47 in corners_by_id:\n            solar_panel_markers = corners_by_id[47]\n        get_solar_panel_positions(\n            solar_panel_markers,\n            camera_matrix,\n            dist_coefs,\n            extrinsic_params,\n            get_robot_position(robot_position),\n        )\n\n        if marker_ids is not None:\n            # Draw all markers borders\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Draw all markers axes\n            for id, corner in zip(marker_ids, marker_corners):\n                marker_id = id[0]\n                if marker_id not in marker_sizes:\n                    logger.warning(f\"Unknown marker found: {marker_id}\")\n                    continue\n\n                _, rvec, tvec = cv2.solvePnP(\n                    get_marker_points(marker_sizes[marker_id]),\n                    corner,\n                    camera_matrix,\n                    dist_coefs,\n                    False,\n                    cv2.SOLVEPNP_IPPE_SQUARE,\n                )\n                cv2.drawFrameAxes(frame, camera_matrix, dist_coefs, rvec, tvec, 50)\n\n        cv2.imshow(\"Marker Detection\", frame)\n\n        k = cv2.waitKey(1)\n        if k == exit_key:\n            break\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_camera_position_on_table","title":"<code>get_camera_position_on_table(table_markers, camera_matrix, dist_coefs)</code>","text":"<p>Return a 3D NDArray of camera position and its rotation in radians in the table coordinate system.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_camera_position_on_table(\n    table_markers: dict[int, MatLike],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n) -&gt; tuple[ArrayLike, float]:\n    \"\"\"\n    Return a 3D NDArray of camera position and its rotation in radians\n    in the table coordinate system.\n    \"\"\"\n    tvecs = {}\n    rvecs = {}\n    distances = {}\n\n    for id, corners in table_markers.items():\n        # Get marker coordinates in the camera coordinate system\n        _, rvec, tvec = cv2.solvePnP(\n            get_marker_points(marker_sizes[id]),\n            corners,\n            camera_matrix,\n            dist_coefs,\n            False,\n            cv2.SOLVEPNP_IPPE_SQUARE,\n        )\n\n        # Distance from the camera to the marker\n        distance = np.sqrt(tvec[0] ** 2 + tvec[1] ** 2 + tvec[2] ** 2)\n\n        # Keep the nearest marker for each id\n        if id not in distances or distances[id] &gt; distance:\n            distances[id] = distance\n            tvecs[id] = tvec\n            rvecs[id] = rvec\n\n    # Get nearest marker: sort by value (distance) in ascending order, and take first element key (id)\n    marker_id, _ = sorted(distances.items(), key=lambda x: x[1])[0]\n    marker_tvec = tvecs[marker_id][:, 0]\n    marker_rvec = rvecs[marker_id][:, 0]\n    marker_rvec_degrees = np.rad2deg(marker_rvec)\n\n    logger.info(\n        f\"- Table marker {marker_id} position relative to camera coordinate system: \"\n        f\"X={marker_tvec[0]:.0f} \"\n        f\"Y={marker_tvec[1]:.0f} \"\n        f\"Z={marker_tvec[2]:.0f} \"\n        f\"roll={marker_rvec_degrees[0]:.0f} \"\n        f\"pitch={marker_rvec_degrees[1]:.0f} \"\n        f\"yaw={marker_rvec_degrees[2]:.0f}\"\n    )\n\n    # Get camera coordinates relative to the marker in the marker axes\n    R_ct = np.matrix(cv2.Rodrigues(marker_rvec)[0])\n    R_tc = R_ct.T\n    camera_tvec = -R_tc * np.matrix(marker_tvec).T  # 2D matrix: [[x], [y], [z]]\n    camera_tvec = np.asarray(camera_tvec).flatten()  # 1D array: [x, y, z]\n    camera_rvec = rotation_matrix_to_euler_angles(R_flip * R_tc)  # 1D array: [roll, pitch, yaw]\n    camera_rvec_degrees = np.rad2deg(camera_rvec)\n\n    logger.info(\n        \"- Camera position relative to the marker in the marker axes: \"\n        f\"X={camera_tvec[0]:.0f} \"\n        f\"Y={camera_tvec[1]:.0f} \"\n        f\"Z={camera_tvec[2]:.0f} \"\n        f\"Angle={camera_rvec_degrees[2]:.0f}\"\n    )\n\n    # Get camera position relative to the marker in the table axes\n    camera_tvec, camera_angle = marker_to_table_axes(camera_tvec, camera_rvec[2])\n    camera_angle_degrees = np.degrees(camera_angle)\n    logger.info(\n        \"- Camera position relative to the marker in the table axes: \"\n        f\"X={camera_tvec[0]:.0f} \"\n        f\"Y={camera_tvec[1]:.0f} \"\n        f\"Z={camera_tvec[2]:.0f} \"\n        f\"Angle={camera_angle_degrees:.0f}\"\n    )\n\n    # Get camera position in the table coordinate system\n    table_camera_tvec = camera_tvec + table_markers_tvecs[marker_id]\n\n    logger.info(\n        \"- Camera position in table coordinate system: \"\n        f\"X={table_camera_tvec[0]:.0f} \"\n        f\"Y={table_camera_tvec[1]:.0f} \"\n        f\"Z={table_camera_tvec[2]:.0f} \"\n        f\"Angle={camera_angle_degrees:.0f}\"\n    )\n\n    return (table_camera_tvec, camera_angle)\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_marker_points","title":"<code>get_marker_points(marker_size)</code>  <code>cached</code>","text":"<p>Get marker points matrix based on marker size, as used by cv2.solvePnP</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>@lru_cache\ndef get_marker_points(marker_size: float):\n    \"\"\"Get marker points matrix based on marker size, as used by cv2.solvePnP\"\"\"\n    return np.array(\n        [\n            [-marker_size / 2, marker_size / 2, 0],\n            [marker_size / 2, marker_size / 2, 0],\n            [marker_size / 2, -marker_size / 2, 0],\n            [-marker_size / 2, -marker_size / 2, 0],\n        ],\n        dtype=np.float32,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_robot_position","title":"<code>get_robot_position(n)</code>","text":"<p>Define the possible start positions.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_robot_position(n: int) -&gt; Pose | None:\n    \"\"\"\n    Define the possible start positions.\n    \"\"\"\n    match n:\n        case 1:  # Back left (yellow)\n            return Pose(\n                x=1000 - 450 + robot_width / 2,\n                y=1500 - 450 + robot_width / 2,\n                O=-90,\n            )\n        case 2:  # Front left (yellow)\n            return Pose(\n                x=-(1000 - 450 + robot_width / 2),\n                y=1500 - 450 + robot_width / 2,\n                O=-90,\n            )\n        case 3:  # Middle right (yellow)\n            return Pose(\n                x=robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 4:  # Back right (blue)\n            return Pose(\n                x=1000 - 450 + robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 5:  # Front right (blue)\n            return Pose(\n                x=-(1000 - 450 + robot_width / 2),\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 6:  # Middle left (blue)\n            return Pose(\n                x=robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n\n    logger.error(\"Unknown robot position: {n}\")\n\n    return None\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_solar_panel_positions","title":"<code>get_solar_panel_positions(markers, camera_matrix, dist_coefs, extrinsic_params, robot_position)</code>","text":"<p>Compute position of solar panels relative to the table coordinate system</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_solar_panel_positions(\n    markers: list[list[ArrayLike]],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n    extrinsic_params: CameraExtrinsicParameters,\n    robot_position: Pose | None,\n) -&gt; dict[int, float]:\n    \"\"\"\n    Compute position of solar panels relative to the table coordinate system\n    \"\"\"\n    panels: dict[int, float] = {}\n\n    if len(markers) == 0:\n        logger.debug(\"No solar panel marker found.\")\n        return panels\n\n    for i, corners in enumerate(markers):\n        # Get marker coordinates in the camera coordinate system\n        _, rvec, tvec = cv2.solvePnP(\n            get_marker_points(marker_sizes[47]),\n            corners,\n            camera_matrix,\n            dist_coefs,\n            False,\n            cv2.SOLVEPNP_IPPE_SQUARE,\n        )\n        marker_tvec = tvec[:, 0]\n        marker_rvec = rvec[:, 0]\n        marker_rvec_degrees = np.rad2deg(marker_rvec)\n        logger.info(f\"Solar panel marker {i}:\")\n        logger.info(\n            f\"- Position relative to camera coordinate system: \"\n            f\"X={marker_tvec[0]:.0f} \"\n            f\"Y={marker_tvec[1]:.0f} \"\n            f\"Z={marker_tvec[2]:.0f} \"\n            f\"roll={marker_rvec_degrees[0]:.0f} \"\n            f\"pitch={marker_rvec_degrees[1]:.0f} \"\n            f\"yaw={marker_rvec_degrees[2]:.0f}\"\n        )\n\n        # Get camera coordinates relative to the marker in the marker axes\n        R_ct = np.matrix(cv2.Rodrigues(marker_rvec)[0])\n        R_tc = R_ct.T\n        marker_camera_tvec = -R_tc * np.matrix(marker_tvec).T  # 2D matrix: [[x], [y], [z]]\n        marker_camera_tvec = np.asarray(marker_camera_tvec).flatten()  # 1D array: [x, y, z]\n        marker_camera_rvec = rotation_matrix_to_euler_angles(R_flip * R_tc)  # 1D array: [roll, pitch, yaw]\n\n        # Use same axes as the table\n        marker_camera_tvec[0], marker_camera_tvec[1] = marker_camera_tvec[1], marker_camera_tvec[0]\n        marker_camera_rvec[2] = -marker_camera_rvec[2]\n\n        marker_camera_rvec_degrees = np.rad2deg(marker_camera_rvec)\n\n        logger.info(\n            \"- Camera position relative to the marker in the marker axes: \"\n            f\"X={marker_camera_tvec[0]:.0f} \"\n            f\"Y={marker_camera_tvec[1]:.0f} \"\n            f\"Z={marker_camera_tvec[2]:.0f} \"\n            f\"roll={marker_camera_rvec_degrees[0]:.0f} \"\n            f\"pitch={marker_camera_rvec_degrees[1]:.0f} \"\n            f\"yaw={marker_camera_rvec_degrees[2]:.0f}\"\n        )\n\n        # Compute marker position relative to the camera in the robot axes\n        hypot = np.hypot(marker_tvec[1], marker_tvec[2])\n\n        angle_marker = np.arcsin(marker_tvec[1] / hypot)\n        angle_camera = np.pi / 2 - marker_camera_rvec[0] + angle_marker\n\n        dist_camera_to_marker_tvec = np.array(\n            [\n                hypot * np.cos(angle_camera),\n                -marker_tvec[0],\n                hypot * np.sin(angle_camera),\n            ]\n        )\n        logger.info(\n            \"- Marker position relative to the camera in the robot axes: \"\n            f\"X={dist_camera_to_marker_tvec[0]:.0f} \"\n            f\"Y={dist_camera_to_marker_tvec[1]:.0f} \"\n            f\"Z={dist_camera_to_marker_tvec[2]:.0f}\"\n        )\n\n        # Compute marker position relative to the robot in the robot axes\n        dist_robot_to_marker_tvec = np.array(\n            [\n                dist_camera_to_marker_tvec[0] - extrinsic_params.x,\n                dist_camera_to_marker_tvec[1] - extrinsic_params.y,\n                extrinsic_params.z - dist_camera_to_marker_tvec[2],\n            ]\n        )\n        logger.info(\n            \"- Marker position relative to the robot in the robot axes: \"\n            f\"X={dist_robot_to_marker_tvec[0]:.0f} \"\n            f\"Y={dist_robot_to_marker_tvec[1]:.0f} \"\n            f\"Z={dist_robot_to_marker_tvec[2]:.0f}\"\n        )\n\n        if robot_position:\n            # Compute solar panel angle in the table coordinate system\n            panel_angle = wrap_to_pi(np.deg2rad(robot_position.O) - marker_camera_rvec[2])\n            panel_angle_degrees = np.rad2deg(panel_angle)\n            logger.info(f\"- Angle in table the axes : {panel_angle_degrees:.0f} ({marker_camera_rvec[2]})\")\n\n            # Compute solar panel marker position  in the table coordinate system\n            table_robot_rotated = rotate_2d(\n                np.array([robot_position.x, robot_position.y]), -np.deg2rad(robot_position.O)\n            )\n            table_marker_rotated = table_robot_rotated + dist_robot_to_marker_tvec[0:2]\n            table_marker_xy = rotate_2d(table_marker_rotated, np.deg2rad(robot_position.O))\n            table_marker_tvec = np.array([table_marker_xy[0], table_marker_xy[1], dist_robot_to_marker_tvec[2]])\n\n            logger.info(\n                \"- Marker position relative in the table coordinates: \"\n                f\"X={table_marker_tvec[0]:.0f} \"\n                f\"Y={table_marker_tvec[1]:.0f} \"\n                f\"Z={table_marker_tvec[2]:.0f}\"\n            )\n\n            # Find solar panel id\n            for n, panel_tvec in solar_panels_tvecs.items():\n                # Solar panel are separated by a minimum of 250 mm.\n                # Considering the precision of the detection, a solar panel detected less than 60 mm around\n                # its theoretical position is enough to identify a specific solar panel.\n                maximum_detection_distance = 60\n                if np.linalg.norm(panel_tvec - table_marker_tvec) &lt; maximum_detection_distance:\n                    panels[n] = panel_angle_degrees\n                    break\n\n    return panels\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.handle_table_markers","title":"<code>handle_table_markers(markers, camera_matrix, dist_coefs, robot_position)</code>","text":"<p>Compute camera position on table and camera position in robot if robot position is given</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def handle_table_markers(\n    markers: dict[int, MatLike],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n    robot_position: Vertex | None,\n):\n    \"\"\"Compute camera position on table and camera position in robot if robot position is given\"\"\"\n    if len(markers) == 0:\n        logger.debug(\"No table marker found, skip robot positioning.\")\n        return\n\n    # Compute camera position on table\n    table_camera_tvec, table_camera_angle = get_camera_position_on_table(\n        markers,\n        camera_matrix,\n        dist_coefs,\n    )\n\n    # Compute camera position in robot if robot position is given\n    if robot_position:\n        get_camera_position_in_robot(\n            robot_position,\n            table_camera_tvec,\n            table_camera_angle,\n        )\n</code></pre>"},{"location":"reference/cogip/tools/camera/info/","title":"info","text":""},{"location":"reference/cogip/tools/camera/info/#cogip.tools.camera.info.cmd_info","title":"<code>cmd_info(ctx, camera_name=None, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480)</code>","text":"<p>Get properties of connected cameras</p> Source code in <code>cogip/tools/camera/info.py</code> <pre><code>def cmd_info(\n    ctx: typer.Context,\n    camera_name: Annotated[\n        Optional[CameraName],  # noqa\n        typer.Option(\n            help=\"Name of the camera (all if not specified)\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = None,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n):\n    \"\"\"Get properties of connected cameras\"\"\"\n    obj = ctx.ensure_object(dict)\n    debug = obj.get(\"debug\", False)\n\n    if debug:\n        v4l2py.device.log.setLevel(logging.DEBUG)\n    else:\n        v4l2py.device.log.setLevel(logging.INFO)\n\n    if camera_name:\n        if not Path(camera_name.val).exists():\n            logger.error(f\"Camera not found: {camera_name}\")\n            return\n        device = v4l2py.Device(camera_name.val)\n        try:\n            device.open()\n        except OSError:\n            logger.error(f\"Failed to open {camera_name.val}\")\n            return\n        print_device_info(device)\n        device.close()\n        show_stream(camera_name, camera_codec, camera_width, camera_height)\n        return\n\n    for device in v4l2py.iter_video_capture_devices():\n        try:\n            device.open()\n        except OSError:\n            pass\n        else:\n            print_device_info(device)\n            device.close()\n            print()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/","title":"utils","text":""},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.get_camera_extrinsic_params_filename","title":"<code>get_camera_extrinsic_params_filename(robot_id, name, codec, width, height)</code>","text":"<p>Get parameters filename based on current package path and camera parameters</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def get_camera_extrinsic_params_filename(\n    robot_id: int,\n    name: CameraName,\n    codec: VideoCodec,\n    width: int,\n    height: int,\n) -&gt; Path:\n    \"\"\"Get parameters filename based on current package path and camera parameters\"\"\"\n    params_filename = Path(__file__).parent\n    params_filename /= f\"cameras/{robot_id}/{name.name}_{codec.name}_{width}x{height}/extrinsic_params.json\"\n    return params_filename\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.get_camera_intrinsic_params_filename","title":"<code>get_camera_intrinsic_params_filename(robot_id, name, codec, width, height)</code>","text":"<p>Get parameters filename based on current package path and camera parameters</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def get_camera_intrinsic_params_filename(\n    robot_id: int,\n    name: CameraName,\n    codec: VideoCodec,\n    width: int,\n    height: int,\n) -&gt; Path:\n    \"\"\"Get parameters filename based on current package path and camera parameters\"\"\"\n    params_filename = Path(__file__).parent\n    params_filename /= f\"cameras/{robot_id}/{name.name}_{codec.name}_{width}x{height}/intrinsic_params.yaml\"\n    return params_filename\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.is_rotation_matrix","title":"<code>is_rotation_matrix(R)</code>","text":"<p>Checks if a matrix is a valid rotation matrix</p> <p>Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def is_rotation_matrix(R):\n    \"\"\"\n    Checks if a matrix is a valid rotation matrix\n\n    Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/\n    \"\"\"\n    Rt = np.transpose(R)\n    shouldBeIdentity = np.dot(Rt, R)\n    ident = np.identity(3, dtype=R.dtype)\n    n = np.linalg.norm(ident - shouldBeIdentity)\n    return n &lt; 1e-6\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.load_camera_extrinsic_params","title":"<code>load_camera_extrinsic_params(path)</code>","text":"<p>Loads camera position relative to robot center.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def load_camera_extrinsic_params(path: Path) -&gt; CameraExtrinsicParameters:\n    \"\"\"Loads camera position relative to robot center.\"\"\"\n    return CameraExtrinsicParameters.model_validate_json(path.read_text())\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.load_camera_intrinsic_params","title":"<code>load_camera_intrinsic_params(path)</code>","text":"<p>Loads camera matrix and distortion coefficients.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def load_camera_intrinsic_params(path: Path) -&gt; tuple[cv2.typing.MatLike, cv2.typing.MatLike]:\n    \"\"\"Loads camera matrix and distortion coefficients.\"\"\"\n    cv_file = cv2.FileStorage(str(path), cv2.FILE_STORAGE_READ)\n    camera_matrix = cv_file.getNode(\"K\").mat()\n    dist_coefs = cv_file.getNode(\"D\").mat()\n    cv_file.release()\n    return [camera_matrix, dist_coefs]\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.rotate_2d","title":"<code>rotate_2d(vector, angle)</code>","text":"<p>Rotate a 2D point with specify angle</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def rotate_2d(vector: cv2.typing.MatLike, angle: float) -&gt; cv2.typing.MatLike:\n    \"\"\"Rotate a 2D point with specify angle\"\"\"\n    rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\n    vector = vector.reshape(1, 2)\n    vector = vector.T\n    rotated: cv2.typing.MatLike = (rotation_matrix @ vector).T\n    return rotated.squeeze()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.rotation_matrix_to_euler_angles","title":"<code>rotation_matrix_to_euler_angles(R)</code>","text":"<p>Calculates rotation matrix to euler angles. The result is the same as MATLAB except the order of the euler angles (x and z are swapped).</p> <p>Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def rotation_matrix_to_euler_angles(R):\n    \"\"\"\n    Calculates rotation matrix to euler angles.\n    The result is the same as MATLAB except the order\n    of the euler angles (x and z are swapped).\n\n    Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/\n    \"\"\"\n    assert is_rotation_matrix(R)\n\n    sy = np.sqrt(R[0, 0] * R[0, 0] + R[1, 0] * R[1, 0])\n\n    singular = sy &lt; 1e-6\n\n    if not singular:\n        x = np.arctan2(R[2, 1], R[2, 2])\n        y = np.arctan2(-R[2, 0], sy)\n        z = np.arctan2(R[1, 0], R[0, 0])\n    else:\n        x = np.arctan2(-R[1, 2], R[1, 1])\n        y = np.arctan2(-R[2, 0], sy)\n        z = 0\n\n    return np.array([x, y, z])\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.save_camera_extrinsic_params","title":"<code>save_camera_extrinsic_params(params, path)</code>","text":"<p>Save the camera position relative to robot center to given path/file.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def save_camera_extrinsic_params(params: CameraExtrinsicParameters, path: Path):\n    \"\"\"Save the camera position relative to robot center to given path/file.\"\"\"\n    path.write_text(CameraExtrinsicParameters.model_dump_json(indent=2))\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.save_camera_intrinsic_params","title":"<code>save_camera_intrinsic_params(camera_matrix, dist_coefs, path)</code>","text":"<p>Save the camera matrix and the distortion coefficients to given path/file.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def save_camera_intrinsic_params(camera_matrix: cv2.typing.MatLike, dist_coefs: cv2.typing.MatLike, path: Path):\n    \"\"\"Save the camera matrix and the distortion coefficients to given path/file.\"\"\"\n    cv_file = cv2.FileStorage(str(path), cv2.FILE_STORAGE_WRITE)\n    cv_file.write(\"K\", camera_matrix)\n    cv_file.write(\"D\", dist_coefs)\n    cv_file.release()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.wrap_to_pi","title":"<code>wrap_to_pi(angle)</code>","text":"<p>Wrap angle to PI, return a angle value between <code>-PI</code> and <code>PI</code></p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Angle in radians</p> required <p>Returns:</p> Type Description <code>float</code> <p>Wrapped angle, in radians</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def wrap_to_pi(angle: float) -&gt; float:\n    \"\"\"Wrap angle to PI, return a angle value between `-PI` and `PI`\n\n    Arguments:\n        angle: Angle in radians\n\n    Returns:\n        Wrapped angle, in radians\n    \"\"\"\n    return np.arctan2(np.sin(angle), np.cos(angle))\n</code></pre>"},{"location":"reference/cogip/tools/cansend/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cansend/__main__/#cogip.tools.cansend.__main__.main","title":"<code>main()</code>","text":"<p>Run cansend utility.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-cansend</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/cansend/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Run cansend utility.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-cansend` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/copilot/__main__/#cogip.tools.copilot.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-copilot</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/copilot/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-copilot` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/controller/","title":"controller","text":""},{"location":"reference/cogip/tools/copilot/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot","title":"<code>Copilot</code>","text":"<p>Main copilot class.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>class Copilot:\n    \"\"\"\n    Main copilot class.\n    \"\"\"\n\n    loop: asyncio.AbstractEventLoop = None  # Event loop to use for all coroutines\n\n    def __init__(self, server_url: str, id: int, can_channel: str, can_bitrate: int, canfd_data_bitrate: int):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            server_url: server URL\n            id: robot id\n            can_channel: CAN channel connected to STM32 device\n            can_bitrate: CAN bitrate\n            canfd_data_bitrate: CAN data bitrate\n        \"\"\"\n        self.server_url = server_url\n        self.id = id\n        self.retry_connection = True\n        self.shell_menu: models.ShellMenu | None = None\n        self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_pose_current_lock: WritePriorityLock | None = None\n        self.shared_avoidance_path: SharedPoseOrderList | None = None\n        self.shared_avoidance_path_lock: WritePriorityLock | None = None\n        self.new_path_event_task: asyncio.Task | None = None\n\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_events = SioEvents(self)\n        self.sio.register_namespace(self.sio_events)\n\n        pb_message_handlers = {\n            reset_uuid: self.handle_reset,\n            pose_order_uuid: self.handle_message_pose,\n            state_uuid: self.handle_message_state,\n            pose_reached_uuid: self.handle_pose_reached,\n            intermediate_pose_reached_uuid: self.handle_intermediate_pose_reached,\n            actuator_state_uuid: self.handle_actuator_state,\n            pid_uuid: self.handle_pid,\n            blocked_uuid: self.handle_blocked,\n        }\n\n        self.pbcom = PBCom(can_channel, can_bitrate, canfd_data_bitrate, pb_message_handlers)\n\n    def create_shared_memory(self):\n        self.shared_memory = SharedMemory(f\"cogip_{self.id}\")\n        self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n        self.shared_pose_current_lock = self.shared_memory.get_lock(LockName.PoseCurrent)\n        self.shared_avoidance_path = self.shared_memory.get_avoidance_path()\n        self.shared_avoidance_path_lock = self.shared_memory.get_lock(LockName.AvoidancePath)\n        self.shared_avoidance_path_lock.register_consumer()\n        self.new_path_event_task = asyncio.create_task(\n            self.new_path_event_loop(),\n            name=\"Robot: Task New Path Event Watcher Loop\",\n        )\n\n    async def delete_shared_memory(self):\n        if self.new_path_event_task:\n            self.new_path_event_task.cancel()\n            try:\n                await self.new_path_event_task\n            except asyncio.CancelledError:\n                logger.info(\"Copilot: Task New Path Event Watcher Loop stopped\")\n            except Exception as exc:\n                logger.warning(f\"Copilot: Unexpected exception {exc}\")\n                traceback.print_exc()\n        self.new_path_event_task = None\n\n        self.shared_avoidance_path_lock = None\n        self.shared_avoidance_path = None\n        self.shared_pose_current_buffer = None\n        self.shared_pose_current_lock = None\n        self.shared_memory = None\n\n    async def run(self):\n        \"\"\"\n        Start copilot.\n        \"\"\"\n        self.loop = asyncio.get_running_loop()\n\n        self.retry_connection = True\n        await self.try_connect()\n\n        await self.pbcom.send_can_message(copilot_connected_uuid, None)\n\n        await self.pbcom.run()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    async def handle_reset(self) -&gt; None:\n        \"\"\"\n        Handle reset message. This means that the robot has just booted.\n\n        Send a reset message to all connected clients.\n        \"\"\"\n        logger.info(\"[CAN] Received reset\")\n        await self.pbcom.send_can_message(copilot_connected_uuid, None)\n        await self.sio_events.emit(\"reset\")\n\n    @pb_exception_handler\n    async def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot pose received from the robot to connected monitors and detector.\n        \"\"\"\n        pb_pose = PB_Pose()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n        pose = MessageToDict(\n            pb_pose,\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio_events.connected:\n            self.shared_pose_current_lock.start_writing()\n            self.shared_pose_current_buffer.push(pose[\"x\"], pose[\"y\"], pose[\"O\"])\n            self.shared_pose_current_lock.finish_writing()\n\n    @pb_exception_handler\n    async def handle_message_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot state received from the robot to connected monitors.\n        \"\"\"\n        pb_state = PB_State()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n        state = MessageToDict(\n            pb_state,\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"state\", state)\n\n    @pb_exception_handler\n    async def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send actuator state received from the robot.\n        \"\"\"\n        pb_actuator_state = PB_ActuatorState()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n        kind = pb_actuator_state.WhichOneof(\"type\")\n        actuator_state = MessageToDict(\n            getattr(pb_actuator_state, kind),\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"actuator_state\", actuator_state)\n\n    @pb_exception_handler\n    async def handle_pid(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send pids state received from the robot to connected dashboards.\n        \"\"\"\n        pb_pid = PB_Pid()\n        if message:\n            await self.loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n        self.pb_pids[pb_pid.id] = pb_pid\n        pid = Pid(\n            id=pb_pid.id,\n            kp=pb_pid.kp,\n            ki=pb_pid.ki,\n            kd=pb_pid.kd,\n            integral_term_limit=pb_pid.integral_term_limit,\n        )\n\n        # Get JSON Schema\n        pid_schema = pid.model_json_schema()\n        # Add namespace in JSON Schema\n        pid_schema[\"namespace\"] = \"/copilot\"\n        pid_schema[\"sio_event\"] = \"config_updated\"\n        # Add current values in JSON Schema\n        pid_schema[\"title\"] = pid.id.name\n        for prop, value in pid.model_dump().items():\n            if prop == \"id\":\n                continue\n            pid_schema[\"properties\"][prop][\"value\"] = value\n            pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n            del pid_schema[\"properties\"][prop]\n        # Send config\n        await self.sio_events.emit(\"config\", pid_schema)\n\n    async def handle_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle pose reached message.\n\n        Forward info to the planner.\n        \"\"\"\n        logger.info(\"[CAN] Received pose reached\")\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"pose_reached\")\n\n    async def handle_intermediate_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle intermediate pose reached message.\n\n        Forward info to the planner.\n        \"\"\"\n        logger.info(\"[CAN] Received intermediate pose reached\")\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"intermediate_pose_reached\")\n\n    async def handle_blocked(self) -&gt; None:\n        \"\"\"\n        Handle blocked message.\n\n        Forward info to the planner.\n        \"\"\"\n        logger.info(\"[CAN] Received blocked\")\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"blocked\")\n\n    async def new_path_event_loop(self):\n        \"\"\"\n        Async worker watching for new path orders in shared memory.\n        When a new path is available, its first pose is sent to the firmware.\n        \"\"\"\n        logger.info(\"Copilot: Task New Path Event Watcher Loop started\")\n        try:\n            while True:\n                await asyncio.to_thread(self.shared_avoidance_path_lock.wait_update)\n                if len(self.shared_avoidance_path) == 0:\n                    continue\n                pose_order = models.PathPose.from_shared(self.shared_avoidance_path[0])\n                if self.id &gt; 1:\n                    pose_order.allow_reverse = False\n                pb_pose_order = PB_PathPose()\n                pose_order.copy_pb(pb_pose_order)\n                await self.pbcom.send_can_message(pose_order_uuid, pb_pose_order)\n\n        except asyncio.CancelledError:\n            logger.info(\"Copilot: Task New Path Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Copilot: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.__init__","title":"<code>__init__(server_url, id, can_channel, can_bitrate, canfd_data_bitrate)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>server URL</p> required <code>id</code> <code>int</code> <p>robot id</p> required <code>can_channel</code> <code>str</code> <p>CAN channel connected to STM32 device</p> required <code>can_bitrate</code> <code>int</code> <p>CAN bitrate</p> required <code>canfd_data_bitrate</code> <code>int</code> <p>CAN data bitrate</p> required Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>def __init__(self, server_url: str, id: int, can_channel: str, can_bitrate: int, canfd_data_bitrate: int):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        server_url: server URL\n        id: robot id\n        can_channel: CAN channel connected to STM32 device\n        can_bitrate: CAN bitrate\n        canfd_data_bitrate: CAN data bitrate\n    \"\"\"\n    self.server_url = server_url\n    self.id = id\n    self.retry_connection = True\n    self.shell_menu: models.ShellMenu | None = None\n    self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_pose_current_lock: WritePriorityLock | None = None\n    self.shared_avoidance_path: SharedPoseOrderList | None = None\n    self.shared_avoidance_path_lock: WritePriorityLock | None = None\n    self.new_path_event_task: asyncio.Task | None = None\n\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_events = SioEvents(self)\n    self.sio.register_namespace(self.sio_events)\n\n    pb_message_handlers = {\n        reset_uuid: self.handle_reset,\n        pose_order_uuid: self.handle_message_pose,\n        state_uuid: self.handle_message_state,\n        pose_reached_uuid: self.handle_pose_reached,\n        intermediate_pose_reached_uuid: self.handle_intermediate_pose_reached,\n        actuator_state_uuid: self.handle_actuator_state,\n        pid_uuid: self.handle_pid,\n        blocked_uuid: self.handle_blocked,\n    }\n\n    self.pbcom = PBCom(can_channel, can_bitrate, canfd_data_bitrate, pb_message_handlers)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_actuator_state","title":"<code>handle_actuator_state(message=None)</code>  <code>async</code>","text":"<p>Send actuator state received from the robot.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send actuator state received from the robot.\n    \"\"\"\n    pb_actuator_state = PB_ActuatorState()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n    kind = pb_actuator_state.WhichOneof(\"type\")\n    actuator_state = MessageToDict(\n        getattr(pb_actuator_state, kind),\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"actuator_state\", actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_blocked","title":"<code>handle_blocked()</code>  <code>async</code>","text":"<p>Handle blocked message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_blocked(self) -&gt; None:\n    \"\"\"\n    Handle blocked message.\n\n    Forward info to the planner.\n    \"\"\"\n    logger.info(\"[CAN] Received blocked\")\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"blocked\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_intermediate_pose_reached","title":"<code>handle_intermediate_pose_reached()</code>  <code>async</code>","text":"<p>Handle intermediate pose reached message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_intermediate_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle intermediate pose reached message.\n\n    Forward info to the planner.\n    \"\"\"\n    logger.info(\"[CAN] Received intermediate pose reached\")\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"intermediate_pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_pose","title":"<code>handle_message_pose(message=None)</code>  <code>async</code>","text":"<p>Send robot pose received from the robot to connected monitors and detector.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot pose received from the robot to connected monitors and detector.\n    \"\"\"\n    pb_pose = PB_Pose()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n    pose = MessageToDict(\n        pb_pose,\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio_events.connected:\n        self.shared_pose_current_lock.start_writing()\n        self.shared_pose_current_buffer.push(pose[\"x\"], pose[\"y\"], pose[\"O\"])\n        self.shared_pose_current_lock.finish_writing()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_state","title":"<code>handle_message_state(message=None)</code>  <code>async</code>","text":"<p>Send robot state received from the robot to connected monitors.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot state received from the robot to connected monitors.\n    \"\"\"\n    pb_state = PB_State()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n    state = MessageToDict(\n        pb_state,\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"state\", state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_pid","title":"<code>handle_pid(message=None)</code>  <code>async</code>","text":"<p>Send pids state received from the robot to connected dashboards.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_pid(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send pids state received from the robot to connected dashboards.\n    \"\"\"\n    pb_pid = PB_Pid()\n    if message:\n        await self.loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n    self.pb_pids[pb_pid.id] = pb_pid\n    pid = Pid(\n        id=pb_pid.id,\n        kp=pb_pid.kp,\n        ki=pb_pid.ki,\n        kd=pb_pid.kd,\n        integral_term_limit=pb_pid.integral_term_limit,\n    )\n\n    # Get JSON Schema\n    pid_schema = pid.model_json_schema()\n    # Add namespace in JSON Schema\n    pid_schema[\"namespace\"] = \"/copilot\"\n    pid_schema[\"sio_event\"] = \"config_updated\"\n    # Add current values in JSON Schema\n    pid_schema[\"title\"] = pid.id.name\n    for prop, value in pid.model_dump().items():\n        if prop == \"id\":\n            continue\n        pid_schema[\"properties\"][prop][\"value\"] = value\n        pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n        del pid_schema[\"properties\"][prop]\n    # Send config\n    await self.sio_events.emit(\"config\", pid_schema)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_pose_reached","title":"<code>handle_pose_reached()</code>  <code>async</code>","text":"<p>Handle pose reached message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle pose reached message.\n\n    Forward info to the planner.\n    \"\"\"\n    logger.info(\"[CAN] Received pose reached\")\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_reset","title":"<code>handle_reset()</code>  <code>async</code>","text":"<p>Handle reset message. This means that the robot has just booted.</p> <p>Send a reset message to all connected clients.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_reset(self) -&gt; None:\n    \"\"\"\n    Handle reset message. This means that the robot has just booted.\n\n    Send a reset message to all connected clients.\n    \"\"\"\n    logger.info(\"[CAN] Received reset\")\n    await self.pbcom.send_can_message(copilot_connected_uuid, None)\n    await self.sio_events.emit(\"reset\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.new_path_event_loop","title":"<code>new_path_event_loop()</code>  <code>async</code>","text":"<p>Async worker watching for new path orders in shared memory. When a new path is available, its first pose is sent to the firmware.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def new_path_event_loop(self):\n    \"\"\"\n    Async worker watching for new path orders in shared memory.\n    When a new path is available, its first pose is sent to the firmware.\n    \"\"\"\n    logger.info(\"Copilot: Task New Path Event Watcher Loop started\")\n    try:\n        while True:\n            await asyncio.to_thread(self.shared_avoidance_path_lock.wait_update)\n            if len(self.shared_avoidance_path) == 0:\n                continue\n            pose_order = models.PathPose.from_shared(self.shared_avoidance_path[0])\n            if self.id &gt; 1:\n                pose_order.allow_reverse = False\n            pb_pose_order = PB_PathPose()\n            pose_order.copy_pb(pb_pose_order)\n            await self.pbcom.send_can_message(pose_order_uuid, pb_pose_order)\n\n    except asyncio.CancelledError:\n        logger.info(\"Copilot: Task New Path Event Watcher Loop cancelled\")\n        raise\n    except Exception as exc:  # noqa\n        logger.warning(f\"Copilot: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start copilot.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start copilot.\n    \"\"\"\n    self.loop = asyncio.get_running_loop()\n\n    self.retry_connection = True\n    await self.try_connect()\n\n    await self.pbcom.send_can_message(copilot_connected_uuid, None)\n\n    await self.pbcom.run()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/copilot/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/copilot/pbcom/","title":"pbcom","text":""},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom","title":"<code>PBCom</code>","text":"Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>class PBCom:\n    can_is_fd: bool = True  # CAN frames are FD frames\n\n    def __init__(\n        self,\n        can_channel: str,\n        can_bitrate: int,\n        canfd_data_bitrate: int,\n        message_handlers: dict[int, Callable],\n    ):\n        self.can_bus = can.Bus(\n            interface=\"socketcan\",\n            channel=can_channel,\n            bitrate=can_bitrate,\n            data_bitrate=canfd_data_bitrate,\n            fd=self.can_is_fd,\n        )\n        self.message_handlers = message_handlers\n\n        # Create asyncio queues\n        self.messages_received = asyncio.Queue()  # Queue for messages received\n        self.messages_to_send = asyncio.Queue()  # Queue for messages waiting to be sent\n\n    async def run(self):\n        \"\"\"\n        Start PBCom.\n        \"\"\"\n        self.loop = asyncio.get_running_loop()\n        self.can_reader = can.AsyncBufferedReader()\n        self.notifier = can.Notifier(bus=self.can_bus, listeners=[self.can_reader], timeout=None, loop=self.loop)\n\n        try:\n            await asyncio.gather(\n                self.payload_decoder(),\n                self.can_receiver(),\n                self.can_sender(),\n            )\n        except asyncio.CancelledError:\n            self.can_bus.shutdown()\n\n    async def payload_decoder(self):\n        \"\"\"\n        Async worker decoding messages received from the robot.\n        \"\"\"\n        uuid: int\n        encoded_payload: bytes\n\n        try:\n            while True:\n                uuid, encoded_payload = await self.messages_received.get()\n                request_handler = self.message_handlers.get(uuid)\n                if not request_handler:\n                    logger.warning(f\"No handler found for message uuid '{uuid}'\")\n                else:\n                    if not encoded_payload:\n                        await request_handler()\n                    else:\n                        await request_handler(encoded_payload)\n\n                self.messages_received.task_done()\n        except asyncio.CancelledError:\n            raise\n\n    async def send_can_message(self, *args) -&gt; None:\n        await self.messages_to_send.put(args)\n\n    async def can_receiver(self):\n        \"\"\"\n        Async worker reading messages from the robot on CAN bus.\n\n        Messages is base64-encoded.\n        After decoding, first byte is the message type, following bytes are\n        the Protobuf encoded message (if any).\n        \"\"\"\n        try:\n            while True:\n                # Read next message\n                can_message = await self.can_reader.get_message()\n\n                # Get message uuid on first bytes\n                uuid = can_message.arbitration_id\n\n                if can_message.dlc == 0:\n                    await self.messages_received.put((uuid, None))\n                    continue\n\n                # Base64 decoding\n                try:\n                    pb_message = base64.decodebytes(can_message.data)\n                except binascii.Error:\n                    logger.error(\"Failed to decode base64 message.\")\n                    continue\n\n                # Send Protobuf message for decoding\n                await self.messages_received.put((uuid, pb_message))\n        except asyncio.CancelledError:\n            raise\n\n    async def can_sender(self):\n        \"\"\"\n        Async worker encoding and sending Protobuf messages to the robot on CAN bus.\n\n        See `can_receiver` for message encoding.\n        \"\"\"\n        try:\n            while True:\n                uuid, pb_message = await self.messages_to_send.get()\n                logger.info(f\"Send 0x{uuid:4x}:\\n{pb_message}\")\n                if pb_message:\n                    response_serialized = await self.loop.run_in_executor(None, pb_message.SerializeToString)\n                    response_base64 = await self.loop.run_in_executor(None, base64.encodebytes, response_serialized)\n                else:\n                    response_base64 = None\n                try:\n                    self.can_bus.send(can.Message(arbitration_id=uuid, data=response_base64, is_fd=self.can_is_fd))\n                except Exception as e:\n                    logger.error(e)\n                self.messages_to_send.task_done()\n        except asyncio.CancelledError:\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.can_receiver","title":"<code>can_receiver()</code>  <code>async</code>","text":"<p>Async worker reading messages from the robot on CAN bus.</p> <p>Messages is base64-encoded. After decoding, first byte is the message type, following bytes are the Protobuf encoded message (if any).</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def can_receiver(self):\n    \"\"\"\n    Async worker reading messages from the robot on CAN bus.\n\n    Messages is base64-encoded.\n    After decoding, first byte is the message type, following bytes are\n    the Protobuf encoded message (if any).\n    \"\"\"\n    try:\n        while True:\n            # Read next message\n            can_message = await self.can_reader.get_message()\n\n            # Get message uuid on first bytes\n            uuid = can_message.arbitration_id\n\n            if can_message.dlc == 0:\n                await self.messages_received.put((uuid, None))\n                continue\n\n            # Base64 decoding\n            try:\n                pb_message = base64.decodebytes(can_message.data)\n            except binascii.Error:\n                logger.error(\"Failed to decode base64 message.\")\n                continue\n\n            # Send Protobuf message for decoding\n            await self.messages_received.put((uuid, pb_message))\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.can_sender","title":"<code>can_sender()</code>  <code>async</code>","text":"<p>Async worker encoding and sending Protobuf messages to the robot on CAN bus.</p> <p>See <code>can_receiver</code> for message encoding.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def can_sender(self):\n    \"\"\"\n    Async worker encoding and sending Protobuf messages to the robot on CAN bus.\n\n    See `can_receiver` for message encoding.\n    \"\"\"\n    try:\n        while True:\n            uuid, pb_message = await self.messages_to_send.get()\n            logger.info(f\"Send 0x{uuid:4x}:\\n{pb_message}\")\n            if pb_message:\n                response_serialized = await self.loop.run_in_executor(None, pb_message.SerializeToString)\n                response_base64 = await self.loop.run_in_executor(None, base64.encodebytes, response_serialized)\n            else:\n                response_base64 = None\n            try:\n                self.can_bus.send(can.Message(arbitration_id=uuid, data=response_base64, is_fd=self.can_is_fd))\n            except Exception as e:\n                logger.error(e)\n            self.messages_to_send.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.payload_decoder","title":"<code>payload_decoder()</code>  <code>async</code>","text":"<p>Async worker decoding messages received from the robot.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def payload_decoder(self):\n    \"\"\"\n    Async worker decoding messages received from the robot.\n    \"\"\"\n    uuid: int\n    encoded_payload: bytes\n\n    try:\n        while True:\n            uuid, encoded_payload = await self.messages_received.get()\n            request_handler = self.message_handlers.get(uuid)\n            if not request_handler:\n                logger.warning(f\"No handler found for message uuid '{uuid}'\")\n            else:\n                if not encoded_payload:\n                    await request_handler()\n                else:\n                    await request_handler(encoded_payload)\n\n            self.messages_received.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start PBCom.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start PBCom.\n    \"\"\"\n    self.loop = asyncio.get_running_loop()\n    self.can_reader = can.AsyncBufferedReader()\n    self.notifier = can.Notifier(bus=self.can_bus, listeners=[self.can_reader], timeout=None, loop=self.loop)\n\n    try:\n        await asyncio.gather(\n            self.payload_decoder(),\n            self.can_receiver(),\n            self.can_sender(),\n        )\n    except asyncio.CancelledError:\n        self.can_bus.shutdown()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pid/","title":"pid","text":""},{"location":"reference/cogip/tools/copilot/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, copilot: \"copilot.Copilot\"):\n        super().__init__(\"/copilot\")\n        self.copilot = copilot\n        self.connected = False\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=1,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n\n        self.copilot.create_shared_memory()\n        self.connected = True\n\n        if self.copilot.shell_menu:\n            await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n        await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n\n    async def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.connected = False\n        await self.copilot.delete_shared_memory()\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_command(self, data):\n        \"\"\"\n        Callback on tool command message.\n        \"\"\"\n        cmd, _, _ = data.partition(\" \")\n        pid_id = PB_Pid_Id()\n        match cmd:\n            case \"angular_speed_pid_config\":\n                # Request angular speed pid state\n                pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_speed_pid_config\":\n                # Request linear_speed pid state\n                pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"angular_position_pid_config\":\n                # Request angular position pid state\n                pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_position_pid_config\":\n                # Request linear position pid state\n                pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_pose_start(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose start (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Pose start: {data}\")\n        start_pose = models.PathPose.model_validate(data)\n        pb_start_pose = PB_PathPose()\n        start_pose.copy_pb(pb_start_pose)\n        await self.copilot.pbcom.send_can_message(copilot.pose_start_uuid, pb_start_pose)\n\n    async def on_actuators_start(self):\n        \"\"\"\n        Callback on actuators_start (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.actuators_thread_start_uuid, None)\n\n    async def on_actuators_stop(self):\n        \"\"\"\n        Callback on actuators_stop (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.actuators_thread_stop_uuid, None)\n\n    async def on_actuator_command(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_command (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Actuator command: {data}\")\n        command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n        pb_command = PB_ActuatorCommand()\n        if isinstance(command, PositionalActuatorCommand):\n            command.pb_copy(pb_command.positional_actuator)\n        await self.copilot.pbcom.send_can_message(copilot.actuator_command_uuid, pb_command)\n\n    async def on_actuator_init(self):\n        \"\"\"\n        Callback on actuator_init (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(\"[SIO] Actuator init\")\n        await self.copilot.pbcom.send_can_message(copilot.actuator_init_uuid, None)\n\n    async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on config_updated from dashboard.\n        Update pid PB message and send it back to firmware.\n        \"\"\"\n        pid_id, _, name = config[\"name\"].partition(\"-\")\n        if pid_id and name:\n            setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n            await self.copilot.pbcom.send_can_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n\n    async def on_set_controller(self, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to firmware.\n        \"\"\"\n        pb_controller = PB_Controller()\n        pb_controller.id = controller\n        await self.copilot.pbcom.send_can_message(copilot.controller_uuid, pb_controller)\n\n    async def on_game_start(self):\n        \"\"\"\n        Callback on game_start message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Game start\")\n        await self.copilot.pbcom.send_can_message(copilot.game_start_uuid, None)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game_end message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Game end\")\n        await self.copilot.pbcom.send_can_message(copilot.game_end_uuid, None)\n\n    async def on_game_reset(self):\n        \"\"\"\n        Callback on game_reset message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Game reset\")\n        await self.copilot.pbcom.send_can_message(copilot.game_reset_uuid, None)\n\n    async def on_brake(self):\n        \"\"\"\n        Callback on brake message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Brake\")\n        await self.copilot.pbcom.send_can_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuator_command","title":"<code>on_actuator_command(data)</code>  <code>async</code>","text":"<p>Callback on actuator_command (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuator_command(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_command (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Actuator command: {data}\")\n    command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n    pb_command = PB_ActuatorCommand()\n    if isinstance(command, PositionalActuatorCommand):\n        command.pb_copy(pb_command.positional_actuator)\n    await self.copilot.pbcom.send_can_message(copilot.actuator_command_uuid, pb_command)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuator_init","title":"<code>on_actuator_init()</code>  <code>async</code>","text":"<p>Callback on actuator_init (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuator_init(self):\n    \"\"\"\n    Callback on actuator_init (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(\"[SIO] Actuator init\")\n    await self.copilot.pbcom.send_can_message(copilot.actuator_init_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuators_start","title":"<code>on_actuators_start()</code>  <code>async</code>","text":"<p>Callback on actuators_start (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuators_start(self):\n    \"\"\"\n    Callback on actuators_start (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.actuators_thread_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuators_stop","title":"<code>on_actuators_stop()</code>  <code>async</code>","text":"<p>Callback on actuators_stop (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuators_stop(self):\n    \"\"\"\n    Callback on actuators_stop (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.actuators_thread_stop_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_brake","title":"<code>on_brake()</code>  <code>async</code>","text":"<p>Callback on brake message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_brake(self):\n    \"\"\"\n    Callback on brake message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Brake\")\n    await self.copilot.pbcom.send_can_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_command","title":"<code>on_command(data)</code>  <code>async</code>","text":"<p>Callback on tool command message.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_command(self, data):\n    \"\"\"\n    Callback on tool command message.\n    \"\"\"\n    cmd, _, _ = data.partition(\" \")\n    pid_id = PB_Pid_Id()\n    match cmd:\n        case \"angular_speed_pid_config\":\n            # Request angular speed pid state\n            pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_speed_pid_config\":\n            # Request linear_speed pid state\n            pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"angular_position_pid_config\":\n            # Request angular position pid state\n            pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_position_pid_config\":\n            # Request linear position pid state\n            pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case _:\n            logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config_updated from dashboard. Update pid PB message and send it back to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on config_updated from dashboard.\n    Update pid PB message and send it back to firmware.\n    \"\"\"\n    pid_id, _, name = config[\"name\"].partition(\"-\")\n    if pid_id and name:\n        setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n        await self.copilot.pbcom.send_can_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=1,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n\n    self.copilot.create_shared_memory()\n    self.connected = True\n\n    if self.copilot.shell_menu:\n        await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n    await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.connected = False\n    await self.copilot.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game_end message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game_end message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Game end\")\n    await self.copilot.pbcom.send_can_message(copilot.game_end_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_reset","title":"<code>on_game_reset()</code>  <code>async</code>","text":"<p>Callback on game_reset message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_reset(self):\n    \"\"\"\n    Callback on game_reset message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Game reset\")\n    await self.copilot.pbcom.send_can_message(copilot.game_reset_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_start","title":"<code>on_game_start()</code>  <code>async</code>","text":"<p>Callback on game_start message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_start(self):\n    \"\"\"\n    Callback on game_start message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Game start\")\n    await self.copilot.pbcom.send_can_message(copilot.game_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_pose_start","title":"<code>on_pose_start(data)</code>  <code>async</code>","text":"<p>Callback on pose start (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_pose_start(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose start (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Pose start: {data}\")\n    start_pose = models.PathPose.model_validate(data)\n    pb_start_pose = PB_PathPose()\n    start_pose.copy_pb(pb_start_pose)\n    await self.copilot.pbcom.send_can_message(copilot.pose_start_uuid, pb_start_pose)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_set_controller","title":"<code>on_set_controller(controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_set_controller(self, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to firmware.\n    \"\"\"\n    pb_controller = PB_Controller()\n    pb_controller.id = controller\n    await self.copilot.pbcom.send_can_message(copilot.controller_uuid, pb_controller)\n</code></pre>"},{"location":"reference/cogip/tools/cpp_cython_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_cython_example/__main__/#cogip.tools.cpp_cython_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a function from a C++ class built in C++ extension with a Cython binding.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-cython-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_cython_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a function from a C++ class built in C++ extension with a Cython binding.\n\n    During installation of cogip-tools, a script called `cogip-cpp-cython-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    example = PyCythonExample()\n    print(example.get_message())\n</code></pre>"},{"location":"reference/cogip/tools/cpp_logger_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_logger_example/__main__/#cogip.tools.cpp_logger_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a C++ function that emits logs to a Python logger.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-logger-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_logger_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a C++ function that emits logs to a Python logger.\n\n    During installation of cogip-tools, a script called `cogip-cpp-logger-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/cpp_nanobind_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_nanobind_example/__main__/#cogip.tools.cpp_nanobind_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a function from a C++ class built in C++ extension with a Nanobind binding.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-nanobind-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_nanobind_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a function from a C++ class built in C++ extension with a Nanobind binding.\n\n    During installation of cogip-tools, a script called `cogip-cpp-nanobind-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    example = NanobindExample()\n    print(example.get_message())\n    data: NDArray = example.get_data()\n    print(f\"data type: {data.__class__}\")\n    print(f\"data shape: {data.shape}\")\n    print(f\"data = \\n{data}\")\n</code></pre>"},{"location":"reference/cogip/tools/cpp_shm_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_shm_example/__main__/#cogip.tools.cpp_shm_example.__main__.main","title":"<code>main()</code>","text":"<p>Usage example for shared memory usage C++ extension.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-shm-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_shm_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Usage example for shared memory usage C++ extension.\n\n    During installation of cogip-tools, a script called `cogip-cpp-shm-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    name = \"/example\"\n\n    # In this example, it is not necessary to create multiple SharedMemory objects.\n    # It is done to illustrate SharedMemory object from different processes.\n    # In the following example, there is no difference between writer and reader objects, only lock usage is important.\n\n    # ==&gt; OWNER process\n    # The owner object will be created in only one process,\n    # typically cogip-server be cause all other processes are depend on it.\n    print(\"Create owner object.\")\n    owner = SharedMemory(name, True)\n\n    # ==&gt; WRITER process\n    # A writer object will be instantiated by processes that need to write into the shared memory.\n    # Each process will get a lock corresponding to the part of the shared memory they want to modify.\n    # Typically, `cogip-copilot` will update the `pose_current` part so it get the lock named `PoseCurrent`.\n    print(\"Create writer object.\")\n    writer = SharedMemory(name)\n    writer_lock = writer.get_lock(LockName.PoseCurrent)\n    writer_data = writer.get_data()\n    writer_pose_current_buffer = writer.get_pose_current_buffer()\n\n    writer_lock.start_reading()\n    print(\" =&gt; writer data = \", writer_data)\n    writer_lock.finish_reading()\n\n    # ==&gt; READER process\n    # A reader object will be instantiated by processes that need to write into the shared memory.\n    # Each process will get a lock corresponding to the part of the shared memory they want to read.\n    # Typically, `cogip-planner` will read the `pose_current` part so it get the lock named `PoseCurrent`.\n    print(\"Create reader object.\")\n    reader = SharedMemory(name)\n    reader_lock = writer.get_lock(LockName.PoseCurrent)\n    reader_data = reader.get_data()\n    reader_pose_current_buffer = reader.get_pose_current_buffer()\n    reader_lock.start_reading()\n    print(\" =&gt; reader data = \", reader_data)\n    reader_lock.finish_reading()\n\n    # ==&gt; WRITER process\n    print(\"Set pose_order\")\n    writer_lock.start_writing()\n    writer_data.pose_order.x = 3.0\n    writer_data.pose_order.y = 4.0\n    writer_data.pose_order.angle = 180.0\n    writer_lock.finish_writing()\n    writer_lock.start_reading()\n    print(\" =&gt; writer data = \", writer_data)\n    writer_lock.finish_reading()\n\n    # ==&gt; READER process\n    reader_lock.start_reading()\n    print(\" =&gt; reader data = \", reader_data)\n    reader_lock.finish_reading()\n\n    # Test for detector_obstacles\n    print(\"\\nTest for detector_obstacles\")\n    reader_detector_obstacles = reader.get_detector_obstacles()\n    writer_detector_obstacles = reader.get_detector_obstacles()\n    print(\" =&gt; reader detector_obstacles size = \", reader_detector_obstacles.size())\n    writer_detector_obstacles.append(1.0, 2.0)\n    writer_detector_obstacles.append(3.0, 4.0)\n    print(\" =&gt; reader detector_obstacles size = \", reader_detector_obstacles.size())\n    print(\" =&gt; reader detector_obstacles[0] = \", reader_detector_obstacles.get(0))\n    print(\" =&gt; reader detector_obstacles[1] = \", reader_detector_obstacles.get(1))\n    writer_detector_obstacles.set(0, 5.0, 6.0)\n    writer_detector_obstacles.set(1, 7.0, 8.0)\n    print(\" =&gt; reader detector_obstacles[0] = \", reader_detector_obstacles.get(0))\n    print(\" =&gt; reader detector_obstacles[1] = \", reader_detector_obstacles.get(1))\n    coords1 = writer_detector_obstacles.get(0)\n    coords2 = writer_detector_obstacles[1]\n    coords1.x = 9.0\n    coords1.y = 10.0\n    coords2.x = 11.0\n    coords2.y = 12.0\n    print(\" =&gt; reader detector_obstacles[0] = \", reader_detector_obstacles.get(0))\n    print(\" =&gt; reader detector_obstacles[1] = \", reader_detector_obstacles.get(1))\n\n    for i, coords in enumerate(writer_detector_obstacles):\n        print(f\" =&gt; writer iterator on detector_obstacles: coords[{i}] = {coords}\")\n\n    for i, coords in enumerate(reader_detector_obstacles):\n        print(f\" =&gt; reader iterator on detector_obstacles: coords[{i}] = {coords}\")\n\n    # Test for circle_obstacles\n    print(\"\\nTest for circle_obstacles\")\n    reader_circle_obstacles = reader.get_circle_obstacles()\n    writer_circle_obstacles = reader.get_circle_obstacles()\n    print(\" =&gt; reader circle_obstacles size = \", reader_circle_obstacles.size())\n    writer_circle_obstacles.append(10, 20, 90, 200, 0.2, 4)\n    writer_circle_obstacles.append(\n        x=40, y=50, angle=180, radius=300, bounding_box_margin=0.2, bounding_box_points_number=5\n    )\n    print(\" =&gt; writer circle_obstacles size = \", len(writer_circle_obstacles))\n    for i, obstacle in enumerate(reader_circle_obstacles):\n        print(f\" =&gt; reader iterator on writer_circle_obstacles: obstacle[{i}] = {obstacle}\")\n\n    # Test for rectangle_obstacles\n    print(\"\\nTest for rectangle_obstacles\")\n    reader_rectangle_obstacles = reader.get_rectangle_obstacles()\n    writer_rectangle_obstacles = reader.get_rectangle_obstacles()\n    print(\" =&gt; reader rectangle_obstacles size = \", reader_rectangle_obstacles.size())\n    writer_rectangle_obstacles.append(10, 20, 90, 200, 300, 0.2)\n    writer_rectangle_obstacles.append(x=40, y=50, angle=180, length_x=250, length_y=350, bounding_box_margin=0.2)\n    print(\" =&gt; writer rectangle_obstacles size = \", len(writer_rectangle_obstacles))\n    for i, obstacle in enumerate(reader_rectangle_obstacles):\n        print(f\" =&gt; reader iterator on writer_rectangle_obstacles: obstacle[{i}] = {obstacle}\")\n\n    # Deep copy test\n    copy_list: list[ObstacleCircle] = []\n    for obstacle in writer_circle_obstacles:\n        copy_list.append(ObstacleCircle(obstacle, deep_copy=True))\n    copy_list[0].center.x = 11\n    copy_list[0].center.y = 22\n\n    print(\" =&gt; writer circle_obstacles[0] = \", writer_circle_obstacles[0])\n    print(\" =&gt; copy_list[0] = \", copy_list[0])\n\n    print(\"\\nTest for pose_current_buffer\")\n    writer_pose_current_buffer.push(1, 2, 90)\n    print(reader_pose_current_buffer.last)\n    writer_pose_current_buffer.push(1, 3, 90)\n    print(reader_pose_current_buffer.last)\n    print(reader_pose_current_buffer.get(1))\n    try:\n        print(reader_pose_current_buffer.get(2))\n    except Exception as exc:\n        print(exc)\n    for i in range(300):\n        writer_pose_current_buffer.push(1, i, 90)\n    print(reader_pose_current_buffer.last)\n\n    # Control order of shared memory object destruction\n    writer_rectangle_obstacles = None\n    writer_circle_obstacles = None\n    writer_detector_obstacles = None\n    writer_lock = None\n    writer_pose_current_buffer = None\n    writer_data = None\n    del writer_lock\n    del writer\n\n    reader_rectangle_obstacles = None\n    reader_circle_obstacles = None\n    reader_detector_obstacles = None\n    reader_lock = None\n    reader_pose_current_buffer = None\n    reader_data = None\n    del reader\n\n    del owner\n    print(\"End.\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/dashboard/__main__/#cogip.tools.dashboard.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Dashboard.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-dashboard</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/dashboard/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Dashboard.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-dashboard` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/app/","title":"app","text":""},{"location":"reference/cogip/tools/dashboard/app/#cogip.tools.dashboard.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/dashboard/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    dashboard = Dashboard()\n    return dashboard.app\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard","title":"<code>Dashboard</code>","text":"Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>class Dashboard:\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _original_uvicorn_exit_handler = Server.handle_exit  # Backup of original exit handler to overload it\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application.\n        \"\"\"\n        self.app = FastAPI(title=\"COGIP Web Monitor\", debug=False)\n\n        # Overload default Uvicorn exit handler\n        Server.handle_exit = self.handle_exit\n\n        # Mount static files\n        current_dir = Path(__file__).parent\n        self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n        # Create HTML templates\n        self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n        # Register routes\n        self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Dashboard._exiting = True\n        Dashboard._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application.</p> Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application.\n    \"\"\"\n    self.app = FastAPI(title=\"COGIP Web Monitor\", debug=False)\n\n    # Overload default Uvicorn exit handler\n    Server.handle_exit = self.handle_exit\n\n    # Mount static files\n    current_dir = Path(__file__).parent\n    self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n    # Create HTML templates\n    self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n    # Register routes\n    self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Dashboard._exiting = True\n    Dashboard._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/routes/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/dashboard/routes/beacon/#cogip.tools.dashboard.routes.beacon.BeaconRouter","title":"<code>BeaconRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> Source code in <code>cogip/tools/dashboard/routes/beacon.py</code> <pre><code>class BeaconRouter(APIRouter):\n    def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        @self.get(\"/\", response_class=HTMLResponse)\n        async def index(request: Request):\n            \"\"\"\n            Homepage of the dashboard web server.\n            \"\"\"\n            robot_id = int(os.getenv(\"ROBOT_ID\", 0))\n            return templates.TemplateResponse(\"dashboard.html\", {\"request\": request, \"robot_id\": robot_id})\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/routes/beacon/#cogip.tools.dashboard.routes.beacon.BeaconRouter.__init__","title":"<code>__init__(templates, *args, **kwargs)</code>","text":"Source code in <code>cogip/tools/dashboard/routes/beacon.py</code> <pre><code>def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    @self.get(\"/\", response_class=HTMLResponse)\n    async def index(request: Request):\n        \"\"\"\n        Homepage of the dashboard web server.\n        \"\"\"\n        robot_id = int(os.getenv(\"ROBOT_ID\", 0))\n        return templates.TemplateResponse(\"dashboard.html\", {\"request\": request, \"robot_id\": robot_id})\n</code></pre>"},{"location":"reference/cogip/tools/detector/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/detector/__main__/#cogip.tools.detector.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Obstacle Detector.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-detector</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/detector/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Obstacle Detector.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-detector` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector","title":"<code>Detector</code>","text":"<p>Main detector class.</p> <p>Read Lidar data from the Lidar in monitoring mode or fake data provided by <code>Monitor</code> in emulation Mode.</p> <p>Build obstacles and send the list to the server.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>class Detector:\n    \"\"\"\n    Main detector class.\n\n    Read Lidar data from the Lidar in monitoring mode\n    or fake data provided by `Monitor` in emulation Mode.\n\n    Build obstacles and send the list to the server.\n    \"\"\"\n\n    TABLE_LIMITS_MARGIN: int = 50\n    YDLIDAR_READY_TIMEOUT_MS: int = 10000\n\n    def __init__(\n        self,\n        robot_id: int,\n        server_url: str,\n        lidar_port: str | None,\n        min_distance: int,\n        max_distance: int,\n        min_intensity: int,\n        refresh_interval: float,\n        sensor_delay: int,\n        cluster_min_samples: int,\n        cluster_eps: float,\n        gui: bool,\n        web: bool,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            robot_id: Robot ID\n            server_url: server URL\n            lidar_port: Serial port connected to the Lidar\n            min_distance: Minimum distance to detect an obstacle\n            max_distance: Maximum distance to detect an obstacle\n            min_intensity: Minimum intensity to detect an obstacle\n            refresh_interval: Interval between each update of the obstacle list (in seconds)\n            sensor_delay: Delay to compensate the delay between sensor data fetch and obstacle positions computation,\"\n                          unit is the index of pose current to get in the past\n            cluster_min_samples: Minimum number of samples to form a cluster\n            cluster_eps: Maximum distance between two samples to form a cluster (mm)\n            gui: Enable GUI\n            web: Enable data display on a web server\n        \"\"\"\n        self.robot_id = robot_id\n        self.server_url = server_url\n        self.lidar_port = lidar_port\n        self.gui = gui\n        self.web = web\n        self.properties = Properties(\n            min_distance=min_distance,\n            max_distance=max_distance,\n            min_intensity=min_intensity,\n            refresh_interval=refresh_interval,\n            sensor_delay=sensor_delay,\n            cluster_min_samples=cluster_min_samples,\n            cluster_eps=cluster_eps,\n        )\n\n        if robot_id == 1:\n            self.LIDAR_OFFSET_X = 0.0\n        else:\n            self.LIDAR_OFFSET_X = 75.5\n        self.LIDAR_OFFSET_Y = 0.0\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_pose_current_lock: WritePriorityLock | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_lidar_data: NDArray | None = None\n        self.shared_lidar_coords: NDArray | None = None\n        self.shared_lidar_data_lock: WritePriorityLock | None = None\n        self.shared_lidar_coords_lock: WritePriorityLock | None = None\n        self.shared_detector_obstacles: SharedCircleList | None = None\n        self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n\n        self.lidar_data_converter: LidarDataConverter | None = None\n\n        self.lidar: LDLidarDriver | YDLidar | None = None\n        self.clusters: list[NDArray] = []\n\n        self.obstacles_updater_loop = ThreadLoop(\n            \"Obstacles updater loop\",\n            refresh_interval,\n            self.process_lidar_coords,\n            logger=True,\n        )\n\n        if gui:\n            self.gui_handler = DetectorGUI(self)\n\n        if web:\n            self.web_thread = threading.Thread(\n                target=start_web,\n                args=(self, 8110 + robot_id),\n                name=\"Web thread\",\n            )\n\n        self.sio = socketio.Client(logger=False)\n        self.sio.register_namespace(SioEvents(self))\n\n    def create_shared_memory(self):\n        self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n        self.shared_pose_current_lock = self.shared_memory.get_lock(LockName.PoseCurrent)\n        self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n        self.shared_lidar_data = self.shared_memory.get_lidar_data()\n        self.shared_lidar_coords = self.shared_memory.get_lidar_coords()\n        self.shared_lidar_data_lock = self.shared_memory.get_lock(LockName.LidarData)\n        self.shared_lidar_coords_lock = self.shared_memory.get_lock(LockName.LidarCoords)\n        self.shared_detector_obstacles = self.shared_memory.get_detector_obstacles()\n        self.shared_detector_obstacles_lock = self.shared_memory.get_lock(LockName.DetectorObstacles)\n\n        self.shared_lidar_data_lock.reset()\n        self.shared_lidar_coords_lock.reset()\n        # self.shared_lidar_coords_lock.register_consumer()\n\n        # Lidar data is initialized to -1 to indicate that no data is available\n        self.shared_lidar_data[0][0] = -1\n        self.shared_lidar_data[0][1] = -1\n        self.shared_lidar_data[0][2] = -1\n        self.shared_lidar_coords[0][0] = -1\n        self.shared_lidar_coords[0][1] = -1\n\n        self.lidar_data_converter = LidarDataConverter(f\"cogip_{self.robot_id}\")\n        self.lidar_data_converter.set_pose_current_index(self.properties.sensor_delay)\n        self.lidar_data_converter.set_lidar_offset_x(self.LIDAR_OFFSET_X)\n        self.lidar_data_converter.set_lidar_offset_y(self.LIDAR_OFFSET_Y)\n        self.lidar_data_converter.set_table_limits_margin(self.TABLE_LIMITS_MARGIN)\n\n    def delete_shared_memory(self):\n        self.shared_detector_obstacles_lock = None\n        self.shared_detector_obstacles = None\n        self.shared_lidar_data_lock = None\n        self.shared_lidar_coords_lock = None\n        self.shared_lidar_coords = None\n        self.shared_lidar_data = None\n        self.shared_pose_current_buffer = None\n        self.shared_pose_current_lock = None\n        self.shared_memory = None\n\n        self.lidar_data_converter = None\n\n    def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        threading.Thread(target=self.try_connect).start()\n\n        if self.web:\n            self.web_thread.start()\n\n        if self.gui:\n            self.gui_handler.start_animation()\n            try:\n                plt.show()\n            except KeyboardInterrupt:\n                pass\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start updating obstacles list.\n        \"\"\"\n        self.create_shared_memory()\n        self.lidar_data_converter.start()\n        self.start_lidar()\n        self.obstacles_updater_loop.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop updating obstacles list.\n        \"\"\"\n        self.obstacles_updater_loop.stop()\n        self.stop_lidar()\n        self.lidar_data_converter.stop()\n        self.delete_shared_memory()\n\n    def try_connect(self):\n        \"\"\"\n        Poll to wait for the first cogip-server connection.\n        Disconnections/re-connections are handle directly by the client.\n        \"\"\"\n        while True:\n            try:\n                self.sio.connect(\n                    self.server_url,\n                    namespaces=[\"/detector\"],\n                )\n                self.sio.wait()\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    def cluster_obstacles(self, lidar_coords: NDArray) -&gt; list[NDArray]:\n        \"\"\"\n        Groups points into obstacle clusters using DBSCAN\n\n        Returns:\n            List of clusters, each cluster being a set of points belonging to the same obstacle\n        \"\"\"\n        if len(lidar_coords) == 0:\n            return []\n\n        db = DBSCAN(\n            eps=self.properties.cluster_eps,\n            min_samples=self.properties.cluster_min_samples,\n        ).fit(lidar_coords)\n        labels = db.labels_\n\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n        clusters = []\n        for i in range(n_clusters):\n            cluster_points = lidar_coords[labels == i]\n            clusters.append(cluster_points)\n\n        return clusters\n\n    def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Estimates position and size of obstacles from clusters\n\n        Args:\n            clusters: List of clusters, each cluster being a set of points\n\n        Returns:\n            List of tuples (center_x, center_y, radius) for each obstacle\n        \"\"\"\n        obstacle_properties = []\n\n        for cluster in clusters:\n            center_x = np.mean(cluster[:, 0])\n            center_y = np.mean(cluster[:, 1])\n\n            # Calculate the maximum distance from center in x and y directions\n            # This will be used as the radius of the circle\n            radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n            radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n            radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n            obstacle_properties.append((center_x, center_y, radius))\n\n        return obstacle_properties\n\n    def process_lidar_coords(self):\n        \"\"\"\n        Function executed in a thread loop to update and send dynamic obstacles.\n        \"\"\"\n        # self.shared_lidar_coords_lock.wait_update()\n        self.shared_lidar_coords_lock.start_reading()\n        lidar_coords = self.shared_lidar_coords[: np.argmax(self.shared_lidar_coords[:, 0] == -1)].copy()\n        self.shared_lidar_coords_lock.finish_reading()\n\n        self.clusters = self.cluster_obstacles(lidar_coords)\n        obstacles = self.estimate_obstacle_properties(self.clusters)\n        self.shared_detector_obstacles_lock.start_writing()\n        self.shared_detector_obstacles.clear()\n        for x, y, radius in obstacles:\n            self.shared_detector_obstacles.append(x=x, y=y, radius=radius)\n        self.shared_detector_obstacles_lock.finish_writing()\n        self.shared_detector_obstacles_lock.post_update()\n\n        logger.debug(f\"Generated obstacles: {obstacles}\")\n\n    def start_lidar(self):\n        \"\"\"\n        Start the Lidar.\n        \"\"\"\n        if self.lidar_port:\n            if self.robot_id == 1:\n                self.lidar = YDLidar(self.shared_lidar_data)\n                self.lidar.set_scan_frequency(10)\n                # No excluded angle range\n                self.lidar.set_invalid_angle_range(360, 0)\n            else:\n                self.lidar = LDLidarDriver(self.shared_lidar_data)\n                # Skip rear-facing Lidar data because Lidar is mounted in PAMI\n                self.lidar.set_invalid_angle_range(30, 330)\n            self.lidar.set_data_write_lock(self.shared_lidar_data_lock)\n            self.lidar.set_min_distance(self.properties.min_distance)\n            self.lidar.set_max_distance(self.properties.max_distance)\n            self.lidar.set_min_intensity(self.properties.min_intensity)\n\n            res = self.lidar.connect(str(self.lidar_port))\n            if not res:\n                logger.error(\"Error: Lidar connection failed.\")\n                os._exit(1)\n            logger.info(\"Lidar connected.\")\n\n            if self.robot_id &gt; 1:\n                res = self.lidar.wait_lidar_comm(self.YDLIDAR_READY_TIMEOUT_MS)\n                if not res:\n                    logger.error(\"Error: Lidar not ready.\")\n                    os._exit(1)\n                logger.info(\"Lidar is ready.\")\n\n            res = self.lidar.start()\n            if not res:\n                logger.error(\"Error: Lidar not started.\")\n                os._exit(1)\n            logger.info(\"Lidar started.\")\n\n    def stop_lidar(self):\n        \"\"\"\n        Stop the Lidar.\n        \"\"\"\n        if self.lidar:\n            self.lidar.stop()\n            self.lidar.disconnect()\n            self.lidar = None\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.__init__","title":"<code>__init__(robot_id, server_url, lidar_port, min_distance, max_distance, min_intensity, refresh_interval, sensor_delay, cluster_min_samples, cluster_eps, gui, web)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>Robot ID</p> required <code>server_url</code> <code>str</code> <p>server URL</p> required <code>lidar_port</code> <code>str | None</code> <p>Serial port connected to the Lidar</p> required <code>min_distance</code> <code>int</code> <p>Minimum distance to detect an obstacle</p> required <code>max_distance</code> <code>int</code> <p>Maximum distance to detect an obstacle</p> required <code>min_intensity</code> <code>int</code> <p>Minimum intensity to detect an obstacle</p> required <code>refresh_interval</code> <code>float</code> <p>Interval between each update of the obstacle list (in seconds)</p> required <code>sensor_delay</code> <code>int</code> <p>Delay to compensate the delay between sensor data fetch and obstacle positions computation,\"           unit is the index of pose current to get in the past</p> required <code>cluster_min_samples</code> <code>int</code> <p>Minimum number of samples to form a cluster</p> required <code>cluster_eps</code> <code>float</code> <p>Maximum distance between two samples to form a cluster (mm)</p> required <code>gui</code> <code>bool</code> <p>Enable GUI</p> required <code>web</code> <code>bool</code> <p>Enable data display on a web server</p> required Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def __init__(\n    self,\n    robot_id: int,\n    server_url: str,\n    lidar_port: str | None,\n    min_distance: int,\n    max_distance: int,\n    min_intensity: int,\n    refresh_interval: float,\n    sensor_delay: int,\n    cluster_min_samples: int,\n    cluster_eps: float,\n    gui: bool,\n    web: bool,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        robot_id: Robot ID\n        server_url: server URL\n        lidar_port: Serial port connected to the Lidar\n        min_distance: Minimum distance to detect an obstacle\n        max_distance: Maximum distance to detect an obstacle\n        min_intensity: Minimum intensity to detect an obstacle\n        refresh_interval: Interval between each update of the obstacle list (in seconds)\n        sensor_delay: Delay to compensate the delay between sensor data fetch and obstacle positions computation,\"\n                      unit is the index of pose current to get in the past\n        cluster_min_samples: Minimum number of samples to form a cluster\n        cluster_eps: Maximum distance between two samples to form a cluster (mm)\n        gui: Enable GUI\n        web: Enable data display on a web server\n    \"\"\"\n    self.robot_id = robot_id\n    self.server_url = server_url\n    self.lidar_port = lidar_port\n    self.gui = gui\n    self.web = web\n    self.properties = Properties(\n        min_distance=min_distance,\n        max_distance=max_distance,\n        min_intensity=min_intensity,\n        refresh_interval=refresh_interval,\n        sensor_delay=sensor_delay,\n        cluster_min_samples=cluster_min_samples,\n        cluster_eps=cluster_eps,\n    )\n\n    if robot_id == 1:\n        self.LIDAR_OFFSET_X = 0.0\n    else:\n        self.LIDAR_OFFSET_X = 75.5\n    self.LIDAR_OFFSET_Y = 0.0\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_pose_current_lock: WritePriorityLock | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_lidar_data: NDArray | None = None\n    self.shared_lidar_coords: NDArray | None = None\n    self.shared_lidar_data_lock: WritePriorityLock | None = None\n    self.shared_lidar_coords_lock: WritePriorityLock | None = None\n    self.shared_detector_obstacles: SharedCircleList | None = None\n    self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n\n    self.lidar_data_converter: LidarDataConverter | None = None\n\n    self.lidar: LDLidarDriver | YDLidar | None = None\n    self.clusters: list[NDArray] = []\n\n    self.obstacles_updater_loop = ThreadLoop(\n        \"Obstacles updater loop\",\n        refresh_interval,\n        self.process_lidar_coords,\n        logger=True,\n    )\n\n    if gui:\n        self.gui_handler = DetectorGUI(self)\n\n    if web:\n        self.web_thread = threading.Thread(\n            target=start_web,\n            args=(self, 8110 + robot_id),\n            name=\"Web thread\",\n        )\n\n    self.sio = socketio.Client(logger=False)\n    self.sio.register_namespace(SioEvents(self))\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.cluster_obstacles","title":"<code>cluster_obstacles(lidar_coords)</code>","text":"<p>Groups points into obstacle clusters using DBSCAN</p> <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points belonging to the same obstacle</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def cluster_obstacles(self, lidar_coords: NDArray) -&gt; list[NDArray]:\n    \"\"\"\n    Groups points into obstacle clusters using DBSCAN\n\n    Returns:\n        List of clusters, each cluster being a set of points belonging to the same obstacle\n    \"\"\"\n    if len(lidar_coords) == 0:\n        return []\n\n    db = DBSCAN(\n        eps=self.properties.cluster_eps,\n        min_samples=self.properties.cluster_min_samples,\n    ).fit(lidar_coords)\n    labels = db.labels_\n\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    clusters = []\n    for i in range(n_clusters):\n        cluster_points = lidar_coords[labels == i]\n        clusters.append(cluster_points)\n\n    return clusters\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.connect","title":"<code>connect()</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    threading.Thread(target=self.try_connect).start()\n\n    if self.web:\n        self.web_thread.start()\n\n    if self.gui:\n        self.gui_handler.start_animation()\n        try:\n            plt.show()\n        except KeyboardInterrupt:\n            pass\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.estimate_obstacle_properties","title":"<code>estimate_obstacle_properties(clusters)</code>","text":"<p>Estimates position and size of obstacles from clusters</p> <p>Parameters:</p> Name Type Description Default <code>clusters</code> <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points</p> required <p>Returns:</p> Type Description <code>list[tuple[float, float, float]]</code> <p>List of tuples (center_x, center_y, radius) for each obstacle</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n    \"\"\"\n    Estimates position and size of obstacles from clusters\n\n    Args:\n        clusters: List of clusters, each cluster being a set of points\n\n    Returns:\n        List of tuples (center_x, center_y, radius) for each obstacle\n    \"\"\"\n    obstacle_properties = []\n\n    for cluster in clusters:\n        center_x = np.mean(cluster[:, 0])\n        center_y = np.mean(cluster[:, 1])\n\n        # Calculate the maximum distance from center in x and y directions\n        # This will be used as the radius of the circle\n        radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n        radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n        radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n        obstacle_properties.append((center_x, center_y, radius))\n\n    return obstacle_properties\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.process_lidar_coords","title":"<code>process_lidar_coords()</code>","text":"<p>Function executed in a thread loop to update and send dynamic obstacles.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def process_lidar_coords(self):\n    \"\"\"\n    Function executed in a thread loop to update and send dynamic obstacles.\n    \"\"\"\n    # self.shared_lidar_coords_lock.wait_update()\n    self.shared_lidar_coords_lock.start_reading()\n    lidar_coords = self.shared_lidar_coords[: np.argmax(self.shared_lidar_coords[:, 0] == -1)].copy()\n    self.shared_lidar_coords_lock.finish_reading()\n\n    self.clusters = self.cluster_obstacles(lidar_coords)\n    obstacles = self.estimate_obstacle_properties(self.clusters)\n    self.shared_detector_obstacles_lock.start_writing()\n    self.shared_detector_obstacles.clear()\n    for x, y, radius in obstacles:\n        self.shared_detector_obstacles.append(x=x, y=y, radius=radius)\n    self.shared_detector_obstacles_lock.finish_writing()\n    self.shared_detector_obstacles_lock.post_update()\n\n    logger.debug(f\"Generated obstacles: {obstacles}\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.start","title":"<code>start()</code>","text":"<p>Start updating obstacles list.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start updating obstacles list.\n    \"\"\"\n    self.create_shared_memory()\n    self.lidar_data_converter.start()\n    self.start_lidar()\n    self.obstacles_updater_loop.start()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.start_lidar","title":"<code>start_lidar()</code>","text":"<p>Start the Lidar.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def start_lidar(self):\n    \"\"\"\n    Start the Lidar.\n    \"\"\"\n    if self.lidar_port:\n        if self.robot_id == 1:\n            self.lidar = YDLidar(self.shared_lidar_data)\n            self.lidar.set_scan_frequency(10)\n            # No excluded angle range\n            self.lidar.set_invalid_angle_range(360, 0)\n        else:\n            self.lidar = LDLidarDriver(self.shared_lidar_data)\n            # Skip rear-facing Lidar data because Lidar is mounted in PAMI\n            self.lidar.set_invalid_angle_range(30, 330)\n        self.lidar.set_data_write_lock(self.shared_lidar_data_lock)\n        self.lidar.set_min_distance(self.properties.min_distance)\n        self.lidar.set_max_distance(self.properties.max_distance)\n        self.lidar.set_min_intensity(self.properties.min_intensity)\n\n        res = self.lidar.connect(str(self.lidar_port))\n        if not res:\n            logger.error(\"Error: Lidar connection failed.\")\n            os._exit(1)\n        logger.info(\"Lidar connected.\")\n\n        if self.robot_id &gt; 1:\n            res = self.lidar.wait_lidar_comm(self.YDLIDAR_READY_TIMEOUT_MS)\n            if not res:\n                logger.error(\"Error: Lidar not ready.\")\n                os._exit(1)\n            logger.info(\"Lidar is ready.\")\n\n        res = self.lidar.start()\n        if not res:\n            logger.error(\"Error: Lidar not started.\")\n            os._exit(1)\n        logger.info(\"Lidar started.\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.stop","title":"<code>stop()</code>","text":"<p>Stop updating obstacles list.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop updating obstacles list.\n    \"\"\"\n    self.obstacles_updater_loop.stop()\n    self.stop_lidar()\n    self.lidar_data_converter.stop()\n    self.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.stop_lidar","title":"<code>stop_lidar()</code>","text":"<p>Stop the Lidar.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def stop_lidar(self):\n    \"\"\"\n    Stop the Lidar.\n    \"\"\"\n    if self.lidar:\n        self.lidar.stop()\n        self.lidar.disconnect()\n        self.lidar = None\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.try_connect","title":"<code>try_connect()</code>","text":"<p>Poll to wait for the first cogip-server connection. Disconnections/re-connections are handle directly by the client.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def try_connect(self):\n    \"\"\"\n    Poll to wait for the first cogip-server connection.\n    Disconnections/re-connections are handle directly by the client.\n    \"\"\"\n    while True:\n        try:\n            self.sio.connect(\n                self.server_url,\n                namespaces=[\"/detector\"],\n            )\n            self.sio.wait()\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/","title":"gui","text":""},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI","title":"<code>DetectorGUI</code>","text":"Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>class DetectorGUI:\n    def __init__(self, detector: \"Detector\"):\n        \"\"\"\n        Initialize the GUI for the detector.\n\n        Args:\n            detector: Reference to the Detector instance for accessing shared data.\n        \"\"\"\n        self.detector = detector\n\n        # Initialize plot and data containers\n        self.fig, self.ax = plt.subplots(figsize=(10, 10))\n\n        # Set figure and axes background color\n        self.fig.patch.set_facecolor(\"#2E2E2E\")\n        self.ax.set_facecolor(\"#1E1E1E\")\n\n        # Set labels and title with light colors\n        self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n        self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n        self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n        # Customize grid\n        self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n        # Customize axis appearance\n        self.ax.spines[\"bottom\"].set_color(\"#555555\")\n        self.ax.spines[\"top\"].set_color(\"#555555\")\n        self.ax.spines[\"left\"].set_color(\"#555555\")\n        self.ax.spines[\"right\"].set_color(\"#555555\")\n\n        # Customize tick parameters\n        self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n        # Invert x-axis and set equal aspect ratio\n        self.ax.invert_xaxis()\n        self.ax.axis(\"equal\")\n\n        # Configure legend with dark theme colors\n        self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n        # Set initial view range\n        view_radius = self.detector.properties.max_distance * 1.2\n        self.ax.set_xlim((view_radius, -view_radius))\n        self.ax.set_ylim((-view_radius, view_radius))\n\n        # Connect the scroll event to the handler\n        self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n        # Visualization elements\n        self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n        self.cluster_scatters: list[PathCollection] = []\n        self.obstacle_circles: list[Ellipse] = []\n\n        # Robot and Lidar markers\n        self.robot_marker = self.ax.scatter(\n            0,\n            0,\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Robot\",\n        )\n\n        # Calculate Lidar position\n        self.lidar_marker = self.ax.scatter(\n            self.detector.LIDAR_OFFSET_Y,\n            self.detector.LIDAR_OFFSET_X,\n            c=\"blue\",\n            s=80,\n            marker=\"o\",\n            label=\"Lidar\",\n        )\n\n        # Animation setup\n        self.animation: FuncAnimation | None = None\n\n    def start_animation(self):\n        \"\"\"Starts the real-time visualization.\"\"\"\n        plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n        self.animation = FuncAnimation(\n            self.fig,\n            self.update_plot,\n            interval=200,\n            blit=False,\n            cache_frame_data=False,\n        )\n\n    def update_robot_pose(self):\n        \"\"\"Update robot pose on the GUI.\"\"\"\n        if not self.detector.shared_pose_current_buffer:\n            return\n\n        pose_current = self.detector.shared_pose_current_buffer.last\n        x = pose_current.x\n        y = pose_current.y\n        angle = pose_current.angle\n\n        self.robot_marker.set_offsets([y, x])\n\n        angle_rad = np.radians(-angle)\n        lidar_offset_rotated = np.array(\n            [\n                self.detector.LIDAR_OFFSET_Y * np.cos(angle_rad) - self.detector.LIDAR_OFFSET_X * np.sin(angle_rad),\n                self.detector.LIDAR_OFFSET_Y * np.sin(angle_rad) + self.detector.LIDAR_OFFSET_X * np.cos(angle_rad),\n            ]\n        )\n        lidar_x = x + lidar_offset_rotated[1]\n        lidar_y = y + lidar_offset_rotated[0]\n        self.lidar_marker.set_offsets([lidar_y, lidar_x])\n\n    def update_plot(self, frame):\n        \"\"\"Updates the visualization with current data.\"\"\"\n        self.update_robot_pose()\n\n        if self.detector.shared_lidar_coords is None:\n            return\n\n        lidar_coords = self.detector.shared_lidar_coords[\n            : np.argmax(self.detector.shared_lidar_coords[:, 0] == -1)\n        ].copy()\n        self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n        for scatter in self.cluster_scatters:\n            scatter.remove()\n        self.cluster_scatters = []\n\n        for circle in self.obstacle_circles:\n            circle.remove()\n        self.obstacle_circles = []\n\n        colors = plt.cm.plasma(np.linspace(0, 1, len(self.detector.clusters) + 1))\n\n        for i, cluster in enumerate(self.detector.clusters):\n            scatter = self.ax.scatter(\n                cluster[:, 1],\n                cluster[:, 0],\n                c=[colors[i]],\n                s=20,\n            )\n            self.cluster_scatters.append(scatter)\n\n        for i, obstacle in enumerate(self.detector.shared_detector_obstacles):\n            center_x = obstacle.x\n            center_y = obstacle.y\n            radius = obstacle.radius\n            circle = Ellipse(\n                (center_y, center_x),\n                width=radius * 2,\n                height=radius * 2,\n                fill=False,\n                edgecolor=colors[i],\n                linewidth=2,\n                alpha=0.8,\n            )\n            self.ax.add_patch(circle)\n            self.obstacle_circles.append(circle)\n\n        self.fig.canvas.draw_idle()\n        self.fig.canvas.flush_events()\n\n    def on_scroll(self, event: MouseEvent):\n        \"\"\"Handle scroll events for zooming.\"\"\"\n        if event.inaxes != self.ax:\n            return\n\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        x_data, y_data = event.xdata, event.ydata\n        zoom_factor = 1.1 if event.button == \"down\" else 0.9\n\n        x_left = x_data - zoom_factor * (x_data - xlim[0])\n        x_right = x_data + zoom_factor * (xlim[1] - x_data)\n        y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n        y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n        view_radius = self.detector.properties.max_distance * 1.2\n        x_left = max(-view_radius, x_left)\n        x_right = min(view_radius, x_right)\n        y_bottom = max(-view_radius, y_bottom)\n        y_top = min(view_radius, y_top)\n\n        self.ax.set_xlim(x_left, x_right)\n        self.ax.set_ylim(y_bottom, y_top)\n\n        plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.__init__","title":"<code>__init__(detector)</code>","text":"<p>Initialize the GUI for the detector.</p> <p>Parameters:</p> Name Type Description Default <code>detector</code> <code>Detector</code> <p>Reference to the Detector instance for accessing shared data.</p> required Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def __init__(self, detector: \"Detector\"):\n    \"\"\"\n    Initialize the GUI for the detector.\n\n    Args:\n        detector: Reference to the Detector instance for accessing shared data.\n    \"\"\"\n    self.detector = detector\n\n    # Initialize plot and data containers\n    self.fig, self.ax = plt.subplots(figsize=(10, 10))\n\n    # Set figure and axes background color\n    self.fig.patch.set_facecolor(\"#2E2E2E\")\n    self.ax.set_facecolor(\"#1E1E1E\")\n\n    # Set labels and title with light colors\n    self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n    self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n    self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n    # Customize grid\n    self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Customize axis appearance\n    self.ax.spines[\"bottom\"].set_color(\"#555555\")\n    self.ax.spines[\"top\"].set_color(\"#555555\")\n    self.ax.spines[\"left\"].set_color(\"#555555\")\n    self.ax.spines[\"right\"].set_color(\"#555555\")\n\n    # Customize tick parameters\n    self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n    # Invert x-axis and set equal aspect ratio\n    self.ax.invert_xaxis()\n    self.ax.axis(\"equal\")\n\n    # Configure legend with dark theme colors\n    self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n    # Set initial view range\n    view_radius = self.detector.properties.max_distance * 1.2\n    self.ax.set_xlim((view_radius, -view_radius))\n    self.ax.set_ylim((-view_radius, view_radius))\n\n    # Connect the scroll event to the handler\n    self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n    # Visualization elements\n    self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n    self.cluster_scatters: list[PathCollection] = []\n    self.obstacle_circles: list[Ellipse] = []\n\n    # Robot and Lidar markers\n    self.robot_marker = self.ax.scatter(\n        0,\n        0,\n        c=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"Robot\",\n    )\n\n    # Calculate Lidar position\n    self.lidar_marker = self.ax.scatter(\n        self.detector.LIDAR_OFFSET_Y,\n        self.detector.LIDAR_OFFSET_X,\n        c=\"blue\",\n        s=80,\n        marker=\"o\",\n        label=\"Lidar\",\n    )\n\n    # Animation setup\n    self.animation: FuncAnimation | None = None\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.on_scroll","title":"<code>on_scroll(event)</code>","text":"<p>Handle scroll events for zooming.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def on_scroll(self, event: MouseEvent):\n    \"\"\"Handle scroll events for zooming.\"\"\"\n    if event.inaxes != self.ax:\n        return\n\n    xlim = self.ax.get_xlim()\n    ylim = self.ax.get_ylim()\n\n    x_data, y_data = event.xdata, event.ydata\n    zoom_factor = 1.1 if event.button == \"down\" else 0.9\n\n    x_left = x_data - zoom_factor * (x_data - xlim[0])\n    x_right = x_data + zoom_factor * (xlim[1] - x_data)\n    y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n    y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n    view_radius = self.detector.properties.max_distance * 1.2\n    x_left = max(-view_radius, x_left)\n    x_right = min(view_radius, x_right)\n    y_bottom = max(-view_radius, y_bottom)\n    y_top = min(view_radius, y_top)\n\n    self.ax.set_xlim(x_left, x_right)\n    self.ax.set_ylim(y_bottom, y_top)\n\n    plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.start_animation","title":"<code>start_animation()</code>","text":"<p>Starts the real-time visualization.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def start_animation(self):\n    \"\"\"Starts the real-time visualization.\"\"\"\n    plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n    self.animation = FuncAnimation(\n        self.fig,\n        self.update_plot,\n        interval=200,\n        blit=False,\n        cache_frame_data=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.update_plot","title":"<code>update_plot(frame)</code>","text":"<p>Updates the visualization with current data.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def update_plot(self, frame):\n    \"\"\"Updates the visualization with current data.\"\"\"\n    self.update_robot_pose()\n\n    if self.detector.shared_lidar_coords is None:\n        return\n\n    lidar_coords = self.detector.shared_lidar_coords[\n        : np.argmax(self.detector.shared_lidar_coords[:, 0] == -1)\n    ].copy()\n    self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n    for scatter in self.cluster_scatters:\n        scatter.remove()\n    self.cluster_scatters = []\n\n    for circle in self.obstacle_circles:\n        circle.remove()\n    self.obstacle_circles = []\n\n    colors = plt.cm.plasma(np.linspace(0, 1, len(self.detector.clusters) + 1))\n\n    for i, cluster in enumerate(self.detector.clusters):\n        scatter = self.ax.scatter(\n            cluster[:, 1],\n            cluster[:, 0],\n            c=[colors[i]],\n            s=20,\n        )\n        self.cluster_scatters.append(scatter)\n\n    for i, obstacle in enumerate(self.detector.shared_detector_obstacles):\n        center_x = obstacle.x\n        center_y = obstacle.y\n        radius = obstacle.radius\n        circle = Ellipse(\n            (center_y, center_x),\n            width=radius * 2,\n            height=radius * 2,\n            fill=False,\n            edgecolor=colors[i],\n            linewidth=2,\n            alpha=0.8,\n        )\n        self.ax.add_patch(circle)\n        self.obstacle_circles.append(circle)\n\n    self.fig.canvas.draw_idle()\n    self.fig.canvas.flush_events()\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.update_robot_pose","title":"<code>update_robot_pose()</code>","text":"<p>Update robot pose on the GUI.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def update_robot_pose(self):\n    \"\"\"Update robot pose on the GUI.\"\"\"\n    if not self.detector.shared_pose_current_buffer:\n        return\n\n    pose_current = self.detector.shared_pose_current_buffer.last\n    x = pose_current.x\n    y = pose_current.y\n    angle = pose_current.angle\n\n    self.robot_marker.set_offsets([y, x])\n\n    angle_rad = np.radians(-angle)\n    lidar_offset_rotated = np.array(\n        [\n            self.detector.LIDAR_OFFSET_Y * np.cos(angle_rad) - self.detector.LIDAR_OFFSET_X * np.sin(angle_rad),\n            self.detector.LIDAR_OFFSET_Y * np.sin(angle_rad) + self.detector.LIDAR_OFFSET_X * np.cos(angle_rad),\n        ]\n    )\n    lidar_x = x + lidar_offset_rotated[1]\n    lidar_y = y + lidar_offset_rotated[0]\n    self.lidar_marker.set_offsets([lidar_y, lidar_x])\n</code></pre>"},{"location":"reference/cogip/tools/detector/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/detector/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/detector/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>ClientNamespace</code></p> <p>Handle all SocketIO events received by Detector.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>class SioEvents(socketio.ClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Detector.\n    \"\"\"\n\n    def __init__(self, detector: \"detector.Detector\"):\n        super().__init__(\"/detector\")\n        self.detector = detector\n\n    def on_connect(self):\n        \"\"\"\n        On connection to cogip-server, start detector threads.\n        \"\"\"\n        polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Connected to cogip-server\")\n        self.emit(\"connected\", self.detector.lidar_port is None)\n        self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n        self.detector.start()\n\n    def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server, stop detector threads.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.detector.stop()\n        self.detector.delete_shared_memory()\n\n    def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Detector is already connected and exit,\n        or retry connection.\n        \"\"\"\n        logger.error(f\"Connect to cogip-server error: {data = }\")\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A detector is already connected\"\n        ):\n            logger.error(message)\n            self.detector.retry_connection = False\n            return\n\n    def on_command(self, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema = self.detector.properties.model_json_schema()\n            # Add namespace in JSON Schema\n            schema[\"namespace\"] = \"/detector\"\n            schema[\"sio_event\"] = \"config_updated\"\n            # Add current values in JSON Schema\n            for prop, value in self.detector.properties.model_dump().items():\n                schema[\"properties\"][prop][\"value\"] = value\n            # Send config\n            self.emit(\"config\", schema)\n        else:\n            logger.warning(f\"Unknown command: {cmd}\")\n\n    def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        value = config[\"value\"]\n        self.detector.properties.__setattr__(name := config[\"name\"], value)\n        match name:\n            case \"refresh_interval\":\n                self.detector.obstacles_updater_loop.interval = value\n            case \"min_distance\":\n                if self.detector.lidar:\n                    self.detector.lidar.set_min_distance(value)\n            case \"max_distance\":\n                if self.detector.lidar:\n                    self.detector.lidar.set_max_distance(value)\n            case \"min_intensity\":\n                if self.detector.lidar:\n                    self.detector.lidar.set_min_intensity(value)\n            case \"sensor_delay\":\n                self.detector.lidar_data_converter.set_pose_current_index(value)\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_command","title":"<code>on_command(cmd)</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_command(self, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema = self.detector.properties.model_json_schema()\n        # Add namespace in JSON Schema\n        schema[\"namespace\"] = \"/detector\"\n        schema[\"sio_event\"] = \"config_updated\"\n        # Add current values in JSON Schema\n        for prop, value in self.detector.properties.model_dump().items():\n            schema[\"properties\"][prop][\"value\"] = value\n        # Send config\n        self.emit(\"config\", schema)\n    else:\n        logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>","text":"<p>On connection to cogip-server, start detector threads.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_connect(self):\n    \"\"\"\n    On connection to cogip-server, start detector threads.\n    \"\"\"\n    polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n    logger.info(\"Connected to cogip-server\")\n    self.emit(\"connected\", self.detector.lidar_port is None)\n    self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n    self.detector.start()\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>","text":"<p>On connection error, check if a Detector is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Detector is already connected and exit,\n    or retry connection.\n    \"\"\"\n    logger.error(f\"Connect to cogip-server error: {data = }\")\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A detector is already connected\"\n    ):\n        logger.error(message)\n        self.detector.retry_connection = False\n        return\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>","text":"<p>On disconnection from cogip-server, stop detector threads.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server, stop detector threads.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.detector.stop()\n    self.detector.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/detector/web/","title":"web","text":""},{"location":"reference/cogip/tools/lidar_ld19/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/lidar_ld19/__main__/#cogip.tools.lidar_ld19.__main__.main","title":"<code>main()</code>","text":"<p>Tool demonstrating usage of lidar_ld19 C++ driver.</p> <p>During installation of cogip-tools, a script called <code>cogip-lidar-ld19</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/lidar_ld19/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Tool demonstrating usage of lidar_ld19 C++ driver.\n\n    During installation of cogip-tools, a script called `cogip-lidar-ld19`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/","title":"gui","text":""},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker","title":"<code>LidarObstacleTracker</code>","text":"Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>class LidarObstacleTracker:\n    def __init__(\n        self,\n        lidar_coords: NDArray,\n        lidar_offset: tuple[float, float],\n        eps: float = 30.0,\n        min_samples: int = 6,\n        update_interval: int = 100,\n    ):\n        \"\"\"\n        Initialize the real-time Lidar obstacle tracker\n\n        Args:\n            lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n            lidar_offset: Lidar offset from robot center\n            eps: DBSCAN clustering parameter\n            min_samples: Minimum points for cluster formation\n            update_interval: Visualization update interval\n        \"\"\"\n        # Use default pose if not provided\n        self.lidar_coords = lidar_coords\n        self.lidar_offset = lidar_offset\n        self.eps = eps\n        self.min_samples = min_samples\n        self.update_interval = update_interval\n        self.view_radius = 2500\n        self.clusters: list[NDArray] = []\n        self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n        # Initialize plot and data containers\n        self.fig, self.ax = plt.subplots(figsize=(10, 10))\n        self.setup_plot()\n\n        # Connect the scroll event to the handler\n        self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n        # Visualization elements\n        self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n        self.cluster_scatters: list[PathCollection] = []\n        self.obstacle_circles: list[Ellipse] = []\n\n        # Robot and Lidar markers\n        self.robot_marker = self.ax.scatter(\n            0,\n            0,\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Robot\",\n        )\n\n        # Calculate Lidar position\n        self.lidar_marker = self.ax.scatter(\n            self.lidar_offset[1],\n            self.lidar_offset[0],\n            c=\"blue\",\n            s=80,\n            marker=\"o\",\n            label=\"Lidar\",\n        )\n\n        # Animation setup\n        self.animation: FuncAnimation | None = None\n\n    def setup_plot(self):\n        \"\"\"Configure the plot appearance with dark theme\"\"\"\n        # Set figure and axes background color\n        self.fig.patch.set_facecolor(\"#2E2E2E\")\n        self.ax.set_facecolor(\"#1E1E1E\")\n\n        # Set labels and title with light colors\n        self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n        self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n        self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n        # Customize grid\n        self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n        # Customize axis appearance\n        self.ax.spines[\"bottom\"].set_color(\"#555555\")\n        self.ax.spines[\"top\"].set_color(\"#555555\")\n        self.ax.spines[\"left\"].set_color(\"#555555\")\n        self.ax.spines[\"right\"].set_color(\"#555555\")\n\n        # Customize tick parameters\n        self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n        # Invert x-axis and set equal aspect ratio\n        self.ax.invert_xaxis()\n        self.ax.axis(\"equal\")\n\n        # Configure legend with dark theme colors\n        self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n        # Set initial view range\n        self.ax.set_xlim((self.view_radius, -self.view_radius))\n        self.ax.set_ylim((-self.view_radius, self.view_radius))\n\n    def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n        \"\"\"\n        Groups points into obstacle clusters using DBSCAN\n\n        Args:\n            points: NDArray of (x, y) points representing detected obstacles\n\n        Returns:\n            List of clusters, each cluster being a set of points belonging to the same obstacle\n        \"\"\"\n        if len(points) == 0:\n            return []\n\n        db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n        labels = db.labels_\n\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n        clusters = []\n        for i in range(n_clusters):\n            cluster_points = points[labels == i]\n            clusters.append(cluster_points)\n\n        return clusters\n\n    def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Estimates position and size of obstacles from clusters\n\n        Args:\n            clusters: List of clusters, each cluster being a set of points\n\n        Returns:\n            List of tuples (center_x, center_y, radius) for each obstacle\n        \"\"\"\n        obstacle_properties = []\n\n        for cluster in clusters:\n            center_x = np.mean(cluster[:, 0])\n            center_y = np.mean(cluster[:, 1])\n\n            # Calculate the maximum distance from center in x and y directions\n            # This will be used as the radius of the circle\n            radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n            radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n            radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n            obstacle_properties.append((center_x, center_y, radius))\n\n        return obstacle_properties\n\n    def update_plot(self, frame):\n        \"\"\"Updates the visualization with current data\"\"\"\n        lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n        self.clusters = self.cluster_obstacles(lidar_coords)\n        self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n        # Update points scatter\n        self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n        # Clear previous cluster scatters and obstacle visualizations\n        for scatter in self.cluster_scatters:\n            scatter.remove()\n        self.cluster_scatters = []\n\n        for circle in self.obstacle_circles:\n            circle.remove()\n        self.obstacle_circles = []\n\n        # Create color map for clusters that works well with dark theme\n        colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n        # Draw new clusters\n        for i, cluster in enumerate(self.clusters):\n            scatter = self.ax.scatter(\n                cluster[:, 1],\n                cluster[:, 0],\n                c=[colors[i]],\n                s=20,\n                label=f\"Cluster {i}\" if i == 0 else \"\",\n            )\n            self.cluster_scatters.append(scatter)\n\n        # Draw obstacle circles and labels\n        for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n            # Create ellipse for the obstacle\n            circle = Ellipse(\n                (center_y, center_x),\n                width=radius * 2,\n                height=radius * 2,\n                fill=False,\n                edgecolor=colors[i],\n                linewidth=2,\n                alpha=0.8,\n            )\n            self.ax.add_patch(circle)\n            self.obstacle_circles.append(circle)\n\n        # Redraw the figure\n        self.fig.canvas.draw_idle()\n\n    def start_animation(self):\n        \"\"\"Starts the real-time visualization\"\"\"\n        # Set dark theme for the color map (for clusters)\n        plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n        # Continue with original animation code\n        self.animation = FuncAnimation(\n            self.fig,\n            self.update_plot,\n            interval=self.update_interval,\n            blit=False,\n            cache_frame_data=False,\n        )\n\n    def on_scroll(self, event: MouseEvent):\n        # Ignore if the mouse is not over the axes\n        if event.inaxes != self.ax:\n            return\n\n        # Get the current limits\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        # Get mouse position in data coordinates\n        x_data, y_data = event.xdata, event.ydata\n\n        # Calculate zoom factor\n        zoom_factor = 1.1 if event.button == \"down\" else 0.9  # Zoom in/out\n\n        # Calculate new limits maintaining the mouse position as center\n        x_left = x_data - zoom_factor * (x_data - xlim[0])\n        x_right = x_data + zoom_factor * (xlim[1] - x_data)\n        y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n        y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n        # Limit the zoom range\n        x_left = max(-self.view_radius, x_left)\n        x_right = min(self.view_radius, x_right)\n        y_bottom = max(-self.view_radius, y_bottom)\n        y_top = min(self.view_radius, y_top)\n\n        # Apply the new limits\n        self.ax.set_xlim(x_left, x_right)\n        self.ax.set_ylim(y_bottom, y_top)\n\n        # Redraw the plot\n        plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.__init__","title":"<code>__init__(lidar_coords, lidar_offset, eps=30.0, min_samples=6, update_interval=100)</code>","text":"<p>Initialize the real-time Lidar obstacle tracker</p> <p>Parameters:</p> Name Type Description Default <code>lidar_coords</code> <code>NDArray</code> <p>2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates</p> required <code>lidar_offset</code> <code>tuple[float, float]</code> <p>Lidar offset from robot center</p> required <code>eps</code> <code>float</code> <p>DBSCAN clustering parameter</p> <code>30.0</code> <code>min_samples</code> <code>int</code> <p>Minimum points for cluster formation</p> <code>6</code> <code>update_interval</code> <code>int</code> <p>Visualization update interval</p> <code>100</code> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def __init__(\n    self,\n    lidar_coords: NDArray,\n    lidar_offset: tuple[float, float],\n    eps: float = 30.0,\n    min_samples: int = 6,\n    update_interval: int = 100,\n):\n    \"\"\"\n    Initialize the real-time Lidar obstacle tracker\n\n    Args:\n        lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n        lidar_offset: Lidar offset from robot center\n        eps: DBSCAN clustering parameter\n        min_samples: Minimum points for cluster formation\n        update_interval: Visualization update interval\n    \"\"\"\n    # Use default pose if not provided\n    self.lidar_coords = lidar_coords\n    self.lidar_offset = lidar_offset\n    self.eps = eps\n    self.min_samples = min_samples\n    self.update_interval = update_interval\n    self.view_radius = 2500\n    self.clusters: list[NDArray] = []\n    self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n    # Initialize plot and data containers\n    self.fig, self.ax = plt.subplots(figsize=(10, 10))\n    self.setup_plot()\n\n    # Connect the scroll event to the handler\n    self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n    # Visualization elements\n    self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n    self.cluster_scatters: list[PathCollection] = []\n    self.obstacle_circles: list[Ellipse] = []\n\n    # Robot and Lidar markers\n    self.robot_marker = self.ax.scatter(\n        0,\n        0,\n        c=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"Robot\",\n    )\n\n    # Calculate Lidar position\n    self.lidar_marker = self.ax.scatter(\n        self.lidar_offset[1],\n        self.lidar_offset[0],\n        c=\"blue\",\n        s=80,\n        marker=\"o\",\n        label=\"Lidar\",\n    )\n\n    # Animation setup\n    self.animation: FuncAnimation | None = None\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.cluster_obstacles","title":"<code>cluster_obstacles(points)</code>","text":"<p>Groups points into obstacle clusters using DBSCAN</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray</code> <p>NDArray of (x, y) points representing detected obstacles</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points belonging to the same obstacle</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n    \"\"\"\n    Groups points into obstacle clusters using DBSCAN\n\n    Args:\n        points: NDArray of (x, y) points representing detected obstacles\n\n    Returns:\n        List of clusters, each cluster being a set of points belonging to the same obstacle\n    \"\"\"\n    if len(points) == 0:\n        return []\n\n    db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n    labels = db.labels_\n\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    clusters = []\n    for i in range(n_clusters):\n        cluster_points = points[labels == i]\n        clusters.append(cluster_points)\n\n    return clusters\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.estimate_obstacle_properties","title":"<code>estimate_obstacle_properties(clusters)</code>","text":"<p>Estimates position and size of obstacles from clusters</p> <p>Parameters:</p> Name Type Description Default <code>clusters</code> <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points</p> required <p>Returns:</p> Type Description <code>list[tuple[float, float, float]]</code> <p>List of tuples (center_x, center_y, radius) for each obstacle</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n    \"\"\"\n    Estimates position and size of obstacles from clusters\n\n    Args:\n        clusters: List of clusters, each cluster being a set of points\n\n    Returns:\n        List of tuples (center_x, center_y, radius) for each obstacle\n    \"\"\"\n    obstacle_properties = []\n\n    for cluster in clusters:\n        center_x = np.mean(cluster[:, 0])\n        center_y = np.mean(cluster[:, 1])\n\n        # Calculate the maximum distance from center in x and y directions\n        # This will be used as the radius of the circle\n        radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n        radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n        radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n        obstacle_properties.append((center_x, center_y, radius))\n\n    return obstacle_properties\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.setup_plot","title":"<code>setup_plot()</code>","text":"<p>Configure the plot appearance with dark theme</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def setup_plot(self):\n    \"\"\"Configure the plot appearance with dark theme\"\"\"\n    # Set figure and axes background color\n    self.fig.patch.set_facecolor(\"#2E2E2E\")\n    self.ax.set_facecolor(\"#1E1E1E\")\n\n    # Set labels and title with light colors\n    self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n    self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n    self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n    # Customize grid\n    self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Customize axis appearance\n    self.ax.spines[\"bottom\"].set_color(\"#555555\")\n    self.ax.spines[\"top\"].set_color(\"#555555\")\n    self.ax.spines[\"left\"].set_color(\"#555555\")\n    self.ax.spines[\"right\"].set_color(\"#555555\")\n\n    # Customize tick parameters\n    self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n    # Invert x-axis and set equal aspect ratio\n    self.ax.invert_xaxis()\n    self.ax.axis(\"equal\")\n\n    # Configure legend with dark theme colors\n    self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n    # Set initial view range\n    self.ax.set_xlim((self.view_radius, -self.view_radius))\n    self.ax.set_ylim((-self.view_radius, self.view_radius))\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.start_animation","title":"<code>start_animation()</code>","text":"<p>Starts the real-time visualization</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def start_animation(self):\n    \"\"\"Starts the real-time visualization\"\"\"\n    # Set dark theme for the color map (for clusters)\n    plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n    # Continue with original animation code\n    self.animation = FuncAnimation(\n        self.fig,\n        self.update_plot,\n        interval=self.update_interval,\n        blit=False,\n        cache_frame_data=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.update_plot","title":"<code>update_plot(frame)</code>","text":"<p>Updates the visualization with current data</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def update_plot(self, frame):\n    \"\"\"Updates the visualization with current data\"\"\"\n    lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n    self.clusters = self.cluster_obstacles(lidar_coords)\n    self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n    # Update points scatter\n    self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n    # Clear previous cluster scatters and obstacle visualizations\n    for scatter in self.cluster_scatters:\n        scatter.remove()\n    self.cluster_scatters = []\n\n    for circle in self.obstacle_circles:\n        circle.remove()\n    self.obstacle_circles = []\n\n    # Create color map for clusters that works well with dark theme\n    colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n    # Draw new clusters\n    for i, cluster in enumerate(self.clusters):\n        scatter = self.ax.scatter(\n            cluster[:, 1],\n            cluster[:, 0],\n            c=[colors[i]],\n            s=20,\n            label=f\"Cluster {i}\" if i == 0 else \"\",\n        )\n        self.cluster_scatters.append(scatter)\n\n    # Draw obstacle circles and labels\n    for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n        # Create ellipse for the obstacle\n        circle = Ellipse(\n            (center_y, center_x),\n            width=radius * 2,\n            height=radius * 2,\n            fill=False,\n            edgecolor=colors[i],\n            linewidth=2,\n            alpha=0.8,\n        )\n        self.ax.add_patch(circle)\n        self.obstacle_circles.append(circle)\n\n    # Redraw the figure\n    self.fig.canvas.draw_idle()\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/web/","title":"web","text":""},{"location":"reference/cogip/tools/mcu_logger/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/mcu_logger/__main__/#cogip.tools.mcu_logger.__main__.main","title":"<code>main()</code>","text":"<p>This tools outputs from a serial port, like mcu-firmware outputs, and forward them to the logger.</p> <p>During installation of cogip-tools, a script called <code>cogip-mcu-logger</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/mcu_logger/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    This tools outputs from a serial port, like mcu-firmware outputs, and forward them to the logger.\n\n    During installation of cogip-tools, a script called `cogip-mcu-logger`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/monitor/actuators/","title":"actuators","text":""},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.ActuatorsDialog","title":"<code>ActuatorsDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>ActuatorsDialog class</p> <p>Build a modal for actuators remote control and monitoring.</p> <p>Attributes:</p> Name Type Description <code>new_actuator_command</code> <code>Signal</code> <p>Qt signal emitted when a actuator command is updated</p> <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>class ActuatorsDialog(QtWidgets.QDialog):\n    \"\"\"\n    ActuatorsDialog class\n\n    Build a modal for actuators remote control and monitoring.\n\n    Attributes:\n        new_actuator_command: Qt signal emitted when a actuator command is updated\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    closed: qtSignal = qtSignal()\n    new_actuator_command: qtSignal = qtSignal(object)\n\n    def __init__(self, parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.positional_actuators: dict[PositionalActuatorEnum, PositionalActuatorControl] = {}\n        self.bool_sensors: dict[BoolSensorEnum, BoolSensorControl] = {}\n        self.setWindowTitle(\"Actuators Control\")\n        self.setModal(False)\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        for id in PositionalActuatorEnum:\n            self.positional_actuators[id] = PositionalActuatorControl(id, layout)\n            self.positional_actuators[id].command_updated.connect(self.command_updated)\n\n        for id in BoolSensorEnum:\n            self.bool_sensors[id] = BoolSensorControl(id, layout)\n\n        self.readSettings()\n\n    def update_actuator(self, actuator_state: ActuatorState):\n        \"\"\"\n        Update an actuator with new values.\n\n        Arguments:\n            actuator_state: current state of an actuator\n        \"\"\"\n\n        match actuator_state.kind:\n            case ActuatorsKindEnum.servo:\n                actuator = self.servos.get(actuator_state.id)\n                if actuator is None:\n                    logger.warning(f\"Unknown servo ID: {actuator_state.id}\")\n                    return\n                actuator.update_value(actuator_state)\n            case ActuatorsKindEnum.positional_actuator:\n                actuator = self.positional_actuators.get(actuator_state.id)\n                if actuator is None:\n                    logger.warning(f\"Unknown positional actuator ID: {actuator_state.id}\")\n                    return\n                actuator.update_value(actuator_state)\n            case ActuatorsKindEnum.bool_sensor:\n                actuator = self.bool_sensors.get(actuator_state.id)\n                if actuator is None:\n                    logger.warning(f\"Unknown bool sensor ID: {actuator_state.id}\")\n                    return\n                actuator.update_value(actuator_state)\n\n    def command_updated(self, command: ActuatorCommand):\n        \"\"\"\n        Emit updated values with namespace, name and value.\n        \"\"\"\n        self.new_actuator_command.emit(command)\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"properties/actuators\", self.saveGeometry())\n\n        self.closed.emit()\n        event.accept()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"properties/actuators\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.ActuatorsDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.positional_actuators: dict[PositionalActuatorEnum, PositionalActuatorControl] = {}\n    self.bool_sensors: dict[BoolSensorEnum, BoolSensorControl] = {}\n    self.setWindowTitle(\"Actuators Control\")\n    self.setModal(False)\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    for id in PositionalActuatorEnum:\n        self.positional_actuators[id] = PositionalActuatorControl(id, layout)\n        self.positional_actuators[id].command_updated.connect(self.command_updated)\n\n    for id in BoolSensorEnum:\n        self.bool_sensors[id] = BoolSensorControl(id, layout)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.ActuatorsDialog.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"properties/actuators\", self.saveGeometry())\n\n    self.closed.emit()\n    event.accept()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.ActuatorsDialog.command_updated","title":"<code>command_updated(command)</code>","text":"<p>Emit updated values with namespace, name and value.</p> Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>def command_updated(self, command: ActuatorCommand):\n    \"\"\"\n    Emit updated values with namespace, name and value.\n    \"\"\"\n    self.new_actuator_command.emit(command)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.ActuatorsDialog.update_actuator","title":"<code>update_actuator(actuator_state)</code>","text":"<p>Update an actuator with new values.</p> <p>Parameters:</p> Name Type Description Default <code>actuator_state</code> <code>ActuatorState</code> <p>current state of an actuator</p> required Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>def update_actuator(self, actuator_state: ActuatorState):\n    \"\"\"\n    Update an actuator with new values.\n\n    Arguments:\n        actuator_state: current state of an actuator\n    \"\"\"\n\n    match actuator_state.kind:\n        case ActuatorsKindEnum.servo:\n            actuator = self.servos.get(actuator_state.id)\n            if actuator is None:\n                logger.warning(f\"Unknown servo ID: {actuator_state.id}\")\n                return\n            actuator.update_value(actuator_state)\n        case ActuatorsKindEnum.positional_actuator:\n            actuator = self.positional_actuators.get(actuator_state.id)\n            if actuator is None:\n                logger.warning(f\"Unknown positional actuator ID: {actuator_state.id}\")\n                return\n            actuator.update_value(actuator_state)\n        case ActuatorsKindEnum.bool_sensor:\n            actuator = self.bool_sensors.get(actuator_state.id)\n            if actuator is None:\n                logger.warning(f\"Unknown bool sensor ID: {actuator_state.id}\")\n                return\n            actuator.update_value(actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.BoolSensorControl","title":"<code>BoolSensorControl</code>","text":"<p>               Bases: <code>QObject</code></p> <p>BoolSensorControl class.</p> <p>Build a widget to show the state of a bool  sensor.</p> Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>class BoolSensorControl(QtCore.QObject):\n    \"\"\"\n    BoolSensorControl class.\n\n    Build a widget to show the state of a bool  sensor.\n    \"\"\"\n\n    def __init__(self, id: BoolSensorEnum, layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            id: ID of bool sensor to display\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self.enabled = False\n        self.id = id\n\n        row = layout.rowCount()\n\n        self.label = QtWidgets.QLabel(self.id.name)\n        layout.addWidget(self.label, row, 0)\n\n        self.kind = QtWidgets.QLabel(\"Bool Sensor\")\n        layout.addWidget(self.kind, row, 1)\n\n        self.state = QtWidgets.QCheckBox()\n        self.state.setToolTip(\"State\")\n        self.state.setAttribute(QtCore.Qt.WidgetAttribute.WA_TransparentForMouseEvents)\n        self.state.setFocusPolicy(QtCore.Qt.NoFocus)\n        self.state.setChecked(False)\n        layout.addWidget(self.state, row, 2)\n\n        self.label.setEnabled(False)\n        self.kind.setEnabled(False)\n        self.state.setEnabled(False)\n\n    def update_value(self, actuator: BoolSensor):\n        if not self.enabled:\n            self.enabled = True\n            self.label.setEnabled(True)\n            self.kind.setEnabled(True)\n            self.state.setEnabled(True)\n\n        self.state.setChecked(actuator.state)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.BoolSensorControl.__init__","title":"<code>__init__(id, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>BoolSensorEnum</code> <p>ID of bool sensor to display</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>def __init__(self, id: BoolSensorEnum, layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        id: ID of bool sensor to display\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self.enabled = False\n    self.id = id\n\n    row = layout.rowCount()\n\n    self.label = QtWidgets.QLabel(self.id.name)\n    layout.addWidget(self.label, row, 0)\n\n    self.kind = QtWidgets.QLabel(\"Bool Sensor\")\n    layout.addWidget(self.kind, row, 1)\n\n    self.state = QtWidgets.QCheckBox()\n    self.state.setToolTip(\"State\")\n    self.state.setAttribute(QtCore.Qt.WidgetAttribute.WA_TransparentForMouseEvents)\n    self.state.setFocusPolicy(QtCore.Qt.NoFocus)\n    self.state.setChecked(False)\n    layout.addWidget(self.state, row, 2)\n\n    self.label.setEnabled(False)\n    self.kind.setEnabled(False)\n    self.state.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.PositionalActuatorControl","title":"<code>PositionalActuatorControl</code>","text":"<p>               Bases: <code>QObject</code></p> <p>PositionalControl class.</p> <p>Build a widget to control a positional actuator.</p> Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>class PositionalActuatorControl(QtCore.QObject):\n    \"\"\"\n    PositionalControl class.\n\n    Build a widget to control a positional actuator.\n    \"\"\"\n\n    command_updated: qtSignal = qtSignal(object)\n\n    def __init__(self, id: PositionalActuatorEnum, layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            id: ID of positional actuator to control\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self.enabled = False\n        command_schema = PositionalActuator.model_json_schema()[\"properties\"][\"command\"]\n        self.id = id\n\n        row = layout.rowCount()\n        minimum, maximum = actuator_limits.get(id, (command_schema.get(\"minimum\"), command_schema.get(\"maximum\")))\n\n        self.label = QtWidgets.QLabel(self.id.name)\n        layout.addWidget(self.label, row, 0)\n\n        self.kind = QtWidgets.QLabel(\"Positional\")\n        layout.addWidget(self.kind, row, 1)\n\n        self.command = QtWidgets.QSpinBox()\n        self.command.setToolTip(\"Position command\")\n        self.command.setMinimum(minimum)\n        self.command.setMaximum(maximum)\n        self.command.setSingleStep(1)\n        self.command.valueChanged.connect(self.command_changed)\n        layout.addWidget(self.command, row, 2)\n\n        self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.slider.setToolTip(\"Position command\")\n        self.slider.setMinimum(minimum)\n        self.slider.setMaximum(maximum)\n        self.slider.setSingleStep(1)\n        self.slider.valueChanged.connect(self.command.setValue)\n        layout.addWidget(self.slider, row, 3)\n\n        self.position = QtWidgets.QLabel()\n        self.position.setToolTip(\"Current command\")\n        layout.addWidget(self.position, row, 4)\n\n        self.label.setEnabled(False)\n        self.kind.setEnabled(False)\n        self.command.setEnabled(False)\n        self.slider.setEnabled(False)\n        self.position.setEnabled(False)\n\n    def command_changed(self, value):\n        self.slider.setValue(value)\n        command = PositionalActuatorCommand(id=self.id, command=value)\n        self.command_updated.emit(command)\n\n    def update_value(self, actuator: PositionalActuator):\n        if not self.enabled:\n            self.enabled = True\n            self.label.setEnabled(True)\n            self.kind.setEnabled(True)\n            self.command.setEnabled(True)\n            self.slider.setEnabled(True)\n            self.position.setEnabled(True)\n\n        self.command.blockSignals(True)\n        self.command.setValue(actuator.command)\n        self.command.blockSignals(False)\n        self.slider.blockSignals(True)\n        self.slider.setValue(actuator.command)\n        self.slider.blockSignals(False)\n        self.position.setText(str(actuator.command))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/actuators/#cogip.tools.monitor.actuators.PositionalActuatorControl.__init__","title":"<code>__init__(id, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>PositionalActuatorEnum</code> <p>ID of positional actuator to control</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/tools/monitor/actuators.py</code> <pre><code>def __init__(self, id: PositionalActuatorEnum, layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        id: ID of positional actuator to control\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self.enabled = False\n    command_schema = PositionalActuator.model_json_schema()[\"properties\"][\"command\"]\n    self.id = id\n\n    row = layout.rowCount()\n    minimum, maximum = actuator_limits.get(id, (command_schema.get(\"minimum\"), command_schema.get(\"maximum\")))\n\n    self.label = QtWidgets.QLabel(self.id.name)\n    layout.addWidget(self.label, row, 0)\n\n    self.kind = QtWidgets.QLabel(\"Positional\")\n    layout.addWidget(self.kind, row, 1)\n\n    self.command = QtWidgets.QSpinBox()\n    self.command.setToolTip(\"Position command\")\n    self.command.setMinimum(minimum)\n    self.command.setMaximum(maximum)\n    self.command.setSingleStep(1)\n    self.command.valueChanged.connect(self.command_changed)\n    layout.addWidget(self.command, row, 2)\n\n    self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n    self.slider.setToolTip(\"Position command\")\n    self.slider.setMinimum(minimum)\n    self.slider.setMaximum(maximum)\n    self.slider.setSingleStep(1)\n    self.slider.valueChanged.connect(self.command.setValue)\n    layout.addWidget(self.slider, row, 3)\n\n    self.position = QtWidgets.QLabel()\n    self.position.setToolTip(\"Current command\")\n    layout.addWidget(self.position, row, 4)\n\n    self.label.setEnabled(False)\n    self.kind.setEnabled(False)\n    self.command.setEnabled(False)\n    self.slider.setEnabled(False)\n    self.position.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/artifacts/","title":"artifacts","text":""},{"location":"reference/cogip/tools/monitor/artifacts/#cogip.tools.monitor.artifacts.ColumnEntity","title":"<code>ColumnEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> Source code in <code>cogip/tools/monitor/artifacts.py</code> <pre><code>class ColumnEntity(Qt3DCore.QEntity):\n    height = 109.0\n    diameter = 73.0\n\n    def __init__(self, parent: Qt3DCore.QEntity, shift: float):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(0, shift, self.height / 2))\n        self.transform.setRotationX(90)\n        self.addComponent(self.transform)\n\n        self.mesh = Qt3DExtras.QCylinderMesh()\n        self.mesh.setLength(self.height)\n        self.mesh.setRadius(self.diameter / 2)\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n        self.material.setDiffuse(QtGui.QColor(192, 192, 192))\n        self.material.setSpecular(QtGui.QColor(255, 255, 255))\n        self.material.setShininess(100.0)\n        self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/artifacts/#cogip.tools.monitor.artifacts.ColumnEntity.__init__","title":"<code>__init__(parent, shift)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/artifacts.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity, shift: float):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(0, shift, self.height / 2))\n    self.transform.setRotationX(90)\n    self.addComponent(self.transform)\n\n    self.mesh = Qt3DExtras.QCylinderMesh()\n    self.mesh.setLength(self.height)\n    self.mesh.setRadius(self.diameter / 2)\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n    self.material.setDiffuse(QtGui.QColor(192, 192, 192))\n    self.material.setSpecular(QtGui.QColor(255, 255, 255))\n    self.material.setShininess(100.0)\n    self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/artifacts/#cogip.tools.monitor.artifacts.PlatformEntity","title":"<code>PlatformEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> Source code in <code>cogip/tools/monitor/artifacts.py</code> <pre><code>class PlatformEntity(Qt3DCore.QEntity):\n    length = 400.0\n    width = 100.0\n    thickness = 15.0\n    height = 109.0\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(0, 0, self.height + self.thickness / 2))\n        self.transform.setRotationZ(90)\n        self.addComponent(self.transform)\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setXExtent(self.length)\n        self.mesh.setYExtent(self.width)\n        self.mesh.setZExtent(self.thickness)\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n        self.material.setDiffuse(QtGui.QColor(139, 69, 19))\n        self.material.setSpecular(QtGui.QColor(255, 255, 255))\n        self.material.setShininess(10.0)\n        self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/artifacts/#cogip.tools.monitor.artifacts.PlatformEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/artifacts.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(0, 0, self.height + self.thickness / 2))\n    self.transform.setRotationZ(90)\n    self.addComponent(self.transform)\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setXExtent(self.length)\n    self.mesh.setYExtent(self.width)\n    self.mesh.setZExtent(self.thickness)\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n    self.material.setDiffuse(QtGui.QColor(139, 69, 19))\n    self.material.setSpecular(QtGui.QColor(255, 255, 255))\n    self.material.setShininess(10.0)\n    self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/artifacts/#cogip.tools.monitor.artifacts.TribuneEntity","title":"<code>TribuneEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A dynamic obstacle detected by the robot.</p> <p>Base class for rectangle and circle obstacles.</p> Source code in <code>cogip/tools/monitor/artifacts.py</code> <pre><code>class TribuneEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A dynamic obstacle detected by the robot.\n\n    Base class for rectangle and circle obstacles.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity, position: Pose):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n\n        # Global transform for the artifact\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(position.x, position.y, 0))\n        self.transform.setRotationZ(position.O)\n        self.addComponent(self.transform)\n\n        self.platform = PlatformEntity(self)\n        self.column1 = ColumnEntity(self, -150)\n        self.column2 = ColumnEntity(self, -50)\n        self.column3 = ColumnEntity(self, 50)\n        self.column4 = ColumnEntity(self, 150)\n\n        # Create a layer used by sensors to activate detection on the artifacts\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        Sensor.add_obstacle(self)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/artifacts/#cogip.tools.monitor.artifacts.TribuneEntity.__init__","title":"<code>__init__(parent, position)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/artifacts.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity, position: Pose):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n\n    # Global transform for the artifact\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(position.x, position.y, 0))\n    self.transform.setRotationZ(position.O)\n    self.addComponent(self.transform)\n\n    self.platform = PlatformEntity(self)\n    self.column1 = ColumnEntity(self, -150)\n    self.column2 = ColumnEntity(self, -50)\n    self.column3 = ColumnEntity(self, 50)\n    self.column4 = ColumnEntity(self, 150)\n\n    # Create a layer used by sensors to activate detection on the artifacts\n    self.layer = Qt3DRender.QLayer(self)\n    self.layer.setRecursive(True)\n    self.layer.setEnabled(True)\n    self.addComponent(self.layer)\n\n    Sensor.add_obstacle(self)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/asset/","title":"asset","text":"<p>This module defines the base class AssetEntity used directly or inherited for specific assets.</p> <p>Asset entities are graphic element displayed on the 3D view and loaded from asset files. It is typically used for table and robot assets.</p> <p>Supported asset files are in Collada format (<code>.dae</code>). Other formats could be also supported, but not tested (see Open Asset Import Library).</p>"},{"location":"reference/cogip/tools/monitor/asset/#cogip.tools.monitor.asset.AssetEntity","title":"<code>AssetEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>Base class for asset entities</p> <p>This class inherits from <code>Qt3DCore.QEntity</code></p> <p>Attributes:</p> Name Type Description <code>ready</code> <code>Signal</code> <p>Qt signal emitted when the asset entity is ready to be used</p> <code>asset_ready</code> <code>bool</code> <p><code>True</code> if the asset is ready</p> <code>asset_entity</code> <code>QEntity</code> <p>first useful <code>QEntity</code> in the asset tree</p> <code>transform_component</code> <p><code>QTransform</code> holding the asset's translation and orientation</p> Source code in <code>cogip/tools/monitor/asset.py</code> <pre><code>class AssetEntity(Qt3DCore.QEntity):\n    \"\"\"Base class for asset entities\n\n    This class inherits from [`Qt3DCore.QEntity`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DCore/QEntity.html)\n\n    Attributes:\n        ready: Qt signal emitted when the asset entity is ready to be used\n        asset_ready: `True` if the asset is ready\n        asset_entity: first useful `QEntity` in the asset tree\n        transform_component: `QTransform` holding the asset's translation and orientation\n    \"\"\"\n\n    ready: qtSignal = qtSignal()\n\n    def __init__(self, asset_path: Path, scale: float = 1.0, parent: Qt3DCore.QEntity = None):\n        \"\"\"\n        The constructor checks the asset's file and starts loading the entity.\n\n        The entity load is asynchronous, a signal is emitted when it is done\n        (see [`on_loader_status_changed`][cogip.tools.monitor.asset.AssetEntity.on_loader_status_changed])\n\n        Arguments:\n            asset_path: path of the asset file\n            scale: scale to apply to the entity after load\n        \"\"\"\n\n        super().__init__(parent)\n\n        self.asset_ready: bool = False\n        self.asset_path: Path = asset_path\n        self.scale: float = scale\n        self.asset_entity: Qt3DCore.QEntity = None\n\n        self.transform_component = Qt3DCore.QTransform()\n        self.addComponent(self.transform_component)\n\n        if not self.asset_path.exists():\n            raise FileNotFoundError(f\"File not found '{self.asset_path}'\")\n        if not self.asset_path.is_file():\n            raise IsADirectoryError(f\"'{self.asset_path}' is not a file\")\n\n        self.loader = Qt3DRender.QSceneLoader(self)\n        self.loader.statusChanged.connect(self.on_loader_status_changed)\n        self.loader.setObjectName(self.asset_path.name)\n        self.addComponent(self.loader)\n        self.loader.setSource(QtCore.QUrl(f\"file:{self.asset_path}\"))\n\n    @qtSlot(Qt3DRender.QSceneLoader.Status)\n    def on_loader_status_changed(self, status: Qt3DRender.QSceneLoader.Status):\n        \"\"\"\n        When the loader has finished, clean the entity tree,\n        record the main `QEntity` and its `QTransform` component.\n\n        Then it generated the dot tree\n        (see [`generate_tree`][cogip.tools.monitor.asset.AssetEntity.generate_tree]),\n        run the [`post_init`][cogip.tools.monitor.asset.AssetEntity.post_init] pass,\n        and emit the `ready` signal.\n\n        Arguments:\n            status: current loader status\n        \"\"\"\n        if (\n            status.value != Qt3DRender.QSceneLoader.Ready.value\n        ):  # .value is workaround to a Python binding bug in PySide6 6.4.\n            return\n\n        self.post_init()\n\n        self.generate_tree()\n\n        self.asset_ready = True\n\n        self.ready.emit()\n\n    def generate_tree(self):\n        \"\"\"\n        Generate a tree of all entities and components starting from the main entity.\n\n        The generated file is stored next to the asset file and it has the same name\n        but with `.tree.dot` extension.\n\n        It is a text file written in [Graphviz](https://graphviz.org/) format.\n\n        To read this file:\n        ```bash\n            sudo apt install graphviz okular\n            dot -Tpdf assets/robot2019.tree.dot | okular -\n        ```\n        \"\"\"\n\n        tree_filename = self.asset_path.with_suffix(\".tree.dot\")\n        with tree_filename.open(mode=\"w\") as fd:\n            fd.write('graph \"\"\\n')\n            fd.write(\"{\\n\")\n            fd.write('label=\"Entity tree\"\\n')\n            root_node_number = 0\n            traverse_tree(self, root_node_number, fd)\n            fd.write(\"}\\n\")\n\n    def post_init(self):\n        \"\"\"\n        Post initialization method that can be overloaded.\n        It it executed after entity and transform components are ready.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/cogip/tools/monitor/asset/#cogip.tools.monitor.asset.AssetEntity.__init__","title":"<code>__init__(asset_path, scale=1.0, parent=None)</code>","text":"<p>The constructor checks the asset's file and starts loading the entity.</p> <p>The entity load is asynchronous, a signal is emitted when it is done (see <code>on_loader_status_changed</code>)</p> <p>Parameters:</p> Name Type Description Default <code>asset_path</code> <code>Path</code> <p>path of the asset file</p> required <code>scale</code> <code>float</code> <p>scale to apply to the entity after load</p> <code>1.0</code> Source code in <code>cogip/tools/monitor/asset.py</code> <pre><code>def __init__(self, asset_path: Path, scale: float = 1.0, parent: Qt3DCore.QEntity = None):\n    \"\"\"\n    The constructor checks the asset's file and starts loading the entity.\n\n    The entity load is asynchronous, a signal is emitted when it is done\n    (see [`on_loader_status_changed`][cogip.tools.monitor.asset.AssetEntity.on_loader_status_changed])\n\n    Arguments:\n        asset_path: path of the asset file\n        scale: scale to apply to the entity after load\n    \"\"\"\n\n    super().__init__(parent)\n\n    self.asset_ready: bool = False\n    self.asset_path: Path = asset_path\n    self.scale: float = scale\n    self.asset_entity: Qt3DCore.QEntity = None\n\n    self.transform_component = Qt3DCore.QTransform()\n    self.addComponent(self.transform_component)\n\n    if not self.asset_path.exists():\n        raise FileNotFoundError(f\"File not found '{self.asset_path}'\")\n    if not self.asset_path.is_file():\n        raise IsADirectoryError(f\"'{self.asset_path}' is not a file\")\n\n    self.loader = Qt3DRender.QSceneLoader(self)\n    self.loader.statusChanged.connect(self.on_loader_status_changed)\n    self.loader.setObjectName(self.asset_path.name)\n    self.addComponent(self.loader)\n    self.loader.setSource(QtCore.QUrl(f\"file:{self.asset_path}\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/asset/#cogip.tools.monitor.asset.AssetEntity.generate_tree","title":"<code>generate_tree()</code>","text":"<p>Generate a tree of all entities and components starting from the main entity.</p> <p>The generated file is stored next to the asset file and it has the same name but with <code>.tree.dot</code> extension.</p> <p>It is a text file written in Graphviz format.</p> <p>To read this file:</p> <pre><code>    sudo apt install graphviz okular\n    dot -Tpdf assets/robot2019.tree.dot | okular -\n</code></pre> Source code in <code>cogip/tools/monitor/asset.py</code> <pre><code>def generate_tree(self):\n    \"\"\"\n    Generate a tree of all entities and components starting from the main entity.\n\n    The generated file is stored next to the asset file and it has the same name\n    but with `.tree.dot` extension.\n\n    It is a text file written in [Graphviz](https://graphviz.org/) format.\n\n    To read this file:\n    ```bash\n        sudo apt install graphviz okular\n        dot -Tpdf assets/robot2019.tree.dot | okular -\n    ```\n    \"\"\"\n\n    tree_filename = self.asset_path.with_suffix(\".tree.dot\")\n    with tree_filename.open(mode=\"w\") as fd:\n        fd.write('graph \"\"\\n')\n        fd.write(\"{\\n\")\n        fd.write('label=\"Entity tree\"\\n')\n        root_node_number = 0\n        traverse_tree(self, root_node_number, fd)\n        fd.write(\"}\\n\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/asset/#cogip.tools.monitor.asset.AssetEntity.on_loader_status_changed","title":"<code>on_loader_status_changed(status)</code>","text":"<p>When the loader has finished, clean the entity tree, record the main <code>QEntity</code> and its <code>QTransform</code> component.</p> <p>Then it generated the dot tree (see <code>generate_tree</code>), run the <code>post_init</code> pass, and emit the <code>ready</code> signal.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>current loader status</p> required Source code in <code>cogip/tools/monitor/asset.py</code> <pre><code>@qtSlot(Qt3DRender.QSceneLoader.Status)\ndef on_loader_status_changed(self, status: Qt3DRender.QSceneLoader.Status):\n    \"\"\"\n    When the loader has finished, clean the entity tree,\n    record the main `QEntity` and its `QTransform` component.\n\n    Then it generated the dot tree\n    (see [`generate_tree`][cogip.tools.monitor.asset.AssetEntity.generate_tree]),\n    run the [`post_init`][cogip.tools.monitor.asset.AssetEntity.post_init] pass,\n    and emit the `ready` signal.\n\n    Arguments:\n        status: current loader status\n    \"\"\"\n    if (\n        status.value != Qt3DRender.QSceneLoader.Ready.value\n    ):  # .value is workaround to a Python binding bug in PySide6 6.4.\n        return\n\n    self.post_init()\n\n    self.generate_tree()\n\n    self.asset_ready = True\n\n    self.ready.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/asset/#cogip.tools.monitor.asset.AssetEntity.post_init","title":"<code>post_init()</code>","text":"<p>Post initialization method that can be overloaded. It it executed after entity and transform components are ready.</p> Source code in <code>cogip/tools/monitor/asset.py</code> <pre><code>def post_init(self):\n    \"\"\"\n    Post initialization method that can be overloaded.\n    It it executed after entity and transform components are ready.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogip/tools/monitor/asset/#cogip.tools.monitor.asset.traverse_tree","title":"<code>traverse_tree(node, next_node_nb, fd)</code>","text":"<p>Recursive function traversing all child entities and write its node and all its components to the .dot file.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>QEntity</code> <p>entity to traverse</p> required <code>next_node_nb</code> <code>int</code> <p>next node number</p> required <code>fd</code> <code>TextIO</code> <p>opened file descriptor used to write the tree</p> required Return <p>tuple of current and next node numbers</p> Source code in <code>cogip/tools/monitor/asset.py</code> <pre><code>def traverse_tree(node: Qt3DCore.QEntity, next_node_nb: int, fd: TextIO) -&gt; tuple[int, int]:\n    \"\"\"\n    Recursive function traversing all child entities and write its node\n    and all its components to the .dot file.\n\n    Arguments:\n        node: entity to traverse\n        next_node_nb: next node number\n        fd: opened file descriptor used to write the tree\n\n    Return:\n        tuple of current and next node numbers\n    \"\"\"\n\n    current_node_nb = next_node_nb\n    next_node_nb += 1\n\n    # Insert current node in the tree\n    fd.write(f'n{current_node_nb:03d} [label=\"{node.metaObject().className()}\\n{node.objectName()}\"] ;\\n')\n\n    # Enumerate components\n    for comp in node.components():\n        fd.write(f'n{next_node_nb:03d} [shape=box,label=\"{comp.metaObject().className()}\\n{comp.objectName()}\"] ;\\n')\n        fd.write(f\"n{current_node_nb:03d} -- n{next_node_nb:03d} [style=dotted];\\n\")\n        next_node_nb += 1\n\n    # Build tree for children\n    for child_node in node.children():\n        if isinstance(child_node, Qt3DCore.QEntity):\n            child_node_nb, next_node_nb = traverse_tree(child_node, next_node_nb, fd)\n            fd.write(f\"n{current_node_nb:03d} -- n{child_node_nb:03d} ;\\n\")\n\n    return current_node_nb, next_node_nb\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/","title":"chartsview","text":""},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView","title":"<code>ChartView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>ChartsView class</p> <p>Chart widget displaying a graph with a 'current' and an 'order' curve.</p> <p>It features a scrollbar, a zoom slider and a button to save the data in CVS format.</p> <p>The chart is reset after the robot mode has changed from RUNNING to an other value.</p> <p>Attributes:</p> Name Type Description <code>need_reset</code> <code>bool</code> <p>True if the data must be reset on next state</p> <code>slider_events_disabled</code> <code>bool</code> <p>Do not recalculate range if False</p> <code>default_range_max_x</code> <code>float</code> <p>Default max X range value</p> <code>default_range_max_y</code> <code>float</code> <p>Default max Y range value</p> <code>range_max_x</code> <code>float</code> <p>Current max X range value</p> <code>range_max_y</code> <code>float</code> <p>Current max Y range value</p> <code>zoom_max</code> <code>int</code> <p>max zoom value</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>class ChartView(QtWidgets.QWidget):\n    \"\"\"ChartsView class\n\n    Chart widget displaying a graph with a 'current' and an 'order' curve.\n\n    It features a scrollbar, a zoom slider and a button to save the data in CVS format.\n\n    The chart is reset after the robot mode has changed from RUNNING to an other value.\n\n    Attributes:\n        need_reset: True if the data must be reset on next state\n        slider_events_disabled: Do not recalculate range if False\n        default_range_max_x: Default max X range value\n        default_range_max_y: Default max Y range value\n        range_max_x: Current max X range value\n        range_max_y: Current max Y range value\n        zoom_max: max zoom value\n    \"\"\"\n\n    need_reset: bool = False\n    slider_events_disabled: bool = False\n    default_range_max_x: float = 100\n    default_range_max_y: float = 0.5\n    range_max_x: float = default_range_max_x\n    range_max_y: float = default_range_max_y\n    zoom_max: int = 10\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None, name: str | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n            name: Name of the current chart\n        \"\"\"\n        super().__init__(parent)\n        self.name = name\n\n        layout = QtWidgets.QVBoxLayout(self)\n\n        self.chart_view = QtCharts.QChartView()\n        self.chart_view.setRenderHint(QtGui.QPainter.Antialiasing)\n        layout.addWidget(self.chart_view)\n\n        sliders_widget = QtWidgets.QWidget()\n        sliders_layout = QtWidgets.QGridLayout(sliders_widget)\n        sliders_widget.setLayout(sliders_layout)\n        layout.addWidget(sliders_widget)\n\n        self.scrollbar = QtWidgets.QScrollBar(QtCore.Qt.Horizontal)\n        self.scrollbar.setMinimum(1)\n        self.scrollbar.setMaximum(self.default_range_max_x)\n        self.scrollbar.setSliderPosition(25)\n        self.scrollbar.valueChanged.connect(self.slider_changed)\n        sliders_layout.addWidget(self.scrollbar, 0, 0)\n\n        self.zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=0, maximum=100, value=60)\n        self.zoom.setMinimum(1)\n        self.zoom.setMaximum(self.zoom_max)\n        self.zoom.setValue(1)\n        self.zoom.valueChanged.connect(self.slider_changed)\n        sliders_layout.addWidget(self.zoom, 1, 0)\n\n        self.save_button = QtWidgets.QPushButton()\n        self.save_button.setIcon(QtGui.QIcon.fromTheme(\"document-save\"))\n        self.save_button.setStatusTip(\"Save values\")\n        self.save_button.clicked.connect(self.save_values)\n        sliders_layout.addWidget(self.save_button, 0, 1, 2, 1)\n\n        self.chart = QtCharts.QChart()\n        self.axis_x = QtCharts.QValueAxis(self)\n        self.axis_y = QtCharts.QValueAxis(self)\n        self.chart.addAxis(self.axis_x, QtCore.Qt.AlignBottom)\n        self.chart.addAxis(self.axis_y, QtCore.Qt.AlignLeft)\n\n        self.serie_current = QtCharts.QLineSeries(name=f\"{self.name} Current\")\n        self.chart.addSeries(self.serie_current)\n        self.serie_current.attachAxis(self.axis_x)\n        self.serie_current.attachAxis(self.axis_y)\n        pen = self.serie_current.pen()\n        pen.setWidth(5)\n        self.serie_current.setPen(pen)\n\n        self.serie_order = QtCharts.QLineSeries(name=f\"{self.name} Order\")\n        self.chart.addSeries(self.serie_order)\n        self.serie_order.attachAxis(self.axis_x)\n        self.serie_order.attachAxis(self.axis_y)\n\n        pen = self.serie_order.pen()\n        pen.setWidth(5)\n        self.serie_order.setPen(pen)\n\n        # self.chart.createDefaultAxes()\n\n        self.axis_x.setMin(1)\n        self.axis_x.setTickInterval(1)\n\n        self.axis_y.setMin(1)\n        self.axis_y.setMax(self.default_range_max_y)\n\n        self.chart_view.setChart(self.chart)\n\n        self.recalculate_range_x()\n\n    @qtSlot(int)\n    def slider_changed(self, value: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the scrollbar and zoom has changed.\n        \"\"\"\n        self.recalculate_range_x()\n\n    def recalculate_range_x(self):\n        \"\"\"\n        Given the current zoom and current position of the scrollbar,\n        compute the X min/max range and the slider position.\n        \"\"\"\n        if self.slider_events_disabled:\n            return\n        self.slider_events_disabled = True\n\n        span = int(self.range_max_x / self.zoom.value())\n        span = span + span % 2\n        scroll_min = span / 2\n        scroll_max = self.range_max_x - span / 2\n\n        scroll = self.scrollbar.value()\n        scroll = max(scroll_min, scroll)\n        scroll = min(scroll_max, scroll)\n\n        self.scrollbar.setMinimum(scroll_min)\n        self.scrollbar.setMaximum(scroll_max)\n        self.scrollbar.setValue(scroll)\n\n        self.axis_x.setMax(self.range_max_x)\n\n        span = int(self.range_max_x / self.zoom.sliderPosition())\n        span = span + span % 2\n\n        x_min = scroll - span / 2\n        x_max = scroll + span / 2\n        self.axis_x.setRange(x_min, x_max)\n\n        self.slider_events_disabled = False\n\n    def reset(self):\n        \"\"\"\n        Reset the chart\n        \"\"\"\n        self.serie_current.clear()\n        self.serie_order.clear()\n\n        self.range_max_x = self.default_range_max_x\n        self.range_max_y = self.default_range_max_y\n\n        self.recalculate_range_x()\n\n    def new_robot_state(self, cycle: int, current: float | None, order: float | None) -&gt; None:\n        \"\"\"\n        Add a new point on the chart view.\n\n        Arguments:\n            cycle: Current cycle\n            current: Current value\n            order: Order value\n        \"\"\"\n        if self.need_reset:\n            self.need_reset = False\n            self.reset()\n\n        self.range_max_x = max(self.range_max_x, cycle)\n\n        if current:\n            self.serie_current.append(cycle, current)\n            self.range_max_y = max(self.range_max_y, current)\n\n        if order:\n            self.serie_order.append(cycle, order)\n            self.range_max_y = max(self.range_max_y, order)\n\n        self.axis_y.setMax(self.range_max_y)\n\n        self.recalculate_range_x()\n\n    @qtSlot()\n    def save_values(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a file and save chart values in it.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n            parent=self,\n            caption=f\"Select file to save {self.name} values\",\n            dir=\"\",\n            filter=\"CSV Files (*.csv)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            with Path(filename).open(\"w\", newline=\"\") as csv_file:\n                writer = csv.DictWriter(csv_file, fieldnames=[\"cycle\", \"order\", \"current\"])\n                writer.writeheader()\n\n                for order, current in zip(self.serie_order.points(), self.serie_current.points()):\n                    writer.writerow({\"cycle\": int(order.x()), \"order\": order.y(), \"current\": current.y()})\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView.__init__","title":"<code>__init__(parent=None, name=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget | None</code> <p>The parent widget</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Name of the current chart</p> <code>None</code> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget | None = None, name: str | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n        name: Name of the current chart\n    \"\"\"\n    super().__init__(parent)\n    self.name = name\n\n    layout = QtWidgets.QVBoxLayout(self)\n\n    self.chart_view = QtCharts.QChartView()\n    self.chart_view.setRenderHint(QtGui.QPainter.Antialiasing)\n    layout.addWidget(self.chart_view)\n\n    sliders_widget = QtWidgets.QWidget()\n    sliders_layout = QtWidgets.QGridLayout(sliders_widget)\n    sliders_widget.setLayout(sliders_layout)\n    layout.addWidget(sliders_widget)\n\n    self.scrollbar = QtWidgets.QScrollBar(QtCore.Qt.Horizontal)\n    self.scrollbar.setMinimum(1)\n    self.scrollbar.setMaximum(self.default_range_max_x)\n    self.scrollbar.setSliderPosition(25)\n    self.scrollbar.valueChanged.connect(self.slider_changed)\n    sliders_layout.addWidget(self.scrollbar, 0, 0)\n\n    self.zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=0, maximum=100, value=60)\n    self.zoom.setMinimum(1)\n    self.zoom.setMaximum(self.zoom_max)\n    self.zoom.setValue(1)\n    self.zoom.valueChanged.connect(self.slider_changed)\n    sliders_layout.addWidget(self.zoom, 1, 0)\n\n    self.save_button = QtWidgets.QPushButton()\n    self.save_button.setIcon(QtGui.QIcon.fromTheme(\"document-save\"))\n    self.save_button.setStatusTip(\"Save values\")\n    self.save_button.clicked.connect(self.save_values)\n    sliders_layout.addWidget(self.save_button, 0, 1, 2, 1)\n\n    self.chart = QtCharts.QChart()\n    self.axis_x = QtCharts.QValueAxis(self)\n    self.axis_y = QtCharts.QValueAxis(self)\n    self.chart.addAxis(self.axis_x, QtCore.Qt.AlignBottom)\n    self.chart.addAxis(self.axis_y, QtCore.Qt.AlignLeft)\n\n    self.serie_current = QtCharts.QLineSeries(name=f\"{self.name} Current\")\n    self.chart.addSeries(self.serie_current)\n    self.serie_current.attachAxis(self.axis_x)\n    self.serie_current.attachAxis(self.axis_y)\n    pen = self.serie_current.pen()\n    pen.setWidth(5)\n    self.serie_current.setPen(pen)\n\n    self.serie_order = QtCharts.QLineSeries(name=f\"{self.name} Order\")\n    self.chart.addSeries(self.serie_order)\n    self.serie_order.attachAxis(self.axis_x)\n    self.serie_order.attachAxis(self.axis_y)\n\n    pen = self.serie_order.pen()\n    pen.setWidth(5)\n    self.serie_order.setPen(pen)\n\n    # self.chart.createDefaultAxes()\n\n    self.axis_x.setMin(1)\n    self.axis_x.setTickInterval(1)\n\n    self.axis_y.setMin(1)\n    self.axis_y.setMax(self.default_range_max_y)\n\n    self.chart_view.setChart(self.chart)\n\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView.new_robot_state","title":"<code>new_robot_state(cycle, current, order)</code>","text":"<p>Add a new point on the chart view.</p> <p>Parameters:</p> Name Type Description Default <code>cycle</code> <code>int</code> <p>Current cycle</p> required <code>current</code> <code>float | None</code> <p>Current value</p> required <code>order</code> <code>float | None</code> <p>Order value</p> required Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def new_robot_state(self, cycle: int, current: float | None, order: float | None) -&gt; None:\n    \"\"\"\n    Add a new point on the chart view.\n\n    Arguments:\n        cycle: Current cycle\n        current: Current value\n        order: Order value\n    \"\"\"\n    if self.need_reset:\n        self.need_reset = False\n        self.reset()\n\n    self.range_max_x = max(self.range_max_x, cycle)\n\n    if current:\n        self.serie_current.append(cycle, current)\n        self.range_max_y = max(self.range_max_y, current)\n\n    if order:\n        self.serie_order.append(cycle, order)\n        self.range_max_y = max(self.range_max_y, order)\n\n    self.axis_y.setMax(self.range_max_y)\n\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView.recalculate_range_x","title":"<code>recalculate_range_x()</code>","text":"<p>Given the current zoom and current position of the scrollbar, compute the X min/max range and the slider position.</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def recalculate_range_x(self):\n    \"\"\"\n    Given the current zoom and current position of the scrollbar,\n    compute the X min/max range and the slider position.\n    \"\"\"\n    if self.slider_events_disabled:\n        return\n    self.slider_events_disabled = True\n\n    span = int(self.range_max_x / self.zoom.value())\n    span = span + span % 2\n    scroll_min = span / 2\n    scroll_max = self.range_max_x - span / 2\n\n    scroll = self.scrollbar.value()\n    scroll = max(scroll_min, scroll)\n    scroll = min(scroll_max, scroll)\n\n    self.scrollbar.setMinimum(scroll_min)\n    self.scrollbar.setMaximum(scroll_max)\n    self.scrollbar.setValue(scroll)\n\n    self.axis_x.setMax(self.range_max_x)\n\n    span = int(self.range_max_x / self.zoom.sliderPosition())\n    span = span + span % 2\n\n    x_min = scroll - span / 2\n    x_max = scroll + span / 2\n    self.axis_x.setRange(x_min, x_max)\n\n    self.slider_events_disabled = False\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView.reset","title":"<code>reset()</code>","text":"<p>Reset the chart</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the chart\n    \"\"\"\n    self.serie_current.clear()\n    self.serie_order.clear()\n\n    self.range_max_x = self.default_range_max_x\n    self.range_max_y = self.default_range_max_y\n\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView.save_values","title":"<code>save_values()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a file and save chart values in it.</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>@qtSlot()\ndef save_values(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a file and save chart values in it.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n        parent=self,\n        caption=f\"Select file to save {self.name} values\",\n        dir=\"\",\n        filter=\"CSV Files (*.csv)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        with Path(filename).open(\"w\", newline=\"\") as csv_file:\n            writer = csv.DictWriter(csv_file, fieldnames=[\"cycle\", \"order\", \"current\"])\n            writer.writeheader()\n\n            for order, current in zip(self.serie_order.points(), self.serie_current.points()):\n                writer.writerow({\"cycle\": int(order.x()), \"order\": order.y(), \"current\": current.y()})\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartView.slider_changed","title":"<code>slider_changed(value)</code>","text":"<p>Qt Slot</p> <p>Function called when the scrollbar and zoom has changed.</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>@qtSlot(int)\ndef slider_changed(self, value: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the scrollbar and zoom has changed.\n    \"\"\"\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartsView","title":"<code>ChartsView</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>ChartsView class</p> <p>Build the calibration charts window.</p> <p>Attributes:</p> Name Type Description <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>class ChartsView(QtWidgets.QDialog):\n    \"\"\"ChartsView class\n\n    Build the calibration charts window.\n\n    Attributes:\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    closed: qtSignal = qtSignal()\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.robot_id = 0\n\n        self.setWindowTitle(\"Calibration Charts\")\n        self.setModal(False)\n        self.setMinimumSize(QtCore.QSize(400, 400))\n\n        self.layout = QtWidgets.QGridLayout()\n        self.setLayout(self.layout)\n\n        self.linear_speed_chart = ChartView(self, \"Linear Speed\")\n        self.angular_speed_chart = ChartView(self, \"Angular Speed\")\n        self.layout.addWidget(self.linear_speed_chart, 0, 0)\n        self.layout.addWidget(self.angular_speed_chart, 1, 0)\n\n        reset_button = QtWidgets.QPushButton(\"Reset\")\n        self.layout.addWidget(reset_button)\n        reset_button.clicked.connect(self.reset)\n\n        self.readSettings()\n\n    def reset(self):\n        \"\"\"\n        Reset charts.\n        \"\"\"\n        self.linear_speed_chart.reset()\n        self.angular_speed_chart.reset()\n\n    def set_robot_id(self, robot_id: int) -&gt; None:\n        self.robot_id = robot_id\n        self.setWindowTitle(f\"Calibration Charts for Robot {robot_id}\")\n        self.readSettings()\n\n    @qtSlot(RobotState)\n    def new_robot_state(self, state: RobotState) -&gt; None:\n        \"\"\"\n        Qt Slot\n\n        Send robot data to corresponding charts\n\n        Arguments:\n            state: New robot state\n        \"\"\"\n        self.linear_speed_chart.new_robot_state(\n            state.cycle,\n            state.speed_current.distance,\n            state.speed_order.distance,\n        )\n        self.angular_speed_chart.new_robot_state(\n            state.cycle,\n            state.speed_current.angle,\n            state.speed_order.angle,\n        )\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(f\"chartsview/geometry/{self.robot_id}\", self.saveGeometry())\n\n        self.closed.emit()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(f\"chartsview/geometry/{self.robot_id}\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartsView.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget | None</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.robot_id = 0\n\n    self.setWindowTitle(\"Calibration Charts\")\n    self.setModal(False)\n    self.setMinimumSize(QtCore.QSize(400, 400))\n\n    self.layout = QtWidgets.QGridLayout()\n    self.setLayout(self.layout)\n\n    self.linear_speed_chart = ChartView(self, \"Linear Speed\")\n    self.angular_speed_chart = ChartView(self, \"Angular Speed\")\n    self.layout.addWidget(self.linear_speed_chart, 0, 0)\n    self.layout.addWidget(self.angular_speed_chart, 1, 0)\n\n    reset_button = QtWidgets.QPushButton(\"Reset\")\n    self.layout.addWidget(reset_button)\n    reset_button.clicked.connect(self.reset)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartsView.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(f\"chartsview/geometry/{self.robot_id}\", self.saveGeometry())\n\n    self.closed.emit()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartsView.new_robot_state","title":"<code>new_robot_state(state)</code>","text":"<p>Qt Slot</p> <p>Send robot data to corresponding charts</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>RobotState</code> <p>New robot state</p> required Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>@qtSlot(RobotState)\ndef new_robot_state(self, state: RobotState) -&gt; None:\n    \"\"\"\n    Qt Slot\n\n    Send robot data to corresponding charts\n\n    Arguments:\n        state: New robot state\n    \"\"\"\n    self.linear_speed_chart.new_robot_state(\n        state.cycle,\n        state.speed_current.distance,\n        state.speed_order.distance,\n    )\n    self.angular_speed_chart.new_robot_state(\n        state.cycle,\n        state.speed_current.angle,\n        state.speed_order.angle,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/monitor/chartsview/#cogip.tools.monitor.chartsview.ChartsView.reset","title":"<code>reset()</code>","text":"<p>Reset charts.</p> Source code in <code>cogip/tools/monitor/chartsview.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset charts.\n    \"\"\"\n    self.linear_speed_chart.reset()\n    self.angular_speed_chart.reset()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/","title":"dynobstacle","text":""},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynBaseObstacleEntity","title":"<code>DynBaseObstacleEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A dynamic obstacle detected by the robot.</p> <p>Base class for rectangle and circle obstacles.</p> Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>class DynBaseObstacleEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A dynamic obstacle detected by the robot.\n\n    Base class for rectangle and circle obstacles.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n        self.points: list[models.Vertex] = []\n\n        self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n        self.material.setDiffuse(QtGui.QColor.fromRgb(255, 50, 50, 100))\n        self.material.setSpecular(QtGui.QColor.fromRgb(255, 50, 50, 100))\n        self.material.setShininess(1.0)\n        self.material.setAlphaBlendingEnabled(True)\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.addComponent(self.transform)\n\n        self.bb = PathEntity(QtGui.QColor(255, 182, 193), self.parent)\n\n    def set_bounding_box(self, points: SharedCoordsList) -&gt; None:\n        new_points = [models.Vertex(x=point.x, y=point.y, z=5) for point in points]\n\n        if self.points == new_points:\n            return\n\n        self.points = new_points\n        self.bb.set_points(new_points)\n\n    def setEnabled(self, isEnabled: bool) -&gt; None:\n        super().setEnabled(isEnabled)\n        self.bb.setEnabled(isEnabled)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynBaseObstacleEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n    self.points: list[models.Vertex] = []\n\n    self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n    self.material.setDiffuse(QtGui.QColor.fromRgb(255, 50, 50, 100))\n    self.material.setSpecular(QtGui.QColor.fromRgb(255, 50, 50, 100))\n    self.material.setShininess(1.0)\n    self.material.setAlphaBlendingEnabled(True)\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.addComponent(self.transform)\n\n    self.bb = PathEntity(QtGui.QColor(255, 182, 193), self.parent)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynCircleObstacleEntity","title":"<code>DynCircleObstacleEntity</code>","text":"<p>               Bases: <code>DynBaseObstacleEntity</code></p> <p>A dynamic circle obstacle detected by the robot.</p> <p>Represented as a transparent red cylinder.</p> Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>class DynCircleObstacleEntity(DynBaseObstacleEntity):\n    \"\"\"\n    A dynamic circle obstacle detected by the robot.\n\n    Represented as a transparent red cylinder.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.position: tuple[int, int, int] = None\n\n        self.mesh = Qt3DExtras.QCylinderMesh()\n        self.mesh.setLength(200)\n        self.mesh.setRadius(400)\n        self.addComponent(self.mesh)\n\n        self.transform.setRotationX(90)\n\n    def set_position(self, x: int, y: int, radius: int) -&gt; None:\n        \"\"\"\n        Set the position and size of the dynamic obstacle.\n\n        Arguments:\n            x: Center X position\n            y: Center Y position\n            radius: Obstacle radius\n        \"\"\"\n        if self.position == (x, y, radius):\n            return\n        self.position = (x, y, radius)\n\n        self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.length() / 2))\n        self.mesh.setRadius(radius)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynCircleObstacleEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.position: tuple[int, int, int] = None\n\n    self.mesh = Qt3DExtras.QCylinderMesh()\n    self.mesh.setLength(200)\n    self.mesh.setRadius(400)\n    self.addComponent(self.mesh)\n\n    self.transform.setRotationX(90)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynCircleObstacleEntity.set_position","title":"<code>set_position(x, y, radius)</code>","text":"<p>Set the position and size of the dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Center X position</p> required <code>y</code> <code>int</code> <p>Center Y position</p> required <code>radius</code> <code>int</code> <p>Obstacle radius</p> required Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>def set_position(self, x: int, y: int, radius: int) -&gt; None:\n    \"\"\"\n    Set the position and size of the dynamic obstacle.\n\n    Arguments:\n        x: Center X position\n        y: Center Y position\n        radius: Obstacle radius\n    \"\"\"\n    if self.position == (x, y, radius):\n        return\n    self.position = (x, y, radius)\n\n    self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.length() / 2))\n    self.mesh.setRadius(radius)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynRectObstacleEntity","title":"<code>DynRectObstacleEntity</code>","text":"<p>               Bases: <code>DynBaseObstacleEntity</code></p> <p>A dynamic rectangle obstacle detected by the robot.</p> <p>Represented as a transparent red cube.</p> Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>class DynRectObstacleEntity(DynBaseObstacleEntity):\n    \"\"\"\n    A dynamic rectangle obstacle detected by the robot.\n\n    Represented as a transparent red cube.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.size: tuple[int, int] = None\n        self.position: tuple[int, int, int] = None\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setZExtent(200)\n        self.addComponent(self.mesh)\n\n    def set_size(self, length: int, width: int) -&gt; None:\n        \"\"\"\n        Set the size of the dynamic obstacle.\n\n        Arguments:\n            length: Length\n            width: Width\n        \"\"\"\n        if self.size == (length, width):\n            return\n\n        self.size = (length, width)\n\n        self.mesh.setXExtent(width)\n        self.mesh.setYExtent(length)\n\n    def set_position(self, x: int, y: int, rotation: int) -&gt; None:\n        \"\"\"\n        Set the position and orientation of the dynamic obstacle.\n\n        Arguments:\n            x: X position\n            y: Y position\n            rotation: Rotation\n        \"\"\"\n        if self.position == (x, y, rotation):\n            return\n\n        self.position = (x, y, rotation)\n\n        self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n        self.transform.setRotationZ(rotation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynRectObstacleEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.size: tuple[int, int] = None\n    self.position: tuple[int, int, int] = None\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setZExtent(200)\n    self.addComponent(self.mesh)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynRectObstacleEntity.set_position","title":"<code>set_position(x, y, rotation)</code>","text":"<p>Set the position and orientation of the dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X position</p> required <code>y</code> <code>int</code> <p>Y position</p> required <code>rotation</code> <code>int</code> <p>Rotation</p> required Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>def set_position(self, x: int, y: int, rotation: int) -&gt; None:\n    \"\"\"\n    Set the position and orientation of the dynamic obstacle.\n\n    Arguments:\n        x: X position\n        y: Y position\n        rotation: Rotation\n    \"\"\"\n    if self.position == (x, y, rotation):\n        return\n\n    self.position = (x, y, rotation)\n\n    self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n    self.transform.setRotationZ(rotation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/dynobstacle/#cogip.tools.monitor.dynobstacle.DynRectObstacleEntity.set_size","title":"<code>set_size(length, width)</code>","text":"<p>Set the size of the dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length</p> required <code>width</code> <code>int</code> <p>Width</p> required Source code in <code>cogip/tools/monitor/dynobstacle.py</code> <pre><code>def set_size(self, length: int, width: int) -&gt; None:\n    \"\"\"\n    Set the size of the dynamic obstacle.\n\n    Arguments:\n        length: Length\n        width: Width\n    \"\"\"\n    if self.size == (length, width):\n        return\n\n    self.size = (length, width)\n\n    self.mesh.setXExtent(width)\n    self.mesh.setYExtent(length)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/","title":"gameview","text":""},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.EventFilter","title":"<code>EventFilter</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Event filter registered on the 3D Window.</p> <p>Filter all mouse and keyboard events related to moving the scene in front of the camera.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>class EventFilter(QtCore.QObject):\n    \"\"\"\n    Event filter registered on the 3D Window.\n\n    Filter all mouse and keyboard events related to moving the scene\n    in front of the camera.\n    \"\"\"\n\n    def __init__(self, parent: \"GameView\"):\n        \"\"\"\n        Class constructor\n        \"\"\"\n        super().__init__(parent)\n        self.game_view = parent\n        self._last_mouse_pos = None\n\n    def eventFilter(self, source, event) -&gt; bool:\n        \"\"\"\n        Required event filter function.\n        \"\"\"\n        if isinstance(event, QtGui.QKeyEvent):\n            key: QtCore.Qt.Key = event.key()\n            modifiers: QtCore.Qt.KeyboardModifiers = event.modifiers()\n\n            if modifiers == QtCore.Qt.NoModifier:\n                if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                    self.game_view.translate(-10, 0, 0)\n                elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                    self.game_view.translate(10, 0, 0)\n                elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                    self.game_view.translate(0, -10, 0)\n                elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                    self.game_view.translate(0, 10, 0)\n                elif key == QtCore.Qt.Key_Space:\n                    self.game_view.top_view()\n                elif key == QtCore.Qt.Key_Return:\n                    self.game_view.default_view()\n                else:\n                    return False\n                return True\n\n            elif modifiers == QtCore.Qt.ShiftModifier:\n                if key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                    self.game_view.rotate(-1, 0, 0)\n                elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                    self.game_view.rotate(1, 0, 0)\n                elif key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                    self.game_view.rotate(0, -1, 0)\n                elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                    self.game_view.rotate(0, 1, 0)\n                else:\n                    return False\n                return True\n\n            elif modifiers == QtCore.Qt.ControlModifier:\n                if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                    self.game_view.rotate(0, 0, -1)\n                elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                    self.game_view.rotate(0, 0, 1)\n                elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                    self.game_view.translate(0, 0, -20)\n                elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                    self.game_view.translate(0, 0, 20)\n                else:\n                    return False\n\n            else:\n                return False\n\n        elif isinstance(event, QtGui.QWheelEvent):\n            self.game_view.translate(0, 0, event.angleDelta().y() / 5)\n\n        elif isinstance(event, QtGui.QMouseEvent):\n            new_pos = event.globalPosition().toPoint()\n            if not self._last_mouse_pos:\n                self._last_mouse_pos = new_pos\n            new_pos = event.globalPosition().toPoint()\n            delta = new_pos - self._last_mouse_pos\n            self._last_mouse_pos = new_pos\n\n            if event.type() == QtCore.QEvent.MouseMove:\n                if event.buttons() == QtCore.Qt.MouseButton.MiddleButton:\n                    self.game_view.rotate(0, 0, (delta.x() + delta.y()) / 2)\n                elif event.buttons() == QtCore.Qt.MouseButton.RightButton:\n                    self.game_view.rotate(delta.y(), delta.x(), 0)\n                else:\n                    return False\n            else:\n                return False\n        else:\n            return False\n\n        return True\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.EventFilter.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def __init__(self, parent: \"GameView\"):\n    \"\"\"\n    Class constructor\n    \"\"\"\n    super().__init__(parent)\n    self.game_view = parent\n    self._last_mouse_pos = None\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.EventFilter.eventFilter","title":"<code>eventFilter(source, event)</code>","text":"<p>Required event filter function.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def eventFilter(self, source, event) -&gt; bool:\n    \"\"\"\n    Required event filter function.\n    \"\"\"\n    if isinstance(event, QtGui.QKeyEvent):\n        key: QtCore.Qt.Key = event.key()\n        modifiers: QtCore.Qt.KeyboardModifiers = event.modifiers()\n\n        if modifiers == QtCore.Qt.NoModifier:\n            if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                self.game_view.translate(-10, 0, 0)\n            elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                self.game_view.translate(10, 0, 0)\n            elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                self.game_view.translate(0, -10, 0)\n            elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                self.game_view.translate(0, 10, 0)\n            elif key == QtCore.Qt.Key_Space:\n                self.game_view.top_view()\n            elif key == QtCore.Qt.Key_Return:\n                self.game_view.default_view()\n            else:\n                return False\n            return True\n\n        elif modifiers == QtCore.Qt.ShiftModifier:\n            if key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                self.game_view.rotate(-1, 0, 0)\n            elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                self.game_view.rotate(1, 0, 0)\n            elif key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                self.game_view.rotate(0, -1, 0)\n            elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                self.game_view.rotate(0, 1, 0)\n            else:\n                return False\n            return True\n\n        elif modifiers == QtCore.Qt.ControlModifier:\n            if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                self.game_view.rotate(0, 0, -1)\n            elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                self.game_view.rotate(0, 0, 1)\n            elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                self.game_view.translate(0, 0, -20)\n            elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                self.game_view.translate(0, 0, 20)\n            else:\n                return False\n\n        else:\n            return False\n\n    elif isinstance(event, QtGui.QWheelEvent):\n        self.game_view.translate(0, 0, event.angleDelta().y() / 5)\n\n    elif isinstance(event, QtGui.QMouseEvent):\n        new_pos = event.globalPosition().toPoint()\n        if not self._last_mouse_pos:\n            self._last_mouse_pos = new_pos\n        new_pos = event.globalPosition().toPoint()\n        delta = new_pos - self._last_mouse_pos\n        self._last_mouse_pos = new_pos\n\n        if event.type() == QtCore.QEvent.MouseMove:\n            if event.buttons() == QtCore.Qt.MouseButton.MiddleButton:\n                self.game_view.rotate(0, 0, (delta.x() + delta.y()) / 2)\n            elif event.buttons() == QtCore.Qt.MouseButton.RightButton:\n                self.game_view.rotate(delta.y(), delta.x(), 0)\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView","title":"<code>GameView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>The <code>GameView</code> class is a <code>QWidget</code> containing a <code>Qt3DWindow</code> used to display all the game element, like table, robot and obstacles.</p> <p>It also contains an horizontal plane entity with a invisible <code>QPlaneMesh</code>. This plane is has a <code>QObjectPicker</code> to detect mouse clicks, to help grabbing and moving entities on the horizontal plane.</p> <p>Attributes:</p> Name Type Description <code>ground_image</code> <code>Path</code> <p>image to display on the table floor</p> <code>obstacle_entities</code> <code>list[ObstacleEntity]</code> <p>List of obstacles</p> <code>plane_intersection</code> <code>QVector3D</code> <p>last active intersection of plane picker in world coordinates</p> <code>mouse_enabled</code> <code>bool</code> <p>True to authorize translation and rotation of the scene using the mouse, False when an other object (obstacle, manual robot, ...) is picked.</p> <code>new_move_delta</code> <code>Signal</code> <p>signal emitted to movable entities when a mouse drag is detected</p> <code>signal_update_shared_obstacles</code> <code>Signal</code> <p>signal emitted with new obstacle positions</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>class GameView(QtWidgets.QWidget):\n    \"\"\"\n    The `GameView` class is a [`QWidget`](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QWidget.html)\n    containing a [`Qt3DWindow`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/Qt3DWindow.html)\n    used to display all the game element, like table, robot and obstacles.\n\n    It also contains an horizontal plane entity with a invisible\n    [`QPlaneMesh`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/QPlaneMesh.html).\n    This plane is has a [`QObjectPicker`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DRender/QObjectPicker.html)\n    to detect mouse clicks, to help grabbing and moving entities on the horizontal plane.\n\n    Attributes:\n        ground_image: image to display on the table floor\n        obstacle_entities: List of obstacles\n        plane_intersection: last active intersection of plane picker in world coordinates\n        mouse_enabled: True to authorize translation and rotation of the scene using the mouse,\n            False when an other object (obstacle, manual robot, ...) is picked.\n        new_move_delta: signal emitted to movable entities when a mouse drag is detected\n        signal_update_shared_obstacles: signal emitted with new obstacle positions\n    \"\"\"\n\n    ground_image: Path = Path(\"assets/table2025.webp\")\n    obstacle_entities: list[ObstacleEntity] = []\n    plane_intersection: QtGui.QVector3D = None\n    mouse_enabled: bool = True\n    new_move_delta: qtSignal = qtSignal(QtGui.QVector3D)\n    signal_update_shared_obstacles: qtSignal = qtSignal(list)\n\n    def __init__(self):\n        \"\"\"\n        Create all entities required in the view:\n\n          - the `Qt3DWindow` to display the scene\n          - the camera and all controls to move the scene in front of the camera\n          - the lights to have a good lightning of the scene\n          - the plane entity to help moving obstacles\n        \"\"\"\n        super().__init__()\n\n        # Create the 3D window and set it as the widget layout\n        self.view = Qt3DExtras.Qt3DWindow()\n        self.view.installEventFilter(EventFilter(self))\n        self.container = self.createWindowContainer(self.view)\n        self.container.setMinimumSize(QtCore.QSize(400, 400))\n        self.container.setFocusPolicy(QtCore.Qt.NoFocus)\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(self.container)\n        self.setLayout(layout)\n\n        picking_settings = self.view.renderSettings().pickingSettings()\n        picking_settings.setPickMethod(Qt3DRender.QPickingSettings.TrianglePicking)\n        picking_settings.setPickResultMode(Qt3DRender.QPickingSettings.AllPicks)\n\n        # Create root entity\n        self.root_entity = Qt3DCore.QEntity()\n        self.view.setRootEntity(self.root_entity)\n\n        self.root_transform = Qt3DCore.QTransform()\n        self.root_entity.addComponent(self.root_transform)\n        self.default_view()\n\n        # Create an object picker to catch mouse clicks on root entity\n        self.root_picker = Qt3DRender.QObjectPicker()\n        self.root_picker.setDragEnabled(True)\n        self.root_picker.pressed.connect(self.pressed)\n        self.root_picker.moved.connect(self.moved)\n        self.root_entity.addComponent(self.root_picker)\n\n        # Create scene entity\n        self.scene_entity = Qt3DCore.QEntity(self.root_entity)\n\n        self.scene_transform = Qt3DCore.QTransform()\n        self.scene_entity.addComponent(self.scene_transform)\n        self.scene_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n        self.scene_transform.setRotationZ(180)\n\n        # Draw axis\n        self.x_axis = LineEntity(QtCore.Qt.red, self.scene_entity)\n        self.x_axis.set_points(\n            models.Vertex(x=0, y=0, z=0),\n            models.Vertex(x=5000, y=0, z=0),\n        )\n\n        self.y_axis = LineEntity(QtCore.Qt.green, self.scene_entity)\n        self.y_axis.set_points(\n            models.Vertex(x=0, y=0, z=0),\n            models.Vertex(x=0, y=5000, z=0),\n        )\n\n        self.z_axis = LineEntity(QtCore.Qt.blue, self.scene_entity)\n        self.z_axis.set_points(\n            models.Vertex(x=0, y=0, z=0),\n            models.Vertex(x=0, y=0, z=5000),\n        )\n\n        # Add robot path entity\n        self.path = PathEntity(parent=self.scene_entity)\n\n        # Init Camera\n        self.camera_entity: Qt3DRender.QCamera = self.view.camera()\n        self.camera_entity.lens().setPerspectiveProjection(45.0, 16.0 / 9.0, 0.1, 10000.0)\n        self.camera_entity.setUpVector(QtGui.QVector3D(0, 0, 1))\n        self.camera_entity.setPosition(QtGui.QVector3D(0, 0, 10))\n        self.camera_entity.setViewCenter(QtGui.QVector3D(0, 0, 0))\n\n        # Create lights\n        self.light_entity = create_light_entity(self.root_entity, 5000, 5000, 5000)\n        self.light_entity2 = create_light_entity(self.root_entity, 5000, -5000, 5000)\n\n        # Create object picker\n        self.create_object_picker()\n\n        # Add image on table floor\n        self.add_ground_image()\n\n        self.start_time = timeit.default_timer()\n\n        self.tribunes: dict[TribuneID, TribuneEntity] = {}\n        for id, tribune in tribune_positions.items():\n            self.tribunes[id] = TribuneEntity(self.scene_entity, tribune)\n\n    def enable_mouse(self, enable: bool) -&gt; None:\n        self.mouse_enabled = enable\n\n    def translate(self, x: int, y: int, z: int) -&gt; None:\n        self.root_transform.setTranslation(\n            QtGui.QVector3D(\n                max(-1500, min(1500, self.root_transform.translation().x() + x)),\n                max(-1000, min(1000, self.root_transform.translation().y() + y)),\n                max(-5000, min(-10, self.root_transform.translation().z() + z)),\n            )\n        )\n\n    def rotate(self, x: int, y: int, z: int) -&gt; None:\n        (self.root_transform.setRotationX((self.root_transform.rotationX() + x) % 360),)\n        (self.root_transform.setRotationY((self.root_transform.rotationY() + y) % 360),)\n        self.root_transform.setRotationZ((self.root_transform.rotationZ() - z) % 360)\n\n    def top_view(self) -&gt; None:\n        (self.root_transform.setRotationX(0),)\n        (self.root_transform.setRotationY(0),)\n        self.root_transform.setRotationZ(-90)\n        self.root_transform.setTranslation(QtGui.QVector3D(0, 0, -3500))\n\n    def default_view(self) -&gt; None:\n        self.root_transform.setRotationX(-45)\n        self.root_transform.setRotationY(0)\n        self.root_transform.setRotationZ(-45)\n        self.root_transform.setTranslation(QtGui.QVector3D(100, 400, -3500))\n\n    def add_asset(self, asset: AssetEntity) -&gt; None:\n        \"\"\"\n        Add an asset (like [TableEntity][cogip.tools.monitor.asset.AssetEntity]\n        or [RobotEntity][cogip.tools.monitor.robot.RobotEntity]) in the 3D view.\n\n        Argument:\n            asset: The asset entity to add to the vew\n        \"\"\"\n        asset.setParent(self.scene_entity)\n        asset.ready.connect(self.asset_ready)\n\n    def add_obstacle(self, x: int = 0, y: int = 0, rotation: int = 0, **kwargs) -&gt; ObstacleEntity:\n        \"\"\"\n        Create a new obstacle in the 3D view.\n\n        Arguments:\n            x: X position\n            y: Y position\n            rotation: Rotation\n\n        Return:\n            The obstacle entity\n        \"\"\"\n        obstacle_entity = ObstacleEntity(self.container, x, y, rotation, **kwargs)\n        obstacle_entity.setParent(self.scene_entity)\n        self.obstacle_entities.append(obstacle_entity)\n        obstacle_entity.enable_controller.connect(self.enable_mouse)\n        obstacle_entity.obstacle_moved.connect(self.update_shared_obstacles)\n        self.new_move_delta.connect(obstacle_entity.new_move_delta)\n        self.update_shared_obstacles()\n        return obstacle_entity\n\n    def update_shared_obstacles(self):\n        \"\"\"\n        Emit position of all obstacles.\n        \"\"\"\n        obstacles: list[models.Vertex] = []\n        for obstacle in self.obstacle_entities:\n            obstacles.append(\n                models.Vertex(\n                    x=obstacle.transform.translation().x(),\n                    y=obstacle.transform.translation().y(),\n                )\n            )\n        self.signal_update_shared_obstacles.emit(obstacles)\n\n    def load_obstacles(self, filename: Path):\n        \"\"\"\n        Load obstacles from a JSON file.\n\n        Arguments:\n            filename: path of the JSON file\n        \"\"\"\n        try:\n            obstacle_models = TypeAdapter(models.ObstacleList).validate_json(filename.read_text())\n            for obstacle_model in obstacle_models:\n                self.add_obstacle(**obstacle_model.model_dump())\n        except ValidationError as exc:\n            print(exc)\n\n    def save_obstacles(self, filename: Path):\n        \"\"\"\n        Save obstacles to a JSON file.\n\n        Arguments:\n            filename: path of the JSON file\n        \"\"\"\n        obstacle_models = []\n        for obstacle_entity in self.obstacle_entities:\n            obstacle_models.append(obstacle_entity.get_model())\n        with filename.open(\"w\") as fd:\n            fd.write(json.dumps(obstacle_models, default=pydantic_encoder, indent=2))\n\n    def asset_ready(self):\n        \"\"\"\n        Create artifacts when all assets are ready (loading assets is done in background).\n        \"\"\"\n        child_assets_not_ready = [\n            child for child in self.scene_entity.findChildren(AssetEntity) if not child.asset_ready\n        ]\n        if len(child_assets_not_ready) == 0:\n            self.robot_manual = RobotManualEntity(self.scene_entity, self.container)\n            self.robot_manual.enable_controller.connect(self.enable_mouse)\n            self.new_move_delta.connect(self.robot_manual.new_move_delta)\n            self.pami_manual = RobotManualEntity(self.scene_entity, self.container, robot_id=2, y=-1200)\n            self.pami_manual.enable_controller.connect(self.enable_mouse)\n            self.new_move_delta.connect(self.pami_manual.new_move_delta)\n\n            print(f\"Load time of assets: {timeit.default_timer() - self.start_time:0.3f}s\")\n\n    def plane_pressed(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Record the intersection between the mouse pointer and the plane entity,\n        on the `pressed` mouse event, in world coordinate.\n        \"\"\"\n        if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n            return\n\n        self.plane_intersection = pick.worldIntersection()\n\n    def plane_moved(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Compute the translation on the plane entity between the\n        current `moved` mouse event and the previous one.\n\n        Emit the `new_move_delta` signal to update the corresponding asset's position.\n        \"\"\"\n        if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n            return\n\n        new_intersection = pick.worldIntersection()\n        delta: QtGui.QVector3D = new_intersection - self.plane_intersection\n        delta.setZ(0)\n        rot_z = self.root_transform.rotationZ()\n        delta = QtGui.QVector3D(\n            -delta.x() * math.cos(math.radians(rot_z)) - delta.y() * math.sin(math.radians(rot_z)),\n            -delta.y() * math.cos(math.radians(rot_z)) + delta.x() * math.sin(math.radians(rot_z)),\n            0,\n        )\n        self.new_move_delta.emit(delta)\n        self.plane_intersection = new_intersection\n\n    def plane_released(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Emit the `new_move_delta` signal with `None` argument,\n        on `released` mouse event, to notify that mouse button was released\n        and no further moves will happen until next `pressed` mouse event.\n        \"\"\"\n        self.plane_intersection = None\n        self.new_move_delta.emit(None)\n\n    def new_robot_path(self, robot_id: int, new_path: list[models.Vertex]) -&gt; None:\n        \"\"\"\n        Function called when robot path is updated.\n\n        Arguments:\n            robot_id: ID of the robot\n            new_path: new robot path\n        \"\"\"\n        for vertex in new_path:\n            vertex.z = 20\n        self.path.set_points(new_path)\n\n    def pressed(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Function called on a ```pressed``` mouse event on the artifact.\n\n        Emit a signal to disable the camera controller before moving the artifact.\n        \"\"\"\n        self.last_mouse_pos = pick.worldIntersection()\n\n    def moved(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Function called on a ```moved``` mouse event on the artifact.\n\n        Just record that the artifact is moving, the translation is computed\n        in the [GameView][cogip.tools.monitor.gameview.GameView] object.\n        \"\"\"\n\n        if not self.mouse_enabled:\n            return\n\n        new_pos = pick.worldIntersection()\n        delta = new_pos - self.last_mouse_pos\n        self.last_mouse_pos = new_pos\n\n        if pick.buttons() == QtCore.Qt.MouseButton.LeftButton.value:\n            self.translate(delta.x(), delta.y(), 0)\n\n    def create_object_picker(self):\n        \"\"\"\n        Add a plane mesh with object picker to help moving objects with mouse drag and drop.\n        \"\"\"\n        self.plane_entity = Qt3DCore.QEntity(self.scene_entity)\n\n        plane_mesh = Qt3DExtras.QPlaneMesh(self.plane_entity)\n        plane_mesh.setHeight(8000)\n        plane_mesh.setWidth(10000)\n        self.plane_entity.addComponent(plane_mesh)\n\n        plane_transform = Qt3DCore.QTransform(self.plane_entity)\n        plane_transform.setTranslation(QtGui.QVector3D(0, 1000, 0))\n        plane_transform.setRotationX(90)\n        self.plane_entity.addComponent(plane_transform)\n\n        plane_picker = Qt3DRender.QObjectPicker(self.plane_entity)\n        plane_picker.setDragEnabled(True)\n        plane_picker.pressed.connect(self.plane_pressed)\n        plane_picker.released.connect(self.plane_released)\n        plane_picker.moved.connect(self.plane_moved)\n        self.plane_entity.addComponent(plane_picker)\n\n    def add_ground_image(self) -&gt; None:\n        \"\"\"\n        Add a plane to display the ground image\n        \"\"\"\n        self.ground_entity = Qt3DCore.QEntity(self.scene_entity)\n\n        ground_mesh = Qt3DExtras.QPlaneMesh(self.ground_entity)\n        ground_mesh.setHeight(3000)\n        ground_mesh.setWidth(2000)\n        self.ground_entity.addComponent(ground_mesh)\n\n        ground_material = Qt3DExtras.QTextureMaterial(self.ground_entity)\n\n        ground_texture = Qt3DRender.QTexture2D(ground_material)\n        ground_texture_image = Qt3DRender.QTextureImage(ground_texture)\n        ground_texture_image.setSource(QtCore.QUrl(f\"file:{self.ground_image}\"))\n        ground_texture_image.setMirrored(False)\n        ground_texture.addTextureImage(ground_texture_image)\n        ground_material.setTexture(ground_texture)\n        self.ground_entity.addComponent(ground_material)\n\n        ground_transform = Qt3DCore.QTransform(self.ground_entity)\n        ground_transform.setRotationX(90)\n        ground_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n        self.ground_entity.addComponent(ground_transform)\n\n    def get_camera_params(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Return current camera parameters to save them for next session.\n        \"\"\"\n        return {\n            \"translation\": self.root_transform.translation().toTuple(),\n            \"rotation\": [\n                self.root_transform.rotationX(),\n                self.root_transform.rotationY(),\n                self.root_transform.rotationZ(),\n            ],\n        }\n\n    def set_camera_params(self, camera_params: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set camera parameters to restore them from previous session.\n        \"\"\"\n        self.root_transform.setTranslation(QtGui.QVector3D(*camera_params[\"translation\"]))\n        self.root_transform.setRotationX(camera_params[\"rotation\"][0])\n        self.root_transform.setRotationY(camera_params[\"rotation\"][1])\n        self.root_transform.setRotationZ(camera_params[\"rotation\"][2])\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.__init__","title":"<code>__init__()</code>","text":"<p>Create all entities required in the view:</p> <ul> <li>the <code>Qt3DWindow</code> to display the scene</li> <li>the camera and all controls to move the scene in front of the camera</li> <li>the lights to have a good lightning of the scene</li> <li>the plane entity to help moving obstacles</li> </ul> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create all entities required in the view:\n\n      - the `Qt3DWindow` to display the scene\n      - the camera and all controls to move the scene in front of the camera\n      - the lights to have a good lightning of the scene\n      - the plane entity to help moving obstacles\n    \"\"\"\n    super().__init__()\n\n    # Create the 3D window and set it as the widget layout\n    self.view = Qt3DExtras.Qt3DWindow()\n    self.view.installEventFilter(EventFilter(self))\n    self.container = self.createWindowContainer(self.view)\n    self.container.setMinimumSize(QtCore.QSize(400, 400))\n    self.container.setFocusPolicy(QtCore.Qt.NoFocus)\n    layout = QtWidgets.QHBoxLayout()\n    layout.addWidget(self.container)\n    self.setLayout(layout)\n\n    picking_settings = self.view.renderSettings().pickingSettings()\n    picking_settings.setPickMethod(Qt3DRender.QPickingSettings.TrianglePicking)\n    picking_settings.setPickResultMode(Qt3DRender.QPickingSettings.AllPicks)\n\n    # Create root entity\n    self.root_entity = Qt3DCore.QEntity()\n    self.view.setRootEntity(self.root_entity)\n\n    self.root_transform = Qt3DCore.QTransform()\n    self.root_entity.addComponent(self.root_transform)\n    self.default_view()\n\n    # Create an object picker to catch mouse clicks on root entity\n    self.root_picker = Qt3DRender.QObjectPicker()\n    self.root_picker.setDragEnabled(True)\n    self.root_picker.pressed.connect(self.pressed)\n    self.root_picker.moved.connect(self.moved)\n    self.root_entity.addComponent(self.root_picker)\n\n    # Create scene entity\n    self.scene_entity = Qt3DCore.QEntity(self.root_entity)\n\n    self.scene_transform = Qt3DCore.QTransform()\n    self.scene_entity.addComponent(self.scene_transform)\n    self.scene_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n    self.scene_transform.setRotationZ(180)\n\n    # Draw axis\n    self.x_axis = LineEntity(QtCore.Qt.red, self.scene_entity)\n    self.x_axis.set_points(\n        models.Vertex(x=0, y=0, z=0),\n        models.Vertex(x=5000, y=0, z=0),\n    )\n\n    self.y_axis = LineEntity(QtCore.Qt.green, self.scene_entity)\n    self.y_axis.set_points(\n        models.Vertex(x=0, y=0, z=0),\n        models.Vertex(x=0, y=5000, z=0),\n    )\n\n    self.z_axis = LineEntity(QtCore.Qt.blue, self.scene_entity)\n    self.z_axis.set_points(\n        models.Vertex(x=0, y=0, z=0),\n        models.Vertex(x=0, y=0, z=5000),\n    )\n\n    # Add robot path entity\n    self.path = PathEntity(parent=self.scene_entity)\n\n    # Init Camera\n    self.camera_entity: Qt3DRender.QCamera = self.view.camera()\n    self.camera_entity.lens().setPerspectiveProjection(45.0, 16.0 / 9.0, 0.1, 10000.0)\n    self.camera_entity.setUpVector(QtGui.QVector3D(0, 0, 1))\n    self.camera_entity.setPosition(QtGui.QVector3D(0, 0, 10))\n    self.camera_entity.setViewCenter(QtGui.QVector3D(0, 0, 0))\n\n    # Create lights\n    self.light_entity = create_light_entity(self.root_entity, 5000, 5000, 5000)\n    self.light_entity2 = create_light_entity(self.root_entity, 5000, -5000, 5000)\n\n    # Create object picker\n    self.create_object_picker()\n\n    # Add image on table floor\n    self.add_ground_image()\n\n    self.start_time = timeit.default_timer()\n\n    self.tribunes: dict[TribuneID, TribuneEntity] = {}\n    for id, tribune in tribune_positions.items():\n        self.tribunes[id] = TribuneEntity(self.scene_entity, tribune)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.add_asset","title":"<code>add_asset(asset)</code>","text":"<p>Add an asset (like TableEntity or RobotEntity) in the 3D view.</p> Argument <p>asset: The asset entity to add to the vew</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def add_asset(self, asset: AssetEntity) -&gt; None:\n    \"\"\"\n    Add an asset (like [TableEntity][cogip.tools.monitor.asset.AssetEntity]\n    or [RobotEntity][cogip.tools.monitor.robot.RobotEntity]) in the 3D view.\n\n    Argument:\n        asset: The asset entity to add to the vew\n    \"\"\"\n    asset.setParent(self.scene_entity)\n    asset.ready.connect(self.asset_ready)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.add_ground_image","title":"<code>add_ground_image()</code>","text":"<p>Add a plane to display the ground image</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def add_ground_image(self) -&gt; None:\n    \"\"\"\n    Add a plane to display the ground image\n    \"\"\"\n    self.ground_entity = Qt3DCore.QEntity(self.scene_entity)\n\n    ground_mesh = Qt3DExtras.QPlaneMesh(self.ground_entity)\n    ground_mesh.setHeight(3000)\n    ground_mesh.setWidth(2000)\n    self.ground_entity.addComponent(ground_mesh)\n\n    ground_material = Qt3DExtras.QTextureMaterial(self.ground_entity)\n\n    ground_texture = Qt3DRender.QTexture2D(ground_material)\n    ground_texture_image = Qt3DRender.QTextureImage(ground_texture)\n    ground_texture_image.setSource(QtCore.QUrl(f\"file:{self.ground_image}\"))\n    ground_texture_image.setMirrored(False)\n    ground_texture.addTextureImage(ground_texture_image)\n    ground_material.setTexture(ground_texture)\n    self.ground_entity.addComponent(ground_material)\n\n    ground_transform = Qt3DCore.QTransform(self.ground_entity)\n    ground_transform.setRotationX(90)\n    ground_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n    self.ground_entity.addComponent(ground_transform)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.add_obstacle","title":"<code>add_obstacle(x=0, y=0, rotation=0, **kwargs)</code>","text":"<p>Create a new obstacle in the 3D view.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X position</p> <code>0</code> <code>y</code> <code>int</code> <p>Y position</p> <code>0</code> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>0</code> Return <p>The obstacle entity</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def add_obstacle(self, x: int = 0, y: int = 0, rotation: int = 0, **kwargs) -&gt; ObstacleEntity:\n    \"\"\"\n    Create a new obstacle in the 3D view.\n\n    Arguments:\n        x: X position\n        y: Y position\n        rotation: Rotation\n\n    Return:\n        The obstacle entity\n    \"\"\"\n    obstacle_entity = ObstacleEntity(self.container, x, y, rotation, **kwargs)\n    obstacle_entity.setParent(self.scene_entity)\n    self.obstacle_entities.append(obstacle_entity)\n    obstacle_entity.enable_controller.connect(self.enable_mouse)\n    obstacle_entity.obstacle_moved.connect(self.update_shared_obstacles)\n    self.new_move_delta.connect(obstacle_entity.new_move_delta)\n    self.update_shared_obstacles()\n    return obstacle_entity\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.asset_ready","title":"<code>asset_ready()</code>","text":"<p>Create artifacts when all assets are ready (loading assets is done in background).</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def asset_ready(self):\n    \"\"\"\n    Create artifacts when all assets are ready (loading assets is done in background).\n    \"\"\"\n    child_assets_not_ready = [\n        child for child in self.scene_entity.findChildren(AssetEntity) if not child.asset_ready\n    ]\n    if len(child_assets_not_ready) == 0:\n        self.robot_manual = RobotManualEntity(self.scene_entity, self.container)\n        self.robot_manual.enable_controller.connect(self.enable_mouse)\n        self.new_move_delta.connect(self.robot_manual.new_move_delta)\n        self.pami_manual = RobotManualEntity(self.scene_entity, self.container, robot_id=2, y=-1200)\n        self.pami_manual.enable_controller.connect(self.enable_mouse)\n        self.new_move_delta.connect(self.pami_manual.new_move_delta)\n\n        print(f\"Load time of assets: {timeit.default_timer() - self.start_time:0.3f}s\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.create_object_picker","title":"<code>create_object_picker()</code>","text":"<p>Add a plane mesh with object picker to help moving objects with mouse drag and drop.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def create_object_picker(self):\n    \"\"\"\n    Add a plane mesh with object picker to help moving objects with mouse drag and drop.\n    \"\"\"\n    self.plane_entity = Qt3DCore.QEntity(self.scene_entity)\n\n    plane_mesh = Qt3DExtras.QPlaneMesh(self.plane_entity)\n    plane_mesh.setHeight(8000)\n    plane_mesh.setWidth(10000)\n    self.plane_entity.addComponent(plane_mesh)\n\n    plane_transform = Qt3DCore.QTransform(self.plane_entity)\n    plane_transform.setTranslation(QtGui.QVector3D(0, 1000, 0))\n    plane_transform.setRotationX(90)\n    self.plane_entity.addComponent(plane_transform)\n\n    plane_picker = Qt3DRender.QObjectPicker(self.plane_entity)\n    plane_picker.setDragEnabled(True)\n    plane_picker.pressed.connect(self.plane_pressed)\n    plane_picker.released.connect(self.plane_released)\n    plane_picker.moved.connect(self.plane_moved)\n    self.plane_entity.addComponent(plane_picker)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.get_camera_params","title":"<code>get_camera_params()</code>","text":"<p>Return current camera parameters to save them for next session.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def get_camera_params(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Return current camera parameters to save them for next session.\n    \"\"\"\n    return {\n        \"translation\": self.root_transform.translation().toTuple(),\n        \"rotation\": [\n            self.root_transform.rotationX(),\n            self.root_transform.rotationY(),\n            self.root_transform.rotationZ(),\n        ],\n    }\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.load_obstacles","title":"<code>load_obstacles(filename)</code>","text":"<p>Load obstacles from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path of the JSON file</p> required Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def load_obstacles(self, filename: Path):\n    \"\"\"\n    Load obstacles from a JSON file.\n\n    Arguments:\n        filename: path of the JSON file\n    \"\"\"\n    try:\n        obstacle_models = TypeAdapter(models.ObstacleList).validate_json(filename.read_text())\n        for obstacle_model in obstacle_models:\n            self.add_obstacle(**obstacle_model.model_dump())\n    except ValidationError as exc:\n        print(exc)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.moved","title":"<code>moved(pick)</code>","text":"<p>Function called on a <code>moved</code> mouse event on the artifact.</p> <p>Just record that the artifact is moving, the translation is computed in the GameView object.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def moved(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Function called on a ```moved``` mouse event on the artifact.\n\n    Just record that the artifact is moving, the translation is computed\n    in the [GameView][cogip.tools.monitor.gameview.GameView] object.\n    \"\"\"\n\n    if not self.mouse_enabled:\n        return\n\n    new_pos = pick.worldIntersection()\n    delta = new_pos - self.last_mouse_pos\n    self.last_mouse_pos = new_pos\n\n    if pick.buttons() == QtCore.Qt.MouseButton.LeftButton.value:\n        self.translate(delta.x(), delta.y(), 0)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.new_robot_path","title":"<code>new_robot_path(robot_id, new_path)</code>","text":"<p>Function called when robot path is updated.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>new_path</code> <code>list[Vertex]</code> <p>new robot path</p> required Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def new_robot_path(self, robot_id: int, new_path: list[models.Vertex]) -&gt; None:\n    \"\"\"\n    Function called when robot path is updated.\n\n    Arguments:\n        robot_id: ID of the robot\n        new_path: new robot path\n    \"\"\"\n    for vertex in new_path:\n        vertex.z = 20\n    self.path.set_points(new_path)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.plane_moved","title":"<code>plane_moved(pick)</code>","text":"<p>Compute the translation on the plane entity between the current <code>moved</code> mouse event and the previous one.</p> <p>Emit the <code>new_move_delta</code> signal to update the corresponding asset's position.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def plane_moved(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Compute the translation on the plane entity between the\n    current `moved` mouse event and the previous one.\n\n    Emit the `new_move_delta` signal to update the corresponding asset's position.\n    \"\"\"\n    if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n        return\n\n    new_intersection = pick.worldIntersection()\n    delta: QtGui.QVector3D = new_intersection - self.plane_intersection\n    delta.setZ(0)\n    rot_z = self.root_transform.rotationZ()\n    delta = QtGui.QVector3D(\n        -delta.x() * math.cos(math.radians(rot_z)) - delta.y() * math.sin(math.radians(rot_z)),\n        -delta.y() * math.cos(math.radians(rot_z)) + delta.x() * math.sin(math.radians(rot_z)),\n        0,\n    )\n    self.new_move_delta.emit(delta)\n    self.plane_intersection = new_intersection\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.plane_pressed","title":"<code>plane_pressed(pick)</code>","text":"<p>Record the intersection between the mouse pointer and the plane entity, on the <code>pressed</code> mouse event, in world coordinate.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def plane_pressed(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Record the intersection between the mouse pointer and the plane entity,\n    on the `pressed` mouse event, in world coordinate.\n    \"\"\"\n    if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n        return\n\n    self.plane_intersection = pick.worldIntersection()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.plane_released","title":"<code>plane_released(pick)</code>","text":"<p>Emit the <code>new_move_delta</code> signal with <code>None</code> argument, on <code>released</code> mouse event, to notify that mouse button was released and no further moves will happen until next <code>pressed</code> mouse event.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def plane_released(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Emit the `new_move_delta` signal with `None` argument,\n    on `released` mouse event, to notify that mouse button was released\n    and no further moves will happen until next `pressed` mouse event.\n    \"\"\"\n    self.plane_intersection = None\n    self.new_move_delta.emit(None)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.pressed","title":"<code>pressed(pick)</code>","text":"<p>Function called on a <code>pressed</code> mouse event on the artifact.</p> <p>Emit a signal to disable the camera controller before moving the artifact.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def pressed(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Function called on a ```pressed``` mouse event on the artifact.\n\n    Emit a signal to disable the camera controller before moving the artifact.\n    \"\"\"\n    self.last_mouse_pos = pick.worldIntersection()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.save_obstacles","title":"<code>save_obstacles(filename)</code>","text":"<p>Save obstacles to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path of the JSON file</p> required Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def save_obstacles(self, filename: Path):\n    \"\"\"\n    Save obstacles to a JSON file.\n\n    Arguments:\n        filename: path of the JSON file\n    \"\"\"\n    obstacle_models = []\n    for obstacle_entity in self.obstacle_entities:\n        obstacle_models.append(obstacle_entity.get_model())\n    with filename.open(\"w\") as fd:\n        fd.write(json.dumps(obstacle_models, default=pydantic_encoder, indent=2))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.set_camera_params","title":"<code>set_camera_params(camera_params)</code>","text":"<p>Set camera parameters to restore them from previous session.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def set_camera_params(self, camera_params: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set camera parameters to restore them from previous session.\n    \"\"\"\n    self.root_transform.setTranslation(QtGui.QVector3D(*camera_params[\"translation\"]))\n    self.root_transform.setRotationX(camera_params[\"rotation\"][0])\n    self.root_transform.setRotationY(camera_params[\"rotation\"][1])\n    self.root_transform.setRotationZ(camera_params[\"rotation\"][2])\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.GameView.update_shared_obstacles","title":"<code>update_shared_obstacles()</code>","text":"<p>Emit position of all obstacles.</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def update_shared_obstacles(self):\n    \"\"\"\n    Emit position of all obstacles.\n    \"\"\"\n    obstacles: list[models.Vertex] = []\n    for obstacle in self.obstacle_entities:\n        obstacles.append(\n            models.Vertex(\n                x=obstacle.transform.translation().x(),\n                y=obstacle.transform.translation().y(),\n            )\n        )\n    self.signal_update_shared_obstacles.emit(obstacles)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/gameview/#cogip.tools.monitor.gameview.create_light_entity","title":"<code>create_light_entity(parent, x, y, z, intensity=1)</code>","text":"<p>Create a light entity at the position specified in arguments.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QEntity</code> <p>parent entity</p> required <code>x</code> <code>float</code> <p>X position</p> required <code>y</code> <code>float</code> <p>Y position</p> required <code>z</code> <code>float</code> <p>Z position</p> required <code>intensity</code> <code>float</code> <p>light intensity</p> <code>1</code> Return <p>The light entity</p> Source code in <code>cogip/tools/monitor/gameview.py</code> <pre><code>def create_light_entity(\n    parent: Qt3DCore.QEntity, x: float, y: float, z: float, intensity: float = 1\n) -&gt; Qt3DCore.QEntity:\n    \"\"\"\n    Create a light entity at the position specified in arguments.\n\n    Arguments:\n        parent: parent entity\n        x: X position\n        y: Y position\n        z: Z position\n        intensity: light intensity\n\n    Return:\n        The light entity\n    \"\"\"\n    light_entity = Qt3DCore.QEntity(parent)\n\n    light = Qt3DRender.QPointLight(light_entity)\n    light.setColor(QtGui.QColor(QtCore.Qt.white))\n    light.setIntensity(intensity)\n    light_entity.addComponent(light)\n\n    light_transform = Qt3DCore.QTransform(light_entity)\n    light_transform.setTranslation(QtGui.QVector3D(x, y, z))\n    light_entity.addComponent(light_transform)\n\n    return light_entity\n</code></pre>"},{"location":"reference/cogip/tools/monitor/help/","title":"help","text":""},{"location":"reference/cogip/tools/monitor/help/#cogip.tools.monitor.help.HelpCameraControlDialog","title":"<code>HelpCameraControlDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>HelpCameraControlDialog class</p> <p>Build a help modal for camera control.</p> <p>Attributes:</p> Name Type Description <code>saved_geometry</code> <p>Saved window position</p> <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/tools/monitor/help.py</code> <pre><code>class HelpCameraControlDialog(QtWidgets.QDialog):\n    \"\"\"HelpCameraControlDialog class\n\n    Build a help modal for camera control.\n\n    Attributes:\n        saved_geometry: Saved window position\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    closed: qtSignal = qtSignal()\n\n    def __init__(self, parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n\n        self.setWindowTitle(\"Camera Control\")\n        self.setModal(False)\n\n        layout = QtWidgets.QVBoxLayout()\n        self.setLayout(layout)\n\n        browser = QtWidgets.QTextBrowser()\n        layout.addWidget(browser)\n\n        browser.document().setMarkdown(help_text)\n\n        self.resize(580, 395)\n\n        self.readSettings()\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"help/geometry\", self.saveGeometry())\n\n        self.closed.emit()\n        event.accept()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"help/geometry\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/help/#cogip.tools.monitor.help.HelpCameraControlDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/tools/monitor/help.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.setWindowTitle(\"Camera Control\")\n    self.setModal(False)\n\n    layout = QtWidgets.QVBoxLayout()\n    self.setLayout(layout)\n\n    browser = QtWidgets.QTextBrowser()\n    layout.addWidget(browser)\n\n    browser.document().setMarkdown(help_text)\n\n    self.resize(580, 395)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/help/#cogip.tools.monitor.help.HelpCameraControlDialog.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/tools/monitor/help.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"help/geometry\", self.saveGeometry())\n\n    self.closed.emit()\n    event.accept()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/impact/","title":"impact","text":""},{"location":"reference/cogip/tools/monitor/impact/#cogip.tools.monitor.impact.ImpactEntity","title":"<code>ImpactEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p><code>QEntity</code> used to visualize to points detected by sensors.</p> <p>It is represented with <code>QSphereMesh</code>, its radius and color are configurable in the constructor.</p> Source code in <code>cogip/tools/monitor/impact.py</code> <pre><code>class ImpactEntity(Qt3DCore.QEntity):\n    \"\"\"\n    `QEntity` used to visualize to points detected by sensors.\n\n    It is represented with [`QSphereMesh`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/QSphereMesh.html),\n    its radius and color are configurable in the constructor.\n    \"\"\"\n\n    def __init__(self, radius: float = 50, color: QtCore.Qt.GlobalColor = QtCore.Qt.red):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            radius: Radius of the sphere\n            color: Color of the sphere\n        \"\"\"\n        super().__init__()\n\n        self.mesh = Qt3DExtras.QSphereMesh()\n        self.mesh.setRadius(radius)\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial()\n        self.material.setDiffuse(QtGui.QColor(color))\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform()\n        self.addComponent(self.transform)\n        self.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/impact/#cogip.tools.monitor.impact.ImpactEntity.__init__","title":"<code>__init__(radius=50, color=QtCore.Qt.red)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the sphere</p> <code>50</code> <code>color</code> <code>GlobalColor</code> <p>Color of the sphere</p> <code>red</code> Source code in <code>cogip/tools/monitor/impact.py</code> <pre><code>def __init__(self, radius: float = 50, color: QtCore.Qt.GlobalColor = QtCore.Qt.red):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        radius: Radius of the sphere\n        color: Color of the sphere\n    \"\"\"\n    super().__init__()\n\n    self.mesh = Qt3DExtras.QSphereMesh()\n    self.mesh.setRadius(radius)\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial()\n    self.material.setDiffuse(QtGui.QColor(color))\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform()\n    self.addComponent(self.transform)\n    self.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/line/","title":"line","text":""},{"location":"reference/cogip/tools/monitor/line/#cogip.tools.monitor.line.LineEntity","title":"<code>LineEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A simple entity drawing a line between two vertices.</p> Source code in <code>cogip/tools/monitor/line.py</code> <pre><code>class LineEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A simple entity drawing a line between two vertices.\n    \"\"\"\n\n    def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            color: color\n            parent: parent entity\n        \"\"\"\n        super().__init__(parent)\n        self.color = color\n\n        self.geometry = Qt3DCore.QGeometry(self)\n\n        self.position_buffer = Qt3DCore.QBuffer(self.geometry)\n\n        self.position_attribute = Qt3DCore.QAttribute(self.geometry)\n        self.position_attribute.setName(Qt3DCore.QAttribute.defaultPositionAttributeName())\n        self.position_attribute.setAttributeType(Qt3DCore.QAttribute.VertexAttribute)\n        self.position_attribute.setVertexBaseType(Qt3DCore.QAttribute.Float)\n        self.position_attribute.setVertexSize(3)\n        self.position_attribute.setCount(2)\n        self.position_attribute.setBuffer(self.position_buffer)\n        self.geometry.addAttribute(self.position_attribute)\n\n        # Connectivity between vertices\n        self.indices = array(\"I\", [0, 1])\n        self.indices_bytes = QtCore.QByteArray(self.indices.tobytes())\n        self.indices_buffer = Qt3DCore.QBuffer(self.geometry)\n        self.indices_buffer.setData(self.indices_bytes)\n\n        self.indices_attribute = Qt3DCore.QAttribute(self.geometry)\n        self.indices_attribute.setVertexBaseType(Qt3DCore.QAttribute.UnsignedInt)\n        self.indices_attribute.setAttributeType(Qt3DCore.QAttribute.IndexAttribute)\n        self.indices_attribute.setBuffer(self.indices_buffer)\n        self.indices_attribute.setCount(2)\n        self.geometry.addAttribute(self.indices_attribute)\n\n        # Mesh\n        self.line = Qt3DRender.QGeometryRenderer(self)\n        self.line.setGeometry(self.geometry)\n        self.line.setPrimitiveType(Qt3DRender.QGeometryRenderer.Lines)\n        self.material = Qt3DExtras.QPhongMaterial(self)\n        self.material.setAmbient(self.color)\n\n        # Entity\n        self.addComponent(self.line)\n        self.addComponent(self.material)\n\n    def set_points(self, start: models.Vertex, end: models.Vertex):\n        \"\"\"\n        Set start and end vertices.\n\n        Arguments:\n            start: start position\n            end: end position\n        \"\"\"\n\n        # Position vertices (start and end)\n        positions = array(\"f\")\n        positions.fromlist([start.x, start.y, start.z])\n        positions.fromlist([end.x, end.y, end.z])\n        buffer_bytes = QtCore.QByteArray(positions.tobytes())\n        self.position_buffer.setData(buffer_bytes)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/line/#cogip.tools.monitor.line.LineEntity.__init__","title":"<code>__init__(color=QtCore.Qt.blue, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>color</p> <code>blue</code> <code>parent</code> <code>QEntity | None</code> <p>parent entity</p> <code>None</code> Source code in <code>cogip/tools/monitor/line.py</code> <pre><code>def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        color: color\n        parent: parent entity\n    \"\"\"\n    super().__init__(parent)\n    self.color = color\n\n    self.geometry = Qt3DCore.QGeometry(self)\n\n    self.position_buffer = Qt3DCore.QBuffer(self.geometry)\n\n    self.position_attribute = Qt3DCore.QAttribute(self.geometry)\n    self.position_attribute.setName(Qt3DCore.QAttribute.defaultPositionAttributeName())\n    self.position_attribute.setAttributeType(Qt3DCore.QAttribute.VertexAttribute)\n    self.position_attribute.setVertexBaseType(Qt3DCore.QAttribute.Float)\n    self.position_attribute.setVertexSize(3)\n    self.position_attribute.setCount(2)\n    self.position_attribute.setBuffer(self.position_buffer)\n    self.geometry.addAttribute(self.position_attribute)\n\n    # Connectivity between vertices\n    self.indices = array(\"I\", [0, 1])\n    self.indices_bytes = QtCore.QByteArray(self.indices.tobytes())\n    self.indices_buffer = Qt3DCore.QBuffer(self.geometry)\n    self.indices_buffer.setData(self.indices_bytes)\n\n    self.indices_attribute = Qt3DCore.QAttribute(self.geometry)\n    self.indices_attribute.setVertexBaseType(Qt3DCore.QAttribute.UnsignedInt)\n    self.indices_attribute.setAttributeType(Qt3DCore.QAttribute.IndexAttribute)\n    self.indices_attribute.setBuffer(self.indices_buffer)\n    self.indices_attribute.setCount(2)\n    self.geometry.addAttribute(self.indices_attribute)\n\n    # Mesh\n    self.line = Qt3DRender.QGeometryRenderer(self)\n    self.line.setGeometry(self.geometry)\n    self.line.setPrimitiveType(Qt3DRender.QGeometryRenderer.Lines)\n    self.material = Qt3DExtras.QPhongMaterial(self)\n    self.material.setAmbient(self.color)\n\n    # Entity\n    self.addComponent(self.line)\n    self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/line/#cogip.tools.monitor.line.LineEntity.set_points","title":"<code>set_points(start, end)</code>","text":"<p>Set start and end vertices.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Vertex</code> <p>start position</p> required <code>end</code> <code>Vertex</code> <p>end position</p> required Source code in <code>cogip/tools/monitor/line.py</code> <pre><code>def set_points(self, start: models.Vertex, end: models.Vertex):\n    \"\"\"\n    Set start and end vertices.\n\n    Arguments:\n        start: start position\n        end: end position\n    \"\"\"\n\n    # Position vertices (start and end)\n    positions = array(\"f\")\n    positions.fromlist([start.x, start.y, start.z])\n    positions.fromlist([end.x, end.y, end.z])\n    buffer_bytes = QtCore.QByteArray(positions.tobytes())\n    self.position_buffer.setData(buffer_bytes)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/main/","title":"main","text":""},{"location":"reference/cogip/tools/monitor/main/#cogip.tools.monitor.main.main","title":"<code>main()</code>","text":"<p>Starts the copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>copilot</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/monitor/main.py</code> <pre><code>def main():\n    \"\"\"\n    Starts the copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `copilot` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/main/#cogip.tools.monitor.main.main_opt","title":"<code>main_opt(url=typer.Argument('http://localhost:8091', envvar='COGIP_SOCKETIO_SERVER_URL', help='Socket.IO Server URL'))</code>","text":"<p>Launch COGIP Monitor.</p> Source code in <code>cogip/tools/monitor/main.py</code> <pre><code>def main_opt(\n    url: str = typer.Argument(\n        \"http://localhost:8091\",\n        envvar=\"COGIP_SOCKETIO_SERVER_URL\",\n        help=\"Socket.IO Server URL\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Launch COGIP Monitor.\n    \"\"\"\n    faulthandler.enable()\n\n    # Create socketio controller\n    controller = SocketioController(url)\n\n    # Create QApplication\n    app = QtWidgets.QApplication(sys.argv)\n\n    # Set icon theme so that icons are visible in Docker containers.\n    if Path(\"/usr/share/icons/Yaru-dark\").exists():\n        QtGui.QIcon.setThemeName(\"Yaru-dark\")\n\n    # Set dark theme\n    palette = app.palette()\n    palette.setColor(QtGui.QPalette.ColorRole.Window, \"#2a2a2a\")\n    palette.setColor(QtGui.QPalette.ColorRole.WindowText, \"#ffffff\")\n    palette.setColor(QtGui.QPalette.ColorRole.Base, \"#2a2a2a\")\n    palette.setColor(QtGui.QPalette.ColorRole.AlternateBase, \"#272727\")\n    palette.setColor(QtGui.QPalette.ColorRole.ToolTipBase, \"#ffffdc\")\n    palette.setColor(QtGui.QPalette.ColorRole.ToolTipText, \"#000000\")\n    palette.setColor(QtGui.QPalette.ColorRole.Text, \"#ffffff\")\n    palette.setColor(QtGui.QPalette.ColorRole.Button, \"#2a2a2a\")\n    palette.setColor(QtGui.QPalette.ColorRole.ButtonText, \"#ffffff\")\n    palette.setColor(QtGui.QPalette.ColorRole.BrightText, \"#ffffff\")\n    palette.setColor(QtGui.QPalette.ColorRole.Highlight, \"#e95420\")\n    palette.setColor(QtGui.QPalette.ColorRole.HighlightedText, \"#ffffff\")\n    palette.setColor(QtGui.QPalette.ColorRole.Light, \"#343434\")\n    palette.setColor(QtGui.QPalette.ColorRole.Midlight, \"#2f2f2f\")\n    palette.setColor(QtGui.QPalette.ColorRole.Dark, \"#252525\")\n    palette.setColor(QtGui.QPalette.ColorRole.Mid, \"#2f2f2f\")\n    palette.setColor(QtGui.QPalette.ColorRole.Shadow, \"#020202\")\n    palette.setColor(QtGui.QPalette.ColorRole.Link, \"#308cc6\")\n    palette.setColor(QtGui.QPalette.ColorRole.LinkVisited, \"#ff00ff\")\n    palette.setColor(QtGui.QPalette.ColorRole.NoRole, \"#000000\")\n    palette.setColor(QtGui.QPalette.ColorRole.PlaceholderText, \"#9b9b9b\")\n    palette.setColor(QtGui.QPalette.ColorRole.Accent, \"#308cc6\")\n    app.setPalette(palette)\n\n    # Create UI\n    win = MainWindow(url)\n    win.setWindowIcon(QtGui.QIcon(\"assets/cogip-logo.png\"))\n\n    # Create table entity\n    table_entity = TableEntity()\n    win.game_view.add_asset(table_entity)\n\n    # Create robot entity\n    robot_manager = RobotManager(win)\n\n    # Connect UI signals to Controller slots\n    win.signal_send_command.connect(controller.new_command)\n    win.signal_config_updated.connect(controller.config_updated)\n    win.signal_wizard_response.connect(controller.wizard_response)\n    win.signal_actuators_opened.connect(controller.actuators_started)\n    win.signal_actuators_closed.connect(controller.actuators_closed)\n    win.signal_new_actuator_command.connect(controller.new_actuator_command)\n    win.signal_starter_changed.connect(controller.starter_changed)\n\n    # Connect UI signals to GameView slots\n    win.signal_add_obstacle.connect(win.game_view.add_obstacle)\n    win.signal_load_obstacles.connect(win.game_view.load_obstacles)\n    win.signal_save_obstacles.connect(win.game_view.save_obstacles)\n\n    # Connect GameView signals to robot manager slots\n    win.game_view.signal_update_shared_obstacles.connect(robot_manager.update_shared_obstacles)\n\n    # Connect Controller signals to robot manager\n    controller.signal_new_robot_pose_order.connect(robot_manager.new_robot_pose_order)\n    controller.signal_add_robot.connect(robot_manager.add_robot)\n    controller.signal_del_robot.connect(robot_manager.del_robot)\n\n    # Connect Controller signals to UI slots\n    controller.signal_new_console_text.connect(win.log_text.append)\n    controller.signal_new_menu.connect(win.load_menu)\n    controller.signal_add_robot.connect(win.add_robot)\n    controller.signal_del_robot.connect(win.del_robot)\n    controller.signal_starter_changed.connect(win.starter_changed)\n    controller.signal_new_robot_state.connect(win.new_robot_state)\n    controller.signal_connected.connect(win.connected)\n    controller.signal_exit.connect(win.close)\n    controller.signal_config_request.connect(win.config_request)\n    controller.signal_wizard_request.connect(win.wizard_request)\n    controller.signal_close_wizard.connect(win.close_wizard)\n    controller.signal_actuator_state.connect(win.actuator_state)\n    controller.signal_planner_reset.connect(win.planner_reset)\n\n    # Connect Controller signals to GameView slots\n    controller.signal_new_robot_path.connect(win.game_view.new_robot_path)\n\n    # Show UI\n    win.show()\n    # win.showFullScreen()\n    win.raise_()\n\n    controller.start()\n\n    ret = app.exec()\n\n    controller.stop()\n    robot_manager.del_robot()\n\n    sys.exit(ret)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/","title":"mainwindow","text":""},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow","title":"<code>MainWindow</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>MainWindow class</p> <p>Build the main window of the monitor.</p> <p>It contains:</p> <ul> <li>a menu bar,</li> <li>a tool bar with buttons to add/load/save obstacles,</li> <li>a status bar with robot position,</li> <li>a menu with commands available in the current firmware shell menu,</li> <li>a console recording the firmware output.</li> </ul> <p>Attributes:</p> Name Type Description <code>signal_config_updated</code> <code>Signal</code> <p>Qt signal to update config</p> <code>signal_wizard_response</code> <code>Signal</code> <p>Qt signal to emit wizard response</p> <code>signal_send_command</code> <code>Signal</code> <p>Qt signal to send a command to the firmware</p> <code>signal_add_obstacle</code> <code>Signal</code> <p>Qt signal to add an obstacle</p> <code>signal_load_obstacles</code> <code>Signal</code> <p>Qt signal to load obstacles</p> <code>signal_save_obstacles</code> <code>Signal</code> <p>Qt signal to save obstacles</p> <code>signal_new_actuator_command</code> <code>Signal</code> <p>Qt signal to send actuator command to server</p> <code>signal_actuators_opened</code> <code>Signal</code> <p>Qt signal to start actuators state request</p> <code>signal_actuators_closed</code> <code>Signal</code> <p>Qt signal to stop actuators state request</p> <code>signal_starter_changed</code> <code>Signal</code> <p>Qt signal emitted the starter state has changed</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>class MainWindow(QtWidgets.QMainWindow):\n    \"\"\"MainWindow class\n\n    Build the main window of the monitor.\n\n    It contains:\n\n      - a menu bar,\n      - a tool bar with buttons to add/load/save obstacles,\n      - a status bar with robot position,\n      - a menu with commands available in the current firmware shell menu,\n      - a console recording the firmware output.\n\n    Attributes:\n        signal_config_updated: Qt signal to update config\n        signal_wizard_response: Qt signal to emit wizard response\n        signal_send_command: Qt signal to send a command to the firmware\n        signal_add_obstacle: Qt signal to add an obstacle\n        signal_load_obstacles: Qt signal to load obstacles\n        signal_save_obstacles: Qt signal to save obstacles\n        signal_new_actuator_command: Qt signal to send actuator command to server\n        signal_actuators_opened: Qt signal to start actuators state request\n        signal_actuators_closed: Qt signal to stop actuators state request\n        signal_starter_changed: Qt signal emitted the starter state has changed\n    \"\"\"\n\n    signal_config_updated: qtSignal = qtSignal(dict)\n    signal_wizard_response: qtSignal = qtSignal(dict)\n    signal_send_command: qtSignal = qtSignal(str, str)\n    signal_add_obstacle: qtSignal = qtSignal()\n    signal_load_obstacles: qtSignal = qtSignal(Path)\n    signal_save_obstacles: qtSignal = qtSignal(Path)\n    signal_actuators_opened: qtSignal = qtSignal()\n    signal_actuators_closed: qtSignal = qtSignal()\n    signal_new_actuator_command: qtSignal = qtSignal(object)\n    signal_starter_changed: qtSignal = qtSignal(int, bool)\n\n    def __init__(self, url: str, *args, **kwargs):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            url: URL of the copilot web server\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.robot_status_row: dict[int, int] = {}\n        self.robot_starters: dict[int, QtWidgets.QCheckBox] = {}\n        self.charts_view: dict[int, ChartsView] = {}\n        self.available_chart_views: list[ChartsView] = []\n        self.menu_widgets: dict[str, dict[str, QtWidgets.QWidget]] = {}\n        self.wizard: WizardDialog | None = None\n\n        self.setWindowTitle(\"COGIP Monitor\")\n\n        self.central_widget = QtWidgets.QWidget()\n        self.central_layout = QtWidgets.QHBoxLayout()\n        self.central_widget.setLayout(self.central_layout)\n        self.setCentralWidget(self.central_widget)\n\n        # Menu bar\n        menubar = self.menuBar()\n        file_menu = menubar.addMenu(\"&amp;File\")\n        obstacles_menu = menubar.addMenu(\"&amp;Obstacles\")\n        self.view_menu = menubar.addMenu(\"&amp;View\")\n        help_menu = menubar.addMenu(\"&amp;Help\")\n\n        # Toolbars\n        file_toolbar = self.addToolBar(\"File\")\n        file_toolbar.setObjectName(\"File Toolbar\")\n        obstacles_toolbar = self.addToolBar(\"Obstacles\")\n        obstacles_toolbar.setObjectName(\"Obstacles Toolbar\")\n        actuators_toolbar = self.addToolBar(\"Obstacles\")\n        actuators_toolbar.setObjectName(\"Actuators Toolbar\")\n\n        # Status bar\n        status_bar = self.statusBar()\n\n        self.connected_label = QtWidgets.QLabel(\"Disconnected\")\n        status_bar.addPermanentWidget(self.connected_label, 1)\n\n        status_widget = QtWidgets.QWidget()\n        status_bar.addPermanentWidget(status_widget)\n\n        self.status_layout = QtWidgets.QGridLayout()\n        status_widget.setLayout(self.status_layout)\n\n        cycle_label = QtWidgets.QLabel(\"Cycle\")\n        self.status_layout.addWidget(cycle_label, 0, 1)\n\n        pos_x_label = QtWidgets.QLabel(\"X\")\n        self.status_layout.addWidget(pos_x_label, 0, 2)\n\n        pos_y_label = QtWidgets.QLabel(\"Y\")\n        self.status_layout.addWidget(pos_y_label, 0, 3)\n\n        pos_angle_label = QtWidgets.QLabel(\"Angle\")\n        self.status_layout.addWidget(pos_angle_label, 0, 4)\n\n        starter_label = QtWidgets.QLabel(\"Starter\")\n        self.status_layout.addWidget(starter_label, 0, 5)\n\n        # Actions\n        # Icons: https://commons.wikimedia.org/wiki/GNOME_Desktop_icons\n\n        # Exit action\n        self.exit_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"application-exit\"), \"Exit\", self)\n        self.exit_action.setShortcut(\"Ctrl+Q\")\n        self.exit_action.setStatusTip(\"Exit application\")\n        self.exit_action.triggered.connect(self.close)\n        file_menu.addAction(self.exit_action)\n        file_toolbar.addAction(self.exit_action)\n\n        # Add obstacle action\n        self.add_obstacle_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"list-add\"), \"Add obstacle\", self)\n        self.add_obstacle_action.setShortcut(\"Ctrl+A\")\n        self.add_obstacle_action.setStatusTip(\"Add obstacle\")\n        self.add_obstacle_action.triggered.connect(self.add_obstacle)\n        obstacles_menu.addAction(self.add_obstacle_action)\n        obstacles_toolbar.addAction(self.add_obstacle_action)\n\n        # Open obstacles action\n        self.load_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-open\"), \"Load obstacles\", self)\n        self.load_obstacles_action.setShortcut(\"Ctrl+O\")\n        self.load_obstacles_action.setStatusTip(\"Load obstacles\")\n        self.load_obstacles_action.triggered.connect(self.load_obstacles)\n        obstacles_menu.addAction(self.load_obstacles_action)\n        obstacles_toolbar.addAction(self.load_obstacles_action)\n\n        # Save obstacles action\n        self.save_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-save\"), \"Save obstacles\", self)\n        self.save_obstacles_action.setShortcut(\"Ctrl+S\")\n        self.save_obstacles_action.setStatusTip(\"Save obstacles\")\n        self.save_obstacles_action.triggered.connect(self.save_obstacles)\n        obstacles_menu.addAction(self.save_obstacles_action)\n        obstacles_toolbar.addAction(self.save_obstacles_action)\n\n        # Actuators control action\n        self.actuators_control_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"emblem-system\"), \"Actuators control\", self)\n        self.actuators_control_action.setStatusTip(\"Actuators control\")\n        self.actuators_control_action.triggered.connect(self.open_actuators_control)\n        actuators_toolbar.addAction(self.actuators_control_action)\n\n        # Console\n        dock = QtWidgets.QDockWidget(\"Console\")\n        dock.setObjectName(\"Console\")\n        dock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea)\n        self.log_text = QtWidgets.QTextEdit()\n        self.log_text.setReadOnly(True)\n        dock.setWidget(self.log_text)\n        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)\n        file_menu.addAction(dock.toggleViewAction())\n        obstacles_menu.addAction(dock.toggleViewAction())\n\n        self.menu_tab_widget = QtWidgets.QTabWidget()\n        self.central_layout.insertWidget(0, self.menu_tab_widget, 1)\n\n        self.menu_staked_widgets: dict[str, QtWidgets.QStackedWidget] = {}\n\n        # GameView widget\n        self.game_view = GameView()\n        self.central_layout.insertWidget(1, self.game_view, 10)\n\n        # Help controls widget\n        self.help_camera_control = HelpCameraControlDialog(self)\n\n        # Properties windows\n        self.properties = {}\n\n        # Actuators control windows\n        self.actuators_dialog = ActuatorsDialog()\n        self.actuators_dialog.new_actuator_command.connect(self.new_actuator_command)\n        self.actuators_dialog.closed.connect(self.actuators_closed)\n\n        # Add help action\n        self.help_camera_control_action = QtGui.QAction(\"Camera control\", self)\n        self.help_camera_control_action.setStatusTip(\"Display camera control help\")\n        self.help_camera_control_action.triggered.connect(self.display_help_camera_control)\n        help_menu.addAction(self.help_camera_control_action)\n\n        self.readSettings()\n\n    @qtSlot(bool)\n    def charts_toggled(self, robot_id: int, checked: bool):\n        \"\"\"\n        Qt Slot\n\n        Show/hide the calibration charts.\n\n        Arguments:\n            robot_id: ID of the robot corresponding to the chart view\n            checked: Show action has checked or unchecked\n        \"\"\"\n        view = self.charts_view.get(robot_id)\n        if view is None:\n            return\n\n        if checked:\n            view.show()\n            view.raise_()\n            view.activateWindow()\n        else:\n            view.close()\n\n    def update_view_menu(self):\n        \"\"\"\n        Rebuild all the view menu to update the calibration charts sub-menu.\n        \"\"\"\n        self.view_menu.clear()\n        if len(self.charts_view):\n            calibration_menu = self.view_menu.addMenu(\"Calibration Charts\")\n            for robot_id, view in self.charts_view.items():\n                action = calibration_menu.addAction(f\"Robot {robot_id}\")\n                action.setCheckable(True)\n                action.toggled.connect(partial(self.charts_toggled, robot_id))\n                if view.isVisible():\n                    action.setChecked(True)\n                view.closed.connect(partial(action.setChecked, False))\n\n    def add_robot(self, robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n        \"\"\"\n        Add a new robot status bar.\n\n        Parameters:\n            robot_id: ID of the new robot\n            virtual_planner: whether the planner is virtual or not,\n                if planner is virtual, use shared memory to get the robot current, pose order and obstacles.\n            virtual_detector: whether the detector is virtual or not,\n                if detector is virtual, detect virtual obstacles and write them in shared memory.\n        \"\"\"\n        # Status bar\n        if robot_id in self.robot_status_row:\n            return\n\n        row = self.status_layout.rowCount()\n        self.robot_status_row[robot_id] = row\n\n        title_text = QtWidgets.QLabel(f\"Robot {robot_id}\")\n        self.status_layout.addWidget(title_text, row, 0)\n\n        cycle_text = QtWidgets.QLabel()\n        cycle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        cycle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(cycle_text, row, 1)\n\n        pos_x_text = QtWidgets.QLabel()\n        pos_x_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        pos_x_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(pos_x_text, row, 2)\n\n        pos_y_text = QtWidgets.QLabel()\n        pos_y_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        pos_y_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(pos_y_text, row, 3)\n\n        pos_angle_text = QtWidgets.QLabel()\n        pos_angle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        pos_angle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(pos_angle_text, row, 4)\n\n        self.robot_starters[robot_id] = (starter_checkbox := QtWidgets.QCheckBox())\n        self.status_layout.addWidget(starter_checkbox, row, 5)\n        starter_checkbox.setEnabled(virtual_planner)\n        starter_checkbox.toggled.connect(partial(self.starter_toggled, robot_id))\n\n        # Chart view\n        view = self.charts_view.get(robot_id)\n        if view is None:\n            if len(self.available_chart_views) == 0:\n                view = ChartsView(self)\n                self.available_chart_views.append(view)\n\n            view = self.available_chart_views.pop(0)\n            self.charts_view[robot_id] = view\n            view.set_robot_id(robot_id)\n            settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n            if settings.value(f\"charts_checked/{robot_id}\") == \"true\":\n                self.charts_toggled(robot_id, True)\n\n        self.update_view_menu()\n\n    def del_robot(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n\n        Parameters:\n            robot_id: ID of the robot to remove\n        \"\"\"\n        # Status bar\n        row = self.robot_status_row.pop(robot_id)\n        if not row:\n            return\n\n        for i in range(7):\n            if not (item := self.status_layout.itemAtPosition(row, i)):\n                continue\n            widget = item.widget()\n            widget.setParent(None)\n            self.status_layout.removeWidget(widget)\n\n        # Chart view\n        self.charts_toggled(robot_id, False)\n        view = self.charts_view.pop(robot_id, None)\n        if view is None:\n            return\n        self.available_chart_views.append(view)\n        view.closed.disconnect()\n        self.update_view_menu()\n\n    def new_robot_pose(self, robot_id: int, pose: Pose):\n        \"\"\"\n        Update robot position information in the status bar.\n\n        Arguments:\n            robot_id: ID of the robot\n            pose: Robot pose\n        \"\"\"\n        row = self.robot_status_row.get(robot_id)\n        if not row:\n            return\n        self.status_layout.itemAtPosition(row, 2).widget().setText(f\"{int(pose.x):&gt; #6d}\")\n        self.status_layout.itemAtPosition(row, 3).widget().setText(f\"{int(pose.y):&gt; #6d}\")\n        self.status_layout.itemAtPosition(row, 4).widget().setText(f\"{int(pose.O):&gt; #4d}\")\n\n    @qtSlot(RobotState)\n    def new_robot_state(self, robot_id: int, state: RobotState):\n        \"\"\"\n        Qt Slot\n\n        Update robot state information in the status bar.\n\n        Arguments:\n            robot_id: ID of the robot\n            state: Robot state\n        \"\"\"\n        row = self.robot_status_row.get(robot_id)\n        if not row:\n            return\n        self.status_layout.itemAtPosition(row, 1).widget().setText(f\"{state.cycle or 0:&gt;#6d}\")\n\n        charts_view = self.charts_view.get(robot_id)\n        if charts_view:\n            charts_view.new_robot_state(state)\n\n    @qtSlot(ShellMenu)\n    def load_menu(self, menu_name: str, new_menu: ShellMenu):\n        \"\"\"\n        Qt Slot\n\n        Display the new menu sent by [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n        Once a menu has been build once, it is cached and reused.\n\n        Arguments:\n            menu_name: menu to update (\"shell\", \"tool\", ...)\n            new_menu: The new menu information sent by the firmware\n        \"\"\"\n        if menu_name not in self.menu_staked_widgets:\n            self.menu_staked_widgets[menu_name] = QtWidgets.QStackedWidget()\n            empty_menu_widget = QtWidgets.QStackedWidget()\n            empty_menu_layout = QtWidgets.QVBoxLayout()\n            empty_menu_widget.setLayout(empty_menu_layout)\n            empty_menu_title = QtWidgets.QLabel(\"No menu loaded\")\n            empty_menu_title.setTextFormat(QtCore.Qt.RichText)\n            empty_menu_title.setAlignment(QtCore.Qt.AlignHCenter)\n            empty_menu_title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n            empty_menu_title.setStyleSheet(\"font-weight: bold; color: #d01b1e\")\n            empty_menu_layout.addWidget(empty_menu_title)\n            empty_menu_layout.addStretch()\n            self.menu_staked_widgets[menu_name].addWidget(empty_menu_widget)\n            self.menu_tab_widget.addTab(self.menu_staked_widgets[menu_name], menu_name)\n\n        if menu_name not in self.menu_widgets:\n            self.menu_widgets[menu_name] = {}\n\n        widget = self.menu_widgets[menu_name].get(new_menu.name)\n        if not widget:\n            # Create a new menu\n            widget = QtWidgets.QWidget()\n            layout = QtWidgets.QVBoxLayout()\n            widget.setLayout(layout)\n            self.menu_widgets[menu_name][new_menu.name] = widget\n            self.menu_staked_widgets[menu_name].addWidget(widget)\n\n        # Clear menu to rebuild it in case it has changed\n        layout = widget.layout()\n        while layout.count():\n            child = layout.takeAt(0)\n            if child.widget():\n                child.widget().deleteLater()\n\n        title = QtWidgets.QLabel(new_menu.name)\n        title.setTextFormat(QtCore.Qt.RichText)\n        title.setAlignment(QtCore.Qt.AlignHCenter)\n        title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        title.setStyleSheet(\"font-weight: bold; color: #d01b1e\")\n        layout.addWidget(title)\n\n        for entry in new_menu.entries:\n            if entry.cmd[0] == \"_\":\n                continue\n            cmd_widget = QtWidgets.QWidget()\n            cmd_layout = QtWidgets.QHBoxLayout()\n            cmd_layout.setContentsMargins(0, 0, 0, 0)\n            cmd_widget.setLayout(cmd_layout)\n            layout.addWidget(cmd_widget)\n\n            desc, args = split_command(entry.desc)\n            button = QtWidgets.QPushButton(desc)\n            cmd_layout.addWidget(button)\n\n            for arg in args:\n                edit = QtWidgets.QLineEdit()\n                edit.setPlaceholderText(arg)\n                edit.setToolTip(arg)\n                cmd_layout.addWidget(edit)\n                edit.returnPressed.connect(\n                    lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout)\n                )\n            button.clicked.connect(lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout))\n\n        layout.addStretch()\n\n        self.menu_staked_widgets[menu_name].setCurrentWidget(widget)\n\n    def build_command(self, menu_name: str, cmd: str, layout: QtWidgets.QHBoxLayout):\n        \"\"\"\n        Build command to send to [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n        It is built based on the command name given in arguments,\n        and arguments strings fetched from the command button in the menu.\n\n        Emit the `signal_send_command` signal with the full command string as argument.\n\n        Arguments:\n            menu_name: menu to update (\"shell\", \"tool\", ...)\n            cmd: The command name\n            layout: The command button containing the command arguments\n        \"\"\"\n        i = 1\n        while i &lt; layout.count():\n            edit = layout.itemAt(i).widget()\n            text = edit.text()\n            if text == \"\":\n                return\n            cmd += f\" {text}\"\n            i += 1\n        self.signal_send_command.emit(menu_name, cmd)\n\n    @qtSlot()\n    def add_obstacle(self):\n        \"\"\"\n        Qt Slot\n\n        Receive signals from \"Add obstacle\" action.\n\n        Emit the `signal_add_obstacle` signal.\n        \"\"\"\n        self.signal_add_obstacle.emit()\n\n    @qtSlot()\n    def load_obstacles(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a file and load obstacles from it.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getOpenFileName(\n            parent=self,\n            caption=\"Select file to load obstacles\",\n            dir=\"\",\n            filter=\"JSON Files (*.json)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            self.signal_load_obstacles.emit(Path(filename))\n\n    @qtSlot()\n    def save_obstacles(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a file and save obstacles in it.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n            parent=self,\n            caption=\"Select file to save obstacles\",\n            dir=\"\",\n            filter=\"JSON Files (*.json)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            self.signal_save_obstacles.emit(Path(filename))\n\n    @qtSlot()\n    def open_actuators_control(self):\n        \"\"\"\n        Qt Slot\n\n        Open the actuators control dialog.\n        \"\"\"\n        self.signal_actuators_opened.emit()\n        self.actuators_dialog.show()\n        self.actuators_dialog.raise_()\n        self.actuators_dialog.activateWindow()\n\n    def display_help_camera_control(self):\n        \"\"\"\n        Qt Slot\n\n        Open camera control help dialog.\n        \"\"\"\n        self.help_camera_control.show()\n        self.help_camera_control.raise_()\n        self.help_camera_control.activateWindow()\n\n    @qtSlot()\n    def connected(self, state: bool):\n        \"\"\"\n        Qt Slot\n\n        Update the status bar with connected/disconnected state.\n\n        Arguments:\n            state: True if connected, False if disconnected\n        \"\"\"\n        self.connected_label.setText(\"Connected\" if state else \"Disconnected\")\n\n    @qtSlot(dict)\n    def config_request(self, config: dict[str, Any]):\n        properties = self.properties.get(f'{config[\"namespace\"]}/{config[\"title\"]}')\n        if not properties:\n            properties = PropertiesDialog(config, self)\n            self.properties[f'{config[\"namespace\"]}/{config[\"title\"]}'] = properties\n            properties.property_updated.connect(self.config_updated)\n        else:\n            properties.update_values(config)\n        properties.show()\n        properties.raise_()\n        properties.activateWindow()\n\n    @qtSlot(dict)\n    def config_updated(self, config: dict[str, Any]):\n        self.signal_config_updated.emit(config)\n\n    @qtSlot(dict)\n    def wizard_request(self, message: dict[str, Any]):\n        self.wizard = WizardDialog(message, self)\n        self.wizard.response.connect(self.wizard_response)\n        self.wizard.show()\n        self.wizard.raise_()\n        self.wizard.activateWindow()\n\n    @qtSlot()\n    def close_wizard(self):\n        if self.wizard:\n            self.wizard.response.disconnect(self.wizard_response)\n            self.wizard.close()\n            self.wizard = None\n\n    @qtSlot(dict)\n    def wizard_response(self, response: dict[str, Any]):\n        self.signal_wizard_response.emit(response)\n        self.wizard = None\n\n    def actuator_state(self, actuator_state: ActuatorState):\n        \"\"\"\n        Receive current state of an actuator.\n\n        Arguments:\n            actuator_state: current actuator state\n        \"\"\"\n        self.actuators_dialog.update_actuator(actuator_state)\n\n    def new_actuator_command(self, command: ActuatorCommand):\n        \"\"\"\n        Function called when an actuator control is modified in the actuators dialog.\n        Forward the command to server.\n\n        Arguments:\n            command: actuator command to send\n        \"\"\"\n        self.signal_new_actuator_command.emit(command)\n\n    def actuators_closed(self):\n        \"\"\"\n        Function called when the actuators dialog is closed.\n        Forward information to server, to stop emitting actuators state from the robot.\n        \"\"\"\n        self.signal_actuators_closed.emit()\n\n    def planner_reset(self):\n        \"\"\"\n        Reset all charts on Planner reset.\n        \"\"\"\n        for chart_view in self.charts_view.values():\n            chart_view.reset()\n\n    def starter_toggled(self, robot_id: int, checked: bool):\n        self.signal_starter_changed.emit(robot_id, checked)\n\n    def starter_changed(self, robot_id: int, checked: bool):\n        if starter_checkbox := self.robot_starters.get(robot_id):\n            enabled = starter_checkbox.isEnabled()\n            starter_checkbox.setEnabled(False)\n            starter_checkbox.setChecked(checked)\n            starter_checkbox.setEnabled(enabled)\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"geometry\", self.saveGeometry())\n        settings.setValue(\"windowState\", self.saveState())\n        for robot_id, view in self.charts_view.items():\n            settings.setValue(f\"charts_checked/{robot_id}\", view.isVisible())\n        settings.setValue(\"camera_params\", json.dumps(self.game_view.get_camera_params()))\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"geometry\"))\n        self.restoreState(settings.value(\"windowState\"))\n        try:\n            camera_params = json.loads(settings.value(\"camera_params\"))\n            self.game_view.set_camera_params(camera_params)\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.__init__","title":"<code>__init__(url, *args, **kwargs)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the copilot web server</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def __init__(self, url: str, *args, **kwargs):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        url: URL of the copilot web server\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.robot_status_row: dict[int, int] = {}\n    self.robot_starters: dict[int, QtWidgets.QCheckBox] = {}\n    self.charts_view: dict[int, ChartsView] = {}\n    self.available_chart_views: list[ChartsView] = []\n    self.menu_widgets: dict[str, dict[str, QtWidgets.QWidget]] = {}\n    self.wizard: WizardDialog | None = None\n\n    self.setWindowTitle(\"COGIP Monitor\")\n\n    self.central_widget = QtWidgets.QWidget()\n    self.central_layout = QtWidgets.QHBoxLayout()\n    self.central_widget.setLayout(self.central_layout)\n    self.setCentralWidget(self.central_widget)\n\n    # Menu bar\n    menubar = self.menuBar()\n    file_menu = menubar.addMenu(\"&amp;File\")\n    obstacles_menu = menubar.addMenu(\"&amp;Obstacles\")\n    self.view_menu = menubar.addMenu(\"&amp;View\")\n    help_menu = menubar.addMenu(\"&amp;Help\")\n\n    # Toolbars\n    file_toolbar = self.addToolBar(\"File\")\n    file_toolbar.setObjectName(\"File Toolbar\")\n    obstacles_toolbar = self.addToolBar(\"Obstacles\")\n    obstacles_toolbar.setObjectName(\"Obstacles Toolbar\")\n    actuators_toolbar = self.addToolBar(\"Obstacles\")\n    actuators_toolbar.setObjectName(\"Actuators Toolbar\")\n\n    # Status bar\n    status_bar = self.statusBar()\n\n    self.connected_label = QtWidgets.QLabel(\"Disconnected\")\n    status_bar.addPermanentWidget(self.connected_label, 1)\n\n    status_widget = QtWidgets.QWidget()\n    status_bar.addPermanentWidget(status_widget)\n\n    self.status_layout = QtWidgets.QGridLayout()\n    status_widget.setLayout(self.status_layout)\n\n    cycle_label = QtWidgets.QLabel(\"Cycle\")\n    self.status_layout.addWidget(cycle_label, 0, 1)\n\n    pos_x_label = QtWidgets.QLabel(\"X\")\n    self.status_layout.addWidget(pos_x_label, 0, 2)\n\n    pos_y_label = QtWidgets.QLabel(\"Y\")\n    self.status_layout.addWidget(pos_y_label, 0, 3)\n\n    pos_angle_label = QtWidgets.QLabel(\"Angle\")\n    self.status_layout.addWidget(pos_angle_label, 0, 4)\n\n    starter_label = QtWidgets.QLabel(\"Starter\")\n    self.status_layout.addWidget(starter_label, 0, 5)\n\n    # Actions\n    # Icons: https://commons.wikimedia.org/wiki/GNOME_Desktop_icons\n\n    # Exit action\n    self.exit_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"application-exit\"), \"Exit\", self)\n    self.exit_action.setShortcut(\"Ctrl+Q\")\n    self.exit_action.setStatusTip(\"Exit application\")\n    self.exit_action.triggered.connect(self.close)\n    file_menu.addAction(self.exit_action)\n    file_toolbar.addAction(self.exit_action)\n\n    # Add obstacle action\n    self.add_obstacle_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"list-add\"), \"Add obstacle\", self)\n    self.add_obstacle_action.setShortcut(\"Ctrl+A\")\n    self.add_obstacle_action.setStatusTip(\"Add obstacle\")\n    self.add_obstacle_action.triggered.connect(self.add_obstacle)\n    obstacles_menu.addAction(self.add_obstacle_action)\n    obstacles_toolbar.addAction(self.add_obstacle_action)\n\n    # Open obstacles action\n    self.load_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-open\"), \"Load obstacles\", self)\n    self.load_obstacles_action.setShortcut(\"Ctrl+O\")\n    self.load_obstacles_action.setStatusTip(\"Load obstacles\")\n    self.load_obstacles_action.triggered.connect(self.load_obstacles)\n    obstacles_menu.addAction(self.load_obstacles_action)\n    obstacles_toolbar.addAction(self.load_obstacles_action)\n\n    # Save obstacles action\n    self.save_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-save\"), \"Save obstacles\", self)\n    self.save_obstacles_action.setShortcut(\"Ctrl+S\")\n    self.save_obstacles_action.setStatusTip(\"Save obstacles\")\n    self.save_obstacles_action.triggered.connect(self.save_obstacles)\n    obstacles_menu.addAction(self.save_obstacles_action)\n    obstacles_toolbar.addAction(self.save_obstacles_action)\n\n    # Actuators control action\n    self.actuators_control_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"emblem-system\"), \"Actuators control\", self)\n    self.actuators_control_action.setStatusTip(\"Actuators control\")\n    self.actuators_control_action.triggered.connect(self.open_actuators_control)\n    actuators_toolbar.addAction(self.actuators_control_action)\n\n    # Console\n    dock = QtWidgets.QDockWidget(\"Console\")\n    dock.setObjectName(\"Console\")\n    dock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea)\n    self.log_text = QtWidgets.QTextEdit()\n    self.log_text.setReadOnly(True)\n    dock.setWidget(self.log_text)\n    self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)\n    file_menu.addAction(dock.toggleViewAction())\n    obstacles_menu.addAction(dock.toggleViewAction())\n\n    self.menu_tab_widget = QtWidgets.QTabWidget()\n    self.central_layout.insertWidget(0, self.menu_tab_widget, 1)\n\n    self.menu_staked_widgets: dict[str, QtWidgets.QStackedWidget] = {}\n\n    # GameView widget\n    self.game_view = GameView()\n    self.central_layout.insertWidget(1, self.game_view, 10)\n\n    # Help controls widget\n    self.help_camera_control = HelpCameraControlDialog(self)\n\n    # Properties windows\n    self.properties = {}\n\n    # Actuators control windows\n    self.actuators_dialog = ActuatorsDialog()\n    self.actuators_dialog.new_actuator_command.connect(self.new_actuator_command)\n    self.actuators_dialog.closed.connect(self.actuators_closed)\n\n    # Add help action\n    self.help_camera_control_action = QtGui.QAction(\"Camera control\", self)\n    self.help_camera_control_action.setStatusTip(\"Display camera control help\")\n    self.help_camera_control_action.triggered.connect(self.display_help_camera_control)\n    help_menu.addAction(self.help_camera_control_action)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.actuator_state","title":"<code>actuator_state(actuator_state)</code>","text":"<p>Receive current state of an actuator.</p> <p>Parameters:</p> Name Type Description Default <code>actuator_state</code> <code>ActuatorState</code> <p>current actuator state</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def actuator_state(self, actuator_state: ActuatorState):\n    \"\"\"\n    Receive current state of an actuator.\n\n    Arguments:\n        actuator_state: current actuator state\n    \"\"\"\n    self.actuators_dialog.update_actuator(actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.actuators_closed","title":"<code>actuators_closed()</code>","text":"<p>Function called when the actuators dialog is closed. Forward information to server, to stop emitting actuators state from the robot.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def actuators_closed(self):\n    \"\"\"\n    Function called when the actuators dialog is closed.\n    Forward information to server, to stop emitting actuators state from the robot.\n    \"\"\"\n    self.signal_actuators_closed.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.add_obstacle","title":"<code>add_obstacle()</code>","text":"<p>Qt Slot</p> <p>Receive signals from \"Add obstacle\" action.</p> <p>Emit the <code>signal_add_obstacle</code> signal.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef add_obstacle(self):\n    \"\"\"\n    Qt Slot\n\n    Receive signals from \"Add obstacle\" action.\n\n    Emit the `signal_add_obstacle` signal.\n    \"\"\"\n    self.signal_add_obstacle.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.add_robot","title":"<code>add_robot(robot_id, virtual_planner, virtual_detector)</code>","text":"<p>Add a new robot status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the new robot</p> required <code>virtual_planner</code> <code>bool</code> <p>whether the planner is virtual or not, if planner is virtual, use shared memory to get the robot current, pose order and obstacles.</p> required <code>virtual_detector</code> <code>bool</code> <p>whether the detector is virtual or not, if detector is virtual, detect virtual obstacles and write them in shared memory.</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def add_robot(self, robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n    \"\"\"\n    Add a new robot status bar.\n\n    Parameters:\n        robot_id: ID of the new robot\n        virtual_planner: whether the planner is virtual or not,\n            if planner is virtual, use shared memory to get the robot current, pose order and obstacles.\n        virtual_detector: whether the detector is virtual or not,\n            if detector is virtual, detect virtual obstacles and write them in shared memory.\n    \"\"\"\n    # Status bar\n    if robot_id in self.robot_status_row:\n        return\n\n    row = self.status_layout.rowCount()\n    self.robot_status_row[robot_id] = row\n\n    title_text = QtWidgets.QLabel(f\"Robot {robot_id}\")\n    self.status_layout.addWidget(title_text, row, 0)\n\n    cycle_text = QtWidgets.QLabel()\n    cycle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    cycle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(cycle_text, row, 1)\n\n    pos_x_text = QtWidgets.QLabel()\n    pos_x_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    pos_x_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(pos_x_text, row, 2)\n\n    pos_y_text = QtWidgets.QLabel()\n    pos_y_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    pos_y_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(pos_y_text, row, 3)\n\n    pos_angle_text = QtWidgets.QLabel()\n    pos_angle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    pos_angle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(pos_angle_text, row, 4)\n\n    self.robot_starters[robot_id] = (starter_checkbox := QtWidgets.QCheckBox())\n    self.status_layout.addWidget(starter_checkbox, row, 5)\n    starter_checkbox.setEnabled(virtual_planner)\n    starter_checkbox.toggled.connect(partial(self.starter_toggled, robot_id))\n\n    # Chart view\n    view = self.charts_view.get(robot_id)\n    if view is None:\n        if len(self.available_chart_views) == 0:\n            view = ChartsView(self)\n            self.available_chart_views.append(view)\n\n        view = self.available_chart_views.pop(0)\n        self.charts_view[robot_id] = view\n        view.set_robot_id(robot_id)\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        if settings.value(f\"charts_checked/{robot_id}\") == \"true\":\n            self.charts_toggled(robot_id, True)\n\n    self.update_view_menu()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.build_command","title":"<code>build_command(menu_name, cmd, layout)</code>","text":"<p>Build command to send to SocketioController.</p> <p>It is built based on the command name given in arguments, and arguments strings fetched from the command button in the menu.</p> <p>Emit the <code>signal_send_command</code> signal with the full command string as argument.</p> <p>Parameters:</p> Name Type Description Default <code>menu_name</code> <code>str</code> <p>menu to update (\"shell\", \"tool\", ...)</p> required <code>cmd</code> <code>str</code> <p>The command name</p> required <code>layout</code> <code>QHBoxLayout</code> <p>The command button containing the command arguments</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def build_command(self, menu_name: str, cmd: str, layout: QtWidgets.QHBoxLayout):\n    \"\"\"\n    Build command to send to [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n    It is built based on the command name given in arguments,\n    and arguments strings fetched from the command button in the menu.\n\n    Emit the `signal_send_command` signal with the full command string as argument.\n\n    Arguments:\n        menu_name: menu to update (\"shell\", \"tool\", ...)\n        cmd: The command name\n        layout: The command button containing the command arguments\n    \"\"\"\n    i = 1\n    while i &lt; layout.count():\n        edit = layout.itemAt(i).widget()\n        text = edit.text()\n        if text == \"\":\n            return\n        cmd += f\" {text}\"\n        i += 1\n    self.signal_send_command.emit(menu_name, cmd)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.charts_toggled","title":"<code>charts_toggled(robot_id, checked)</code>","text":"<p>Qt Slot</p> <p>Show/hide the calibration charts.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot corresponding to the chart view</p> required <code>checked</code> <code>bool</code> <p>Show action has checked or unchecked</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(bool)\ndef charts_toggled(self, robot_id: int, checked: bool):\n    \"\"\"\n    Qt Slot\n\n    Show/hide the calibration charts.\n\n    Arguments:\n        robot_id: ID of the robot corresponding to the chart view\n        checked: Show action has checked or unchecked\n    \"\"\"\n    view = self.charts_view.get(robot_id)\n    if view is None:\n        return\n\n    if checked:\n        view.show()\n        view.raise_()\n        view.activateWindow()\n    else:\n        view.close()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.connected","title":"<code>connected(state)</code>","text":"<p>Qt Slot</p> <p>Update the status bar with connected/disconnected state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>True if connected, False if disconnected</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef connected(self, state: bool):\n    \"\"\"\n    Qt Slot\n\n    Update the status bar with connected/disconnected state.\n\n    Arguments:\n        state: True if connected, False if disconnected\n    \"\"\"\n    self.connected_label.setText(\"Connected\" if state else \"Disconnected\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.del_robot","title":"<code>del_robot(robot_id)</code>","text":"<p>Remove a robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot to remove</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def del_robot(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Remove a robot.\n\n    Parameters:\n        robot_id: ID of the robot to remove\n    \"\"\"\n    # Status bar\n    row = self.robot_status_row.pop(robot_id)\n    if not row:\n        return\n\n    for i in range(7):\n        if not (item := self.status_layout.itemAtPosition(row, i)):\n            continue\n        widget = item.widget()\n        widget.setParent(None)\n        self.status_layout.removeWidget(widget)\n\n    # Chart view\n    self.charts_toggled(robot_id, False)\n    view = self.charts_view.pop(robot_id, None)\n    if view is None:\n        return\n    self.available_chart_views.append(view)\n    view.closed.disconnect()\n    self.update_view_menu()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.display_help_camera_control","title":"<code>display_help_camera_control()</code>","text":"<p>Qt Slot</p> <p>Open camera control help dialog.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def display_help_camera_control(self):\n    \"\"\"\n    Qt Slot\n\n    Open camera control help dialog.\n    \"\"\"\n    self.help_camera_control.show()\n    self.help_camera_control.raise_()\n    self.help_camera_control.activateWindow()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.load_menu","title":"<code>load_menu(menu_name, new_menu)</code>","text":"<p>Qt Slot</p> <p>Display the new menu sent by SocketioController.</p> <p>Once a menu has been build once, it is cached and reused.</p> <p>Parameters:</p> Name Type Description Default <code>menu_name</code> <code>str</code> <p>menu to update (\"shell\", \"tool\", ...)</p> required <code>new_menu</code> <code>ShellMenu</code> <p>The new menu information sent by the firmware</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(ShellMenu)\ndef load_menu(self, menu_name: str, new_menu: ShellMenu):\n    \"\"\"\n    Qt Slot\n\n    Display the new menu sent by [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n    Once a menu has been build once, it is cached and reused.\n\n    Arguments:\n        menu_name: menu to update (\"shell\", \"tool\", ...)\n        new_menu: The new menu information sent by the firmware\n    \"\"\"\n    if menu_name not in self.menu_staked_widgets:\n        self.menu_staked_widgets[menu_name] = QtWidgets.QStackedWidget()\n        empty_menu_widget = QtWidgets.QStackedWidget()\n        empty_menu_layout = QtWidgets.QVBoxLayout()\n        empty_menu_widget.setLayout(empty_menu_layout)\n        empty_menu_title = QtWidgets.QLabel(\"No menu loaded\")\n        empty_menu_title.setTextFormat(QtCore.Qt.RichText)\n        empty_menu_title.setAlignment(QtCore.Qt.AlignHCenter)\n        empty_menu_title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        empty_menu_title.setStyleSheet(\"font-weight: bold; color: #d01b1e\")\n        empty_menu_layout.addWidget(empty_menu_title)\n        empty_menu_layout.addStretch()\n        self.menu_staked_widgets[menu_name].addWidget(empty_menu_widget)\n        self.menu_tab_widget.addTab(self.menu_staked_widgets[menu_name], menu_name)\n\n    if menu_name not in self.menu_widgets:\n        self.menu_widgets[menu_name] = {}\n\n    widget = self.menu_widgets[menu_name].get(new_menu.name)\n    if not widget:\n        # Create a new menu\n        widget = QtWidgets.QWidget()\n        layout = QtWidgets.QVBoxLayout()\n        widget.setLayout(layout)\n        self.menu_widgets[menu_name][new_menu.name] = widget\n        self.menu_staked_widgets[menu_name].addWidget(widget)\n\n    # Clear menu to rebuild it in case it has changed\n    layout = widget.layout()\n    while layout.count():\n        child = layout.takeAt(0)\n        if child.widget():\n            child.widget().deleteLater()\n\n    title = QtWidgets.QLabel(new_menu.name)\n    title.setTextFormat(QtCore.Qt.RichText)\n    title.setAlignment(QtCore.Qt.AlignHCenter)\n    title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    title.setStyleSheet(\"font-weight: bold; color: #d01b1e\")\n    layout.addWidget(title)\n\n    for entry in new_menu.entries:\n        if entry.cmd[0] == \"_\":\n            continue\n        cmd_widget = QtWidgets.QWidget()\n        cmd_layout = QtWidgets.QHBoxLayout()\n        cmd_layout.setContentsMargins(0, 0, 0, 0)\n        cmd_widget.setLayout(cmd_layout)\n        layout.addWidget(cmd_widget)\n\n        desc, args = split_command(entry.desc)\n        button = QtWidgets.QPushButton(desc)\n        cmd_layout.addWidget(button)\n\n        for arg in args:\n            edit = QtWidgets.QLineEdit()\n            edit.setPlaceholderText(arg)\n            edit.setToolTip(arg)\n            cmd_layout.addWidget(edit)\n            edit.returnPressed.connect(\n                lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout)\n            )\n        button.clicked.connect(lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout))\n\n    layout.addStretch()\n\n    self.menu_staked_widgets[menu_name].setCurrentWidget(widget)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.load_obstacles","title":"<code>load_obstacles()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a file and load obstacles from it.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef load_obstacles(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a file and load obstacles from it.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getOpenFileName(\n        parent=self,\n        caption=\"Select file to load obstacles\",\n        dir=\"\",\n        filter=\"JSON Files (*.json)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        self.signal_load_obstacles.emit(Path(filename))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.new_actuator_command","title":"<code>new_actuator_command(command)</code>","text":"<p>Function called when an actuator control is modified in the actuators dialog. Forward the command to server.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ActuatorCommand</code> <p>actuator command to send</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def new_actuator_command(self, command: ActuatorCommand):\n    \"\"\"\n    Function called when an actuator control is modified in the actuators dialog.\n    Forward the command to server.\n\n    Arguments:\n        command: actuator command to send\n    \"\"\"\n    self.signal_new_actuator_command.emit(command)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.new_robot_pose","title":"<code>new_robot_pose(robot_id, pose)</code>","text":"<p>Update robot position information in the status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>pose</code> <code>Pose</code> <p>Robot pose</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def new_robot_pose(self, robot_id: int, pose: Pose):\n    \"\"\"\n    Update robot position information in the status bar.\n\n    Arguments:\n        robot_id: ID of the robot\n        pose: Robot pose\n    \"\"\"\n    row = self.robot_status_row.get(robot_id)\n    if not row:\n        return\n    self.status_layout.itemAtPosition(row, 2).widget().setText(f\"{int(pose.x):&gt; #6d}\")\n    self.status_layout.itemAtPosition(row, 3).widget().setText(f\"{int(pose.y):&gt; #6d}\")\n    self.status_layout.itemAtPosition(row, 4).widget().setText(f\"{int(pose.O):&gt; #4d}\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.new_robot_state","title":"<code>new_robot_state(robot_id, state)</code>","text":"<p>Qt Slot</p> <p>Update robot state information in the status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>state</code> <code>RobotState</code> <p>Robot state</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(RobotState)\ndef new_robot_state(self, robot_id: int, state: RobotState):\n    \"\"\"\n    Qt Slot\n\n    Update robot state information in the status bar.\n\n    Arguments:\n        robot_id: ID of the robot\n        state: Robot state\n    \"\"\"\n    row = self.robot_status_row.get(robot_id)\n    if not row:\n        return\n    self.status_layout.itemAtPosition(row, 1).widget().setText(f\"{state.cycle or 0:&gt;#6d}\")\n\n    charts_view = self.charts_view.get(robot_id)\n    if charts_view:\n        charts_view.new_robot_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.open_actuators_control","title":"<code>open_actuators_control()</code>","text":"<p>Qt Slot</p> <p>Open the actuators control dialog.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef open_actuators_control(self):\n    \"\"\"\n    Qt Slot\n\n    Open the actuators control dialog.\n    \"\"\"\n    self.signal_actuators_opened.emit()\n    self.actuators_dialog.show()\n    self.actuators_dialog.raise_()\n    self.actuators_dialog.activateWindow()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.planner_reset","title":"<code>planner_reset()</code>","text":"<p>Reset all charts on Planner reset.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def planner_reset(self):\n    \"\"\"\n    Reset all charts on Planner reset.\n    \"\"\"\n    for chart_view in self.charts_view.values():\n        chart_view.reset()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.save_obstacles","title":"<code>save_obstacles()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a file and save obstacles in it.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef save_obstacles(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a file and save obstacles in it.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n        parent=self,\n        caption=\"Select file to save obstacles\",\n        dir=\"\",\n        filter=\"JSON Files (*.json)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        self.signal_save_obstacles.emit(Path(filename))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.update_view_menu","title":"<code>update_view_menu()</code>","text":"<p>Rebuild all the view menu to update the calibration charts sub-menu.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def update_view_menu(self):\n    \"\"\"\n    Rebuild all the view menu to update the calibration charts sub-menu.\n    \"\"\"\n    self.view_menu.clear()\n    if len(self.charts_view):\n        calibration_menu = self.view_menu.addMenu(\"Calibration Charts\")\n        for robot_id, view in self.charts_view.items():\n            action = calibration_menu.addAction(f\"Robot {robot_id}\")\n            action.setCheckable(True)\n            action.toggled.connect(partial(self.charts_toggled, robot_id))\n            if view.isVisible():\n                action.setChecked(True)\n            view.closed.connect(partial(action.setChecked, False))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.split_command","title":"<code>split_command(command)</code>","text":"<p>Split the full command string to separate the name of the command and its arguments.</p> <p>The command is in the following format:</p> <pre><code>\"command name &lt;arg1&gt; &lt;arg2&gt; ...\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command string to split</p> required Return <p>A tuple of the command name and a list of arguments</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def split_command(command: str) -&gt; tuple[str, list[str]]:\n    \"\"\"\n    Split the full command string to separate the name of the command\n    and its arguments.\n\n    The command is in the following format:\n    ```\n    \"command name &lt;arg1&gt; &lt;arg2&gt; ...\"\n    ```\n\n    Arguments:\n        command: The command string to split\n\n    Return:\n        A tuple of the command name and a list of arguments\n    \"\"\"\n    result: list[str] = list()\n    arg_match = re.findall(r\"(&lt;[\\d\\w]+&gt;)\", command)\n    for arg in arg_match:\n        result.append(arg[1:-1])\n        command = command.replace(arg, \"\")\n    command = command.strip()\n    return (command, result)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/","title":"obstacle","text":""},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity","title":"<code>ObstacleEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>An obstacle on the table.</p> <p>It is represented as a cube (QCuboidMesh).</p> <p>When selected with a mouse click, a property window is displayed to modify the obstacle properties.</p> <p>The obstacle can also be moved using the mouse.</p> <p>Attributes:</p> Name Type Description <code>enable_controller</code> <p>Qt signal used to disable the camera controller when moving the obstacle using the mouse</p> <code>obstacle_moved</code> <code>Signal</code> <p>Qt signal emitted after the obstacle has been moved</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>class ObstacleEntity(Qt3DCore.QEntity):\n    \"\"\"\n    An obstacle on the table.\n\n    It is represented as a cube ([QCuboidMesh](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/QCuboidMesh.html)).\n\n    When selected with a mouse click, a property window is displayed\n    to modify the obstacle properties.\n\n    The obstacle can also be moved using the mouse.\n\n    Attributes:\n        enable_controller: Qt signal used to disable the camera controller\n            when moving the obstacle using the mouse\n        obstacle_moved: Qt signal emitted after the obstacle has been moved\n    \"\"\"\n\n    enable_controller = qtSignal(bool)\n    obstacle_moved: qtSignal = qtSignal()\n\n    def __init__(\n        self,\n        parent_widget: QtWidgets.QWidget,\n        x: int = 0,\n        y: int = 0,\n        rotation: int = 0,\n        length: int = 225,\n        width: int = 225,\n        height: int = 350,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent_widget: Parent widget\n            x: X position\n            y: Y position\n            rotation: Rotation\n            length: Length\n            width: Width\n            height: Height\n        \"\"\"\n        super().__init__()\n\n        self.parent_widget = parent_widget\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setXExtent(width)\n        self.mesh.setYExtent(length)\n        self.mesh.setZExtent(height)\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial(self)\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n        self.transform.setRotationZ(rotation)\n        self.addComponent(self.transform)\n\n        self.picker = Qt3DRender.QObjectPicker()\n        self.picker.setDragEnabled(True)\n        self.picker.pressed.connect(self.pressed_obstacle)\n        self.picker.released.connect(self.released_obstacle)\n        self.picker.moved.connect(self.moved_obstacle)\n        self.addComponent(self.picker)\n\n        self.beacon_entity = Qt3DCore.QEntity(self)\n        self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n        self.beacon_mesh.setLength(80)\n        self.beacon_mesh.setRadius(35)\n        self.beacon_entity.addComponent(self.beacon_mesh)\n\n        self.beacon_material = Qt3DExtras.QPhongMaterial(self.beacon_entity)\n        self.beacon_entity.addComponent(self.beacon_material)\n\n        self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n        self.beacon_transform.setTranslation(\n            QtGui.QVector3D(0, 0, self.mesh.zExtent() / 2 + self.beacon_mesh.length() / 2)\n        )\n        self.beacon_transform.setRotationX(90)\n        self.beacon_entity.addComponent(self.beacon_transform)\n\n        self.moving = False\n\n        self.mesh.zExtentChanged.connect(self.updateZTranslation)\n\n        # Create a layer used by sensors to activate detection on the obstacles\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        # Create properties dialog\n        self.properties = ObstacleProperties(self.parent_widget, self)\n\n        Sensor.add_obstacle(self)\n\n    @qtSlot(float)\n    def updateZTranslation(self, zExtent: float):\n        \"\"\"\n        Qt Slot\n\n        Update the Z position based on the obstacle height.\n        This function is called each time the height is modified\n        to set the bottom on Z=0.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setZ(zExtent / 2)\n        self.transform.setTranslation(translation)\n\n    @qtSlot(int)\n    def setXTranslation(self, x: int):\n        \"\"\"\n        Qt Slot\n\n        Set the X position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setX(float(x))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(int)\n    def setYTranslation(self, y: int):\n        \"\"\"\n        Qt Slot\n\n        Set the Y position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setY(float(y))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def pressed_obstacle(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```pressed``` mouse event on the obstacle.\n\n        Emit a signal to disable the camera controller before moving the obstacle.\n        \"\"\"\n        self.enable_controller.emit(False)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def released_obstacle(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```released``` mouse event on the obstacle.\n\n        If this event occurs just after a ```pressed``` event, it is only a mouse click,\n        so display the property window.\n\n        Emit a signal to re-enable the camera controller after moving the obstacle.\n        \"\"\"\n        if not self.moving:\n            if ObstacleProperties.active_properties:\n                ObstacleProperties.active_properties.close()\n            self.properties.show()\n            self.properties.raise_()\n            self.properties.activateWindow()\n            ObstacleProperties.set_active_properties(self.properties)\n        self.moving = False\n        self.enable_controller.emit(True)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def moved_obstacle(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```moved``` mouse event on the obstacle.\n\n        Just record that the obstacle is moving, the translation is computed\n        in the [GameView][cogip.tools.monitor.gameview.GameView] object.\n        \"\"\"\n        self.moving = True\n\n    def get_model(self) -&gt; models.Obstacle:\n        \"\"\"\n        Returns the [Obstacle][cogip.models.models.Obstacle] model.\n        Used to save the obstacles list.\n\n        Returns:\n            The obstacle model\n        \"\"\"\n        return models.Obstacle(\n            x=self.transform.translation().x(),\n            y=self.transform.translation().y(),\n            rotation=self.transform.rotationZ(),\n            length=self.mesh.yExtent(),\n            width=self.mesh.xExtent(),\n            height=self.mesh.zExtent(),\n        )\n\n    @qtSlot(QtGui.QVector3D)\n    def new_move_delta(self, delta: QtGui.QVector3D):\n        \"\"\"\n        Qt Slot\n\n        Update the obstacle position.\n\n        Arguments:\n            delta: The difference between current and new position\n        \"\"\"\n        if not delta:\n            self.moving = False\n        elif self.moving:\n            new_translation = self.transform.translation() + delta\n            self.transform.setTranslation(new_translation)\n            self.properties.spin_x.setValue(new_translation.x())\n            self.properties.spin_y.setValue(new_translation.y())\n            self.obstacle_moved.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.__init__","title":"<code>__init__(parent_widget, x=0, y=0, rotation=0, length=225, width=225, height=350)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Parent widget</p> required <code>x</code> <code>int</code> <p>X position</p> <code>0</code> <code>y</code> <code>int</code> <p>Y position</p> <code>0</code> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>0</code> <code>length</code> <code>int</code> <p>Length</p> <code>225</code> <code>width</code> <code>int</code> <p>Width</p> <code>225</code> <code>height</code> <code>int</code> <p>Height</p> <code>350</code> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>def __init__(\n    self,\n    parent_widget: QtWidgets.QWidget,\n    x: int = 0,\n    y: int = 0,\n    rotation: int = 0,\n    length: int = 225,\n    width: int = 225,\n    height: int = 350,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent_widget: Parent widget\n        x: X position\n        y: Y position\n        rotation: Rotation\n        length: Length\n        width: Width\n        height: Height\n    \"\"\"\n    super().__init__()\n\n    self.parent_widget = parent_widget\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setXExtent(width)\n    self.mesh.setYExtent(length)\n    self.mesh.setZExtent(height)\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial(self)\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n    self.transform.setRotationZ(rotation)\n    self.addComponent(self.transform)\n\n    self.picker = Qt3DRender.QObjectPicker()\n    self.picker.setDragEnabled(True)\n    self.picker.pressed.connect(self.pressed_obstacle)\n    self.picker.released.connect(self.released_obstacle)\n    self.picker.moved.connect(self.moved_obstacle)\n    self.addComponent(self.picker)\n\n    self.beacon_entity = Qt3DCore.QEntity(self)\n    self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n    self.beacon_mesh.setLength(80)\n    self.beacon_mesh.setRadius(35)\n    self.beacon_entity.addComponent(self.beacon_mesh)\n\n    self.beacon_material = Qt3DExtras.QPhongMaterial(self.beacon_entity)\n    self.beacon_entity.addComponent(self.beacon_material)\n\n    self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n    self.beacon_transform.setTranslation(\n        QtGui.QVector3D(0, 0, self.mesh.zExtent() / 2 + self.beacon_mesh.length() / 2)\n    )\n    self.beacon_transform.setRotationX(90)\n    self.beacon_entity.addComponent(self.beacon_transform)\n\n    self.moving = False\n\n    self.mesh.zExtentChanged.connect(self.updateZTranslation)\n\n    # Create a layer used by sensors to activate detection on the obstacles\n    self.layer = Qt3DRender.QLayer(self)\n    self.layer.setRecursive(True)\n    self.layer.setEnabled(True)\n    self.addComponent(self.layer)\n\n    # Create properties dialog\n    self.properties = ObstacleProperties(self.parent_widget, self)\n\n    Sensor.add_obstacle(self)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.get_model","title":"<code>get_model()</code>","text":"<p>Returns the Obstacle model. Used to save the obstacles list.</p> <p>Returns:</p> Type Description <code>Obstacle</code> <p>The obstacle model</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>def get_model(self) -&gt; models.Obstacle:\n    \"\"\"\n    Returns the [Obstacle][cogip.models.models.Obstacle] model.\n    Used to save the obstacles list.\n\n    Returns:\n        The obstacle model\n    \"\"\"\n    return models.Obstacle(\n        x=self.transform.translation().x(),\n        y=self.transform.translation().y(),\n        rotation=self.transform.rotationZ(),\n        length=self.mesh.yExtent(),\n        width=self.mesh.xExtent(),\n        height=self.mesh.zExtent(),\n    )\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.moved_obstacle","title":"<code>moved_obstacle(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>moved</code> mouse event on the obstacle.</p> <p>Just record that the obstacle is moving, the translation is computed in the GameView object.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef moved_obstacle(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```moved``` mouse event on the obstacle.\n\n    Just record that the obstacle is moving, the translation is computed\n    in the [GameView][cogip.tools.monitor.gameview.GameView] object.\n    \"\"\"\n    self.moving = True\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.new_move_delta","title":"<code>new_move_delta(delta)</code>","text":"<p>Qt Slot</p> <p>Update the obstacle position.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>QVector3D</code> <p>The difference between current and new position</p> required Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(QtGui.QVector3D)\ndef new_move_delta(self, delta: QtGui.QVector3D):\n    \"\"\"\n    Qt Slot\n\n    Update the obstacle position.\n\n    Arguments:\n        delta: The difference between current and new position\n    \"\"\"\n    if not delta:\n        self.moving = False\n    elif self.moving:\n        new_translation = self.transform.translation() + delta\n        self.transform.setTranslation(new_translation)\n        self.properties.spin_x.setValue(new_translation.x())\n        self.properties.spin_y.setValue(new_translation.y())\n        self.obstacle_moved.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.pressed_obstacle","title":"<code>pressed_obstacle(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>pressed</code> mouse event on the obstacle.</p> <p>Emit a signal to disable the camera controller before moving the obstacle.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef pressed_obstacle(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```pressed``` mouse event on the obstacle.\n\n    Emit a signal to disable the camera controller before moving the obstacle.\n    \"\"\"\n    self.enable_controller.emit(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.released_obstacle","title":"<code>released_obstacle(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>released</code> mouse event on the obstacle.</p> <p>If this event occurs just after a <code>pressed</code> event, it is only a mouse click, so display the property window.</p> <p>Emit a signal to re-enable the camera controller after moving the obstacle.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef released_obstacle(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```released``` mouse event on the obstacle.\n\n    If this event occurs just after a ```pressed``` event, it is only a mouse click,\n    so display the property window.\n\n    Emit a signal to re-enable the camera controller after moving the obstacle.\n    \"\"\"\n    if not self.moving:\n        if ObstacleProperties.active_properties:\n            ObstacleProperties.active_properties.close()\n        self.properties.show()\n        self.properties.raise_()\n        self.properties.activateWindow()\n        ObstacleProperties.set_active_properties(self.properties)\n    self.moving = False\n    self.enable_controller.emit(True)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.setXTranslation","title":"<code>setXTranslation(x)</code>","text":"<p>Qt Slot</p> <p>Set the X position.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(int)\ndef setXTranslation(self, x: int):\n    \"\"\"\n    Qt Slot\n\n    Set the X position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setX(float(x))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.setYTranslation","title":"<code>setYTranslation(y)</code>","text":"<p>Qt Slot</p> <p>Set the Y position.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(int)\ndef setYTranslation(self, y: int):\n    \"\"\"\n    Qt Slot\n\n    Set the Y position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setY(float(y))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleEntity.updateZTranslation","title":"<code>updateZTranslation(zExtent)</code>","text":"<p>Qt Slot</p> <p>Update the Z position based on the obstacle height. This function is called each time the height is modified to set the bottom on Z=0.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@qtSlot(float)\ndef updateZTranslation(self, zExtent: float):\n    \"\"\"\n    Qt Slot\n\n    Update the Z position based on the obstacle height.\n    This function is called each time the height is modified\n    to set the bottom on Z=0.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setZ(zExtent / 2)\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleProperties","title":"<code>ObstacleProperties</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>The property window.</p> <p>Each obstacle has its own property window.</p> <p>Attributes:</p> Name Type Description <code>active_properties</code> <code>ObstacleProperties</code> <p>The current property window displayed.</p> Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>class ObstacleProperties(QtWidgets.QDialog):\n    \"\"\"\n    The property window.\n\n    Each obstacle has its own property window.\n\n    Attributes:\n        active_properties: The current property window displayed.\n    \"\"\"\n\n    active_properties: \"ObstacleProperties\" = None\n\n    def __init__(self, parent: QtWidgets.QWidget, obstacle_entity: ObstacleEntity):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n            obstacle_entity: The related obstacle entity\n        \"\"\"\n        super().__init__(parent)\n\n        self.obstacle_entity = obstacle_entity\n        self.setWindowTitle(\"Obstacle Properties\")\n        self.setModal(False)\n        self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        row = 0\n\n        label_x = QtWidgets.QLabel(\"X\")\n        self.spin_x = QtWidgets.QSpinBox()\n        self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_x.setMinimum(-1000)\n        self.spin_x.setMaximum(1000)\n        self.spin_x.setValue(int(self.obstacle_entity.transform.translation().x()))\n        self.spin_x.valueChanged.connect(self.obstacle_entity.setXTranslation)\n        layout.addWidget(label_x, row, 0)\n        layout.addWidget(self.spin_x, row, 1)\n        row += 1\n\n        label_y = QtWidgets.QLabel(\"Y\")\n        self.spin_y = QtWidgets.QSpinBox()\n        self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_y.setMinimum(-1500)\n        self.spin_y.setMaximum(1500)\n        self.spin_y.setValue(int(self.obstacle_entity.transform.translation().y()))\n        self.spin_y.valueChanged.connect(self.obstacle_entity.setYTranslation)\n        layout.addWidget(label_y, row, 0)\n        layout.addWidget(self.spin_y, row, 1)\n        row += 1\n\n        label_rotation = QtWidgets.QLabel(\"Rotation\")\n        self.spin_rotation = QtWidgets.QSpinBox()\n        self.spin_rotation.setSuffix(\"\u00b0\")\n        self.spin_rotation.setMinimum(-180)\n        self.spin_rotation.setMaximum(180)\n        self.spin_rotation.setValue(int(self.obstacle_entity.transform.rotationZ()))\n        self.spin_rotation.valueChanged.connect(self.obstacle_entity.transform.setRotationZ)\n        layout.addWidget(label_rotation, row, 0)\n        layout.addWidget(self.spin_rotation, row, 1)\n        row += 1\n\n        label_width = QtWidgets.QLabel(\"Width\")\n        self.spin_width = QtWidgets.QSpinBox()\n        self.spin_width.setMaximum(2000)\n        self.spin_width.setSingleStep(10)\n        self.spin_width.setValue(int(self.obstacle_entity.mesh.xExtent()))\n        self.spin_width.valueChanged.connect(self.obstacle_entity.mesh.setXExtent)\n        layout.addWidget(label_width, row, 0)\n        layout.addWidget(self.spin_width, row, 1)\n        row += 1\n\n        label_length = QtWidgets.QLabel(\"Length\")\n        self.spin_length = QtWidgets.QSpinBox()\n        self.spin_length.setMaximum(2000)\n        self.spin_length.setSingleStep(10)\n        self.spin_length.setValue(int(self.obstacle_entity.mesh.yExtent()))\n        self.spin_length.valueChanged.connect(self.obstacle_entity.mesh.setYExtent)\n        layout.addWidget(label_length, row, 0)\n        layout.addWidget(self.spin_length, row, 1)\n        row += 1\n\n        label_height = QtWidgets.QLabel(\"Height\")\n        self.spin_height = QtWidgets.QSpinBox()\n        self.spin_height.setMaximum(1000)\n        self.spin_height.setSingleStep(10)\n        self.spin_height.setValue(int(self.obstacle_entity.mesh.zExtent()))\n        self.spin_height.valueChanged.connect(self.obstacle_entity.mesh.setZExtent)\n        layout.addWidget(label_height, row, 0)\n        layout.addWidget(self.spin_height, row, 1)\n        row += 1\n\n        self.readSettings()\n\n    @classmethod\n    def set_active_properties(cls, properties: \"ObstacleProperties\"):\n        \"\"\"\n        Class method.\n\n        Set the current property window displayed.\n\n        Arguments:\n            properties: The current property\n        \"\"\"\n        cls.active_properties = properties\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Close the property windows.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        ObstacleProperties.set_active_properties(None)\n\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"obstacle_dialog/geometry\", self.saveGeometry())\n\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"obstacle_dialog/geometry\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleProperties.__init__","title":"<code>__init__(parent, obstacle_entity)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>obstacle_entity</code> <code>ObstacleEntity</code> <p>The related obstacle entity</p> required Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget, obstacle_entity: ObstacleEntity):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n        obstacle_entity: The related obstacle entity\n    \"\"\"\n    super().__init__(parent)\n\n    self.obstacle_entity = obstacle_entity\n    self.setWindowTitle(\"Obstacle Properties\")\n    self.setModal(False)\n    self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    row = 0\n\n    label_x = QtWidgets.QLabel(\"X\")\n    self.spin_x = QtWidgets.QSpinBox()\n    self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_x.setMinimum(-1000)\n    self.spin_x.setMaximum(1000)\n    self.spin_x.setValue(int(self.obstacle_entity.transform.translation().x()))\n    self.spin_x.valueChanged.connect(self.obstacle_entity.setXTranslation)\n    layout.addWidget(label_x, row, 0)\n    layout.addWidget(self.spin_x, row, 1)\n    row += 1\n\n    label_y = QtWidgets.QLabel(\"Y\")\n    self.spin_y = QtWidgets.QSpinBox()\n    self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_y.setMinimum(-1500)\n    self.spin_y.setMaximum(1500)\n    self.spin_y.setValue(int(self.obstacle_entity.transform.translation().y()))\n    self.spin_y.valueChanged.connect(self.obstacle_entity.setYTranslation)\n    layout.addWidget(label_y, row, 0)\n    layout.addWidget(self.spin_y, row, 1)\n    row += 1\n\n    label_rotation = QtWidgets.QLabel(\"Rotation\")\n    self.spin_rotation = QtWidgets.QSpinBox()\n    self.spin_rotation.setSuffix(\"\u00b0\")\n    self.spin_rotation.setMinimum(-180)\n    self.spin_rotation.setMaximum(180)\n    self.spin_rotation.setValue(int(self.obstacle_entity.transform.rotationZ()))\n    self.spin_rotation.valueChanged.connect(self.obstacle_entity.transform.setRotationZ)\n    layout.addWidget(label_rotation, row, 0)\n    layout.addWidget(self.spin_rotation, row, 1)\n    row += 1\n\n    label_width = QtWidgets.QLabel(\"Width\")\n    self.spin_width = QtWidgets.QSpinBox()\n    self.spin_width.setMaximum(2000)\n    self.spin_width.setSingleStep(10)\n    self.spin_width.setValue(int(self.obstacle_entity.mesh.xExtent()))\n    self.spin_width.valueChanged.connect(self.obstacle_entity.mesh.setXExtent)\n    layout.addWidget(label_width, row, 0)\n    layout.addWidget(self.spin_width, row, 1)\n    row += 1\n\n    label_length = QtWidgets.QLabel(\"Length\")\n    self.spin_length = QtWidgets.QSpinBox()\n    self.spin_length.setMaximum(2000)\n    self.spin_length.setSingleStep(10)\n    self.spin_length.setValue(int(self.obstacle_entity.mesh.yExtent()))\n    self.spin_length.valueChanged.connect(self.obstacle_entity.mesh.setYExtent)\n    layout.addWidget(label_length, row, 0)\n    layout.addWidget(self.spin_length, row, 1)\n    row += 1\n\n    label_height = QtWidgets.QLabel(\"Height\")\n    self.spin_height = QtWidgets.QSpinBox()\n    self.spin_height.setMaximum(1000)\n    self.spin_height.setSingleStep(10)\n    self.spin_height.setValue(int(self.obstacle_entity.mesh.zExtent()))\n    self.spin_height.valueChanged.connect(self.obstacle_entity.mesh.setZExtent)\n    layout.addWidget(label_height, row, 0)\n    layout.addWidget(self.spin_height, row, 1)\n    row += 1\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleProperties.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Close the property windows.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Close the property windows.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    ObstacleProperties.set_active_properties(None)\n\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"obstacle_dialog/geometry\", self.saveGeometry())\n\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/#cogip.tools.monitor.obstacle.ObstacleProperties.set_active_properties","title":"<code>set_active_properties(properties)</code>  <code>classmethod</code>","text":"<p>Class method.</p> <p>Set the current property window displayed.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>ObstacleProperties</code> <p>The current property</p> required Source code in <code>cogip/tools/monitor/obstacle.py</code> <pre><code>@classmethod\ndef set_active_properties(cls, properties: \"ObstacleProperties\"):\n    \"\"\"\n    Class method.\n\n    Set the current property window displayed.\n\n    Arguments:\n        properties: The current property\n    \"\"\"\n    cls.active_properties = properties\n</code></pre>"},{"location":"reference/cogip/tools/monitor/path/","title":"path","text":""},{"location":"reference/cogip/tools/monitor/path/#cogip.tools.monitor.path.PathEntity","title":"<code>PathEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A simple entity drawing a path along a list of vertices.</p> Source code in <code>cogip/tools/monitor/path.py</code> <pre><code>class PathEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A simple entity drawing a path along a list of vertices.\n    \"\"\"\n\n    def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            color: color\n            parent: parent entity\n        \"\"\"\n        super().__init__(parent)\n        self.points = []\n        self.color = color\n        self.lines: list[LineEntity] = []\n        self.lines_pool: list[LineEntity] = []\n\n    def set_points(self, points: list[models.Vertex]):\n        \"\"\"\n        Set points of the path.\n\n        Arguments:\n            points: list of vertices composing the line\n        \"\"\"\n        self.points = points\n\n        if len(self.points) &lt; 2:\n            return\n\n        self.points += [self.points[0]]\n\n        for line in self.lines:\n            line.setEnabled(False)\n            self.lines_pool.append(line)\n\n        self.lines = []\n\n        start = self.points.pop(0)\n        for next in self.points:\n            if len(self.lines_pool) == 0:\n                self.lines_pool.append(LineEntity(self.color, self))\n            line = self.lines_pool.pop()\n            line.setEnabled(True)\n            line.set_points(start, next)\n            self.lines.append(line)\n            start = next\n</code></pre>"},{"location":"reference/cogip/tools/monitor/path/#cogip.tools.monitor.path.PathEntity.__init__","title":"<code>__init__(color=QtCore.Qt.blue, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>color</p> <code>blue</code> <code>parent</code> <code>QEntity | None</code> <p>parent entity</p> <code>None</code> Source code in <code>cogip/tools/monitor/path.py</code> <pre><code>def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        color: color\n        parent: parent entity\n    \"\"\"\n    super().__init__(parent)\n    self.points = []\n    self.color = color\n    self.lines: list[LineEntity] = []\n    self.lines_pool: list[LineEntity] = []\n</code></pre>"},{"location":"reference/cogip/tools/monitor/path/#cogip.tools.monitor.path.PathEntity.set_points","title":"<code>set_points(points)</code>","text":"<p>Set points of the path.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Vertex]</code> <p>list of vertices composing the line</p> required Source code in <code>cogip/tools/monitor/path.py</code> <pre><code>def set_points(self, points: list[models.Vertex]):\n    \"\"\"\n    Set points of the path.\n\n    Arguments:\n        points: list of vertices composing the line\n    \"\"\"\n    self.points = points\n\n    if len(self.points) &lt; 2:\n        return\n\n    self.points += [self.points[0]]\n\n    for line in self.lines:\n        line.setEnabled(False)\n        self.lines_pool.append(line)\n\n    self.lines = []\n\n    start = self.points.pop(0)\n    for next in self.points:\n        if len(self.lines_pool) == 0:\n            self.lines_pool.append(LineEntity(self.color, self))\n        line = self.lines_pool.pop()\n        line.setEnabled(True)\n        line.set_points(start, next)\n        self.lines.append(line)\n        start = next\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.BoolProperty","title":"<code>BoolProperty</code>","text":"<p>               Bases: <code>QObject</code></p> <p>BoolProperty class.</p> <p>Build a widget to configure a bool property.</p> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>class BoolProperty(QtCore.QObject):\n    \"\"\"\n    BoolProperty class.\n\n    Build a widget to configure a bool property.\n    \"\"\"\n\n    value_updated: qtSignal = qtSignal(str, int)\n\n    def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: property name\n            props: properties of the bool property\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self._name = name\n\n        row = layout.rowCount()\n        help = props.get(\"description\")\n\n        label = QtWidgets.QLabel(props[\"title\"])\n        label.setToolTip(help)\n        layout.addWidget(label, row, 0)\n\n        self._value = QtWidgets.QCheckBox()\n        self._value.setToolTip(help)\n        self._value.stateChanged.connect(self.value_changed)\n        self._value.setChecked(props[\"value\"])\n        layout.addWidget(self._value, row, 1)\n\n    def value_changed(self, value: int):\n        self.value_updated.emit(self._name, value == QtCore.Qt.CheckState.Checked.value)\n\n    def update_value(self, value):\n        self._value.blockSignals(True)\n        self._value.setChecked(value)\n        self._value.blockSignals(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.BoolProperty.__init__","title":"<code>__init__(name, props, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>property name</p> required <code>props</code> <code>dict[str, Any]</code> <p>properties of the bool property</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: property name\n        props: properties of the bool property\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self._name = name\n\n    row = layout.rowCount()\n    help = props.get(\"description\")\n\n    label = QtWidgets.QLabel(props[\"title\"])\n    label.setToolTip(help)\n    layout.addWidget(label, row, 0)\n\n    self._value = QtWidgets.QCheckBox()\n    self._value.setToolTip(help)\n    self._value.stateChanged.connect(self.value_changed)\n    self._value.setChecked(props[\"value\"])\n    layout.addWidget(self._value, row, 1)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.IntegerProperty","title":"<code>IntegerProperty</code>","text":"<p>               Bases: <code>QObject</code></p> <p>IntegerProperty class.</p> <p>Build a widget to configure a integer property.</p> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>class IntegerProperty(QtCore.QObject):\n    \"\"\"\n    IntegerProperty class.\n\n    Build a widget to configure a integer property.\n    \"\"\"\n\n    value_updated: qtSignal = qtSignal(str, int)\n\n    def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: property name\n            props: properties of the integer property\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self._name = name\n\n        row = layout.rowCount()\n        minimum = props.get(\"minimum\")\n        maximum = props.get(\"maximum\")\n        step = props.get(\"multipleOf\", 1)\n        help = props.get(\"description\")\n        self._slider = None\n\n        label = QtWidgets.QLabel(props[\"title\"])\n        label.setToolTip(help)\n        layout.addWidget(label, row, 0)\n\n        self._value = QtWidgets.QSpinBox()\n        self._value.setToolTip(help)\n        self._value.valueChanged.connect(self.value_changed)\n        if minimum is not None:\n            self._value.setMinimum(minimum)\n        if maximum is not None:\n            self._value.setMaximum(maximum)\n        self._value.setSingleStep(step)\n        self._value.setValue(props[\"value\"])\n        layout.addWidget(self._value, row, 1)\n\n        if minimum is not None and maximum is not None:\n            self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n            self._slider.setToolTip(help)\n            self._slider.setMinimum(minimum)\n            self._slider.setMaximum(maximum)\n            self._slider.setSingleStep(step)\n            self._slider.setValue(props[\"value\"])\n            self._slider.valueChanged.connect(self._value.setValue)\n            layout.addWidget(self._slider, row, 2)\n\n    def value_changed(self, value):\n        if self._slider:\n            self._slider.setValue(value)\n        self.value_updated.emit(self._name, value)\n\n    def update_value(self, value):\n        self._value.blockSignals(True)\n        self._value.setValue(value)\n        self._value.blockSignals(False)\n        if self._slider:\n            self._slider.blockSignals(True)\n            self._slider.setValue(value)\n            self._slider.blockSignals(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.IntegerProperty.__init__","title":"<code>__init__(name, props, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>property name</p> required <code>props</code> <code>dict[str, Any]</code> <p>properties of the integer property</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: property name\n        props: properties of the integer property\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self._name = name\n\n    row = layout.rowCount()\n    minimum = props.get(\"minimum\")\n    maximum = props.get(\"maximum\")\n    step = props.get(\"multipleOf\", 1)\n    help = props.get(\"description\")\n    self._slider = None\n\n    label = QtWidgets.QLabel(props[\"title\"])\n    label.setToolTip(help)\n    layout.addWidget(label, row, 0)\n\n    self._value = QtWidgets.QSpinBox()\n    self._value.setToolTip(help)\n    self._value.valueChanged.connect(self.value_changed)\n    if minimum is not None:\n        self._value.setMinimum(minimum)\n    if maximum is not None:\n        self._value.setMaximum(maximum)\n    self._value.setSingleStep(step)\n    self._value.setValue(props[\"value\"])\n    layout.addWidget(self._value, row, 1)\n\n    if minimum is not None and maximum is not None:\n        self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self._slider.setToolTip(help)\n        self._slider.setMinimum(minimum)\n        self._slider.setMaximum(maximum)\n        self._slider.setSingleStep(step)\n        self._slider.setValue(props[\"value\"])\n        self._slider.valueChanged.connect(self._value.setValue)\n        layout.addWidget(self._slider, row, 2)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.NumberProperty","title":"<code>NumberProperty</code>","text":"<p>               Bases: <code>QObject</code></p> <p>NumberProperty class.</p> <p>Build a widget to configure a number property.</p> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>class NumberProperty(QtCore.QObject):\n    \"\"\"\n    NumberProperty class.\n\n    Build a widget to configure a number property.\n    \"\"\"\n\n    value_updated: qtSignal = qtSignal(str, float)\n\n    def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: property name\n            props: properties of the number property\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self._name = name\n\n        row = layout.rowCount()\n        minimum = props.get(\"minimum\")\n        maximum = props.get(\"maximum\")\n        step = props.get(\"multipleOf\", 0.1)\n        self._slider = None\n\n        label = QtWidgets.QLabel(props[\"title\"])\n        layout.addWidget(label, row, 0)\n\n        self._value = QtWidgets.QDoubleSpinBox()\n        self._value.setDecimals(4)\n        self._value.valueChanged.connect(self.value_changed)\n        if minimum is not None:\n            self._value.setMinimum(minimum)\n        if maximum is not None:\n            self._value.setMaximum(maximum)\n        self._value.setSingleStep(step)\n        self._value.setValue(props[\"value\"])\n        layout.addWidget(self._value, row, 1)\n\n        if minimum is not None and maximum is not None:\n            self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n            self._slider.setMinimum(minimum * 100)\n            self._slider.setMaximum(maximum * 100)\n            self._slider.setSingleStep(step * 100)\n            self._slider.setValue(props[\"value\"] * 100)\n            self._slider.valueChanged.connect(lambda v: self._value.setValue(v / 100))\n            layout.addWidget(self._slider, row, 2)\n\n    def value_changed(self, value):\n        if self._slider:\n            self._slider.setValue(value * 100)\n        self.value_updated.emit(self._name, value)\n\n    def update_value(self, value):\n        self._value.blockSignals(True)\n        self._value.setValue(value)\n        self._value.blockSignals(False)\n        if self._slider:\n            self._slider.blockSignals(True)\n            self._slider.setValue(value * 100)\n            self._slider.blockSignals(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.NumberProperty.__init__","title":"<code>__init__(name, props, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>property name</p> required <code>props</code> <code>dict[str, Any]</code> <p>properties of the number property</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: property name\n        props: properties of the number property\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self._name = name\n\n    row = layout.rowCount()\n    minimum = props.get(\"minimum\")\n    maximum = props.get(\"maximum\")\n    step = props.get(\"multipleOf\", 0.1)\n    self._slider = None\n\n    label = QtWidgets.QLabel(props[\"title\"])\n    layout.addWidget(label, row, 0)\n\n    self._value = QtWidgets.QDoubleSpinBox()\n    self._value.setDecimals(4)\n    self._value.valueChanged.connect(self.value_changed)\n    if minimum is not None:\n        self._value.setMinimum(minimum)\n    if maximum is not None:\n        self._value.setMaximum(maximum)\n    self._value.setSingleStep(step)\n    self._value.setValue(props[\"value\"])\n    layout.addWidget(self._value, row, 1)\n\n    if minimum is not None and maximum is not None:\n        self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self._slider.setMinimum(minimum * 100)\n        self._slider.setMaximum(maximum * 100)\n        self._slider.setSingleStep(step * 100)\n        self._slider.setValue(props[\"value\"] * 100)\n        self._slider.valueChanged.connect(lambda v: self._value.setValue(v / 100))\n        layout.addWidget(self._slider, row, 2)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.PropertiesDialog","title":"<code>PropertiesDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>PropertiesDialog class</p> <p>Build a modal for properties configuration.</p> <p>Attributes:</p> Name Type Description <code>property_updated</code> <code>Signal</code> <p>Qt signal emitted when a property is updated</p> <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>class PropertiesDialog(QtWidgets.QDialog):\n    \"\"\"\n    PropertiesDialog class\n\n    Build a modal for properties configuration.\n\n    Attributes:\n        property_updated: Qt signal emitted when a property is updated\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    property_updated: qtSignal = qtSignal(dict)\n    closed: qtSignal = qtSignal()\n\n    def __init__(self, config: dict[str, Any], parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            config: JSON Schema of properties with current values and namespace\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._config = config\n        self._properties: OrderedDict[str, IntegerProperty | NumberProperty] = collections.OrderedDict()\n        self.setWindowTitle(config[\"title\"])\n        self.setModal(False)\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        self.add_properties(config[\"properties\"], layout)\n\n        self.readSettings()\n\n    def add_properties(self, props: dict[str, Any], layout: QtWidgets.QGridLayout, parent: str = \"\"):\n        \"\"\"\n        Add properties.\n\n        Arguments:\n            props:  properties to add\n            layout: parent layout\n            parent: parent property name if any\n        \"\"\"\n        for name, props in props.items():\n            if props.get(\"value\") is None:\n                # Value is not set for properties with excluded=True\n                continue\n            if parent:\n                name = f\"{parent}/{name}\"\n            match type := props[\"type\"]:\n                case \"integer\":\n                    self._properties[name] = IntegerProperty(name, props, layout)\n                    self._properties[name].value_updated.connect(self.value_updated)\n                case \"number\":\n                    self._properties[name] = NumberProperty(name, props, layout)\n                    self._properties[name].value_updated.connect(self.value_updated)\n                case \"boolean\":\n                    self._properties[name] = BoolProperty(name, props, layout)\n                    self._properties[name].value_updated.connect(self.value_updated)\n                case \"array\":\n                    values = props[\"value\"]\n                    for value in values:\n                        box = QtWidgets.QGroupBox(value[\"title\"])\n                        layout.addWidget(box, layout.rowCount(), 0, 1, -1)\n                        box_layout = QtWidgets.QGridLayout()\n                        box.setLayout(box_layout)\n                        self.add_properties(value[\"properties\"], box_layout, parent=value[\"title\"])\n                case _:\n                    logger.error(f\"Unsupported property type: {type}\")\n\n    def update_values(self, config: dict[str, Any]):\n        \"\"\"\n        Update properties with new values.\n\n        Arguments:\n            config: JSON Schema of properties with current values and namespace\n        \"\"\"\n        for name, props in config[\"properties\"].items():\n            if property := self._properties.get(name):\n                property.update_value(props[\"value\"])\n\n    def value_updated(self, name: str, value: int | float):\n        \"\"\"\n        Emit updated values with namespace, name and value.\n        \"\"\"\n        self.property_updated.emit(\n            {\n                \"namespace\": self._config[\"namespace\"],\n                \"sio_event\": self._config.get(\"sio_event\", \"config_updated\"),\n                \"name\": name,\n                \"value\": value,\n            }\n        )\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(f\"properties/{self._config['namespace']}/{self._config['title']}\", self.saveGeometry())\n\n        self.closed.emit()\n        event.accept()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(f\"properties/{self._config['namespace']}/{self._config['title']}\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.PropertiesDialog.__init__","title":"<code>__init__(config, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>JSON Schema of properties with current values and namespace</p> required <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def __init__(self, config: dict[str, Any], parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        config: JSON Schema of properties with current values and namespace\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self._config = config\n    self._properties: OrderedDict[str, IntegerProperty | NumberProperty] = collections.OrderedDict()\n    self.setWindowTitle(config[\"title\"])\n    self.setModal(False)\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    self.add_properties(config[\"properties\"], layout)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.PropertiesDialog.add_properties","title":"<code>add_properties(props, layout, parent='')</code>","text":"<p>Add properties.</p> <p>Parameters:</p> Name Type Description Default <code>props</code> <code>dict[str, Any]</code> <p>properties to add</p> required <code>layout</code> <code>QGridLayout</code> <p>parent layout</p> required <code>parent</code> <code>str</code> <p>parent property name if any</p> <code>''</code> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def add_properties(self, props: dict[str, Any], layout: QtWidgets.QGridLayout, parent: str = \"\"):\n    \"\"\"\n    Add properties.\n\n    Arguments:\n        props:  properties to add\n        layout: parent layout\n        parent: parent property name if any\n    \"\"\"\n    for name, props in props.items():\n        if props.get(\"value\") is None:\n            # Value is not set for properties with excluded=True\n            continue\n        if parent:\n            name = f\"{parent}/{name}\"\n        match type := props[\"type\"]:\n            case \"integer\":\n                self._properties[name] = IntegerProperty(name, props, layout)\n                self._properties[name].value_updated.connect(self.value_updated)\n            case \"number\":\n                self._properties[name] = NumberProperty(name, props, layout)\n                self._properties[name].value_updated.connect(self.value_updated)\n            case \"boolean\":\n                self._properties[name] = BoolProperty(name, props, layout)\n                self._properties[name].value_updated.connect(self.value_updated)\n            case \"array\":\n                values = props[\"value\"]\n                for value in values:\n                    box = QtWidgets.QGroupBox(value[\"title\"])\n                    layout.addWidget(box, layout.rowCount(), 0, 1, -1)\n                    box_layout = QtWidgets.QGridLayout()\n                    box.setLayout(box_layout)\n                    self.add_properties(value[\"properties\"], box_layout, parent=value[\"title\"])\n            case _:\n                logger.error(f\"Unsupported property type: {type}\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.PropertiesDialog.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(f\"properties/{self._config['namespace']}/{self._config['title']}\", self.saveGeometry())\n\n    self.closed.emit()\n    event.accept()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.PropertiesDialog.update_values","title":"<code>update_values(config)</code>","text":"<p>Update properties with new values.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>JSON Schema of properties with current values and namespace</p> required Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def update_values(self, config: dict[str, Any]):\n    \"\"\"\n    Update properties with new values.\n\n    Arguments:\n        config: JSON Schema of properties with current values and namespace\n    \"\"\"\n    for name, props in config[\"properties\"].items():\n        if property := self._properties.get(name):\n            property.update_value(props[\"value\"])\n</code></pre>"},{"location":"reference/cogip/tools/monitor/properties/#cogip.tools.monitor.properties.PropertiesDialog.value_updated","title":"<code>value_updated(name, value)</code>","text":"<p>Emit updated values with namespace, name and value.</p> Source code in <code>cogip/tools/monitor/properties.py</code> <pre><code>def value_updated(self, name: str, value: int | float):\n    \"\"\"\n    Emit updated values with namespace, name and value.\n    \"\"\"\n    self.property_updated.emit(\n        {\n            \"namespace\": self._config[\"namespace\"],\n            \"sio_event\": self._config.get(\"sio_event\", \"config_updated\"),\n            \"name\": name,\n            \"value\": value,\n        }\n    )\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/","title":"robot","text":""},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity","title":"<code>RobotEntity</code>","text":"<p>               Bases: <code>AssetEntity</code></p> <p>The robot entity displayed on the table.</p> <p>Attributes:</p> Name Type Description <code>update_pose_current_interval</code> <code>int</code> <p>Interval in milliseconds between each current pose update</p> <code>order_robot</code> <code>RobotOrderEntity</code> <p>: Entity that represents the robot next destination</p> Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>class RobotEntity(AssetEntity):\n    \"\"\"\n    The robot entity displayed on the table.\n\n    Attributes:\n        update_pose_current_interval: Interval in milliseconds between each current pose update\n        order_robot:: Entity that represents the robot next destination\n    \"\"\"\n\n    update_pose_current_interval: int = 100\n    order_robot: RobotOrderEntity = None\n\n    def __init__(\n        self,\n        robot_id: int,\n        win: MainWindow,\n        parent: Qt3DCore.QEntity | None = None,\n        virtual_planner: bool = False,\n        virtual_detector: bool = False,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Inherits [AssetEntity][cogip.tools.monitor.asset.AssetEntity].\n        \"\"\"\n        self.win = win\n        asset_path = Path(f\"assets/{'robot' if robot_id == 1 else 'pami'}2025.dae\")\n        super().__init__(asset_path, parent=parent)\n        self.robot_id = robot_id\n        self.virtual_planner = virtual_planner\n        self.virtual_detector = virtual_detector\n        self.sensors: list[Sensor] = []\n        self.rect_obstacles_pool = []\n        self.round_obstacles_pool = []\n        self.beacon_entity: Qt3DCore.QEntity | None = None\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_lidar_data: NDArray | None = None\n        self.shared_lidar_data_lock: WritePriorityLock | None = None\n        self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n        self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n        self.shared_obstacles_lock: WritePriorityLock | None = None\n        self.shared_monitor_obstacles: SharedCircleList | None = None\n        self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n\n        if robot_id == 1:\n            self.beacon_entity = Qt3DCore.QEntity(self)\n            self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n            self.beacon_mesh.setLength(80)\n            self.beacon_mesh.setRadius(40)\n            self.beacon_entity.addComponent(self.beacon_mesh)\n\n            self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n            self.beacon_transform.setTranslation(QtGui.QVector3D(0, 0, 350 + self.beacon_mesh.length() / 2))\n            self.beacon_transform.setRotationX(90)\n            self.beacon_entity.addComponent(self.beacon_transform)\n\n            if virtual_detector:\n                # Create a layer used by sensors to activate detection on the beacon\n                self.beacon_entity.layer = Qt3DRender.QLayer(self.beacon_entity)\n                self.beacon_entity.layer.setRecursive(True)\n                self.beacon_entity.layer.setEnabled(True)\n                self.beacon_entity.addComponent(self.beacon_entity.layer)\n\n                Sensor.add_obstacle(self.beacon_entity)\n        elif virtual_detector:\n            # Create a layer used by sensors to activate detection on the robot parts\n            self.layer = Qt3DRender.QLayer(self)\n            self.layer.setRecursive(True)\n            self.layer.setEnabled(True)\n            self.addComponent(self.layer)\n\n            Sensor.add_obstacle(self)\n\n        self.update_pose_current_timer = QtCore.QTimer()\n        self.update_pose_current_timer.timeout.connect(self.update_pose_current)\n        if self.virtual_planner:\n            self.update_pose_current_timer.start(RobotEntity.update_pose_current_interval)\n\n        # Create a timer for consistent hit updates\n        self.update_hit_timer = QtCore.QTimer()\n        self.update_hit_timer.setTimerType(QtCore.Qt.TimerType.PreciseTimer)\n        if virtual_detector:\n            self.update_hit_timer.start(RobotEntity.update_pose_current_interval)\n\n        if virtual_planner or virtual_detector:\n            self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n        if virtual_planner:\n            self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n            self.shared_circle_obstacles = self.shared_memory.get_circle_obstacles()\n            self.shared_rectangle_obstacles = self.shared_memory.get_rectangle_obstacles()\n            self.shared_obstacles_lock = self.shared_memory.get_lock(LockName.Obstacles)\n            self.shared_obstacles_lock.register_consumer()\n        if virtual_detector:\n            self.shared_lidar_data = self.shared_memory.get_lidar_data()\n            self.shared_lidar_data_lock = self.shared_memory.get_lock(LockName.LidarData)\n            self.shared_monitor_obstacles = self.shared_memory.get_monitor_obstacles()\n            self.shared_monitor_obstacles_lock = self.shared_memory.get_lock(LockName.MonitorObstacles)\n\n        if self.virtual_detector:\n            for i in range(360):\n                self.shared_lidar_data[i][0] = i\n                self.shared_lidar_data[i][2] = 255\n            if self.robot_id &gt; 1:\n                for i in range(90, 270):\n                    self.shared_lidar_data[i][1] = 65535\n            self.shared_lidar_data[360][0] = -1\n            for self.sensor in self.sensors:\n                self.sensor.shared_sensor_data = self.shared_lidar_data\n                self.sensor.shared_sensor_data_lock = self.shared_lidar_data_lock\n\n    def delete_shared_memory(self):\n        for self.sensor in self.sensors:\n            self.sensor.shared_sensor_data = None\n            self.sensor.shared_sensor_data_lock = None\n        self.update_pose_current_timer.stop()\n        self.shared_monitor_obstacles_lock = None\n        self.shared_monitor_obstacles = None\n        self.shared_obstacles_lock = None\n        self.shared_rectangle_obstacles = None\n        self.shared_circle_obstacles = None\n        self.shared_lidar_data_lock = None\n        self.shared_lidar_data = None\n        self.shared_pose_current_buffer = None\n        self.shared_memory = None\n\n    def post_init(self):\n        \"\"\"\n        Function called once the asset has been loaded.\n\n        Set the color and enable sensors.\n        \"\"\"\n        super().post_init()\n\n        if self.virtual_detector:\n            self.add_lidar_sensors()\n\n        self.order_robot = RobotOrderEntity(self.parent(), self.robot_id)\n\n    def add_lidar_sensors(self):\n        \"\"\"\n        Add LIDAR sensors to the robot entity,\n        one by degree around the top of the robot.\n        \"\"\"\n\n        if self.robot_id == 1:\n            radius = 65.0 / 2\n            shift_x = 0.0\n            shift_y = 0.0\n            shift_z = 360.0\n        else:\n            radius = 35.29 / 2\n            shift_x = 75.5\n            shift_y = 0.0\n            shift_z = 60.8\n\n        for angle in range(0, 360):\n            if self.robot_id &gt; 1 and (90 &lt; angle &lt; 270):\n                continue\n            origin_x = radius * math.sin(math.radians(90 - angle))\n            origin_y = radius * math.cos(math.radians(90 - angle))\n            sensor = LidarSensor(\n                asset_entity=self,\n                name=f\"Lidar {angle}\",\n                angle=angle,\n                origin_x=shift_x,\n                origin_y=shift_y,\n                origin_z=shift_z + 5,\n                direction_x=origin_x,\n                direction_y=origin_y,\n            )\n            sensor.shared_sensor_data = self.shared_lidar_data\n            sensor.shared_sensor_data_lock = self.shared_lidar_data_lock\n            self.sensors.append(sensor)\n            self.update_hit_timer.timeout.connect(sensor.ray_caster.trigger)\n\n    def add_tof_sensor(self):\n        \"\"\"\n        Add a ToF sensor in front of the robot entity.\n        \"\"\"\n        sensor = ToFSensor(\n            asset_entity=self,\n            name=\"ToF\",\n            angle=0,\n            origin_x=106,\n            origin_y=0,\n        )\n        sensor.shared_sensor_data = self.shared_lidar_data\n        sensor.shared_sensor_data_lock = self.shared_lidar_data_lock\n        self.sensors.append(sensor)\n\n    def update_pose_current(self) -&gt; None:\n        \"\"\"\n        Update pose current from shared memory.\n        \"\"\"\n        pose_current = self.shared_pose_current_buffer.last\n        self.transform_component.setTranslation(QtGui.QVector3D(pose_current.x, pose_current.y, 0))\n        self.transform_component.setRotationZ(pose_current.angle)\n        self.win.new_robot_pose(\n            self.robot_id,\n            Pose(x=pose_current.x, y=pose_current.y, O=pose_current.angle),\n        )\n\n    @qtSlot(Pose)\n    def new_robot_pose_order(self, new_pose: Pose) -&gt; None:\n        \"\"\"\n        Qt slot called to set the robot's new pose order.\n\n        Arguments:\n            robot_id: ID of the robot\n            new_pose: new robot pose\n        \"\"\"\n        if self.order_robot:\n            self.order_robot.transform.setTranslation(QtGui.QVector3D(new_pose.x, new_pose.y, 0))\n            self.order_robot.transform.setRotationZ(new_pose.O)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity.__init__","title":"<code>__init__(robot_id, win, parent=None, virtual_planner=False, virtual_detector=False)</code>","text":"<p>Class constructor.</p> <p>Inherits AssetEntity.</p> Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>def __init__(\n    self,\n    robot_id: int,\n    win: MainWindow,\n    parent: Qt3DCore.QEntity | None = None,\n    virtual_planner: bool = False,\n    virtual_detector: bool = False,\n):\n    \"\"\"\n    Class constructor.\n\n    Inherits [AssetEntity][cogip.tools.monitor.asset.AssetEntity].\n    \"\"\"\n    self.win = win\n    asset_path = Path(f\"assets/{'robot' if robot_id == 1 else 'pami'}2025.dae\")\n    super().__init__(asset_path, parent=parent)\n    self.robot_id = robot_id\n    self.virtual_planner = virtual_planner\n    self.virtual_detector = virtual_detector\n    self.sensors: list[Sensor] = []\n    self.rect_obstacles_pool = []\n    self.round_obstacles_pool = []\n    self.beacon_entity: Qt3DCore.QEntity | None = None\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_lidar_data: NDArray | None = None\n    self.shared_lidar_data_lock: WritePriorityLock | None = None\n    self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n    self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n    self.shared_obstacles_lock: WritePriorityLock | None = None\n    self.shared_monitor_obstacles: SharedCircleList | None = None\n    self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n\n    if robot_id == 1:\n        self.beacon_entity = Qt3DCore.QEntity(self)\n        self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n        self.beacon_mesh.setLength(80)\n        self.beacon_mesh.setRadius(40)\n        self.beacon_entity.addComponent(self.beacon_mesh)\n\n        self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n        self.beacon_transform.setTranslation(QtGui.QVector3D(0, 0, 350 + self.beacon_mesh.length() / 2))\n        self.beacon_transform.setRotationX(90)\n        self.beacon_entity.addComponent(self.beacon_transform)\n\n        if virtual_detector:\n            # Create a layer used by sensors to activate detection on the beacon\n            self.beacon_entity.layer = Qt3DRender.QLayer(self.beacon_entity)\n            self.beacon_entity.layer.setRecursive(True)\n            self.beacon_entity.layer.setEnabled(True)\n            self.beacon_entity.addComponent(self.beacon_entity.layer)\n\n            Sensor.add_obstacle(self.beacon_entity)\n    elif virtual_detector:\n        # Create a layer used by sensors to activate detection on the robot parts\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        Sensor.add_obstacle(self)\n\n    self.update_pose_current_timer = QtCore.QTimer()\n    self.update_pose_current_timer.timeout.connect(self.update_pose_current)\n    if self.virtual_planner:\n        self.update_pose_current_timer.start(RobotEntity.update_pose_current_interval)\n\n    # Create a timer for consistent hit updates\n    self.update_hit_timer = QtCore.QTimer()\n    self.update_hit_timer.setTimerType(QtCore.Qt.TimerType.PreciseTimer)\n    if virtual_detector:\n        self.update_hit_timer.start(RobotEntity.update_pose_current_interval)\n\n    if virtual_planner or virtual_detector:\n        self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n    if virtual_planner:\n        self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n        self.shared_circle_obstacles = self.shared_memory.get_circle_obstacles()\n        self.shared_rectangle_obstacles = self.shared_memory.get_rectangle_obstacles()\n        self.shared_obstacles_lock = self.shared_memory.get_lock(LockName.Obstacles)\n        self.shared_obstacles_lock.register_consumer()\n    if virtual_detector:\n        self.shared_lidar_data = self.shared_memory.get_lidar_data()\n        self.shared_lidar_data_lock = self.shared_memory.get_lock(LockName.LidarData)\n        self.shared_monitor_obstacles = self.shared_memory.get_monitor_obstacles()\n        self.shared_monitor_obstacles_lock = self.shared_memory.get_lock(LockName.MonitorObstacles)\n\n    if self.virtual_detector:\n        for i in range(360):\n            self.shared_lidar_data[i][0] = i\n            self.shared_lidar_data[i][2] = 255\n        if self.robot_id &gt; 1:\n            for i in range(90, 270):\n                self.shared_lidar_data[i][1] = 65535\n        self.shared_lidar_data[360][0] = -1\n        for self.sensor in self.sensors:\n            self.sensor.shared_sensor_data = self.shared_lidar_data\n            self.sensor.shared_sensor_data_lock = self.shared_lidar_data_lock\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity.add_lidar_sensors","title":"<code>add_lidar_sensors()</code>","text":"<p>Add LIDAR sensors to the robot entity, one by degree around the top of the robot.</p> Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>def add_lidar_sensors(self):\n    \"\"\"\n    Add LIDAR sensors to the robot entity,\n    one by degree around the top of the robot.\n    \"\"\"\n\n    if self.robot_id == 1:\n        radius = 65.0 / 2\n        shift_x = 0.0\n        shift_y = 0.0\n        shift_z = 360.0\n    else:\n        radius = 35.29 / 2\n        shift_x = 75.5\n        shift_y = 0.0\n        shift_z = 60.8\n\n    for angle in range(0, 360):\n        if self.robot_id &gt; 1 and (90 &lt; angle &lt; 270):\n            continue\n        origin_x = radius * math.sin(math.radians(90 - angle))\n        origin_y = radius * math.cos(math.radians(90 - angle))\n        sensor = LidarSensor(\n            asset_entity=self,\n            name=f\"Lidar {angle}\",\n            angle=angle,\n            origin_x=shift_x,\n            origin_y=shift_y,\n            origin_z=shift_z + 5,\n            direction_x=origin_x,\n            direction_y=origin_y,\n        )\n        sensor.shared_sensor_data = self.shared_lidar_data\n        sensor.shared_sensor_data_lock = self.shared_lidar_data_lock\n        self.sensors.append(sensor)\n        self.update_hit_timer.timeout.connect(sensor.ray_caster.trigger)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity.add_tof_sensor","title":"<code>add_tof_sensor()</code>","text":"<p>Add a ToF sensor in front of the robot entity.</p> Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>def add_tof_sensor(self):\n    \"\"\"\n    Add a ToF sensor in front of the robot entity.\n    \"\"\"\n    sensor = ToFSensor(\n        asset_entity=self,\n        name=\"ToF\",\n        angle=0,\n        origin_x=106,\n        origin_y=0,\n    )\n    sensor.shared_sensor_data = self.shared_lidar_data\n    sensor.shared_sensor_data_lock = self.shared_lidar_data_lock\n    self.sensors.append(sensor)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity.new_robot_pose_order","title":"<code>new_robot_pose_order(new_pose)</code>","text":"<p>Qt slot called to set the robot's new pose order.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <p>ID of the robot</p> required <code>new_pose</code> <code>Pose</code> <p>new robot pose</p> required Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>@qtSlot(Pose)\ndef new_robot_pose_order(self, new_pose: Pose) -&gt; None:\n    \"\"\"\n    Qt slot called to set the robot's new pose order.\n\n    Arguments:\n        robot_id: ID of the robot\n        new_pose: new robot pose\n    \"\"\"\n    if self.order_robot:\n        self.order_robot.transform.setTranslation(QtGui.QVector3D(new_pose.x, new_pose.y, 0))\n        self.order_robot.transform.setRotationZ(new_pose.O)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity.post_init","title":"<code>post_init()</code>","text":"<p>Function called once the asset has been loaded.</p> <p>Set the color and enable sensors.</p> Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>def post_init(self):\n    \"\"\"\n    Function called once the asset has been loaded.\n\n    Set the color and enable sensors.\n    \"\"\"\n    super().post_init()\n\n    if self.virtual_detector:\n        self.add_lidar_sensors()\n\n    self.order_robot = RobotOrderEntity(self.parent(), self.robot_id)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot/#cogip.tools.monitor.robot.RobotEntity.update_pose_current","title":"<code>update_pose_current()</code>","text":"<p>Update pose current from shared memory.</p> Source code in <code>cogip/tools/monitor/robot.py</code> <pre><code>def update_pose_current(self) -&gt; None:\n    \"\"\"\n    Update pose current from shared memory.\n    \"\"\"\n    pose_current = self.shared_pose_current_buffer.last\n    self.transform_component.setTranslation(QtGui.QVector3D(pose_current.x, pose_current.y, 0))\n    self.transform_component.setRotationZ(pose_current.angle)\n    self.win.new_robot_pose(\n        self.robot_id,\n        Pose(x=pose_current.x, y=pose_current.y, O=pose_current.angle),\n    )\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/","title":"robot_manual","text":""},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity","title":"<code>RobotManualEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>An robot entity that can be moved and rotated manually on the table.</p> <p>When selected with a mouse click, a property window is displayed to modify the robot properties.</p> <p>The robot can also be moved using the mouse.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>QColor</code> <p>Robot color</p> <code>enable_controller</code> <p>Qt signal used to disable the camera controller when moving the robot using the mouse</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>class RobotManualEntity(Qt3DCore.QEntity):\n    \"\"\"\n    An robot entity that can be moved and rotated manually on the table.\n\n    When selected with a mouse click, a property window is displayed\n    to modify the robot properties.\n\n    The robot can also be moved using the mouse.\n\n    Attributes:\n        color: Robot color\n        enable_controller: Qt signal used to disable the camera controller\n            when moving the robot using the mouse\n    \"\"\"\n\n    color: QtGui.QColor = QtGui.QColor.fromRgb(17, 70, 92, 100)\n    enable_controller = qtSignal(bool)\n\n    def __init__(\n        self,\n        parent: Qt3DCore.QEntity,\n        parent_widget: QtWidgets.QWidget,\n        robot_id: int = 1,\n        x: int = 1200,\n        y: int = 1200,\n        rotation: int = 180,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent entity\n            parent_widget: Parent widget\n            x: X position\n            y: Y position\n            rotation: Rotation\n        \"\"\"\n        super().__init__(parent)\n\n        self.parent_widget = parent_widget\n\n        self.mesh = Qt3DRender.QMesh(self)\n        self.mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2025.stl\"))\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial(self)\n        self.material.setShininess(1.0)\n        self.material.setDiffuse(self.color)\n        self.material.setSpecular(self.color)\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(x, y, 0))\n        self.transform.setRotationZ(rotation)\n        self.addComponent(self.transform)\n\n        self.picker = Qt3DRender.QObjectPicker()\n        self.picker.setDragEnabled(True)\n        self.picker.pressed.connect(self.pressed)\n        self.picker.released.connect(self.released)\n        self.picker.moved.connect(self.moved)\n        self.addComponent(self.picker)\n\n        self.moving = False\n\n        # Create a layer used by sensors to activate detection on the robot\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        # Create properties dialog\n        self.properties = RobotManualProperties(self.parent_widget, self)\n\n    @qtSlot(int)\n    def setXTranslation(self, x: int):\n        \"\"\"\n        Qt Slot\n\n        Set the X position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setX(float(x))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(int)\n    def setYTranslation(self, y: int):\n        \"\"\"\n        Qt Slot\n\n        Set the Y position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setY(float(y))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def pressed(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```pressed``` mouse event on the robot.\n\n        Emit a signal to disable the camera controller before moving the robot.\n        \"\"\"\n        self.enable_controller.emit(False)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def released(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```released``` mouse event on the robot.\n\n        If this event occurs just after a ```pressed``` event, it is only a mouse click,\n        so display the property window.\n\n        Emit a signal to re-enable the camera controller after moving the robot.\n        \"\"\"\n        if not self.moving:\n            if RobotManualProperties.active_properties:\n                RobotManualProperties.active_properties.close()\n            self.properties.show()\n            self.properties.raise_()\n            self.properties.activateWindow()\n            RobotManualProperties.set_active_properties(self.properties)\n        self.moving = False\n        self.enable_controller.emit(True)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def moved(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```moved``` mouse event on the robot.\n\n        Just record that the robot is moving, the translation is computed\n        in the [GameView][cogip.tools.monitor.gameview.GameView] object.\n        \"\"\"\n        self.moving = True\n\n    @qtSlot(QtGui.QVector3D)\n    def new_move_delta(self, delta: QtGui.QVector3D):\n        \"\"\"\n        Qt Slot\n\n        Update the robot position.\n\n        Arguments:\n            delta: The difference between current and new position\n        \"\"\"\n        if not delta:\n            self.moving = False\n        elif self.moving:\n            new_translation = self.transform.translation() + delta\n            self.transform.setTranslation(new_translation)\n            self.properties.spin_x.setValue(new_translation.x())\n            self.properties.spin_y.setValue(new_translation.y())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.__init__","title":"<code>__init__(parent, parent_widget, robot_id=1, x=1200, y=1200, rotation=180)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QEntity</code> <p>The parent entity</p> required <code>parent_widget</code> <code>QWidget</code> <p>Parent widget</p> required <code>x</code> <code>int</code> <p>X position</p> <code>1200</code> <code>y</code> <code>int</code> <p>Y position</p> <code>1200</code> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>180</code> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>def __init__(\n    self,\n    parent: Qt3DCore.QEntity,\n    parent_widget: QtWidgets.QWidget,\n    robot_id: int = 1,\n    x: int = 1200,\n    y: int = 1200,\n    rotation: int = 180,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent entity\n        parent_widget: Parent widget\n        x: X position\n        y: Y position\n        rotation: Rotation\n    \"\"\"\n    super().__init__(parent)\n\n    self.parent_widget = parent_widget\n\n    self.mesh = Qt3DRender.QMesh(self)\n    self.mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2025.stl\"))\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial(self)\n    self.material.setShininess(1.0)\n    self.material.setDiffuse(self.color)\n    self.material.setSpecular(self.color)\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(x, y, 0))\n    self.transform.setRotationZ(rotation)\n    self.addComponent(self.transform)\n\n    self.picker = Qt3DRender.QObjectPicker()\n    self.picker.setDragEnabled(True)\n    self.picker.pressed.connect(self.pressed)\n    self.picker.released.connect(self.released)\n    self.picker.moved.connect(self.moved)\n    self.addComponent(self.picker)\n\n    self.moving = False\n\n    # Create a layer used by sensors to activate detection on the robot\n    self.layer = Qt3DRender.QLayer(self)\n    self.layer.setRecursive(True)\n    self.layer.setEnabled(True)\n    self.addComponent(self.layer)\n\n    # Create properties dialog\n    self.properties = RobotManualProperties(self.parent_widget, self)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.moved","title":"<code>moved(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>moved</code> mouse event on the robot.</p> <p>Just record that the robot is moving, the translation is computed in the GameView object.</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef moved(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```moved``` mouse event on the robot.\n\n    Just record that the robot is moving, the translation is computed\n    in the [GameView][cogip.tools.monitor.gameview.GameView] object.\n    \"\"\"\n    self.moving = True\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.new_move_delta","title":"<code>new_move_delta(delta)</code>","text":"<p>Qt Slot</p> <p>Update the robot position.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>QVector3D</code> <p>The difference between current and new position</p> required Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@qtSlot(QtGui.QVector3D)\ndef new_move_delta(self, delta: QtGui.QVector3D):\n    \"\"\"\n    Qt Slot\n\n    Update the robot position.\n\n    Arguments:\n        delta: The difference between current and new position\n    \"\"\"\n    if not delta:\n        self.moving = False\n    elif self.moving:\n        new_translation = self.transform.translation() + delta\n        self.transform.setTranslation(new_translation)\n        self.properties.spin_x.setValue(new_translation.x())\n        self.properties.spin_y.setValue(new_translation.y())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.pressed","title":"<code>pressed(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>pressed</code> mouse event on the robot.</p> <p>Emit a signal to disable the camera controller before moving the robot.</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef pressed(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```pressed``` mouse event on the robot.\n\n    Emit a signal to disable the camera controller before moving the robot.\n    \"\"\"\n    self.enable_controller.emit(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.released","title":"<code>released(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>released</code> mouse event on the robot.</p> <p>If this event occurs just after a <code>pressed</code> event, it is only a mouse click, so display the property window.</p> <p>Emit a signal to re-enable the camera controller after moving the robot.</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef released(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```released``` mouse event on the robot.\n\n    If this event occurs just after a ```pressed``` event, it is only a mouse click,\n    so display the property window.\n\n    Emit a signal to re-enable the camera controller after moving the robot.\n    \"\"\"\n    if not self.moving:\n        if RobotManualProperties.active_properties:\n            RobotManualProperties.active_properties.close()\n        self.properties.show()\n        self.properties.raise_()\n        self.properties.activateWindow()\n        RobotManualProperties.set_active_properties(self.properties)\n    self.moving = False\n    self.enable_controller.emit(True)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.setXTranslation","title":"<code>setXTranslation(x)</code>","text":"<p>Qt Slot</p> <p>Set the X position.</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@qtSlot(int)\ndef setXTranslation(self, x: int):\n    \"\"\"\n    Qt Slot\n\n    Set the X position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setX(float(x))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualEntity.setYTranslation","title":"<code>setYTranslation(y)</code>","text":"<p>Qt Slot</p> <p>Set the Y position.</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@qtSlot(int)\ndef setYTranslation(self, y: int):\n    \"\"\"\n    Qt Slot\n\n    Set the Y position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setY(float(y))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualProperties","title":"<code>RobotManualProperties</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>The property window.</p> <p>Attributes:</p> Name Type Description <code>active_properties</code> <code>RobotManualProperties</code> <p>The current property window displayed.</p> Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>class RobotManualProperties(QtWidgets.QDialog):\n    \"\"\"\n    The property window.\n\n    Attributes:\n        active_properties: The current property window displayed.\n    \"\"\"\n\n    active_properties: \"RobotManualProperties\" = None\n\n    def __init__(self, parent: QtWidgets.QWidget, robot_entity: RobotManualEntity):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n            robot_entity: The related robot entity\n        \"\"\"\n        super().__init__(parent)\n\n        self.robot_entity = robot_entity\n        self.setWindowTitle(\"Robot Properties\")\n        self.setModal(False)\n        self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        row = 0\n\n        label_x = QtWidgets.QLabel(\"X\")\n        self.spin_x = QtWidgets.QSpinBox()\n        self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_x.setMinimum(-1200)\n        self.spin_x.setMaximum(1200)\n        self.spin_x.setValue(int(self.robot_entity.transform.translation().x()))\n        self.spin_x.valueChanged.connect(self.robot_entity.setXTranslation)\n        layout.addWidget(label_x, row, 0)\n        layout.addWidget(self.spin_x, row, 1)\n        row += 1\n\n        label_y = QtWidgets.QLabel(\"Y\")\n        self.spin_y = QtWidgets.QSpinBox()\n        self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_y.setMinimum(-1700)\n        self.spin_y.setMaximum(1700)\n        self.spin_y.setValue(int(self.robot_entity.transform.translation().y()))\n        self.spin_y.valueChanged.connect(self.robot_entity.setYTranslation)\n        layout.addWidget(label_y, row, 0)\n        layout.addWidget(self.spin_y, row, 1)\n        row += 1\n\n        label_rotation = QtWidgets.QLabel(\"Rotation\")\n        self.spin_rotation = QtWidgets.QSpinBox()\n        self.spin_rotation.setSuffix(\"\u00b0\")\n        self.spin_rotation.setMinimum(-180)\n        self.spin_rotation.setMaximum(180)\n        self.spin_rotation.setValue(int(self.robot_entity.transform.rotationZ()))\n        self.spin_rotation.valueChanged.connect(self.robot_entity.transform.setRotationZ)\n        layout.addWidget(label_rotation, row, 0)\n        layout.addWidget(self.spin_rotation, row, 1)\n        row += 1\n\n        self.readSettings()\n\n    @classmethod\n    def set_active_properties(cls, properties: \"RobotManualProperties\"):\n        \"\"\"\n        Class method.\n\n        Set the current property window displayed.\n\n        Arguments:\n            properties: The current property\n        \"\"\"\n        cls.active_properties = properties\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Close the property windows.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        RobotManualProperties.set_active_properties(None)\n\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"manual_robot_dialog/geometry\", self.saveGeometry())\n\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"manual_robot_dialog/geometry\"))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualProperties.__init__","title":"<code>__init__(parent, robot_entity)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>robot_entity</code> <code>RobotManualEntity</code> <p>The related robot entity</p> required Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget, robot_entity: RobotManualEntity):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n        robot_entity: The related robot entity\n    \"\"\"\n    super().__init__(parent)\n\n    self.robot_entity = robot_entity\n    self.setWindowTitle(\"Robot Properties\")\n    self.setModal(False)\n    self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    row = 0\n\n    label_x = QtWidgets.QLabel(\"X\")\n    self.spin_x = QtWidgets.QSpinBox()\n    self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_x.setMinimum(-1200)\n    self.spin_x.setMaximum(1200)\n    self.spin_x.setValue(int(self.robot_entity.transform.translation().x()))\n    self.spin_x.valueChanged.connect(self.robot_entity.setXTranslation)\n    layout.addWidget(label_x, row, 0)\n    layout.addWidget(self.spin_x, row, 1)\n    row += 1\n\n    label_y = QtWidgets.QLabel(\"Y\")\n    self.spin_y = QtWidgets.QSpinBox()\n    self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_y.setMinimum(-1700)\n    self.spin_y.setMaximum(1700)\n    self.spin_y.setValue(int(self.robot_entity.transform.translation().y()))\n    self.spin_y.valueChanged.connect(self.robot_entity.setYTranslation)\n    layout.addWidget(label_y, row, 0)\n    layout.addWidget(self.spin_y, row, 1)\n    row += 1\n\n    label_rotation = QtWidgets.QLabel(\"Rotation\")\n    self.spin_rotation = QtWidgets.QSpinBox()\n    self.spin_rotation.setSuffix(\"\u00b0\")\n    self.spin_rotation.setMinimum(-180)\n    self.spin_rotation.setMaximum(180)\n    self.spin_rotation.setValue(int(self.robot_entity.transform.rotationZ()))\n    self.spin_rotation.valueChanged.connect(self.robot_entity.transform.setRotationZ)\n    layout.addWidget(label_rotation, row, 0)\n    layout.addWidget(self.spin_rotation, row, 1)\n    row += 1\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualProperties.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Close the property windows.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Close the property windows.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    RobotManualProperties.set_active_properties(None)\n\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"manual_robot_dialog/geometry\", self.saveGeometry())\n\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_manual/#cogip.tools.monitor.robot_manual.RobotManualProperties.set_active_properties","title":"<code>set_active_properties(properties)</code>  <code>classmethod</code>","text":"<p>Class method.</p> <p>Set the current property window displayed.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>RobotManualProperties</code> <p>The current property</p> required Source code in <code>cogip/tools/monitor/robot_manual.py</code> <pre><code>@classmethod\ndef set_active_properties(cls, properties: \"RobotManualProperties\"):\n    \"\"\"\n    Class method.\n\n    Set the current property window displayed.\n\n    Arguments:\n        properties: The current property\n    \"\"\"\n    cls.active_properties = properties\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_order/","title":"robot_order","text":""},{"location":"reference/cogip/tools/monitor/robot_order/#cogip.tools.monitor.robot_order.RobotOrderEntity","title":"<code>RobotOrderEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A robot entity to display to order position.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>QColor</code> <p>Robot color</p> Source code in <code>cogip/tools/monitor/robot_order.py</code> <pre><code>class RobotOrderEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A robot entity to display to order position.\n\n    Attributes:\n        color: Robot color\n    \"\"\"\n\n    color: QtGui.QColor = QtGui.QColor.fromRgb(10, 77, 18, 100)\n\n    def __init__(self, parent: Qt3DCore.QEntity, robot_id: int = 1):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n\n        mesh = Qt3DRender.QMesh(self)\n        mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2025.stl\"))\n\n        self.transform = Qt3DCore.QTransform(self)\n\n        self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n        self.material.setShininess(1.0)\n        self.material.setDiffuse(self.color)\n        self.material.setSpecular(self.color)\n\n        self.addComponent(mesh)\n        self.addComponent(self.transform)\n        self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robot_order/#cogip.tools.monitor.robot_order.RobotOrderEntity.__init__","title":"<code>__init__(parent, robot_id=1)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/robot_order.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity, robot_id: int = 1):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n\n    mesh = Qt3DRender.QMesh(self)\n    mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2025.stl\"))\n\n    self.transform = Qt3DCore.QTransform(self)\n\n    self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n    self.material.setShininess(1.0)\n    self.material.setDiffuse(self.color)\n    self.material.setSpecular(self.color)\n\n    self.addComponent(mesh)\n    self.addComponent(self.transform)\n    self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/","title":"robots","text":""},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager","title":"<code>RobotManager</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>class RobotManager(QtCore.QObject):\n    def __init__(self, win: MainWindow):\n        \"\"\"\n        Class constructor.\n\n        Parameters:\n            game_view: parent of the robots\n        \"\"\"\n        super().__init__()\n        self._win = win\n        self._game_view = win.game_view\n        self._rect_obstacles_pool: list[DynRectObstacleEntity] = []\n        self._round_obstacles_pool: list[DynCircleObstacleEntity] = []\n        self._update_obstacles = QtCore.QTimer()\n        self._update_obstacles.timeout.connect(self.update_obstacles)\n        self._update_obstacles_interval = 100\n        self.virtual_planner = False\n        self.virtual_detector = False\n\n    def add_robot(self, robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n        \"\"\"\n        Add the robot.\n\n        Parameters:\n            robot_id: ID of the robot\n            virtual_planner: whether the planner is virtual or not,\n                if planner is virtual, use shared memory to get the robot current, pose order and obstacles.\n            virtual_detector: whether the detector is virtual or not,\n                if detector is virtual, detect virtual obstacles and write them in shared memory.\n        \"\"\"\n        self.virtual_planner = virtual_planner\n        self.virtual_detector = virtual_detector\n        self.robot = RobotEntity(\n            robot_id,\n            self._win,\n            self._game_view.scene_entity,\n            virtual_planner=virtual_planner,\n            virtual_detector=virtual_detector,\n        )\n        self._game_view.add_asset(self.robot)\n\n        if virtual_planner:\n            self._update_obstacles.start(self._update_obstacles_interval)\n\n    def del_robot(self, robot_id: int = 0) -&gt; None:\n        \"\"\"\n        Remove a robot.\n\n        Parameters:\n            robot_id: ID of the robot to remove\n        \"\"\"\n        if self.virtual_planner:\n            self._update_obstacles.stop()\n        self.robot.setParent(None)\n        self.robot.delete_shared_memory()\n        self.robot = None\n\n    def new_robot_pose_order(self, new_pose: Pose) -&gt; None:\n        \"\"\"\n        Set the robot's new pose order.\n\n        Arguments:\n            new_pose: new robot pose\n        \"\"\"\n        if self.robot:\n            self.robot.new_robot_pose_order(new_pose)\n\n    def update_obstacles(self) -&gt; None:\n        \"\"\"\n        Qt Slot\n\n        Display the dynamic obstacles detected by the robot.\n\n        Reuse already created dynamic obstacles to optimize performance\n        and memory consumption.\n        \"\"\"\n        # Store new and already existing dyn obstacles\n        current_rect_obstacles = []\n        current_round_obstacles = []\n\n        if self.robot:\n            if self.robot.shared_circle_obstacles is not None:\n                self.robot.shared_obstacles_lock.start_reading()\n                for circle_obstacle in self.robot.shared_circle_obstacles:\n                    if len(self._round_obstacles_pool):\n                        obstacle = self._round_obstacles_pool.pop(0)\n                        obstacle.setEnabled(True)\n                    else:\n                        obstacle = DynCircleObstacleEntity(self._game_view.scene_entity)\n\n                    obstacle.set_position(\n                        x=circle_obstacle.center.x,\n                        y=circle_obstacle.center.y,\n                        radius=circle_obstacle.radius,\n                    )\n                    obstacle.set_bounding_box(circle_obstacle.bounding_box)\n\n                    current_round_obstacles.append(obstacle)\n                self.robot.shared_obstacles_lock.finish_reading()\n\n            if self.robot.shared_rectangle_obstacles is not None:\n                for rectangle_obstacle in self.robot.shared_rectangle_obstacles:\n                    if len(self._rect_obstacles_pool):\n                        obstacle = self._rect_obstacles_pool.pop(0)\n                        obstacle.setEnabled(True)\n                    else:\n                        obstacle = DynRectObstacleEntity(self._game_view.scene_entity)\n\n                    obstacle.set_position(\n                        x=rectangle_obstacle.center.x,\n                        y=rectangle_obstacle.center.y,\n                        rotation=rectangle_obstacle.center.angle,\n                    )\n                    obstacle.set_size(length=rectangle_obstacle.length_y, width=rectangle_obstacle.length_x)\n                    obstacle.set_bounding_box(rectangle_obstacle.bounding_box)\n\n                    current_rect_obstacles.append(obstacle)\n\n        # Disable remaining dyn obstacles\n        while len(self._rect_obstacles_pool):\n            dyn_obstacle = self._rect_obstacles_pool.pop(0)\n            dyn_obstacle.setEnabled(False)\n            current_rect_obstacles.append(dyn_obstacle)\n\n        while len(self._round_obstacles_pool):\n            dyn_obstacle = self._round_obstacles_pool.pop(0)\n            dyn_obstacle.setEnabled(False)\n            current_round_obstacles.append(dyn_obstacle)\n\n        self._rect_obstacles_pool = current_rect_obstacles\n        self._round_obstacles_pool = current_round_obstacles\n\n    def update_shared_obstacles(self, obstacles: list[Vertex]):\n        if self.robot:\n            self.robot.shared_monitor_obstacles_lock.start_writing()\n            self.robot.shared_monitor_obstacles.clear()\n            for obstacle in obstacles:\n                self.robot.shared_monitor_obstacles.append(obstacle.x, obstacle.y)\n            self.robot.shared_monitor_obstacles_lock.finish_writing()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.__init__","title":"<code>__init__(win)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>game_view</code> <p>parent of the robots</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def __init__(self, win: MainWindow):\n    \"\"\"\n    Class constructor.\n\n    Parameters:\n        game_view: parent of the robots\n    \"\"\"\n    super().__init__()\n    self._win = win\n    self._game_view = win.game_view\n    self._rect_obstacles_pool: list[DynRectObstacleEntity] = []\n    self._round_obstacles_pool: list[DynCircleObstacleEntity] = []\n    self._update_obstacles = QtCore.QTimer()\n    self._update_obstacles.timeout.connect(self.update_obstacles)\n    self._update_obstacles_interval = 100\n    self.virtual_planner = False\n    self.virtual_detector = False\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.add_robot","title":"<code>add_robot(robot_id, virtual_planner, virtual_detector)</code>","text":"<p>Add the robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>virtual_planner</code> <code>bool</code> <p>whether the planner is virtual or not, if planner is virtual, use shared memory to get the robot current, pose order and obstacles.</p> required <code>virtual_detector</code> <code>bool</code> <p>whether the detector is virtual or not, if detector is virtual, detect virtual obstacles and write them in shared memory.</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def add_robot(self, robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n    \"\"\"\n    Add the robot.\n\n    Parameters:\n        robot_id: ID of the robot\n        virtual_planner: whether the planner is virtual or not,\n            if planner is virtual, use shared memory to get the robot current, pose order and obstacles.\n        virtual_detector: whether the detector is virtual or not,\n            if detector is virtual, detect virtual obstacles and write them in shared memory.\n    \"\"\"\n    self.virtual_planner = virtual_planner\n    self.virtual_detector = virtual_detector\n    self.robot = RobotEntity(\n        robot_id,\n        self._win,\n        self._game_view.scene_entity,\n        virtual_planner=virtual_planner,\n        virtual_detector=virtual_detector,\n    )\n    self._game_view.add_asset(self.robot)\n\n    if virtual_planner:\n        self._update_obstacles.start(self._update_obstacles_interval)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.del_robot","title":"<code>del_robot(robot_id=0)</code>","text":"<p>Remove a robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot to remove</p> <code>0</code> Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def del_robot(self, robot_id: int = 0) -&gt; None:\n    \"\"\"\n    Remove a robot.\n\n    Parameters:\n        robot_id: ID of the robot to remove\n    \"\"\"\n    if self.virtual_planner:\n        self._update_obstacles.stop()\n    self.robot.setParent(None)\n    self.robot.delete_shared_memory()\n    self.robot = None\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.new_robot_pose_order","title":"<code>new_robot_pose_order(new_pose)</code>","text":"<p>Set the robot's new pose order.</p> <p>Parameters:</p> Name Type Description Default <code>new_pose</code> <code>Pose</code> <p>new robot pose</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def new_robot_pose_order(self, new_pose: Pose) -&gt; None:\n    \"\"\"\n    Set the robot's new pose order.\n\n    Arguments:\n        new_pose: new robot pose\n    \"\"\"\n    if self.robot:\n        self.robot.new_robot_pose_order(new_pose)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.update_obstacles","title":"<code>update_obstacles()</code>","text":"<p>Qt Slot</p> <p>Display the dynamic obstacles detected by the robot.</p> <p>Reuse already created dynamic obstacles to optimize performance and memory consumption.</p> Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def update_obstacles(self) -&gt; None:\n    \"\"\"\n    Qt Slot\n\n    Display the dynamic obstacles detected by the robot.\n\n    Reuse already created dynamic obstacles to optimize performance\n    and memory consumption.\n    \"\"\"\n    # Store new and already existing dyn obstacles\n    current_rect_obstacles = []\n    current_round_obstacles = []\n\n    if self.robot:\n        if self.robot.shared_circle_obstacles is not None:\n            self.robot.shared_obstacles_lock.start_reading()\n            for circle_obstacle in self.robot.shared_circle_obstacles:\n                if len(self._round_obstacles_pool):\n                    obstacle = self._round_obstacles_pool.pop(0)\n                    obstacle.setEnabled(True)\n                else:\n                    obstacle = DynCircleObstacleEntity(self._game_view.scene_entity)\n\n                obstacle.set_position(\n                    x=circle_obstacle.center.x,\n                    y=circle_obstacle.center.y,\n                    radius=circle_obstacle.radius,\n                )\n                obstacle.set_bounding_box(circle_obstacle.bounding_box)\n\n                current_round_obstacles.append(obstacle)\n            self.robot.shared_obstacles_lock.finish_reading()\n\n        if self.robot.shared_rectangle_obstacles is not None:\n            for rectangle_obstacle in self.robot.shared_rectangle_obstacles:\n                if len(self._rect_obstacles_pool):\n                    obstacle = self._rect_obstacles_pool.pop(0)\n                    obstacle.setEnabled(True)\n                else:\n                    obstacle = DynRectObstacleEntity(self._game_view.scene_entity)\n\n                obstacle.set_position(\n                    x=rectangle_obstacle.center.x,\n                    y=rectangle_obstacle.center.y,\n                    rotation=rectangle_obstacle.center.angle,\n                )\n                obstacle.set_size(length=rectangle_obstacle.length_y, width=rectangle_obstacle.length_x)\n                obstacle.set_bounding_box(rectangle_obstacle.bounding_box)\n\n                current_rect_obstacles.append(obstacle)\n\n    # Disable remaining dyn obstacles\n    while len(self._rect_obstacles_pool):\n        dyn_obstacle = self._rect_obstacles_pool.pop(0)\n        dyn_obstacle.setEnabled(False)\n        current_rect_obstacles.append(dyn_obstacle)\n\n    while len(self._round_obstacles_pool):\n        dyn_obstacle = self._round_obstacles_pool.pop(0)\n        dyn_obstacle.setEnabled(False)\n        current_round_obstacles.append(dyn_obstacle)\n\n    self._rect_obstacles_pool = current_rect_obstacles\n    self._round_obstacles_pool = current_round_obstacles\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/","title":"sensor","text":""},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.LidarSensor","title":"<code>LidarSensor</code>","text":"<p>               Bases: <code>Sensor</code></p> <p>Specialized LIDAR sensor.</p> <p>Its impact entity is represented by a small blue sphere.</p> Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>class LidarSensor(Sensor):\n    \"\"\"\n    Specialized LIDAR sensor.\n\n    Its impact entity is represented by a small blue sphere.\n    \"\"\"\n\n    nb_lidar_sensors = 0\n\n    def __init__(\n        self,\n        asset_entity: AssetEntity,\n        name: str,\n        angle: int,\n        origin_x: float,\n        origin_y: float,\n        origin_z: float,\n        direction_x: float,\n        direction_y: float,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            asset_entity: Entity containing the sensor\n            name: Name of the sensor\n            angle: Sensor orientation in degrees\n            origin_x: X origin of the ray caster\n            origin_y: Y origin of the ray caster\n            origin_z: Z origin of the ray caster\n            direction_x: X direction of the ray caster\n            direction_y: Y direction of the ray caster\n        \"\"\"\n\n        super().__init__(\n            asset_entity=asset_entity,\n            name=name,\n            angle=angle,\n            origin_x=origin_x,\n            origin_y=origin_y,\n            origin_z=origin_z,\n            direction_x=direction_x,\n            direction_y=direction_y,\n            direction_z=0,\n            impact_radius=10,\n            impact_color=QtCore.Qt.cyan,\n        )\n\n        self.lidar_id = LidarSensor.nb_lidar_sensors\n        LidarSensor.nb_lidar_sensors += 1\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.LidarSensor.__init__","title":"<code>__init__(asset_entity, name, angle, origin_x, origin_y, origin_z, direction_x, direction_y)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>asset_entity</code> <code>AssetEntity</code> <p>Entity containing the sensor</p> required <code>name</code> <code>str</code> <p>Name of the sensor</p> required <code>angle</code> <code>int</code> <p>Sensor orientation in degrees</p> required <code>origin_x</code> <code>float</code> <p>X origin of the ray caster</p> required <code>origin_y</code> <code>float</code> <p>Y origin of the ray caster</p> required <code>origin_z</code> <code>float</code> <p>Z origin of the ray caster</p> required <code>direction_x</code> <code>float</code> <p>X direction of the ray caster</p> required <code>direction_y</code> <code>float</code> <p>Y direction of the ray caster</p> required Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>def __init__(\n    self,\n    asset_entity: AssetEntity,\n    name: str,\n    angle: int,\n    origin_x: float,\n    origin_y: float,\n    origin_z: float,\n    direction_x: float,\n    direction_y: float,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        asset_entity: Entity containing the sensor\n        name: Name of the sensor\n        angle: Sensor orientation in degrees\n        origin_x: X origin of the ray caster\n        origin_y: Y origin of the ray caster\n        origin_z: Z origin of the ray caster\n        direction_x: X direction of the ray caster\n        direction_y: Y direction of the ray caster\n    \"\"\"\n\n    super().__init__(\n        asset_entity=asset_entity,\n        name=name,\n        angle=angle,\n        origin_x=origin_x,\n        origin_y=origin_y,\n        origin_z=origin_z,\n        direction_x=direction_x,\n        direction_y=direction_y,\n        direction_z=0,\n        impact_radius=10,\n        impact_color=QtCore.Qt.cyan,\n    )\n\n    self.lidar_id = LidarSensor.nb_lidar_sensors\n    LidarSensor.nb_lidar_sensors += 1\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.Sensor","title":"<code>Sensor</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Base class for all sensors.</p> <p>The sensors are based on QRayCaster. It casts a ray and detects collisions with obstacles. Detected collision is represented using a ImpactEntity object.</p> <p>Attributes:</p> Name Type Description <code>obstacles</code> <code>list[QEntity]</code> <p>Class attribute recording all entities that should be detected</p> <code>all_sensors</code> <code>list[Sensor]</code> <p>Class attribute recording all sensors</p> Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>class Sensor(QtCore.QObject):\n    \"\"\"\n    Base class for all sensors.\n\n    The sensors are based on [QRayCaster](https://doc.qt.io/qtforpython-6/PySide6/Qt3DRender/QRayCaster.html).\n    It casts a ray and detects collisions with obstacles.\n    Detected collision is represented using a [ImpactEntity][cogip.tools.monitor.impact.ImpactEntity] object.\n\n    Attributes:\n        obstacles: Class attribute recording all entities that should be detected\n        all_sensors: Class attribute recording all sensors\n    \"\"\"\n\n    obstacles: list[Qt3DCore.QEntity] = []\n    all_sensors: list[\"Sensor\"] = []\n\n    def __init__(\n        self,\n        asset_entity: AssetEntity,\n        name: str,\n        angle: int,\n        origin_x: float,\n        origin_y: float,\n        origin_z: float,\n        direction_x: float,\n        direction_y: float,\n        direction_z: float,\n        impact_radius: float = 50,\n        impact_color: QtCore.Qt.GlobalColor = QtCore.Qt.red,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Origin and direction are relative to the parent entity (the robot).\n\n        Arguments:\n            asset_entity: Entity containing the sensor\n            name: Name of the sensor\n            angle: Sensor orientation in degrees\n            origin_x: X origin of the ray caster\n            origin_y: Y origin of the ray caster\n            origin_z: Z origin of the ray caster\n            direction_x: X direction of the ray caster\n            direction_y: Y direction of the ray caster\n            direction_z: Z direction of the ray caster\n            impact_radius: Radius of the `ImpactEntity` representing the collision\n            impact_color: Color of the `ImpactEntity` representing the collision\n        \"\"\"\n        super().__init__()\n\n        Sensor.all_sensors.append(self)\n        self.origin_x = origin_x\n        self.origin_y = origin_y\n        self.origin_z = origin_z\n        self.asset_entity = asset_entity\n        self.name = name\n        self.angle = angle\n        self.shared_sensor_data: NDArray | None = None\n        self.shared_sensor_data_lock: WritePriorityLock | None = None\n        self.hit: Qt3DRender.QRayCasterHit | None = None\n        self.hit_distance = 65535\n\n        self.ray_caster = Qt3DRender.QRayCaster()\n        self.ray_caster.setLength(0)  # Infinite\n        self.ray_caster.setRunMode(Qt3DRender.QAbstractRayCaster.RunMode.SingleShot)\n        self.ray_caster.setFilterMode(Qt3DRender.QAbstractRayCaster.FilterMode.AcceptAnyMatchingLayers)\n        self.ray_caster.setOrigin(QtGui.QVector3D(float(origin_x), float(origin_y), float(origin_z)))\n        self.ray_caster.setDirection(QtGui.QVector3D(float(direction_x), float(direction_y), float(direction_z)))\n        self.ray_caster.hitsChanged.connect(self.update_hit)\n        self.asset_entity.addComponent(self.ray_caster)\n\n        # Add layers for obstacles already present\n        for obstacle in self.obstacles:\n            self.add_obstacle_layer(obstacle)\n\n        # Add impact entity\n        self.impact_entity = ImpactEntity(radius=impact_radius, color=impact_color)\n        self.impact_entity.setParent(self.asset_entity.parent().parent().parent())\n\n    @qtSlot()\n    def update_hit(self):\n        \"\"\"\n        Qt Slot\n\n        Compute the distance with the closest detected obstacle.\n        \"\"\"\n        distances = [hit for hit in self.ray_caster.hits() if hit.distance() != 0.0]\n        if len(distances):\n            self.hit = min(distances, key=lambda x: x.distance())\n            self.hit_distance = int(self.hit.distance())\n        else:\n            self.hit = None\n            self.hit_distance = 65535\n\n        if self.shared_sensor_data is not None:\n            self.shared_sensor_data[self.angle][1] = self.hit_distance\n\n            if self.angle == 359:\n                self.shared_sensor_data_lock.post_update()\n\n        self.update_impact()\n\n    def update_impact(self):\n        \"\"\"\n        Display the impact entity at the collision point.\n        \"\"\"\n        if self.hit:\n            self.impact_entity.setEnabled(True)\n            self.impact_entity.transform.setTranslation(self.hit.worldIntersection())\n        else:\n            self.impact_entity.setEnabled(False)\n\n    @classmethod\n    def add_obstacle(cls, obstacle: Qt3DCore.QEntity):\n        \"\"\"\n        Class method.\n\n        Register an obstacle added on the table.\n\n        Arguments:\n            obstacle: The obstacle to register\n        \"\"\"\n        cls.obstacles.append(obstacle)\n        for sensor in cls.all_sensors:\n            sensor.add_obstacle_layer(obstacle)\n\n    def add_obstacle_layer(self, obstacle: Qt3DCore.QEntity):\n        \"\"\"\n        Add the obstacle layer to the ray caster.\n        This allows the obstacle to be detected by the ray caster.\n\n        Arguments:\n            obstacle: The obstacle to detect\n        \"\"\"\n        self.ray_caster.addLayer(obstacle.layer)\n        self.ray_caster.trigger()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.Sensor.__init__","title":"<code>__init__(asset_entity, name, angle, origin_x, origin_y, origin_z, direction_x, direction_y, direction_z, impact_radius=50, impact_color=QtCore.Qt.red)</code>","text":"<p>Class constructor.</p> <p>Origin and direction are relative to the parent entity (the robot).</p> <p>Parameters:</p> Name Type Description Default <code>asset_entity</code> <code>AssetEntity</code> <p>Entity containing the sensor</p> required <code>name</code> <code>str</code> <p>Name of the sensor</p> required <code>angle</code> <code>int</code> <p>Sensor orientation in degrees</p> required <code>origin_x</code> <code>float</code> <p>X origin of the ray caster</p> required <code>origin_y</code> <code>float</code> <p>Y origin of the ray caster</p> required <code>origin_z</code> <code>float</code> <p>Z origin of the ray caster</p> required <code>direction_x</code> <code>float</code> <p>X direction of the ray caster</p> required <code>direction_y</code> <code>float</code> <p>Y direction of the ray caster</p> required <code>direction_z</code> <code>float</code> <p>Z direction of the ray caster</p> required <code>impact_radius</code> <code>float</code> <p>Radius of the <code>ImpactEntity</code> representing the collision</p> <code>50</code> <code>impact_color</code> <code>GlobalColor</code> <p>Color of the <code>ImpactEntity</code> representing the collision</p> <code>red</code> Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>def __init__(\n    self,\n    asset_entity: AssetEntity,\n    name: str,\n    angle: int,\n    origin_x: float,\n    origin_y: float,\n    origin_z: float,\n    direction_x: float,\n    direction_y: float,\n    direction_z: float,\n    impact_radius: float = 50,\n    impact_color: QtCore.Qt.GlobalColor = QtCore.Qt.red,\n):\n    \"\"\"\n    Class constructor.\n\n    Origin and direction are relative to the parent entity (the robot).\n\n    Arguments:\n        asset_entity: Entity containing the sensor\n        name: Name of the sensor\n        angle: Sensor orientation in degrees\n        origin_x: X origin of the ray caster\n        origin_y: Y origin of the ray caster\n        origin_z: Z origin of the ray caster\n        direction_x: X direction of the ray caster\n        direction_y: Y direction of the ray caster\n        direction_z: Z direction of the ray caster\n        impact_radius: Radius of the `ImpactEntity` representing the collision\n        impact_color: Color of the `ImpactEntity` representing the collision\n    \"\"\"\n    super().__init__()\n\n    Sensor.all_sensors.append(self)\n    self.origin_x = origin_x\n    self.origin_y = origin_y\n    self.origin_z = origin_z\n    self.asset_entity = asset_entity\n    self.name = name\n    self.angle = angle\n    self.shared_sensor_data: NDArray | None = None\n    self.shared_sensor_data_lock: WritePriorityLock | None = None\n    self.hit: Qt3DRender.QRayCasterHit | None = None\n    self.hit_distance = 65535\n\n    self.ray_caster = Qt3DRender.QRayCaster()\n    self.ray_caster.setLength(0)  # Infinite\n    self.ray_caster.setRunMode(Qt3DRender.QAbstractRayCaster.RunMode.SingleShot)\n    self.ray_caster.setFilterMode(Qt3DRender.QAbstractRayCaster.FilterMode.AcceptAnyMatchingLayers)\n    self.ray_caster.setOrigin(QtGui.QVector3D(float(origin_x), float(origin_y), float(origin_z)))\n    self.ray_caster.setDirection(QtGui.QVector3D(float(direction_x), float(direction_y), float(direction_z)))\n    self.ray_caster.hitsChanged.connect(self.update_hit)\n    self.asset_entity.addComponent(self.ray_caster)\n\n    # Add layers for obstacles already present\n    for obstacle in self.obstacles:\n        self.add_obstacle_layer(obstacle)\n\n    # Add impact entity\n    self.impact_entity = ImpactEntity(radius=impact_radius, color=impact_color)\n    self.impact_entity.setParent(self.asset_entity.parent().parent().parent())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.Sensor.add_obstacle","title":"<code>add_obstacle(obstacle)</code>  <code>classmethod</code>","text":"<p>Class method.</p> <p>Register an obstacle added on the table.</p> <p>Parameters:</p> Name Type Description Default <code>obstacle</code> <code>QEntity</code> <p>The obstacle to register</p> required Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>@classmethod\ndef add_obstacle(cls, obstacle: Qt3DCore.QEntity):\n    \"\"\"\n    Class method.\n\n    Register an obstacle added on the table.\n\n    Arguments:\n        obstacle: The obstacle to register\n    \"\"\"\n    cls.obstacles.append(obstacle)\n    for sensor in cls.all_sensors:\n        sensor.add_obstacle_layer(obstacle)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.Sensor.add_obstacle_layer","title":"<code>add_obstacle_layer(obstacle)</code>","text":"<p>Add the obstacle layer to the ray caster. This allows the obstacle to be detected by the ray caster.</p> <p>Parameters:</p> Name Type Description Default <code>obstacle</code> <code>QEntity</code> <p>The obstacle to detect</p> required Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>def add_obstacle_layer(self, obstacle: Qt3DCore.QEntity):\n    \"\"\"\n    Add the obstacle layer to the ray caster.\n    This allows the obstacle to be detected by the ray caster.\n\n    Arguments:\n        obstacle: The obstacle to detect\n    \"\"\"\n    self.ray_caster.addLayer(obstacle.layer)\n    self.ray_caster.trigger()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.Sensor.update_hit","title":"<code>update_hit()</code>","text":"<p>Qt Slot</p> <p>Compute the distance with the closest detected obstacle.</p> Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>@qtSlot()\ndef update_hit(self):\n    \"\"\"\n    Qt Slot\n\n    Compute the distance with the closest detected obstacle.\n    \"\"\"\n    distances = [hit for hit in self.ray_caster.hits() if hit.distance() != 0.0]\n    if len(distances):\n        self.hit = min(distances, key=lambda x: x.distance())\n        self.hit_distance = int(self.hit.distance())\n    else:\n        self.hit = None\n        self.hit_distance = 65535\n\n    if self.shared_sensor_data is not None:\n        self.shared_sensor_data[self.angle][1] = self.hit_distance\n\n        if self.angle == 359:\n            self.shared_sensor_data_lock.post_update()\n\n    self.update_impact()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.Sensor.update_impact","title":"<code>update_impact()</code>","text":"<p>Display the impact entity at the collision point.</p> Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>def update_impact(self):\n    \"\"\"\n    Display the impact entity at the collision point.\n    \"\"\"\n    if self.hit:\n        self.impact_entity.setEnabled(True)\n        self.impact_entity.transform.setTranslation(self.hit.worldIntersection())\n    else:\n        self.impact_entity.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.ToFSensor","title":"<code>ToFSensor</code>","text":"<p>               Bases: <code>Sensor</code></p> <p>Specialized ToF sensor.</p> <p>It is represented by a small red cube placed at the origin of the ray caster.</p> <p>Its impact entity is represented by a small red sphere.</p> Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>class ToFSensor(Sensor):\n    \"\"\"\n    Specialized ToF sensor.\n\n    It is represented by a small red cube placed at the origin of the ray caster.\n\n    Its impact entity is represented by a small red sphere.\n    \"\"\"\n\n    nb_tof_sensors = 0\n\n    def __init__(\n        self,\n        asset_entity: AssetEntity,\n        name: str,\n        angle: int,\n        origin_x: float,\n        origin_y: float,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            asset_entity: Entity containing the sensor\n            name: Name of the sensor\n            angle: Sensor orientation in degrees\n            origin_x: X origin of the ray caster\n            origin_y: Y origin of the ray caster\n        \"\"\"\n        super().__init__(\n            asset_entity=asset_entity,\n            name=name,\n            angle=angle,\n            origin_x=origin_x,\n            origin_y=origin_y,\n            origin_z=60,\n            direction_x=origin_x,\n            direction_y=origin_y,\n            direction_z=0,\n            impact_radius=50,\n            impact_color=QtCore.Qt.red,\n        )\n        self.tof_id = ToFSensor.nb_tof_sensors\n        ToFSensor.nb_tof_sensors += 1\n\n        rotation = math.degrees(math.acos(origin_x / math.dist((0, 0), (origin_x, origin_y))))\n\n        self.entity = Qt3DCore.QEntity()\n        self.entity.setParent(self.asset_entity)\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setXExtent(10)\n        self.mesh.setYExtent(10)\n        self.mesh.setZExtent(10)\n        self.entity.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial()\n        self.material.setDiffuse(QtGui.QColor(QtCore.Qt.red))\n        self.entity.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform()\n        self.transform.setTranslation(QtGui.QVector3D(origin_x, origin_y, 60))\n        self.transform.setRotationZ(rotation)\n        self.entity.addComponent(self.transform)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sensor/#cogip.tools.monitor.sensor.ToFSensor.__init__","title":"<code>__init__(asset_entity, name, angle, origin_x, origin_y)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>asset_entity</code> <code>AssetEntity</code> <p>Entity containing the sensor</p> required <code>name</code> <code>str</code> <p>Name of the sensor</p> required <code>angle</code> <code>int</code> <p>Sensor orientation in degrees</p> required <code>origin_x</code> <code>float</code> <p>X origin of the ray caster</p> required <code>origin_y</code> <code>float</code> <p>Y origin of the ray caster</p> required Source code in <code>cogip/tools/monitor/sensor.py</code> <pre><code>def __init__(\n    self,\n    asset_entity: AssetEntity,\n    name: str,\n    angle: int,\n    origin_x: float,\n    origin_y: float,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        asset_entity: Entity containing the sensor\n        name: Name of the sensor\n        angle: Sensor orientation in degrees\n        origin_x: X origin of the ray caster\n        origin_y: Y origin of the ray caster\n    \"\"\"\n    super().__init__(\n        asset_entity=asset_entity,\n        name=name,\n        angle=angle,\n        origin_x=origin_x,\n        origin_y=origin_y,\n        origin_z=60,\n        direction_x=origin_x,\n        direction_y=origin_y,\n        direction_z=0,\n        impact_radius=50,\n        impact_color=QtCore.Qt.red,\n    )\n    self.tof_id = ToFSensor.nb_tof_sensors\n    ToFSensor.nb_tof_sensors += 1\n\n    rotation = math.degrees(math.acos(origin_x / math.dist((0, 0), (origin_x, origin_y))))\n\n    self.entity = Qt3DCore.QEntity()\n    self.entity.setParent(self.asset_entity)\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setXExtent(10)\n    self.mesh.setYExtent(10)\n    self.mesh.setZExtent(10)\n    self.entity.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial()\n    self.material.setDiffuse(QtGui.QColor(QtCore.Qt.red))\n    self.entity.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform()\n    self.transform.setTranslation(QtGui.QVector3D(origin_x, origin_y, 60))\n    self.transform.setRotationZ(rotation)\n    self.entity.addComponent(self.transform)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/","title":"socketiocontroller","text":""},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController","title":"<code>SocketioController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>This class controls the socket.io port used to communicate with the server. Its main purpose is to get the shell and tool menus to update the interface, get the robot position to update its position, and send the commands to the robot and to the tools.</p> <p>Attributes:</p> Name Type Description <code>signal_new_console_text</code> <code>Signal</code> <p>Qt signal emitted to log messages in UI console</p> <code>signal_new_menu</code> <code>Signal</code> <p>Qt signal emitted to load a new shell/tool menu</p> <code>signal_new_robot_pose_order</code> <code>Signal</code> <p>Qt signal emitted on robot pose order update</p> <code>signal_new_robot_state</code> <code>Signal</code> <p>Qt signal emitted on robot state update</p> <code>signal_new_robot_path</code> <code>Signal</code> <p>Qt signal emitted on robot path update</p> <code>signal_connected</code> <code>Signal</code> <p>Qt signal emitted on server connection state changes</p> <code>signal_exit</code> <code>Signal</code> <p>Qt signal emitted to exit Monitor</p> <code>signal_add_robot</code> <code>Signal</code> <p>Qt signal emitted to add a new robot</p> <code>signal_del_robot</code> <code>Signal</code> <p>Qt signal emitted to remove a robot</p> <code>signal_wizard_request</code> <code>Signal</code> <p>Qt signal emitted to forward wizard requests</p> <code>signal_start_sensors_emulation</code> <code>Signal</code> <p>Qt signal emitted to start sensors emulation</p> <code>signal_stop_sensors_emulation</code> <code>Signal</code> <p>Qt signal emitted to stop sensors emulation</p> <code>signal_config_request</code> <code>Signal</code> <p>Qt signal emitted to load a new shell/tool menu</p> <code>signal_planner_reset</code> <code>Signal</code> <p>Qt signal emitted on Planner reset command</p> <code>signal_starter_changed</code> <code>Signal</code> <p>Qt signal emitted the starter state has changed</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>class SocketioController(QtCore.QObject):\n    \"\"\"\n    This class controls the socket.io port used to communicate with the server.\n    Its main purpose is to get the shell and tool menus to update the interface,\n    get the robot position to update its position, and send the commands\n    to the robot and to the tools.\n\n    Attributes:\n        signal_new_console_text:\n            Qt signal emitted to log messages in UI console\n        signal_new_menu:\n            Qt signal emitted to load a new shell/tool menu\n        signal_new_robot_pose_order:\n            Qt signal emitted on robot pose order update\n        signal_new_robot_state:\n            Qt signal emitted on robot state update\n        signal_new_robot_path:\n            Qt signal emitted on robot path update\n        signal_connected:\n            Qt signal emitted on server connection state changes\n        signal_exit:\n            Qt signal emitted to exit Monitor\n        signal_add_robot:\n            Qt signal emitted to add a new robot\n        signal_del_robot:\n            Qt signal emitted to remove a robot\n        signal_wizard_request:\n            Qt signal emitted to forward wizard requests\n        signal_start_sensors_emulation:\n            Qt signal emitted to start sensors emulation\n        signal_stop_sensors_emulation:\n            Qt signal emitted to stop sensors emulation\n        signal_config_request:\n            Qt signal emitted to load a new shell/tool menu\n        signal_planner_reset:\n            Qt signal emitted on Planner reset command\n        signal_starter_changed:\n            Qt signal emitted the starter state has changed\n    \"\"\"\n\n    signal_new_console_text: qtSignal = qtSignal(str)\n    signal_new_menu: qtSignal = qtSignal(str, models.ShellMenu)\n    signal_new_robot_pose_order: qtSignal = qtSignal(models.Pose)\n    signal_new_robot_state: qtSignal = qtSignal(int, models.RobotState)\n    signal_new_robot_path: qtSignal = qtSignal(int, list)\n    signal_connected: qtSignal = qtSignal(bool)\n    signal_exit: qtSignal = qtSignal()\n    signal_add_robot: qtSignal = qtSignal(int, bool, bool)\n    signal_del_robot: qtSignal = qtSignal(int)\n    signal_wizard_request: qtSignal = qtSignal(dict)\n    signal_close_wizard: qtSignal = qtSignal()\n    signal_start_sensors_emulation: qtSignal = qtSignal(int)\n    signal_stop_sensors_emulation: qtSignal = qtSignal(int)\n    signal_config_request: qtSignal = qtSignal(dict)\n    signal_actuator_state: qtSignal = qtSignal(object)\n    signal_planner_reset: qtSignal = qtSignal()\n    signal_starter_changed: qtSignal = qtSignal(int, bool)\n\n    def __init__(self, url: str):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            url: URL to socket.io server\n        \"\"\"\n        super().__init__()\n\n        self.url = url\n        self.sio = socketio.Client()\n        self.register_handlers()\n\n        self.menus: dict[str, models.ShellMenu | None] = {}\n\n    def start(self):\n        \"\"\"\n        Connect to socket.io server.\n        \"\"\"\n        # Poll in background to wait for the first connection.\n        # Disconnections/reconnections are handle directly by the client.\n        self._retry_connection = True\n        Thread(target=self.try_connect).start()\n\n    def try_connect(self):\n        while self._retry_connection:\n            try:\n                self.sio.connect(self.url, namespaces=[\"/monitor\", \"/dashboard\"])\n            except socketio.exceptions.ConnectionError as ex:\n                print(ex)\n                time.sleep(2)\n                continue\n            break\n\n    def stop(self):\n        \"\"\"\n        Disconnect from socket.io server.\n        \"\"\"\n        self._retry_connection = False\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    @qtSlot(str)\n    def new_command(self, menu_name: str, command: str):\n        \"\"\"\n        Send a command to the robot.\n\n        Arguments:\n            menu_name: menu to update (\"tool\", ...)\n            command: Command to send\n        \"\"\"\n        self.sio.emit(f\"{menu_name}_cmd\", command, namespace=\"/dashboard\")\n        self.signal_new_console_text.emit(f\"Send '{command}' to {menu_name}\")\n\n    @qtSlot(dict)\n    def config_updated(self, config: dict[str, Any]):\n        self.sio.emit(\"config_updated\", config, namespace=\"/dashboard\")\n\n    @qtSlot(dict)\n    def wizard_response(self, response: dict[str, Any]):\n        self.sio.emit(\"wizard\", response, namespace=\"/dashboard\")\n\n    def new_actuator_command(self, command: ActuatorCommand):\n        \"\"\"\n        Send an actuator command to the robot.\n\n        Arguments:\n            command: actuator command to send\n        \"\"\"\n        self.sio.emit(\"actuator_command\", command.model_dump(mode=\"json\"), namespace=\"/dashboard\")\n\n    def actuators_started(self):\n        \"\"\"\n        Request to start emitting actuators state from the robot.\n        \"\"\"\n        self.sio.emit(\"actuators_start\", namespace=\"/dashboard\")\n\n    def actuators_closed(self):\n        \"\"\"\n        Request to stop emitting actuators state from the robot.\n        \"\"\"\n        self.sio.emit(\"actuators_stop\", namespace=\"/dashboard\")\n\n    @qtSlot(int, bool)\n    def starter_changed(self, robot_id, pushed: bool):\n        self.sio.emit(\"starter_changed\", pushed, namespace=\"/dashboard\")\n\n    def on_menu(self, menu_name: str, data):\n        menu = models.ShellMenu.model_validate(data)\n        if self.menus.get(menu_name) != menu:\n            self.menus[menu_name] = menu\n            self.signal_new_menu.emit(menu_name, menu)\n\n    def register_handlers(self):\n        \"\"\"\n        Define socket.io message handlers.\n        \"\"\"\n\n        @self.sio.on(\"connect\", namespace=\"/dashboard\")\n        def dashboard_connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Dashboard connected to cogip-server\")\n            self.sio.emit(\"connected\", namespace=\"/dashboard\")\n\n        @self.sio.on(\"connect\", namespace=\"/monitor\")\n        def monitor_connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Monitor connected to cogip-server\")\n            self.sio.emit(\"connected\", namespace=\"/monitor\")\n            self.signal_new_console_text.emit(\"Connected to server\")\n            self.signal_connected.emit(True)\n\n        @self.sio.event(namespace=\"/monitor\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            if (\n                data\n                and isinstance(data, dict)\n                and (message := data.get(\"message\"))\n                and message == \"A monitor is already connected\"\n            ):\n                logger.error(f\"Error: {message}.\")\n                self._retry_connection = False\n                self.signal_exit.emit()\n                return\n            logger.error(f\"Monitor connection error: {data}\")\n            self.signal_new_console_text.emit(\"Connection to server failed.\")\n            self.signal_connected.emit(False)\n\n        @self.sio.event(namespace=\"/dashboard\")\n        def dashboard_disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Dashboard disconnected from cogip-server\")\n\n        @self.sio.event(namespace=\"/monitor\")\n        def monitor_disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            self.signal_new_console_text.emit(\"Disconnected from server.\")\n            self.signal_connected.emit(False)\n            logger.info(\"Monitor disconnected from cogip-server\")\n\n        @self.sio.on(\"shell_menu\", namespace=\"/dashboard\")\n        def on_shell_menu(robot_id: int, menu: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on shell menu message.\n            \"\"\"\n            self.on_menu(f\"shell {robot_id}\", menu)\n\n        @self.sio.on(\"tool_menu\", namespace=\"/dashboard\")\n        def on_tool_menu(data):\n            \"\"\"\n            Callback on tool menu message.\n            \"\"\"\n            self.on_menu(\"tool\", data)\n\n        @self.sio.on(\"config\", namespace=\"/dashboard\")\n        def on_config(config):\n            \"\"\"\n            Callback on config request.\n            \"\"\"\n            self.signal_config_request.emit(config)\n\n        @self.sio.on(\"actuator_state\", namespace=\"/dashboard\")\n        def on_actuator_state(actuator_state):\n            \"\"\"\n            Callback on actuator_state message.\n            \"\"\"\n            try:\n                state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n                self.signal_actuator_state.emit(state)\n            except ValidationError as exc:\n                logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n\n        @self.sio.on(\"pose_order\", namespace=\"/dashboard\")\n        def on_pose_order(robot_id: int, data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on robot pose order message.\n            \"\"\"\n            pose = models.Pose.model_validate(data)\n            self.signal_new_robot_pose_order.emit(pose)\n\n        @self.sio.on(\"state\", namespace=\"/dashboard\")\n        def on_state(robot_id: int, data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on robot state message.\n            \"\"\"\n            state = models.RobotState.model_validate(data)\n            self.signal_new_robot_state.emit(robot_id, state)\n\n        @self.sio.on(\"path\", namespace=\"/dashboard\")\n        def on_path(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n            \"\"\"\n            Callback on robot path message.\n            \"\"\"\n            path = TypeAdapter(list[models.Vertex]).validate_python(data)\n            self.signal_new_robot_path.emit(robot_id, path)\n\n        @self.sio.on(\"add_robot\", namespace=\"/monitor\")\n        def on_add_robot(robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n            \"\"\"\n            Add a new robot.\n            \"\"\"\n            self.signal_add_robot.emit(int(robot_id), virtual_planner, virtual_detector)\n\n        @self.sio.on(\"del_robot\", namespace=\"/monitor\")\n        def on_del_robot(robot_id: int) -&gt; None:\n            \"\"\"\n            Remove a robot.\n            \"\"\"\n            self.signal_del_robot.emit(robot_id)\n\n        @self.sio.on(\"wizard\", namespace=\"/dashboard\")\n        def on_wizard_request(data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Wizard request.\n            \"\"\"\n            self.signal_wizard_request.emit(data)\n\n        @self.sio.on(\"close_wizard\", namespace=\"/dashboard\")\n        def on_close_wizard() -&gt; None:\n            \"\"\"\n            Close wizard.\n            \"\"\"\n            self.signal_close_wizard.emit()\n\n        @self.sio.on(\"cmd_reset\", namespace=\"/monitor\")\n        def on_cmd_reset() -&gt; None:\n            \"\"\"\n            Reset command from Planner.\n            \"\"\"\n            self.signal_planner_reset.emit()\n\n        @self.sio.on(\"starter_changed\", namespace=\"/dashboard\")\n        def on_starter_changed(robot_id: int, pushed: bool) -&gt; None:\n            \"\"\"\n            Change the state of a starter.\n            \"\"\"\n            self.signal_starter_changed.emit(robot_id, pushed)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.__init__","title":"<code>__init__(url)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to socket.io server</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def __init__(self, url: str):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        url: URL to socket.io server\n    \"\"\"\n    super().__init__()\n\n    self.url = url\n    self.sio = socketio.Client()\n    self.register_handlers()\n\n    self.menus: dict[str, models.ShellMenu | None] = {}\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.actuators_closed","title":"<code>actuators_closed()</code>","text":"<p>Request to stop emitting actuators state from the robot.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def actuators_closed(self):\n    \"\"\"\n    Request to stop emitting actuators state from the robot.\n    \"\"\"\n    self.sio.emit(\"actuators_stop\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.actuators_started","title":"<code>actuators_started()</code>","text":"<p>Request to start emitting actuators state from the robot.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def actuators_started(self):\n    \"\"\"\n    Request to start emitting actuators state from the robot.\n    \"\"\"\n    self.sio.emit(\"actuators_start\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.new_actuator_command","title":"<code>new_actuator_command(command)</code>","text":"<p>Send an actuator command to the robot.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ActuatorCommand</code> <p>actuator command to send</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def new_actuator_command(self, command: ActuatorCommand):\n    \"\"\"\n    Send an actuator command to the robot.\n\n    Arguments:\n        command: actuator command to send\n    \"\"\"\n    self.sio.emit(\"actuator_command\", command.model_dump(mode=\"json\"), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.new_command","title":"<code>new_command(menu_name, command)</code>","text":"<p>Send a command to the robot.</p> <p>Parameters:</p> Name Type Description Default <code>menu_name</code> <code>str</code> <p>menu to update (\"tool\", ...)</p> required <code>command</code> <code>str</code> <p>Command to send</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>@qtSlot(str)\ndef new_command(self, menu_name: str, command: str):\n    \"\"\"\n    Send a command to the robot.\n\n    Arguments:\n        menu_name: menu to update (\"tool\", ...)\n        command: Command to send\n    \"\"\"\n    self.sio.emit(f\"{menu_name}_cmd\", command, namespace=\"/dashboard\")\n    self.signal_new_console_text.emit(f\"Send '{command}' to {menu_name}\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.register_handlers","title":"<code>register_handlers()</code>","text":"<p>Define socket.io message handlers.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def register_handlers(self):\n    \"\"\"\n    Define socket.io message handlers.\n    \"\"\"\n\n    @self.sio.on(\"connect\", namespace=\"/dashboard\")\n    def dashboard_connect():\n        \"\"\"\n        Callback on server connection.\n        \"\"\"\n        polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Dashboard connected to cogip-server\")\n        self.sio.emit(\"connected\", namespace=\"/dashboard\")\n\n    @self.sio.on(\"connect\", namespace=\"/monitor\")\n    def monitor_connect():\n        \"\"\"\n        Callback on server connection.\n        \"\"\"\n        polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Monitor connected to cogip-server\")\n        self.sio.emit(\"connected\", namespace=\"/monitor\")\n        self.signal_new_console_text.emit(\"Connected to server\")\n        self.signal_connected.emit(True)\n\n    @self.sio.event(namespace=\"/monitor\")\n    def connect_error(data):\n        \"\"\"\n        Callback on server connection error.\n        \"\"\"\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A monitor is already connected\"\n        ):\n            logger.error(f\"Error: {message}.\")\n            self._retry_connection = False\n            self.signal_exit.emit()\n            return\n        logger.error(f\"Monitor connection error: {data}\")\n        self.signal_new_console_text.emit(\"Connection to server failed.\")\n        self.signal_connected.emit(False)\n\n    @self.sio.event(namespace=\"/dashboard\")\n    def dashboard_disconnect():\n        \"\"\"\n        Callback on server disconnection.\n        \"\"\"\n        logger.info(\"Dashboard disconnected from cogip-server\")\n\n    @self.sio.event(namespace=\"/monitor\")\n    def monitor_disconnect():\n        \"\"\"\n        Callback on server disconnection.\n        \"\"\"\n        self.signal_new_console_text.emit(\"Disconnected from server.\")\n        self.signal_connected.emit(False)\n        logger.info(\"Monitor disconnected from cogip-server\")\n\n    @self.sio.on(\"shell_menu\", namespace=\"/dashboard\")\n    def on_shell_menu(robot_id: int, menu: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on shell menu message.\n        \"\"\"\n        self.on_menu(f\"shell {robot_id}\", menu)\n\n    @self.sio.on(\"tool_menu\", namespace=\"/dashboard\")\n    def on_tool_menu(data):\n        \"\"\"\n        Callback on tool menu message.\n        \"\"\"\n        self.on_menu(\"tool\", data)\n\n    @self.sio.on(\"config\", namespace=\"/dashboard\")\n    def on_config(config):\n        \"\"\"\n        Callback on config request.\n        \"\"\"\n        self.signal_config_request.emit(config)\n\n    @self.sio.on(\"actuator_state\", namespace=\"/dashboard\")\n    def on_actuator_state(actuator_state):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        try:\n            state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n            self.signal_actuator_state.emit(state)\n        except ValidationError as exc:\n            logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n\n    @self.sio.on(\"pose_order\", namespace=\"/dashboard\")\n    def on_pose_order(robot_id: int, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot pose order message.\n        \"\"\"\n        pose = models.Pose.model_validate(data)\n        self.signal_new_robot_pose_order.emit(pose)\n\n    @self.sio.on(\"state\", namespace=\"/dashboard\")\n    def on_state(robot_id: int, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot state message.\n        \"\"\"\n        state = models.RobotState.model_validate(data)\n        self.signal_new_robot_state.emit(robot_id, state)\n\n    @self.sio.on(\"path\", namespace=\"/dashboard\")\n    def on_path(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n        \"\"\"\n        Callback on robot path message.\n        \"\"\"\n        path = TypeAdapter(list[models.Vertex]).validate_python(data)\n        self.signal_new_robot_path.emit(robot_id, path)\n\n    @self.sio.on(\"add_robot\", namespace=\"/monitor\")\n    def on_add_robot(robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n        \"\"\"\n        Add a new robot.\n        \"\"\"\n        self.signal_add_robot.emit(int(robot_id), virtual_planner, virtual_detector)\n\n    @self.sio.on(\"del_robot\", namespace=\"/monitor\")\n    def on_del_robot(robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n        \"\"\"\n        self.signal_del_robot.emit(robot_id)\n\n    @self.sio.on(\"wizard\", namespace=\"/dashboard\")\n    def on_wizard_request(data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Wizard request.\n        \"\"\"\n        self.signal_wizard_request.emit(data)\n\n    @self.sio.on(\"close_wizard\", namespace=\"/dashboard\")\n    def on_close_wizard() -&gt; None:\n        \"\"\"\n        Close wizard.\n        \"\"\"\n        self.signal_close_wizard.emit()\n\n    @self.sio.on(\"cmd_reset\", namespace=\"/monitor\")\n    def on_cmd_reset() -&gt; None:\n        \"\"\"\n        Reset command from Planner.\n        \"\"\"\n        self.signal_planner_reset.emit()\n\n    @self.sio.on(\"starter_changed\", namespace=\"/dashboard\")\n    def on_starter_changed(robot_id: int, pushed: bool) -&gt; None:\n        \"\"\"\n        Change the state of a starter.\n        \"\"\"\n        self.signal_starter_changed.emit(robot_id, pushed)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.start","title":"<code>start()</code>","text":"<p>Connect to socket.io server.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def start(self):\n    \"\"\"\n    Connect to socket.io server.\n    \"\"\"\n    # Poll in background to wait for the first connection.\n    # Disconnections/reconnections are handle directly by the client.\n    self._retry_connection = True\n    Thread(target=self.try_connect).start()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.stop","title":"<code>stop()</code>","text":"<p>Disconnect from socket.io server.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Disconnect from socket.io server.\n    \"\"\"\n    self._retry_connection = False\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/table/","title":"table","text":""},{"location":"reference/cogip/tools/monitor/table/#cogip.tools.monitor.table.TableEntity","title":"<code>TableEntity</code>","text":"<p>               Bases: <code>AssetEntity</code></p> <p>The table entity.</p> <p>Attributes:</p> Name Type Description <code>asset_path</code> <code>Path</code> <p>Path of the asset file</p> Source code in <code>cogip/tools/monitor/table.py</code> <pre><code>class TableEntity(AssetEntity):\n    \"\"\"\n    The table entity.\n\n    Attributes:\n        asset_path: Path of the asset file\n    \"\"\"\n\n    asset_path: Path = Path(\"assets/table2025.dae\")\n\n    def __init__(self, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Inherits [AssetEntity][cogip.tools.monitor.asset.AssetEntity].\n        \"\"\"\n        super().__init__(self.asset_path, parent=parent)\n        self._parent = parent\n\n        # Create a layer used by sensors to activate detection on the table borders\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        Sensor.add_obstacle(self)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/table/#cogip.tools.monitor.table.TableEntity.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Inherits AssetEntity.</p> Source code in <code>cogip/tools/monitor/table.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Inherits [AssetEntity][cogip.tools.monitor.asset.AssetEntity].\n    \"\"\"\n    super().__init__(self.asset_path, parent=parent)\n    self._parent = parent\n\n    # Create a layer used by sensors to activate detection on the table borders\n    self.layer = Qt3DRender.QLayer(self)\n    self.layer.setRecursive(True)\n    self.layer.setEnabled(True)\n    self.addComponent(self.layer)\n\n    Sensor.add_obstacle(self)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/","title":"wizard","text":""},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.BooleanWizard","title":"<code>BooleanWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>BooleanWizard class.</p> <p>Build a widget to input a boolean.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class BooleanWizard(QtCore.QObject):\n    \"\"\"\n    BooleanWizard class.\n\n    Build a widget to input a boolean.\n    \"\"\"\n\n    response: qtSignal = qtSignal(bool)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignHCenter)\n        parent.setLayout(layout)\n\n        self.input = QtWidgets.QCheckBox()\n        self.input.setChecked(self.wizard.get(\"value\", False))\n        layout.addWidget(self.input)\n\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(self.input.isChecked())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.BooleanWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    layout.setAlignment(QtCore.Qt.AlignHCenter)\n    parent.setLayout(layout)\n\n    self.input = QtWidgets.QCheckBox()\n    self.input.setChecked(self.wizard.get(\"value\", False))\n    layout.addWidget(self.input)\n\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.BooleanWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(self.input.isChecked())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.CampWizard","title":"<code>CampWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>CampWizard class.</p> <p>Build a widget to select a string.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class CampWizard(QtCore.QObject):\n    \"\"\"\n    CampWizard class.\n\n    Build a widget to select a string.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        layout.addLayout(button_layout)\n\n        self.buttons = QtWidgets.QButtonGroup()\n\n        self.button_blue = QtWidgets.QRadioButton()\n        self.button_blue.setObjectName(\"blueCamp\")\n        self.button_blue.setCheckable(True)\n        self.button_blue.setStyleSheet(\n            \"\"\"\n            QRadioButton#blueCamp {\n                border-color: #005CE6;\n                background-color: #005CE6;\n                border-width: 2px;\n                border-radius: 10px;\n                border-style: inset;\n                min-width: 6em;\n                padding: 6px;\n            }\n            QRadioButton#blueCamp:checked {\n                border-color: beige;\n                border-style: outset;\n            }\n            QRadioButton#blueCamp::indicator {\n                border-width: 0;\n            }\n            \"\"\"\n        )\n        self.button_yellow = QtWidgets.QRadioButton()\n        self.button_yellow.setObjectName(\"yellowCamp\")\n        self.button_yellow.setCheckable(True)\n        self.button_yellow.setStyleSheet(\n            \"\"\"\n            QRadioButton#yellowCamp {\n                border-color: #FFBF00;\n                background-color: #FFBF00;\n                border-width: 2px;\n                border-radius: 10px;\n                border-style: inset;\n                min-width: 6em;\n                padding: 6px;\n            }\n            QRadioButton#yellowCamp:checked {\n                border-color: beige;\n                border-style: outset;\n            }\n            QRadioButton#yellowCamp::indicator {\n                border-width: 0;\n            }\n            \"\"\"\n        )\n        self.buttons.addButton(self.button_yellow)\n        button_layout.addWidget(self.button_yellow)\n\n        self.buttons.addButton(self.button_blue)\n        button_layout.addWidget(self.button_blue)\n\n        if wizard[\"value\"] == \"yellow\":\n            self.button_yellow.setChecked(True)\n        else:\n            self.button_blue.setChecked(True)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        color = \"blue\" if self.button_blue.isChecked() else \"yellow\"\n        self.response.emit(color)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.CampWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    button_layout = QtWidgets.QHBoxLayout()\n    layout.addLayout(button_layout)\n\n    self.buttons = QtWidgets.QButtonGroup()\n\n    self.button_blue = QtWidgets.QRadioButton()\n    self.button_blue.setObjectName(\"blueCamp\")\n    self.button_blue.setCheckable(True)\n    self.button_blue.setStyleSheet(\n        \"\"\"\n        QRadioButton#blueCamp {\n            border-color: #005CE6;\n            background-color: #005CE6;\n            border-width: 2px;\n            border-radius: 10px;\n            border-style: inset;\n            min-width: 6em;\n            padding: 6px;\n        }\n        QRadioButton#blueCamp:checked {\n            border-color: beige;\n            border-style: outset;\n        }\n        QRadioButton#blueCamp::indicator {\n            border-width: 0;\n        }\n        \"\"\"\n    )\n    self.button_yellow = QtWidgets.QRadioButton()\n    self.button_yellow.setObjectName(\"yellowCamp\")\n    self.button_yellow.setCheckable(True)\n    self.button_yellow.setStyleSheet(\n        \"\"\"\n        QRadioButton#yellowCamp {\n            border-color: #FFBF00;\n            background-color: #FFBF00;\n            border-width: 2px;\n            border-radius: 10px;\n            border-style: inset;\n            min-width: 6em;\n            padding: 6px;\n        }\n        QRadioButton#yellowCamp:checked {\n            border-color: beige;\n            border-style: outset;\n        }\n        QRadioButton#yellowCamp::indicator {\n            border-width: 0;\n        }\n        \"\"\"\n    )\n    self.buttons.addButton(self.button_yellow)\n    button_layout.addWidget(self.button_yellow)\n\n    self.buttons.addButton(self.button_blue)\n    button_layout.addWidget(self.button_blue)\n\n    if wizard[\"value\"] == \"yellow\":\n        self.button_yellow.setChecked(True)\n    else:\n        self.button_blue.setChecked(True)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.ChoiceWizard","title":"<code>ChoiceWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>ChoiceWizard class.</p> <p>Build a widget to choose a integer, float or string from a list.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class ChoiceWizard(QtCore.QObject):\n    \"\"\"\n    ChoiceWizard class.\n\n    Build a widget to choose a integer, float or string from a list.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        # Normalize choice and group by category as dict[category, list[tuple[value, name]]].\n        # Register a dict to convert name to value.\n        choices: dict[str, list[tuple[str, str]]] = dict()\n        self.name_value_dict: dict[str, str] = dict()\n        for v in wizard[\"choices\"]:\n            if not isinstance(v, list):\n                value, category, name = (v, \"Other\", v)\n            elif isinstance(v, list):\n                if len(v) == 2:\n                    value, category, name = (v[0], v[1], v[0])\n                elif len(v) == 3:\n                    value, category, name = v\n                else:\n                    logger.warning(f\"Unknown value for 'choice_str': {v}\")\n                    continue\n\n            if category not in choices:\n                choices[category] = list()\n            choices[category].append((str(value), str(name)))\n\n            self.name_value_dict[str(name)] = str(value)\n\n        self.tab_widget = QtWidgets.QTabWidget()\n        self.tab_widget.setTabBarAutoHide(True)\n        self.tab_widget.setSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)\n        layout.addWidget(self.tab_widget)\n\n        self.button_groups: dict[str, QtWidgets.QButtonGroup] = dict()\n\n        for category, choices in choices.items():\n            if category not in self.button_groups:\n                tab = QtWidgets.QWidget()\n                tab_layout = QtWidgets.QVBoxLayout(tab)\n                tab_layout.setAlignment(QtCore.Qt.AlignmentFlag.AlignTop)\n                tab.setLayout(tab_layout)\n                self.button_groups[category] = QtWidgets.QButtonGroup(tab)\n                self.tab_widget.addTab(tab, category)\n            button_group = self.button_groups[category]\n            for value, name in choices:\n                button = QtWidgets.QRadioButton(str(name), tab)\n                button_group.addButton(button)\n                if value == str(wizard[\"value\"]):\n                    button.setChecked(True)\n                    self.tab_widget.setCurrentWidget(tab)\n                tab_layout.addWidget(button)\n\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        index = self.tab_widget.currentIndex()\n        category = self.tab_widget.tabText(index)\n        buttons = self.button_groups[category]\n        button = buttons.checkedButton()\n        if button:\n            name = button.text()\n            value = self.name_value_dict[name]\n            self.response.emit(value)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.ChoiceWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    # Normalize choice and group by category as dict[category, list[tuple[value, name]]].\n    # Register a dict to convert name to value.\n    choices: dict[str, list[tuple[str, str]]] = dict()\n    self.name_value_dict: dict[str, str] = dict()\n    for v in wizard[\"choices\"]:\n        if not isinstance(v, list):\n            value, category, name = (v, \"Other\", v)\n        elif isinstance(v, list):\n            if len(v) == 2:\n                value, category, name = (v[0], v[1], v[0])\n            elif len(v) == 3:\n                value, category, name = v\n            else:\n                logger.warning(f\"Unknown value for 'choice_str': {v}\")\n                continue\n\n        if category not in choices:\n            choices[category] = list()\n        choices[category].append((str(value), str(name)))\n\n        self.name_value_dict[str(name)] = str(value)\n\n    self.tab_widget = QtWidgets.QTabWidget()\n    self.tab_widget.setTabBarAutoHide(True)\n    self.tab_widget.setSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)\n    layout.addWidget(self.tab_widget)\n\n    self.button_groups: dict[str, QtWidgets.QButtonGroup] = dict()\n\n    for category, choices in choices.items():\n        if category not in self.button_groups:\n            tab = QtWidgets.QWidget()\n            tab_layout = QtWidgets.QVBoxLayout(tab)\n            tab_layout.setAlignment(QtCore.Qt.AlignmentFlag.AlignTop)\n            tab.setLayout(tab_layout)\n            self.button_groups[category] = QtWidgets.QButtonGroup(tab)\n            self.tab_widget.addTab(tab, category)\n        button_group = self.button_groups[category]\n        for value, name in choices:\n            button = QtWidgets.QRadioButton(str(name), tab)\n            button_group.addButton(button)\n            if value == str(wizard[\"value\"]):\n                button.setChecked(True)\n                self.tab_widget.setCurrentWidget(tab)\n            tab_layout.addWidget(button)\n\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.ChoiceWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    index = self.tab_widget.currentIndex()\n    category = self.tab_widget.tabText(index)\n    buttons = self.button_groups[category]\n    button = buttons.checkedButton()\n    if button:\n        name = button.text()\n        value = self.name_value_dict[name]\n        self.response.emit(value)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.InputWizard","title":"<code>InputWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>InputWizard class.</p> <p>Build a widget to input an integer, float or string.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class InputWizard(QtCore.QObject):\n    \"\"\"\n    InputWizard class.\n\n    Build a widget to input an integer, float or string.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        match self.wizard[\"type\"]:\n            case \"integer\":\n                self.input = QtWidgets.QSpinBox()\n                self.input.setValue(int(self.wizard.get(\"value\", 0)))\n            case \"floating\":\n                self.input = QtWidgets.QDoubleSpinBox()\n                self.input.setValue(float(self.wizard.get(\"value\", 0.0)))\n            case \"str\":\n                self.input = QtWidgets.QLineEdit()\n                self.input.setText(self.wizard.get(\"value\", \"\"))\n        layout.addWidget(self.input)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(self.input.text())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.InputWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    match self.wizard[\"type\"]:\n        case \"integer\":\n            self.input = QtWidgets.QSpinBox()\n            self.input.setValue(int(self.wizard.get(\"value\", 0)))\n        case \"floating\":\n            self.input = QtWidgets.QDoubleSpinBox()\n            self.input.setValue(float(self.wizard.get(\"value\", 0.0)))\n        case \"str\":\n            self.input = QtWidgets.QLineEdit()\n            self.input.setText(self.wizard.get(\"value\", \"\"))\n    layout.addWidget(self.input)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.InputWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(self.input.text())\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.MessageWizard","title":"<code>MessageWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>MessageWizard class.</p> <p>Build a widget to display a message.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class MessageWizard(QtCore.QObject):\n    \"\"\"\n    MessageWizard class.\n\n    Build a widget to display a message.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignHCenter)\n        parent.setLayout(layout)\n\n        self.input = QtWidgets.QLabel()\n        self.input.setText(self.wizard.get(\"value\", False))\n        layout.addWidget(self.input)\n\n        send_button = QtWidgets.QPushButton(\"Ok\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(\"\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.MessageWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    layout.setAlignment(QtCore.Qt.AlignHCenter)\n    parent.setLayout(layout)\n\n    self.input = QtWidgets.QLabel()\n    self.input.setText(self.wizard.get(\"value\", False))\n    layout.addWidget(self.input)\n\n    send_button = QtWidgets.QPushButton(\"Ok\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.MessageWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(\"\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.SelectWizard","title":"<code>SelectWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>SelectWizard class.</p> <p>Build a widget to select one or more integer, float or string from a list.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class SelectWizard(QtCore.QObject):\n    \"\"\"\n    SelectWizard class.\n\n    Build a widget to select one or more integer, float or string from a list.\n    \"\"\"\n\n    response: qtSignal = qtSignal(list)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        self.buttons = []\n        for v in wizard[\"choices\"]:\n            button = QtWidgets.QCheckBox(str(v))\n            self.buttons.append(button)\n            button.setChecked(v in wizard[\"value\"])\n            layout.addWidget(button)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        print([button.text() for button in self.buttons if button.isChecked()])\n        self.response.emit([button.text() for button in self.buttons if button.isChecked()])\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.SelectWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    self.buttons = []\n    for v in wizard[\"choices\"]:\n        button = QtWidgets.QCheckBox(str(v))\n        self.buttons.append(button)\n        button.setChecked(v in wizard[\"value\"])\n        layout.addWidget(button)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.SelectWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    print([button.text() for button in self.buttons if button.isChecked()])\n    self.response.emit([button.text() for button in self.buttons if button.isChecked()])\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.WizardDialog","title":"<code>WizardDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>WizardDialog class</p> <p>Build a modal for wizard request.</p> <p>Attributes:</p> Name Type Description <code>property_updated</code> <p>Qt signal emitted when a property is updated</p> <code>closed</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>class WizardDialog(QtWidgets.QDialog):\n    \"\"\"\n    WizardDialog class\n\n    Build a modal for wizard request.\n\n    Attributes:\n        property_updated: Qt signal emitted when a property is updated\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    response: qtSignal = qtSignal(dict)\n\n    def __init__(self, message: dict[str, Any], parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            message: JSON Schema of properties with current values and namespace\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.message = message\n        self.setWindowTitle(self.message[\"name\"])\n        self.setModal(False)\n        self.setMinimumWidth(300)\n\n        match wizard_type := self.message[\"type\"]:\n            case \"boolean\":\n                self.wizard = BooleanWizard(self.message, self)\n            case \"integer\" | \"floating\" | \"str\":\n                self.wizard = InputWizard(self.message, self)\n            case \"message\":\n                self.wizard = MessageWizard(self.message, self)\n            case \"choice_integer\" | \"choice_floating\" | \"choice_str\":\n                self.wizard = ChoiceWizard(self.message, self)\n            case \"select_integer\" | \"select_floating\" | \"select_str\":\n                self.wizard = SelectWizard(self.message, self)\n            case \"camp\":\n                self.wizard = CampWizard(self.message, self)\n            case _:\n                logger.warning(f\"Wizard message '{wizard_type} unsupported'\")\n                return\n\n        self.wizard.response.connect(self.respond)\n        self.rejected.connect(self.force_close)\n\n    def respond(self, response: str | list[str]):\n        self.message[\"value\"] = response\n        self.response.emit(self.message)\n        self.accept()\n\n    def force_close(self):\n        self.message[\"value\"] = None\n        self.response.emit(self.message)\n        self.accept()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/wizard/#cogip.tools.monitor.wizard.WizardDialog.__init__","title":"<code>__init__(message, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>dict[str, Any]</code> <p>JSON Schema of properties with current values and namespace</p> required <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/tools/monitor/wizard.py</code> <pre><code>def __init__(self, message: dict[str, Any], parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        message: JSON Schema of properties with current values and namespace\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.message = message\n    self.setWindowTitle(self.message[\"name\"])\n    self.setModal(False)\n    self.setMinimumWidth(300)\n\n    match wizard_type := self.message[\"type\"]:\n        case \"boolean\":\n            self.wizard = BooleanWizard(self.message, self)\n        case \"integer\" | \"floating\" | \"str\":\n            self.wizard = InputWizard(self.message, self)\n        case \"message\":\n            self.wizard = MessageWizard(self.message, self)\n        case \"choice_integer\" | \"choice_floating\" | \"choice_str\":\n            self.wizard = ChoiceWizard(self.message, self)\n        case \"select_integer\" | \"select_floating\" | \"select_str\":\n            self.wizard = SelectWizard(self.message, self)\n        case \"camp\":\n            self.wizard = CampWizard(self.message, self)\n        case _:\n            logger.warning(f\"Wizard message '{wizard_type} unsupported'\")\n            return\n\n    self.wizard.response.connect(self.respond)\n    self.rejected.connect(self.force_close)\n</code></pre>"},{"location":"reference/cogip/tools/planner/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/planner/__main__/#cogip.tools.planner.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Game Planner.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-planner</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/planner/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Game Planner.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-planner` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actuators/","title":"actuators","text":""},{"location":"reference/cogip/tools/planner/actuators/#cogip.tools.planner.actuators.actuators_init","title":"<code>actuators_init(planner)</code>  <code>async</code>","text":"<p>Send actuators initialization command to the firmware.</p> Source code in <code>cogip/tools/planner/actuators.py</code> <pre><code>async def actuators_init(planner: \"Planner\"):\n    \"\"\"\n    Send actuators initialization command to the firmware.\n    \"\"\"\n    await arm_right_front(planner)\n    await arm_left_front(planner)\n    await magnet_side_right_in(planner)\n    await magnet_center_right_in(planner)\n    await magnet_center_left_in(planner)\n    await magnet_side_left_in(planner)\n    await arms_close(planner)\n\n    # Right arm first\n    await arm_grip_right_close(planner)\n    await asyncio.sleep(0.2)\n\n    # Left arm\n    await arm_grip_left_close(planner)\n\n    await planner.sio_ns.emit(\"actuator_init\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/cameras/","title":"cameras","text":""},{"location":"reference/cogip/tools/planner/camp/","title":"camp","text":""},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp","title":"<code>Camp</code>","text":"<p>Class representing the camp selected before the game starts.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>class Camp(metaclass=Singleton):\n    \"\"\"\n    Class representing the camp selected before the game starts.\n    \"\"\"\n\n    class Colors(IntEnum):\n        blue = 0\n        yellow = 1\n\n    def __init__(self, color: Colors = Colors.blue):\n        self.color = color\n\n    def adapt_y(self, dist: float) -&gt; float:\n        \"\"\"\n        Adapt Y distance depending on the selected camp.\n        Given the current table orientation and axes,\n        only Y has to be adapted when the camp changes.\n        \"\"\"\n        return dist if self.color == Camp.Colors.blue else -dist\n\n    def adapt_angle(self, angle: float | None) -&gt; float | None:\n        \"\"\"\n        Adapt an angle depending on the actual camp.\n        \"\"\"\n        if angle is None:\n            return None\n        return angle if self.color == Camp.Colors.blue else -angle\n</code></pre>"},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp.adapt_angle","title":"<code>adapt_angle(angle)</code>","text":"<p>Adapt an angle depending on the actual camp.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>def adapt_angle(self, angle: float | None) -&gt; float | None:\n    \"\"\"\n    Adapt an angle depending on the actual camp.\n    \"\"\"\n    if angle is None:\n        return None\n    return angle if self.color == Camp.Colors.blue else -angle\n</code></pre>"},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp.adapt_y","title":"<code>adapt_y(dist)</code>","text":"<p>Adapt Y distance depending on the selected camp. Given the current table orientation and axes, only Y has to be adapted when the camp changes.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>def adapt_y(self, dist: float) -&gt; float:\n    \"\"\"\n    Adapt Y distance depending on the selected camp.\n    Given the current table orientation and axes,\n    only Y has to be adapted when the camp changes.\n    \"\"\"\n    return dist if self.color == Camp.Colors.blue else -dist\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/","title":"context","text":""},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext","title":"<code>GameContext</code>","text":"<p>A class recording the current game context.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>class GameContext(metaclass=Singleton):\n    \"\"\"\n    A class recording the current game context.\n    \"\"\"\n\n    def __init__(self):\n        self.robot_id = int(os.getenv(\"ROBOT_ID\"))\n        self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n        self.shared_properties = self.shared_memory.get_properties()\n        self.game_duration: int = 100\n        self.minimum_score: int = 0\n        self.camp = Camp()\n        self.reset()\n\n        self.tribunes_in_robot = 0\n\n    @property\n    def table(self) -&gt; Table:\n        \"\"\"\n        Selected table.\n        \"\"\"\n        return tables[TableEnum(self.shared_properties.table)]\n\n    @property\n    def start_pose(self) -&gt; Pose:\n        \"\"\"\n        Start pose.\n        \"\"\"\n        return self.start_poses[StartPosition(self.shared_properties.start_position)]\n\n    def reset(self):\n        \"\"\"\n        Reset the context.\n        \"\"\"\n        self.playing = False\n        self.score = self.minimum_score\n        self.countdown = self.game_duration\n        self.last_countdown = self.game_duration\n        self.tribunes_in_robot = 0\n        self.create_start_poses()\n        self.create_artifacts()\n        self.create_fixed_obstacles()\n        self.create_actuators_states()\n\n    @property\n    def default_controller(self) -&gt; ControllerEnum:\n        match self.shared_properties.strategy:\n            case actions.Strategy.PidAngularSpeedTest.val:\n                return ControllerEnum.ANGULAR_SPEED_TEST\n            case actions.Strategy.PidLinearSpeedTest.val:\n                return ControllerEnum.LINEAR_SPEED_TEST\n            case _:\n                return ControllerEnum.QUADPID\n\n    def create_start_poses(self):\n        self.start_poses = {\n            StartPosition.Bottom: AdaptedPose(\n                x=-550 - self.shared_properties.robot_length / 2,\n                y=-100 - self.shared_properties.robot_width / 2,\n                O=0,\n            ),\n            StartPosition.Top: AdaptedPose(\n                x=550 + self.shared_properties.robot_length / 2,\n                y=-900 - self.shared_properties.robot_width / 2,\n                O=180,\n            ),\n            StartPosition.Opposite: AdaptedPose(\n                x=-350 + self.shared_properties.robot_width / 2,\n                y=1050 + self.shared_properties.robot_length / 2,\n                O=-90,\n            ),\n            StartPosition.PAMI2: AdaptedPose(\n                x=550 + 100 * 0.5,\n                y=-1350 - self.shared_properties.robot_length / 2,\n                O=90,\n            ),\n            StartPosition.PAMI3: AdaptedPose(\n                x=550 + 100 * 1.5,\n                y=-1350 - self.shared_properties.robot_length / 2,\n                O=90,\n            ),\n            StartPosition.PAMI4: AdaptedPose(\n                x=550 + 100 * 2.5,\n                y=-1350 - self.shared_properties.robot_length / 2,\n                O=90,\n            ),\n            StartPosition.PAMI5: AdaptedPose(\n                x=550 + 100 * 3.5,\n                y=-1350 - self.shared_properties.robot_length / 2,\n                O=90,\n            ),\n        }\n\n        # Adapt poses for training table\n        if self.shared_properties.table == TableEnum.Training.val:\n            self.start_poses[StartPosition.Top].x -= 1000\n            self.start_poses[StartPosition.PAMI2].x -= 1000\n            self.start_poses[StartPosition.PAMI3].x -= 1000\n            self.start_poses[StartPosition.PAMI4].x -= 1000\n            self.start_poses[StartPosition.PAMI5].x -= 1000\n\n    def is_valid_start_position(self, position: StartPosition) -&gt; bool:\n        if self.shared_properties.table == TableEnum.Training.val and position == StartPosition.Opposite:\n            return False\n        if self.robot_id == 1 and position not in [\n            StartPosition.Top,\n            StartPosition.Bottom,\n            StartPosition.Opposite,\n        ]:\n            return False\n        return True\n\n    def create_artifacts(self):\n        # Positions are related to the default camp blue.\n        self.construction_areas: dict[ConstructionAreaID, ConstructionArea] = {}\n        self.opponent_construction_areas: dict[ConstructionAreaID, ConstructionArea] = {}\n        self.tribunes: dict[TribuneID, Tribune] = {}\n\n        # Construction areas\n        for id, area in construction_area_positions.items():\n            adapted_pose = AdaptedPose(**area.model_dump())\n            self.construction_areas[id] = ConstructionAreaSmall(**adapted_pose.model_dump(), id=id, enabled=False)\n            self.opponent_construction_areas[id] = ConstructionAreaSmall(\n                x=adapted_pose.x,\n                y=-adapted_pose.y,\n                O=-adapted_pose.O,\n                id=id,\n            )\n\n        self.opponent_construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled = False\n        self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled = False\n        if self.shared_properties.table == TableEnum.Training.val:\n            self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge1].enabled = False\n            self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled = False\n            self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled = False\n\n        # Tribunes\n        for id, tribune in tribune_positions.items():\n            adapted_pose = AdaptedPose(**tribune.model_dump())\n            self.tribunes[id] = Tribune(**adapted_pose.model_dump(), id=id)\n\n        if self.shared_properties.table == TableEnum.Training.val:\n            self.tribunes[TribuneID.LocalTop] = self.tribunes[TribuneID.LocalTopTraining].model_copy(\n                update={\"id\": TribuneID.LocalTop}\n            )\n            self.tribunes[TribuneID.LocalTop].x -= 73.0 / 2\n            self.tribunes[TribuneID.LocalCenter].x -= 73.0 / 2\n        del self.tribunes[TribuneID.LocalTopTraining]\n\n    def create_fixed_obstacles(self):\n        # Positions are related to the default camp blue.\n        self.fixed_obstacles: dict[FixedObstacleID, FixedObstacle] = {}\n\n        # Ramp\n        self.fixed_obstacles[FixedObstacleID.Ramp] = FixedObstacle(\n            **AdaptedPose(x=900, y=-650).model_dump(),\n            length=400,\n            width=200,\n            id=FixedObstacleID.Ramp,\n        )\n\n        # Scene\n        self.fixed_obstacles[FixedObstacleID.Scene] = FixedObstacle(\n            **AdaptedPose(x=825, y=-225).model_dump(),\n            length=450,\n            width=450,\n            id=FixedObstacleID.Scene,\n        )\n\n        # Pami 5 path\n        self.fixed_obstacles[FixedObstacleID.Pami5Path] = FixedObstacle(\n            **AdaptedPose(x=930, y=-1175).model_dump(),\n            length=650,\n            width=50,\n            id=FixedObstacleID.Pami5Path,\n        )\n\n        # Opponent ramp\n        self.fixed_obstacles[FixedObstacleID.OpponentRamp] = FixedObstacle(\n            **AdaptedPose(x=900, y=650).model_dump(),\n            length=400,\n            width=200,\n            id=FixedObstacleID.OpponentRamp,\n        )\n\n        # Opponent scene\n        self.fixed_obstacles[FixedObstacleID.OpponentScene] = FixedObstacle(\n            **AdaptedPose(x=825, y=225).model_dump(),\n            length=450,\n            width=450,\n            id=FixedObstacleID.OpponentScene,\n        )\n\n        # Backstage\n        self.fixed_obstacles[FixedObstacleID.Backstage] = FixedObstacle(\n            **AdaptedPose(x=1000 - 450 / 2, y=-1500 + 150 + 450 / 2).model_dump(),\n            length=450,\n            width=450,\n            enabled=False,\n            id=FixedObstacleID.Backstage,\n        )\n\n        # PAMIs starting area for robot ID 1, the main robot.\n        if self.robot_id == 1:\n            self.fixed_obstacles[FixedObstacleID.PamiStartArea] = FixedObstacle(\n                **AdaptedPose(x=825, y=-1425).model_dump(),\n                length=150,\n                width=450,\n                id=FixedObstacleID.PamiStartArea,\n            )\n\n            self.fixed_obstacles[FixedObstacleID.PitArea] = FixedObstacle(\n                **AdaptedPose(x=375, y=-350).model_dump(),\n                length=700,\n                width=350,\n                enabled=False,\n                id=FixedObstacleID.PitArea,\n            )\n\n            self.fixed_obstacles[FixedObstacleID.OpponentPitArea] = FixedObstacle(\n                **AdaptedPose(x=375, y=350).model_dump(),\n                length=700,\n                width=350,\n                enabled=False,\n                id=FixedObstacleID.OpponentPitArea,\n            )\n\n        if self.robot_id == 1 and self.shared_properties.table == TableEnum.Training.val or self.robot_id == 5:\n            self.fixed_obstacles[FixedObstacleID.Ramp].enabled = False\n            self.fixed_obstacles[FixedObstacleID.Scene].enabled = False\n            self.fixed_obstacles[FixedObstacleID.Pami5Path].enabled = False\n\n        if self.shared_properties.table == TableEnum.Training.val:\n            for obstacle in self.fixed_obstacles.values():\n                obstacle.x -= 1000\n\n    def create_actuators_states(self):\n        self.positional_actuator_states: dict[PositionalActuatorEnum, PositionalActuator] = {}\n        self.bool_sensor_states: dict[BoolSensorEnum, BoolSensor] = {id: BoolSensor(id=id) for id in BoolSensorEnum}\n        self.emulated_actuator_states: set[PositionalActuatorEnum] = {}\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.start_pose","title":"<code>start_pose: Pose</code>  <code>property</code>","text":"<p>Start pose.</p>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.table","title":"<code>table: Table</code>  <code>property</code>","text":"<p>Selected table.</p>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.reset","title":"<code>reset()</code>","text":"<p>Reset the context.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the context.\n    \"\"\"\n    self.playing = False\n    self.score = self.minimum_score\n    self.countdown = self.game_duration\n    self.last_countdown = self.game_duration\n    self.tribunes_in_robot = 0\n    self.create_start_poses()\n    self.create_artifacts()\n    self.create_fixed_obstacles()\n    self.create_actuators_states()\n</code></pre>"},{"location":"reference/cogip/tools/planner/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/planner/planner/","title":"planner","text":""},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner","title":"<code>Planner</code>","text":"<p>Main planner class.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>class Planner:\n    \"\"\"\n    Main planner class.\n    \"\"\"\n\n    def __init__(\n        self,\n        robot_id: int,\n        server_url: str,\n        robot_width: int,\n        robot_length: int,\n        obstacle_radius: int,\n        obstacle_bb_margin: float,\n        obstacle_bb_vertices: int,\n        obstacle_updater_interval: float,\n        path_refresh_interval: float,\n        starter_pin: int | None,\n        led_red_pin: int | None,\n        led_green_pin: int | None,\n        led_blue_pin: int | None,\n        flag_motor_pin: int | None,\n        oled_bus: int | None,\n        oled_address: int | None,\n        bypass_detector: bool,\n        scservos_port: Path | None,\n        scservos_baud_rate: int,\n        disable_fixed_obstacles: bool,\n        table: TableEnum,\n        strategy: Strategy,\n        start_position: StartPosition,\n        avoidance_strategy: AvoidanceStrategy,\n        debug: bool,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            robot_id: Robot ID\n            server_url: Socket.IO Server URL\n            robot_width: Width of the robot (in mm)\n            robot_length: Length of the robot (in mm)\n            obstacle_radius: Radius of a dynamic obstacle (in mm)\n            obstacle_bb_margin: Obstacle bounding box margin in percent of the radius\n            obstacle_bb_vertices: Number of obstacle bounding box vertices\n            obstacle_updater_interval: Interval between each send of obstacles to dashboards (in seconds)\n            path_refresh_interval: Interval between each update of robot paths (in seconds)\n            starter_pin: GPIO pin connected to the starter\n            led_red_pin: GPIO pin connected to the red LED\n            led_green_pin: GPIO pin connected to the green LED\n            led_blue_pin: GPIO pin connected to the blue LED\n            flag_motor_pin: GPIO pin connected to the flag motor\n            oled_bus: PAMI OLED display i2c bus\n            oled_address: PAMI OLED display i2c address\n            bypass_detector: Use perfect obstacles from monitor instead of detected obstacles by Lidar\n            scservos_port: SC Servos serial port\n            scservos_baud_rate: SC Servos baud rate (usually 921600 or 1000000)\n            disable_fixed_obstacles: Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance\n            table: Default table on startup\n            strategy: Default strategy on startup\n            start_position: Default start position on startup\n            debug: enable debug messages\n        \"\"\"\n        self.robot_id = robot_id\n        self.server_url = server_url\n        self.oled_bus = oled_bus\n        self.oled_address = oled_address\n        self.scservos_port = scservos_port\n        self.scservos_baud_rate = scservos_baud_rate\n        self.debug = debug\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_properties: SharedProperties | None = None\n        self.shared_pose_current_lock: WritePriorityLock | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_table_limits: NDArray | None = None\n        self.shared_detector_obstacles: SharedCircleList | None = None\n        self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n        self.shared_monitor_obstacles: SharedCircleList | None = None\n        self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n        self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n        self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n        self.shared_obstacles_lock: WritePriorityLock | None = None\n        self.shared_avoidance_pose_order: SharedPoseOrder | None = None\n        self.shared_avoidance_blocked_lock: WritePriorityLock | None = None\n        self.shared_avoidance_path: SharedPoseOrderList | None = None\n        self.shared_avoidance_path_lock: WritePriorityLock | None = None\n        self.create_shared_memory()\n\n        # Fix type checker after shared memory creation\n        self.shared_properties: SharedProperties\n\n        # Update shared memory properties\n        self.shared_properties.robot_id = robot_id\n        self.shared_properties.robot_width = robot_width\n        self.shared_properties.robot_length = robot_length\n        self.shared_properties.obstacle_radius = obstacle_radius\n        self.shared_properties.obstacle_bb_margin = obstacle_bb_margin\n        self.shared_properties.obstacle_bb_vertices = obstacle_bb_vertices\n        self.shared_properties.obstacle_updater_interval = obstacle_updater_interval\n        self.shared_properties.path_refresh_interval = path_refresh_interval\n        self.shared_properties.bypass_detector = bypass_detector\n        self.shared_properties.disable_fixed_obstacles = disable_fixed_obstacles\n        self.shared_properties.table = table.val\n        self.shared_properties.strategy = strategy.val\n        self.shared_properties.start_position = start_position.val\n        self.shared_properties.avoidance_strategy = avoidance_strategy.val\n\n        self.virtual = platform.machine() != \"aarch64\"\n        self.retry_connection = True\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_ns = sio_events.SioEvents(self)\n        self.sio.register_namespace(self.sio_ns)\n        self.game_context = GameContext()\n        self.process_manager = Manager()\n        self.action: actions.Action | None = None\n        self.actions = action_classes.get(self.shared_properties.strategy, actions.Actions)(self)\n        self.obstacles_updater_loop = AsyncLoop(\n            \"Obstacles updater loop\",\n            obstacle_updater_interval,\n            self.update_obstacles,\n            logger=self.debug,\n        )\n        self._pose_order: pose.Pose | None = None\n        self.pose_reached: bool = True\n        self.blocked_counter: int = 0\n        self.controller = self.game_context.default_controller\n        self.game_wizard = GameWizard(self)\n        self.countdown_task: asyncio.Task | None = None\n        self.blocked_event_task: asyncio.Task | None = None\n        self.new_path_event_task: asyncio.Task | None = None\n        self.scservos = SCServos(self.scservos_port, scservos_baud_rate)\n        self.pami_event = asyncio.Event()\n        self.last_starter_event_timestamp: datetime | None = None\n        self.countdown_start_timestamp: datetime = datetime.now(UTC)\n\n        if not self.game_context.is_valid_start_position(start_position):\n            logger.error(f\"Start position {start_position.name} invalid in current table and camp\")\n            sys.exit(1)\n\n        self.avoidance_process: Process | None = None\n\n        if starter_pin:\n            self.starter = Button(\n                starter_pin,\n                pull_up=False,\n                bounce_time=None,\n            )\n        else:\n            self.starter = Button(\n                17,\n                pull_up=True,\n                pin_factory=MockFactory(),\n            )\n        self.starter.when_activated = partial(self.starter_changed_callback, True)\n        self.starter.when_deactivated = partial(self.starter_changed_callback, False)\n\n        if led_red_pin and led_green_pin and led_blue_pin:\n            self.led = RGBLED(\n                led_red_pin,\n                led_green_pin,\n                led_blue_pin,\n                initial_value=(1, 0, 0),\n            )\n        else:\n            self.led = Mock()\n\n        if flag_motor_pin:\n            self.flag_motor = OutputDevice(flag_motor_pin)\n        else:\n            self.flag_motor = Mock()\n\n        if self.oled_bus and self.oled_address:\n            self.oled_serial = i2c(port=self.oled_bus, address=self.oled_address)\n            self.oled_device = sh1106(self.oled_serial)\n            self.oled_font = ImageFont.truetype(\"DejaVuSansMono.ttf\", 9)\n            self.oled_image = canvas(self.oled_device)\n            self.oled_update_loop = AsyncLoop(\n                \"OLED display update loop\",\n                0.5,\n                self.update_oled_display,\n                logger=self.debug,\n            )\n\n    def create_shared_memory(self):\n        if self.shared_memory is None:\n            self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n            self.shared_properties = self.shared_memory.get_properties()\n            self.shared_pose_current_lock = self.shared_memory.get_lock(LockName.PoseCurrent)\n            self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n            self.shared_table_limits = self.shared_memory.get_table_limits()\n            self.shared_detector_obstacles = self.shared_memory.get_detector_obstacles()\n            self.shared_detector_obstacles_lock = self.shared_memory.get_lock(LockName.DetectorObstacles)\n            self.shared_monitor_obstacles = self.shared_memory.get_monitor_obstacles()\n            self.shared_monitor_obstacles_lock = self.shared_memory.get_lock(LockName.MonitorObstacles)\n            self.shared_circle_obstacles = self.shared_memory.get_circle_obstacles()\n            self.shared_rectangle_obstacles = self.shared_memory.get_rectangle_obstacles()\n            self.shared_obstacles_lock = self.shared_memory.get_lock(LockName.Obstacles)\n            self.shared_avoidance_pose_order = self.shared_memory.get_avoidance_pose_order()\n            self.shared_avoidance_blocked_lock = self.shared_memory.get_lock(LockName.AvoidanceBlocked)\n            self.shared_avoidance_blocked_lock.reset()\n            self.shared_avoidance_blocked_lock.register_consumer()\n            self.shared_avoidance_path = self.shared_memory.get_avoidance_path()\n            self.shared_avoidance_path_lock = self.shared_memory.get_lock(LockName.AvoidancePath)\n            self.shared_avoidance_path_lock.register_consumer()\n\n    def delete_shared_memory(self):\n        if self.shared_memory is not None:\n            self.shared_avoidance_path_lock = None\n            self.shared_avoidance_path = None\n            self.shared_avoidance_blocked_lock = None\n            self.shared_avoidance_pose_order = None\n            self.shared_obstacles_lock = None\n            self.shared_rectangle_obstacles = None\n            self.shared_circle_obstacles = None\n            self.shared_monitor_obstacles_lock = None\n            self.shared_monitor_obstacles = None\n            self.shared_detector_obstacles_lock = None\n            self.shared_detector_obstacles = None\n            self.shared_table_limits = None\n            self.shared_pose_current_buffer = None\n            self.shared_pose_current_lock = None\n            self.shared_properties = None\n            self.shared_memory = None\n\n    async def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        self.retry_connection = True\n        try:\n            await self.try_connect()\n            await self.sio.wait()\n        except asyncio.CancelledError:\n            self.process_manager.shutdown()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/planner\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    @property\n    def pose_current(self) -&gt; models.Pose:\n        \"\"\"\n        Get the current pose of the robot.\n        \"\"\"\n        pose = self.shared_pose_current_buffer.last\n        return models.Pose(x=pose.x, y=pose.y, O=pose.angle)\n\n    async def start(self):\n        \"\"\"\n        Start sending obstacles list.\n        \"\"\"\n        logger.info(\"Planner: start\")\n        self.create_shared_memory()\n        self.shared_memory.avoidance_exiting = False\n        await self.soft_reset()\n        self.blocked_event_task = asyncio.create_task(\n            self.blocked_event_loop(),\n            name=\"Robot: Task Blocked Event Watcher Loop\",\n        )\n        self.new_path_event_task = asyncio.create_task(\n            self.new_path_event_loop(),\n            name=\"Robot: Task New Path Event Watcher Loop\",\n        )\n        await self.sio_ns.emit(\"starter_changed\", self.starter.is_pressed)\n        await self.sio_ns.emit(\"game_reset\")\n        await self.countdown_start()\n        self.obstacles_updater_loop.start()\n        if self.oled_bus and self.oled_address:\n            self.oled_update_loop.start()\n\n        self.avoidance_process = Process(target=avoidance_process, args=(self.robot_id,))\n        self.avoidance_process.start()\n\n        await actuators.actuators_init(self)\n\n    async def stop(self):\n        \"\"\"\n        Stop running tasks.\n        \"\"\"\n        logger.info(\"Planner: stop\")\n\n        self.shared_memory.avoidance_exiting = True\n\n        await self.sio_ns.emit(\"stop_video_record\")\n\n        await self.countdown_stop()\n\n        await self.obstacles_updater_loop.stop()\n        if self.oled_bus and self.oled_address:\n            await self.oled_update_loop.stop()\n\n        if self.blocked_event_task:\n            self.blocked_event_task.cancel()\n            try:\n                await self.blocked_event_task\n            except asyncio.CancelledError:\n                logger.info(\"Planner: Task Blocked Event Watcher Loop stopped\")\n            except Exception as exc:\n                logger.warning(f\"Planner: Unexpected exception {exc}\")\n        self.blocked_event_task = None\n\n        if self.new_path_event_task:\n            self.new_path_event_task.cancel()\n            try:\n                await self.new_path_event_task\n            except asyncio.CancelledError:\n                logger.info(\"Planner: Task New Path Event Watcher Loop stopped\")\n            except Exception as exc:\n                logger.warning(f\"Planner: Unexpected exception {exc}\")\n                traceback.print_exc()\n        self.new_path_event_task = None\n\n        if self.avoidance_process and self.avoidance_process.is_alive():\n            self.avoidance_process.join()\n            self.avoidance_process = None\n\n        self.delete_shared_memory()\n\n    async def reset(self):\n        \"\"\"\n        Reset planner, context, robots and actions.\n        \"\"\"\n        await self.stop()\n        await self.start()\n\n    async def soft_reset(self):\n        \"\"\"\n        Only reset context and actions.\n        \"\"\"\n        self.game_context.reset()\n        await self.set_controller(self.game_context.default_controller, True)\n        self.shared_table_limits[0] = self.game_context.table.x_min\n        self.shared_table_limits[1] = self.game_context.table.x_max\n        self.shared_table_limits[2] = self.game_context.table.y_min\n        self.shared_table_limits[3] = self.game_context.table.y_max\n        self.shared_memory.avoidance_has_pose_order = False\n        self.shared_memory.avoidance_has_new_pose_order = False\n        self.flag_motor.off()\n        self.actions = action_classes.get(Strategy(self.shared_properties.strategy), actions.Actions)(self)\n        await self.set_pose_start(self.game_context.start_pose.pose)\n        self.pami_event.clear()\n\n    async def blocked_event_loop(self):\n        logger.info(\"Planner: Task Blocked Event Watcher Loop started\")\n        try:\n            while True:\n                await asyncio.to_thread(self.shared_avoidance_blocked_lock.wait_update)\n                if self.sio.connected:\n                    await self.sio_ns.emit(\"brake\")\n                self.blocked_counter += 1\n                if self.blocked_counter &gt; 10:\n                    self.blocked_counter = 0\n                    await self.blocked()\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Blocked Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Task Blocked Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def new_path_event_loop(self):\n        logger.info(\"Planner: Task New Path Event Watcher Loop started\")\n        try:\n            while True:\n                await asyncio.to_thread(self.shared_avoidance_path_lock.wait_update)\n                self.blocked_counter = 0\n                if self.pose_order:\n                    await self.pose_order.act_intermediate_pose()\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task New Path Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def countdown_loop(self):\n        logger.info(\"Planner: Task Countdown started\")\n        try:\n            self.game_context.last_countdown = self.game_context.countdown\n            while True:\n                await asyncio.sleep(0.2)\n\n                if not self.game_context.playing:\n                    continue\n\n                now = datetime.now(UTC)\n                self.game_context.countdown = (\n                    self.game_context.game_duration - (now - self.countdown_start_timestamp).total_seconds()\n                )\n\n                logger.info(f\"Planner: countdown = {self.game_context.countdown: 3.2f}\")\n                if self.robot_id &gt; 1 and self.game_context.countdown &lt; 15 and self.game_context.last_countdown &gt; 15:\n                    logger.info(\"Planner: countdown==15: start PAMI\")\n                    self.pami_event.set()\n                if self.robot_id == 1 and self.game_context.countdown &lt; 7 and self.game_context.last_countdown &gt; 7:\n                    logger.info(\"Planner: countdown==7: force blocked\")\n                    asyncio.create_task(self.blocked())\n                if self.game_context.countdown &lt; 0 and self.game_context.last_countdown &gt; 0:\n                    logger.info(\"Planner: countdown==0: final action\")\n                    await self.final_action()\n                if self.game_context.countdown &lt; -5 and self.game_context.last_countdown &gt; -5:\n                    await self.sio_ns.emit(\"stop_video_record\")\n                self.game_context.last_countdown = self.game_context.countdown\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Countdown cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Unknown exception {exc}\")\n            raise\n\n    async def countdown_start(self):\n        await self.countdown_stop()\n        self.countdown_task = asyncio.create_task(self.countdown_loop())\n\n    async def countdown_stop(self):\n        if self.countdown_task is None:\n            return\n\n        self.countdown_task.cancel()\n        try:\n            await self.countdown_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Countdown stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n\n        self.countdown_task = None\n\n    async def final_action(self):\n        if not self.game_context.playing:\n            return\n        self.game_context.playing = False\n        await self.sio_ns.emit(\"game_end\")\n        if self.robot_id == 1:\n            if self.robot_in_parking():\n                self.game_context.score += 10\n\n            # Display score\n            await self.sio_ns.emit(\"score\", self.game_context.score)\n\n        self.flag_motor.on()\n        self.pose_order = None\n\n    def starter_changed_callback(self, pushed: bool):\n        asyncio.create_task(self.starter_changed(pushed))\n\n    async def starter_changed(self, pushed: bool):\n        self.last_starter_event_timestamp = datetime.now(UTC)\n        if not self.virtual:\n            await self.sio_ns.emit(\"starter_changed\", pushed)\n\n    async def set_controller(self, new_controller: ControllerEnum, force: bool = False):\n        if self.controller == new_controller and not force:\n            return\n        self.controller = new_controller\n        await self.sio_ns.emit(\"set_controller\", self.controller.value)\n\n    async def set_pose_start(self, pose_start: models.Pose):\n        \"\"\"\n        Set the start position of the robot for the next game.\n        \"\"\"\n        self.action = None\n        self.pose_order = None\n        self.pose_reached = True\n\n        # When the firmware receives a pose start, it does not send its updated pose current,\n        # so do it here.\n        self.shared_pose_current_buffer.push(pose_start.x, pose_start.y, pose_start.O)\n        await self.sio_ns.emit(\"pose_start\", pose_start.model_dump())\n\n    @property\n    def pose_order(self) -&gt; pose.Pose | None:\n        return self._pose_order\n\n    @pose_order.setter\n    def pose_order(self, new_pose: pose.Pose | None):\n        logger.info(f\"Planner: pose_order={new_pose.path_pose if new_pose else None}\")\n        self._pose_order = new_pose\n        self.shared_memory.avoidance_has_pose_order = False\n        if new_pose is None:\n            self.shared_memory.avoidance_has_new_pose_order = False\n        else:\n            self.shared_memory.avoidance_has_new_pose_order = True\n            new_pose.to_shared(self.shared_avoidance_pose_order)\n\n    async def set_pose_reached(self):\n        \"\"\"\n        Set pose reached for a robot.\n        \"\"\"\n        logger.info(\"Planner: set_pose_reached()\")\n\n        # Set pose reached\n        if not self.pose_reached and (pose_order := self.pose_order):\n            self.pose_order = None\n            await pose_order.act_after_pose()\n        else:\n            self.pose_order = None\n\n        self.pose_reached = True\n        if (action := self.action) and len(self.action.poses) == 0:\n            self.action = None\n            await action.act_after_action()\n\n        if not self.game_context.playing:\n            return\n\n        await self.next_pose()\n\n    async def set_intermediate_pose_reached(self):\n        \"\"\"\n        Set pose reached for a robot.\n        \"\"\"\n        logger.info(\"Planner: set_intermediate_pose_reached()\")\n\n        # The pose reached is intermediate, just force path recompute.\n        if self.pose_order:\n            self.pose_order.path_pose.to_shared(self.shared_avoidance_pose_order)\n            self.shared_memory.avoidance_has_new_pose_order = True\n\n    async def next_pose_in_action(self):\n        if self.action and len(self.action.poses) &gt; 0:\n            pose_order = self.action.poses.pop(0)\n            self.pose_order = None\n            await pose_order.act_before_pose()\n            self.blocked_counter = 0\n            self.pose_order = pose_order\n\n            if self.shared_properties.strategy in [Strategy.PidLinearSpeedTest.val, Strategy.PidAngularSpeedTest.val]:\n                await self.sio_ns.emit(\"pose_order\", self.pose_order.path_pose.model_dump())\n\n    async def next_pose(self):\n        \"\"\"\n        Select the next pose for a robot.\n        \"\"\"\n        logger.info(\"Planner: next_pose()\")\n        try:\n            # Get and set new pose\n            self.pose_reached = False\n            await self.next_pose_in_action()\n\n            # If no pose left in current action, get and set new action\n            if not self.pose_order and (new_action := self.get_action()):\n                await self.set_action(new_action)\n                if not self.pose_order:\n                    asyncio.create_task(self.set_pose_reached())\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    def get_action(self) -&gt; actions.Action | None:\n        \"\"\"\n        Get a new action for a robot.\n        Simply choose next action in the list for now.\n        \"\"\"\n        sorted_actions = sorted(\n            [action for action in self.actions if not action.recycled and action.weight() &gt; 0],\n            key=lambda action: action.weight(),\n        )\n\n        if len(sorted_actions) == 0:\n            return None\n\n        action = sorted_actions[-1]\n        self.actions.remove(action)\n        return action\n\n    async def set_action(self, action: \"actions.Action\"):\n        \"\"\"\n        Set current action.\n        \"\"\"\n        logger.info(f\"Planner: set action '{action.name}'\")\n        self.pose_order = None\n        self.action = action\n        await self.action.act_before_action()\n        await self.next_pose_in_action()\n\n    async def blocked(self):\n        \"\"\"\n        Function called when a robot cannot find a path to go to the current pose of the current action\n        \"\"\"\n        if (current_action := self.action) and current_action.interruptable:\n            logger.info(\"Planner: blocked\")\n            if new_action := self.get_action():\n                await self.set_action(new_action)\n            await current_action.recycle()\n            self.actions.append(current_action)\n            if not self.pose_order:\n                asyncio.create_task(self.set_pose_reached())\n\n    async def update_obstacles(self):\n        table = self.game_context.table\n        try:\n            margin = self.shared_properties.obstacle_bb_margin * self.shared_properties.robot_length / 2\n            if self.shared_properties.bypass_detector:\n                shared_obstacles = self.shared_monitor_obstacles\n                shared_lock = self.shared_monitor_obstacles_lock\n            else:\n                shared_obstacles = self.shared_detector_obstacles\n                shared_lock = self.shared_detector_obstacles_lock\n            shared_lock.start_reading()\n            self.shared_obstacles_lock.start_writing()\n            self.shared_circle_obstacles.clear()\n            self.shared_rectangle_obstacles.clear()\n\n            # Add dynamic obstacles\n            for detector_obstacle in shared_obstacles:\n                if not table.contains(detector_obstacle, margin):\n                    continue\n                if self.robot_id == 1:\n                    radius = self.shared_properties.obstacle_radius\n                else:\n                    radius = detector_obstacle.radius\n                radius += self.shared_properties.robot_length / 2\n                self.shared_circle_obstacles.append(\n                    x=detector_obstacle.x,\n                    y=detector_obstacle.y,\n                    angle=0,\n                    radius=radius,\n                    bounding_box_margin=margin,\n                    bounding_box_points_number=self.shared_properties.obstacle_bb_vertices,\n                )\n            shared_lock.finish_reading()\n\n            if not self.shared_properties.disable_fixed_obstacles:\n                if self.robot_id == 1:\n                    # Add artifact obstacles\n                    construction_areas: list[ConstructionArea] = list(\n                        self.game_context.construction_areas.values()\n                    ) + list(self.game_context.opponent_construction_areas.values())\n                    for construction_area in construction_areas:\n                        if not construction_area.enabled:\n                            continue\n                        if not table.contains(construction_area, margin):\n                            continue\n                        self.shared_rectangle_obstacles.append(\n                            x=construction_area.x,\n                            y=construction_area.y,\n                            angle=construction_area.O,\n                            length_x=construction_area.length + self.shared_properties.robot_width,\n                            length_y=construction_area.width + self.shared_properties.robot_width,\n                            bounding_box_margin=margin,\n                            id=construction_area.id.value,\n                        )\n                    for tribune in self.game_context.tribunes.values():\n                        if not tribune.enabled:\n                            continue\n                        if not table.contains(tribune, margin):\n                            continue\n                        self.shared_rectangle_obstacles.append(\n                            x=tribune.x,\n                            y=tribune.y,\n                            angle=tribune.O,\n                            length_x=tribune.width + self.shared_properties.robot_width,\n                            length_y=tribune.length + self.shared_properties.robot_width,\n                            bounding_box_margin=margin,\n                            id=tribune.id.value,\n                        )\n\n                # Add fixed obstacles\n                for fixed_obstacle in self.game_context.fixed_obstacles.values():\n                    if not fixed_obstacle.enabled:\n                        continue\n                    if not table.contains(fixed_obstacle, margin):\n                        continue\n                    self.shared_rectangle_obstacles.append(\n                        x=fixed_obstacle.x,\n                        y=fixed_obstacle.y,\n                        angle=0,\n                        length_x=fixed_obstacle.width + self.shared_properties.robot_width,\n                        length_y=fixed_obstacle.length + self.shared_properties.robot_width,\n                        bounding_box_margin=margin,\n                        id=fixed_obstacle.id.value,\n                    )\n\n            self.shared_obstacles_lock.finish_writing()\n            self.shared_obstacles_lock.post_update()\n        except Exception as exc:\n            logger.warning(f\"Planner: update_obstacles: Unknown exception {exc}\")\n            traceback.print_exc()\n\n    async def update_oled_display(self):\n        try:\n            pose_current = self.pose_current\n            text = (\n                f\"{'Connected' if self.sio.connected else 'Not connected': &lt;20}\"\n                f\"{'\u25b6' if self.game_context.playing else '\u25fc'}\\n\"\n                f\"Camp: {self.game_context.camp.color.name}\\n\"\n                f\"Strategy: {Strategy(self.shared_properties.strategy).name}\\n\"\n                f\"Pose: {pose_current.x},{pose_current.y},{pose_current.O}\\n\"\n                f\"Countdown: {self.game_context.countdown:.2f}\"\n            )\n            with self.oled_image as draw:\n                draw.rectangle([(0, 0), (128, 64)], fill=\"black\", outline=\"black\")\n                draw.multiline_text(\n                    (1, 0),\n                    text,\n                    fill=\"white\",\n                    font=self.oled_font,\n                )\n        except Exception as exc:\n            logger.warning(f\"Planner: OLED display update loop: Unknown exception {exc}\")\n            traceback.print_exc()\n\n    async def command(self, cmd: str, *args):\n        \"\"\"\n        Execute a command from the menu.\n        \"\"\"\n        if cmd.startswith(\"wizard_\"):\n            await self.cmd_wizard_test(cmd)\n            return\n\n        if cmd.startswith(\"act_\"):\n            await self.cmd_act(cmd)\n            return\n\n        if cmd.startswith(\"cam_\"):\n            await self.cmd_cam(cmd)\n            return\n\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema_with_values = properties_schema.copy()\n            # Add current values in JSON Schema\n            for prop in schema_with_values[\"properties\"]:\n                schema_with_values[\"properties\"][prop][\"value\"] = getattr(self.shared_properties, prop)\n            # Send config\n            await self.sio_ns.emit(\"config\", schema_with_values)\n            return\n\n        if cmd == \"scservos\":\n            # Get JSON Schema\n            schema = self.scservos.get_schema()\n            await self.sio_ns.emit(\"config\", schema)\n            return\n\n        if cmd == \"game_wizard\":\n            await self.game_wizard.start()\n            return\n\n        if not (cmd_func := getattr(self, f\"cmd_{cmd}\", None)):\n            logger.warning(f\"Unknown command: {cmd}\")\n            return\n\n        await cmd_func(*args)\n\n    def update_config(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update a Planner property with the value sent by the dashboard.\n        \"\"\"\n        name = config[\"name\"]\n        current_value = getattr(self.shared_properties, name)\n        current_value_type = type(current_value)\n        setattr(self.shared_properties, name, current_value_type(config[\"value\"]))\n        match name:\n            case \"obstacle_updater_interval\":\n                self.obstacles_updater_loop.interval = self.shared_properties.obstacle_updater_interval\n\n    async def update_scservo(self, servo: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update a SC Servo with the value sent by the dashboard.\n        \"\"\"\n        self.scservos.set(SCServoEnum[servo[\"name\"]], servo[\"value\"])\n\n    async def cmd_play(self, timestamp: str | None = None):\n        \"\"\"\n        Play command from the menu.\n        \"\"\"\n        if timestamp:\n            self.countdown_start_timestamp = datetime.fromisoformat(timestamp)\n        else:\n            self.countdown_start_timestamp = datetime.now(UTC)\n\n        logger.info(f\"Planner: cmd_play({self.countdown_start_timestamp})\")\n        if self.game_context.playing:\n            return\n\n        self.game_context.countdown = self.game_context.game_duration\n        self.game_context.playing = True\n        self.led.color = Color(\"blue\")\n\n        await self.sio_ns.emit(\n            \"start_countdown\",\n            (self.robot_id, self.game_context.game_duration, self.countdown_start_timestamp.isoformat(), \"deepskyblue\"),\n        )\n\n        await self.sio_ns.emit(\"start_video_record\")\n        asyncio.create_task(self.set_pose_reached())\n\n    async def cmd_stop(self):\n        \"\"\"\n        Stop command from the menu.\n        \"\"\"\n        logger.info(\"Planner: cmd_stop()\")\n        self.game_context.playing = False\n        await self.sio_ns.emit(\"stop_video_record\")\n\n    async def cmd_next(self):\n        \"\"\"\n        Next command from the menu.\n        Ignored if current pose is not reached for all robots.\n        \"\"\"\n        logger.info(\"Planner: cmd_next()\")\n        if self.game_context.playing:\n            return\n\n        # Check that pose_reached is set\n        if not self.pose_reached:\n            return\n\n        asyncio.create_task(self.next_pose())\n\n    async def cmd_reset(self):\n        \"\"\"\n        Reset command from the menu.\n        \"\"\"\n        logger.info(\"Planner: cmd_reset()\")\n        await self.reset()\n        await self.sio_ns.emit(\"cmd_reset\")\n\n    async def cmd_choose_camp(self):\n        \"\"\"\n        Choose camp command from the menu.\n        Send camp wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Camp\",\n                \"type\": \"camp\",\n                \"value\": self.game_context.camp.color.name,\n            },\n        )\n\n    async def cmd_choose_strategy(self):\n        \"\"\"\n        Choose strategy command from the menu.\n        Send strategy wizard message.\n        \"\"\"\n        choices: list[tuple[str, str, str]] = []  # list of (category, value, name). Name can be used for display.\n        for strategy in Strategy:\n            split = re.findall(r\"[A-Z][a-z]*|[a-z]+|[0-9]+\", strategy.name)\n            choices.append((strategy.name, split[0], \" \".join(split)))\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Strategy\",\n                \"type\": \"choice_str\",\n                \"choices\": choices,\n                \"value\": Strategy(self.shared_properties.strategy).name,\n            },\n        )\n\n    async def cmd_choose_avoidance(self):\n        \"\"\"\n        Choose avoidance strategy command from the menu.\n        Send avoidance strategy wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Avoidance\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in AvoidanceStrategy],\n                \"value\": AvoidanceStrategy(self.shared_properties.avoidance_strategy).name,\n            },\n        )\n\n    async def cmd_choose_start_position(self):\n        \"\"\"\n        Choose start position command from the menu.\n        Send start position wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Start Position\",\n                \"type\": \"choice_integer\",\n                \"choices\": [p.name for p in StartPosition if self.game_context.is_valid_start_position(p)],\n                \"value\": StartPosition(self.shared_properties.start_position).name,\n            },\n        )\n\n    async def cmd_choose_table(self):\n        \"\"\"\n        Choose table command from the menu.\n        Send table wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Table\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in TableEnum],\n                \"value\": TableEnum(self.shared_properties.table).name,\n            },\n        )\n\n    async def wizard_response(self, message: dict[str, Any]):\n        \"\"\"\n        Handle wizard response sent from the dashboard.\n        \"\"\"\n        if (value := message[\"value\"]) is None:\n            return\n\n        match name := message.get(\"name\"):\n            case \"Choose Camp\":\n                new_camp = Camp.Colors[value]\n                if self.game_context.camp.color == new_camp:\n                    return\n                previous_camp = self.game_context.camp.color\n                if self.shared_properties.table == TableEnum.Training.val and new_camp == Camp.Colors.yellow:\n                    error_message = \"Yellow camp not compatible with training table\"\n                    self.game_context.camp.color = previous_camp\n                    logger.warning(f\"Wizard: {error_message}\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": message,\n                        },\n                    )\n                    return\n                self.game_context.camp.color = new_camp\n                await self.soft_reset()\n                logger.info(f\"Wizard: New camp: {self.game_context.camp.color.name}\")\n            case \"Choose Strategy\":\n                new_strategy = Strategy[value]\n                if self.shared_properties.strategy == new_strategy.val:\n                    return\n                self.shared_properties.strategy = new_strategy.val\n                await self.soft_reset()\n                logger.info(f\"Wizard: New strategy: {value}\")\n            case \"Choose Avoidance\":\n                new_avoidance = AvoidanceStrategy[value]\n                if self.shared_properties.avoidance_strategy == new_avoidance.val:\n                    return\n                self.shared_properties.avoidance_strategy = new_avoidance.val\n                logger.info(f\"Wizard: New avoidance strategy: {value}\")\n            case \"Choose Start Position\":\n                new_start_position = StartPosition[value]\n                if self.shared_properties.start_position == new_start_position.val:\n                    return\n                if not self.game_context.is_valid_start_position(new_start_position):\n                    message = f\"Start position {new_start_position.name} invalid in current table and camp\"\n                    logger.warning(f\"Wizard: {message}\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": message,\n                        },\n                    )\n                    return\n                self.shared_properties.start_position = new_start_position.val\n                await self.soft_reset()\n            case \"Choose Table\":\n                new_table = TableEnum[value]\n                if self.shared_properties.table == new_table.val:\n                    return\n                error_message = \"\"\n                previous_table = self.shared_properties.table\n                self.shared_properties.table = new_table.val\n                if not self.game_context.is_valid_start_position(StartPosition(self.shared_properties.start_position)):\n                    error_message = (\n                        f\"Table {new_table.name} not compatible \"\n                        f\"with start position {StartPosition(self.shared_properties.start_position).name}\"\n                    )\n                if new_table == TableEnum.Training and self.game_context.camp.color == Camp.Colors.yellow:\n                    error_message = f\"Table {new_table.name} not compatible yellow camp\"\n                if error_message:\n                    self.shared_properties.table = previous_table\n                    logger.warning(f\"Wizard: {error_message}\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": error_message,\n                        },\n                    )\n                    return\n\n                self.shared_table_limits[0] = self.game_context.table.x_min\n                self.shared_table_limits[1] = self.game_context.table.x_max\n                self.shared_table_limits[2] = self.game_context.table.y_min\n                self.shared_table_limits[3] = self.game_context.table.y_max\n                await self.soft_reset()\n                logger.info(f\"Wizard: New table: {value}\")\n            case game_wizard_response if game_wizard_response.startswith(\"Game Wizard\"):\n                await self.game_wizard.response(message)\n            case wizard_test_response if wizard_test_response.startswith(\"Wizard Test\"):\n                logger.info(f\"Wizard test response: {name} = {value}\")\n            case _:\n                logger.warning(f\"Wizard: Unknown type: {name}\")\n\n    async def cmd_wizard_test(self, cmd: str):\n        match cmd:\n            case \"wizard_boolean\":\n                message = {\n                    \"name\": \"Wizard Test Boolean\",\n                    \"type\": \"boolean\",\n                    \"value\": True,\n                }\n            case \"wizard_integer\":\n                message = {\n                    \"name\": \"Wizard Test Integer\",\n                    \"type\": \"integer\",\n                    \"value\": 42,\n                }\n            case \"wizard_floating\":\n                message = {\n                    \"name\": \"Wizard Test Float\",\n                    \"type\": \"floating\",\n                    \"value\": 66.6,\n                }\n            case \"wizard_str\":\n                message = {\n                    \"name\": \"Wizard Test String\",\n                    \"type\": \"str\",\n                    \"value\": \"cogip\",\n                }\n            case \"wizard_message\":\n                message = {\n                    \"name\": \"Wizard Test Message\",\n                    \"type\": \"message\",\n                    \"value\": \"Hello Robot!\",\n                }\n            case \"wizard_choice_integer\":\n                message = {\n                    \"name\": \"Wizard Test Choice Integer\",\n                    \"type\": \"choice_integer\",\n                    \"choices\": [1, 2, 3],\n                    \"value\": 2,\n                }\n            case \"wizard_choice_floating\":\n                message = {\n                    \"name\": \"Wizard Test Choice Float\",\n                    \"type\": \"choice_floating\",\n                    \"choices\": [1.1, 2.2, 3.3],\n                    \"value\": 2.2,\n                }\n            case \"wizard_choice_str\":\n                message = {\n                    \"name\": \"Wizard Test Choice String\",\n                    \"type\": \"choice_str\",\n                    \"choices\": [\"one\", \"two\", \"three\"],\n                    \"value\": \"two\",\n                }\n            case \"wizard_choice_str_group\":\n                message = {\n                    \"name\": \"Wizard Test Choice String\",\n                    \"type\": \"choice_str\",\n                    \"choices\": [\n                        (\"one\", \"Group A\", \"One\"),\n                        (\"two\", \"Group A\", \"Two\"),\n                        (\"three\", \"Group B\", \"Three\"),\n                    ],\n                    \"value\": \"two\",\n                }\n            case \"wizard_select_integer\":\n                message = {\n                    \"name\": \"Wizard Test Select Integer\",\n                    \"type\": \"select_integer\",\n                    \"choices\": [1, 2, 3],\n                    \"value\": [1, 3],\n                }\n            case \"wizard_select_floating\":\n                message = {\n                    \"name\": \"Wizard Test Select Float\",\n                    \"type\": \"select_floating\",\n                    \"choices\": [1.1, 2.2, 3.3],\n                    \"value\": [1.1, 3.3],\n                }\n            case \"wizard_select_str\":\n                message = {\n                    \"name\": \"Wizard Test Select String\",\n                    \"type\": \"select_str\",\n                    \"choices\": [\"one\", \"two\", \"tree\"],\n                    \"value\": [\"one\", \"tree\"],\n                }\n            case \"wizard_camp\":\n                message = {\n                    \"name\": \"Wizard Test Camp\",\n                    \"type\": \"camp\",\n                    \"value\": \"blue\",\n                }\n            case \"wizard_camera\":\n                message = {\n                    \"name\": \"Wizard Test Camera\",\n                    \"type\": \"camera\",\n                }\n            case \"wizard_score\":\n                await self.sio_ns.emit(\"score\", 100)\n                return\n            case _:\n                logger.warning(f\"Wizard test unsupported: {cmd}\")\n                return\n\n        await self.sio_ns.emit(\"wizard\", message)\n\n    async def cmd_act(self, cmd: str):\n        _, _, command = cmd.partition(\"_\")\n        func = getattr(actuators, command)\n        await func(self)\n\n    async def cmd_cam(self, cmd: str):\n        _, _, command = cmd.partition(\"_\")\n        match command:\n            case \"snapshot\":\n                await cameras.snapshot()\n            case \"camera_position\":\n                await self.get_camera_position()\n\n    async def get_camera_position(self):\n        if camera_position := await cameras.calibrate_camera(self):\n            logger.info(\n                f\"Planner: Camera position in robot:\"\n                f\" X={camera_position.x:.0f} Y={camera_position.y:.0f} Z={camera_position.z:.0f}\"\n            )\n        else:\n            logger.info(\"Planner: No table marker found\")\n\n    async def update_actuator_state(self, actuator_state: ActuatorState):\n        # actuators_states = getattr(self.game_context, f\"{actuator_state.kind.name}_states\")\n        # actuators_states[actuator_state.id] = actuator_state\n        # if not self.virtual and actuator_state.id in self.game_context.emulated_actuator_states:\n        #     self.game_context.emulated_actuator_states.remove(actuator_state.id)\n        pass\n\n    def robot_in_parking(self) -&gt; bool:\n        pose_current = self.pose_current.model_copy()\n        robot_half = self.shared_properties.robot_width / 2.0\n        robot_square = Polygon(\n            [\n                (-robot_half, -robot_half),\n                (robot_half, -robot_half),\n                (robot_half, robot_half),\n                (-robot_half, robot_half),\n            ]\n        )\n        robot_square = rotate(robot_square, pose_current.O, origin=(0, 0), use_radians=False)\n        robot_square = translate(robot_square, xoff=pose_current.x, yoff=pose_current.y)\n\n        parking = self.game_context.fixed_obstacles[FixedObstacleID.Backstage]\n        parking_half = parking.width / 2.0\n        parking_square = Polygon(\n            [\n                (-parking_half, -parking_half),\n                (parking_half, -parking_half),\n                (parking_half, parking_half),\n                (-parking_half, parking_half),\n            ]\n        )\n        parking_square = translate(parking_square, xoff=parking.x, yoff=parking.y)\n\n        result = robot_square.intersects(parking_square)\n        logger.info(f\"Planner: Robot in parking={result}\")\n        return result\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.pose_current","title":"<code>pose_current: models.Pose</code>  <code>property</code>","text":"<p>Get the current pose of the robot.</p>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.__init__","title":"<code>__init__(robot_id, server_url, robot_width, robot_length, obstacle_radius, obstacle_bb_margin, obstacle_bb_vertices, obstacle_updater_interval, path_refresh_interval, starter_pin, led_red_pin, led_green_pin, led_blue_pin, flag_motor_pin, oled_bus, oled_address, bypass_detector, scservos_port, scservos_baud_rate, disable_fixed_obstacles, table, strategy, start_position, avoidance_strategy, debug)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>Robot ID</p> required <code>server_url</code> <code>str</code> <p>Socket.IO Server URL</p> required <code>robot_width</code> <code>int</code> <p>Width of the robot (in mm)</p> required <code>robot_length</code> <code>int</code> <p>Length of the robot (in mm)</p> required <code>obstacle_radius</code> <code>int</code> <p>Radius of a dynamic obstacle (in mm)</p> required <code>obstacle_bb_margin</code> <code>float</code> <p>Obstacle bounding box margin in percent of the radius</p> required <code>obstacle_bb_vertices</code> <code>int</code> <p>Number of obstacle bounding box vertices</p> required <code>obstacle_updater_interval</code> <code>float</code> <p>Interval between each send of obstacles to dashboards (in seconds)</p> required <code>path_refresh_interval</code> <code>float</code> <p>Interval between each update of robot paths (in seconds)</p> required <code>starter_pin</code> <code>int | None</code> <p>GPIO pin connected to the starter</p> required <code>led_red_pin</code> <code>int | None</code> <p>GPIO pin connected to the red LED</p> required <code>led_green_pin</code> <code>int | None</code> <p>GPIO pin connected to the green LED</p> required <code>led_blue_pin</code> <code>int | None</code> <p>GPIO pin connected to the blue LED</p> required <code>flag_motor_pin</code> <code>int | None</code> <p>GPIO pin connected to the flag motor</p> required <code>oled_bus</code> <code>int | None</code> <p>PAMI OLED display i2c bus</p> required <code>oled_address</code> <code>int | None</code> <p>PAMI OLED display i2c address</p> required <code>bypass_detector</code> <code>bool</code> <p>Use perfect obstacles from monitor instead of detected obstacles by Lidar</p> required <code>scservos_port</code> <code>Path | None</code> <p>SC Servos serial port</p> required <code>scservos_baud_rate</code> <code>int</code> <p>SC Servos baud rate (usually 921600 or 1000000)</p> required <code>disable_fixed_obstacles</code> <code>bool</code> <p>Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance</p> required <code>table</code> <code>TableEnum</code> <p>Default table on startup</p> required <code>strategy</code> <code>Strategy</code> <p>Default strategy on startup</p> required <code>start_position</code> <code>StartPosition</code> <p>Default start position on startup</p> required <code>debug</code> <code>bool</code> <p>enable debug messages</p> required Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def __init__(\n    self,\n    robot_id: int,\n    server_url: str,\n    robot_width: int,\n    robot_length: int,\n    obstacle_radius: int,\n    obstacle_bb_margin: float,\n    obstacle_bb_vertices: int,\n    obstacle_updater_interval: float,\n    path_refresh_interval: float,\n    starter_pin: int | None,\n    led_red_pin: int | None,\n    led_green_pin: int | None,\n    led_blue_pin: int | None,\n    flag_motor_pin: int | None,\n    oled_bus: int | None,\n    oled_address: int | None,\n    bypass_detector: bool,\n    scservos_port: Path | None,\n    scservos_baud_rate: int,\n    disable_fixed_obstacles: bool,\n    table: TableEnum,\n    strategy: Strategy,\n    start_position: StartPosition,\n    avoidance_strategy: AvoidanceStrategy,\n    debug: bool,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        robot_id: Robot ID\n        server_url: Socket.IO Server URL\n        robot_width: Width of the robot (in mm)\n        robot_length: Length of the robot (in mm)\n        obstacle_radius: Radius of a dynamic obstacle (in mm)\n        obstacle_bb_margin: Obstacle bounding box margin in percent of the radius\n        obstacle_bb_vertices: Number of obstacle bounding box vertices\n        obstacle_updater_interval: Interval between each send of obstacles to dashboards (in seconds)\n        path_refresh_interval: Interval between each update of robot paths (in seconds)\n        starter_pin: GPIO pin connected to the starter\n        led_red_pin: GPIO pin connected to the red LED\n        led_green_pin: GPIO pin connected to the green LED\n        led_blue_pin: GPIO pin connected to the blue LED\n        flag_motor_pin: GPIO pin connected to the flag motor\n        oled_bus: PAMI OLED display i2c bus\n        oled_address: PAMI OLED display i2c address\n        bypass_detector: Use perfect obstacles from monitor instead of detected obstacles by Lidar\n        scservos_port: SC Servos serial port\n        scservos_baud_rate: SC Servos baud rate (usually 921600 or 1000000)\n        disable_fixed_obstacles: Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance\n        table: Default table on startup\n        strategy: Default strategy on startup\n        start_position: Default start position on startup\n        debug: enable debug messages\n    \"\"\"\n    self.robot_id = robot_id\n    self.server_url = server_url\n    self.oled_bus = oled_bus\n    self.oled_address = oled_address\n    self.scservos_port = scservos_port\n    self.scservos_baud_rate = scservos_baud_rate\n    self.debug = debug\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_properties: SharedProperties | None = None\n    self.shared_pose_current_lock: WritePriorityLock | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_table_limits: NDArray | None = None\n    self.shared_detector_obstacles: SharedCircleList | None = None\n    self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n    self.shared_monitor_obstacles: SharedCircleList | None = None\n    self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n    self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n    self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n    self.shared_obstacles_lock: WritePriorityLock | None = None\n    self.shared_avoidance_pose_order: SharedPoseOrder | None = None\n    self.shared_avoidance_blocked_lock: WritePriorityLock | None = None\n    self.shared_avoidance_path: SharedPoseOrderList | None = None\n    self.shared_avoidance_path_lock: WritePriorityLock | None = None\n    self.create_shared_memory()\n\n    # Fix type checker after shared memory creation\n    self.shared_properties: SharedProperties\n\n    # Update shared memory properties\n    self.shared_properties.robot_id = robot_id\n    self.shared_properties.robot_width = robot_width\n    self.shared_properties.robot_length = robot_length\n    self.shared_properties.obstacle_radius = obstacle_radius\n    self.shared_properties.obstacle_bb_margin = obstacle_bb_margin\n    self.shared_properties.obstacle_bb_vertices = obstacle_bb_vertices\n    self.shared_properties.obstacle_updater_interval = obstacle_updater_interval\n    self.shared_properties.path_refresh_interval = path_refresh_interval\n    self.shared_properties.bypass_detector = bypass_detector\n    self.shared_properties.disable_fixed_obstacles = disable_fixed_obstacles\n    self.shared_properties.table = table.val\n    self.shared_properties.strategy = strategy.val\n    self.shared_properties.start_position = start_position.val\n    self.shared_properties.avoidance_strategy = avoidance_strategy.val\n\n    self.virtual = platform.machine() != \"aarch64\"\n    self.retry_connection = True\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_ns = sio_events.SioEvents(self)\n    self.sio.register_namespace(self.sio_ns)\n    self.game_context = GameContext()\n    self.process_manager = Manager()\n    self.action: actions.Action | None = None\n    self.actions = action_classes.get(self.shared_properties.strategy, actions.Actions)(self)\n    self.obstacles_updater_loop = AsyncLoop(\n        \"Obstacles updater loop\",\n        obstacle_updater_interval,\n        self.update_obstacles,\n        logger=self.debug,\n    )\n    self._pose_order: pose.Pose | None = None\n    self.pose_reached: bool = True\n    self.blocked_counter: int = 0\n    self.controller = self.game_context.default_controller\n    self.game_wizard = GameWizard(self)\n    self.countdown_task: asyncio.Task | None = None\n    self.blocked_event_task: asyncio.Task | None = None\n    self.new_path_event_task: asyncio.Task | None = None\n    self.scservos = SCServos(self.scservos_port, scservos_baud_rate)\n    self.pami_event = asyncio.Event()\n    self.last_starter_event_timestamp: datetime | None = None\n    self.countdown_start_timestamp: datetime = datetime.now(UTC)\n\n    if not self.game_context.is_valid_start_position(start_position):\n        logger.error(f\"Start position {start_position.name} invalid in current table and camp\")\n        sys.exit(1)\n\n    self.avoidance_process: Process | None = None\n\n    if starter_pin:\n        self.starter = Button(\n            starter_pin,\n            pull_up=False,\n            bounce_time=None,\n        )\n    else:\n        self.starter = Button(\n            17,\n            pull_up=True,\n            pin_factory=MockFactory(),\n        )\n    self.starter.when_activated = partial(self.starter_changed_callback, True)\n    self.starter.when_deactivated = partial(self.starter_changed_callback, False)\n\n    if led_red_pin and led_green_pin and led_blue_pin:\n        self.led = RGBLED(\n            led_red_pin,\n            led_green_pin,\n            led_blue_pin,\n            initial_value=(1, 0, 0),\n        )\n    else:\n        self.led = Mock()\n\n    if flag_motor_pin:\n        self.flag_motor = OutputDevice(flag_motor_pin)\n    else:\n        self.flag_motor = Mock()\n\n    if self.oled_bus and self.oled_address:\n        self.oled_serial = i2c(port=self.oled_bus, address=self.oled_address)\n        self.oled_device = sh1106(self.oled_serial)\n        self.oled_font = ImageFont.truetype(\"DejaVuSansMono.ttf\", 9)\n        self.oled_image = canvas(self.oled_device)\n        self.oled_update_loop = AsyncLoop(\n            \"OLED display update loop\",\n            0.5,\n            self.update_oled_display,\n            logger=self.debug,\n        )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.blocked","title":"<code>blocked()</code>  <code>async</code>","text":"<p>Function called when a robot cannot find a path to go to the current pose of the current action</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def blocked(self):\n    \"\"\"\n    Function called when a robot cannot find a path to go to the current pose of the current action\n    \"\"\"\n    if (current_action := self.action) and current_action.interruptable:\n        logger.info(\"Planner: blocked\")\n        if new_action := self.get_action():\n            await self.set_action(new_action)\n        await current_action.recycle()\n        self.actions.append(current_action)\n        if not self.pose_order:\n            asyncio.create_task(self.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_avoidance","title":"<code>cmd_choose_avoidance()</code>  <code>async</code>","text":"<p>Choose avoidance strategy command from the menu. Send avoidance strategy wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_avoidance(self):\n    \"\"\"\n    Choose avoidance strategy command from the menu.\n    Send avoidance strategy wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Avoidance\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in AvoidanceStrategy],\n            \"value\": AvoidanceStrategy(self.shared_properties.avoidance_strategy).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_camp","title":"<code>cmd_choose_camp()</code>  <code>async</code>","text":"<p>Choose camp command from the menu. Send camp wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_camp(self):\n    \"\"\"\n    Choose camp command from the menu.\n    Send camp wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Camp\",\n            \"type\": \"camp\",\n            \"value\": self.game_context.camp.color.name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_start_position","title":"<code>cmd_choose_start_position()</code>  <code>async</code>","text":"<p>Choose start position command from the menu. Send start position wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_start_position(self):\n    \"\"\"\n    Choose start position command from the menu.\n    Send start position wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Start Position\",\n            \"type\": \"choice_integer\",\n            \"choices\": [p.name for p in StartPosition if self.game_context.is_valid_start_position(p)],\n            \"value\": StartPosition(self.shared_properties.start_position).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_strategy","title":"<code>cmd_choose_strategy()</code>  <code>async</code>","text":"<p>Choose strategy command from the menu. Send strategy wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_strategy(self):\n    \"\"\"\n    Choose strategy command from the menu.\n    Send strategy wizard message.\n    \"\"\"\n    choices: list[tuple[str, str, str]] = []  # list of (category, value, name). Name can be used for display.\n    for strategy in Strategy:\n        split = re.findall(r\"[A-Z][a-z]*|[a-z]+|[0-9]+\", strategy.name)\n        choices.append((strategy.name, split[0], \" \".join(split)))\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Strategy\",\n            \"type\": \"choice_str\",\n            \"choices\": choices,\n            \"value\": Strategy(self.shared_properties.strategy).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_table","title":"<code>cmd_choose_table()</code>  <code>async</code>","text":"<p>Choose table command from the menu. Send table wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_table(self):\n    \"\"\"\n    Choose table command from the menu.\n    Send table wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Table\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in TableEnum],\n            \"value\": TableEnum(self.shared_properties.table).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_next","title":"<code>cmd_next()</code>  <code>async</code>","text":"<p>Next command from the menu. Ignored if current pose is not reached for all robots.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_next(self):\n    \"\"\"\n    Next command from the menu.\n    Ignored if current pose is not reached for all robots.\n    \"\"\"\n    logger.info(\"Planner: cmd_next()\")\n    if self.game_context.playing:\n        return\n\n    # Check that pose_reached is set\n    if not self.pose_reached:\n        return\n\n    asyncio.create_task(self.next_pose())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_play","title":"<code>cmd_play(timestamp=None)</code>  <code>async</code>","text":"<p>Play command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_play(self, timestamp: str | None = None):\n    \"\"\"\n    Play command from the menu.\n    \"\"\"\n    if timestamp:\n        self.countdown_start_timestamp = datetime.fromisoformat(timestamp)\n    else:\n        self.countdown_start_timestamp = datetime.now(UTC)\n\n    logger.info(f\"Planner: cmd_play({self.countdown_start_timestamp})\")\n    if self.game_context.playing:\n        return\n\n    self.game_context.countdown = self.game_context.game_duration\n    self.game_context.playing = True\n    self.led.color = Color(\"blue\")\n\n    await self.sio_ns.emit(\n        \"start_countdown\",\n        (self.robot_id, self.game_context.game_duration, self.countdown_start_timestamp.isoformat(), \"deepskyblue\"),\n    )\n\n    await self.sio_ns.emit(\"start_video_record\")\n    asyncio.create_task(self.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_reset","title":"<code>cmd_reset()</code>  <code>async</code>","text":"<p>Reset command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_reset(self):\n    \"\"\"\n    Reset command from the menu.\n    \"\"\"\n    logger.info(\"Planner: cmd_reset()\")\n    await self.reset()\n    await self.sio_ns.emit(\"cmd_reset\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_stop","title":"<code>cmd_stop()</code>  <code>async</code>","text":"<p>Stop command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_stop(self):\n    \"\"\"\n    Stop command from the menu.\n    \"\"\"\n    logger.info(\"Planner: cmd_stop()\")\n    self.game_context.playing = False\n    await self.sio_ns.emit(\"stop_video_record\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.command","title":"<code>command(cmd, *args)</code>  <code>async</code>","text":"<p>Execute a command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def command(self, cmd: str, *args):\n    \"\"\"\n    Execute a command from the menu.\n    \"\"\"\n    if cmd.startswith(\"wizard_\"):\n        await self.cmd_wizard_test(cmd)\n        return\n\n    if cmd.startswith(\"act_\"):\n        await self.cmd_act(cmd)\n        return\n\n    if cmd.startswith(\"cam_\"):\n        await self.cmd_cam(cmd)\n        return\n\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema_with_values = properties_schema.copy()\n        # Add current values in JSON Schema\n        for prop in schema_with_values[\"properties\"]:\n            schema_with_values[\"properties\"][prop][\"value\"] = getattr(self.shared_properties, prop)\n        # Send config\n        await self.sio_ns.emit(\"config\", schema_with_values)\n        return\n\n    if cmd == \"scservos\":\n        # Get JSON Schema\n        schema = self.scservos.get_schema()\n        await self.sio_ns.emit(\"config\", schema)\n        return\n\n    if cmd == \"game_wizard\":\n        await self.game_wizard.start()\n        return\n\n    if not (cmd_func := getattr(self, f\"cmd_{cmd}\", None)):\n        logger.warning(f\"Unknown command: {cmd}\")\n        return\n\n    await cmd_func(*args)\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    self.retry_connection = True\n    try:\n        await self.try_connect()\n        await self.sio.wait()\n    except asyncio.CancelledError:\n        self.process_manager.shutdown()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.get_action","title":"<code>get_action()</code>","text":"<p>Get a new action for a robot. Simply choose next action in the list for now.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def get_action(self) -&gt; actions.Action | None:\n    \"\"\"\n    Get a new action for a robot.\n    Simply choose next action in the list for now.\n    \"\"\"\n    sorted_actions = sorted(\n        [action for action in self.actions if not action.recycled and action.weight() &gt; 0],\n        key=lambda action: action.weight(),\n    )\n\n    if len(sorted_actions) == 0:\n        return None\n\n    action = sorted_actions[-1]\n    self.actions.remove(action)\n    return action\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.next_pose","title":"<code>next_pose()</code>  <code>async</code>","text":"<p>Select the next pose for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def next_pose(self):\n    \"\"\"\n    Select the next pose for a robot.\n    \"\"\"\n    logger.info(\"Planner: next_pose()\")\n    try:\n        # Get and set new pose\n        self.pose_reached = False\n        await self.next_pose_in_action()\n\n        # If no pose left in current action, get and set new action\n        if not self.pose_order and (new_action := self.get_action()):\n            await self.set_action(new_action)\n            if not self.pose_order:\n                asyncio.create_task(self.set_pose_reached())\n    except Exception as exc:  # noqa\n        logger.warning(f\"Planner: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.reset","title":"<code>reset()</code>  <code>async</code>","text":"<p>Reset planner, context, robots and actions.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def reset(self):\n    \"\"\"\n    Reset planner, context, robots and actions.\n    \"\"\"\n    await self.stop()\n    await self.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_action","title":"<code>set_action(action)</code>  <code>async</code>","text":"<p>Set current action.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_action(self, action: \"actions.Action\"):\n    \"\"\"\n    Set current action.\n    \"\"\"\n    logger.info(f\"Planner: set action '{action.name}'\")\n    self.pose_order = None\n    self.action = action\n    await self.action.act_before_action()\n    await self.next_pose_in_action()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_intermediate_pose_reached","title":"<code>set_intermediate_pose_reached()</code>  <code>async</code>","text":"<p>Set pose reached for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_intermediate_pose_reached(self):\n    \"\"\"\n    Set pose reached for a robot.\n    \"\"\"\n    logger.info(\"Planner: set_intermediate_pose_reached()\")\n\n    # The pose reached is intermediate, just force path recompute.\n    if self.pose_order:\n        self.pose_order.path_pose.to_shared(self.shared_avoidance_pose_order)\n        self.shared_memory.avoidance_has_new_pose_order = True\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_reached","title":"<code>set_pose_reached()</code>  <code>async</code>","text":"<p>Set pose reached for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_pose_reached(self):\n    \"\"\"\n    Set pose reached for a robot.\n    \"\"\"\n    logger.info(\"Planner: set_pose_reached()\")\n\n    # Set pose reached\n    if not self.pose_reached and (pose_order := self.pose_order):\n        self.pose_order = None\n        await pose_order.act_after_pose()\n    else:\n        self.pose_order = None\n\n    self.pose_reached = True\n    if (action := self.action) and len(self.action.poses) == 0:\n        self.action = None\n        await action.act_after_action()\n\n    if not self.game_context.playing:\n        return\n\n    await self.next_pose()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_start","title":"<code>set_pose_start(pose_start)</code>  <code>async</code>","text":"<p>Set the start position of the robot for the next game.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_pose_start(self, pose_start: models.Pose):\n    \"\"\"\n    Set the start position of the robot for the next game.\n    \"\"\"\n    self.action = None\n    self.pose_order = None\n    self.pose_reached = True\n\n    # When the firmware receives a pose start, it does not send its updated pose current,\n    # so do it here.\n    self.shared_pose_current_buffer.push(pose_start.x, pose_start.y, pose_start.O)\n    await self.sio_ns.emit(\"pose_start\", pose_start.model_dump())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.soft_reset","title":"<code>soft_reset()</code>  <code>async</code>","text":"<p>Only reset context and actions.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def soft_reset(self):\n    \"\"\"\n    Only reset context and actions.\n    \"\"\"\n    self.game_context.reset()\n    await self.set_controller(self.game_context.default_controller, True)\n    self.shared_table_limits[0] = self.game_context.table.x_min\n    self.shared_table_limits[1] = self.game_context.table.x_max\n    self.shared_table_limits[2] = self.game_context.table.y_min\n    self.shared_table_limits[3] = self.game_context.table.y_max\n    self.shared_memory.avoidance_has_pose_order = False\n    self.shared_memory.avoidance_has_new_pose_order = False\n    self.flag_motor.off()\n    self.actions = action_classes.get(Strategy(self.shared_properties.strategy), actions.Actions)(self)\n    await self.set_pose_start(self.game_context.start_pose.pose)\n    self.pami_event.clear()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start sending obstacles list.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start sending obstacles list.\n    \"\"\"\n    logger.info(\"Planner: start\")\n    self.create_shared_memory()\n    self.shared_memory.avoidance_exiting = False\n    await self.soft_reset()\n    self.blocked_event_task = asyncio.create_task(\n        self.blocked_event_loop(),\n        name=\"Robot: Task Blocked Event Watcher Loop\",\n    )\n    self.new_path_event_task = asyncio.create_task(\n        self.new_path_event_loop(),\n        name=\"Robot: Task New Path Event Watcher Loop\",\n    )\n    await self.sio_ns.emit(\"starter_changed\", self.starter.is_pressed)\n    await self.sio_ns.emit(\"game_reset\")\n    await self.countdown_start()\n    self.obstacles_updater_loop.start()\n    if self.oled_bus and self.oled_address:\n        self.oled_update_loop.start()\n\n    self.avoidance_process = Process(target=avoidance_process, args=(self.robot_id,))\n    self.avoidance_process.start()\n\n    await actuators.actuators_init(self)\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop running tasks.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def stop(self):\n    \"\"\"\n    Stop running tasks.\n    \"\"\"\n    logger.info(\"Planner: stop\")\n\n    self.shared_memory.avoidance_exiting = True\n\n    await self.sio_ns.emit(\"stop_video_record\")\n\n    await self.countdown_stop()\n\n    await self.obstacles_updater_loop.stop()\n    if self.oled_bus and self.oled_address:\n        await self.oled_update_loop.stop()\n\n    if self.blocked_event_task:\n        self.blocked_event_task.cancel()\n        try:\n            await self.blocked_event_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Blocked Event Watcher Loop stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n    self.blocked_event_task = None\n\n    if self.new_path_event_task:\n        self.new_path_event_task.cancel()\n        try:\n            await self.new_path_event_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task New Path Event Watcher Loop stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n            traceback.print_exc()\n    self.new_path_event_task = None\n\n    if self.avoidance_process and self.avoidance_process.is_alive():\n        self.avoidance_process.join()\n        self.avoidance_process = None\n\n    self.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/planner\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.update_config","title":"<code>update_config(config)</code>","text":"<p>Update a Planner property with the value sent by the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def update_config(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update a Planner property with the value sent by the dashboard.\n    \"\"\"\n    name = config[\"name\"]\n    current_value = getattr(self.shared_properties, name)\n    current_value_type = type(current_value)\n    setattr(self.shared_properties, name, current_value_type(config[\"value\"]))\n    match name:\n        case \"obstacle_updater_interval\":\n            self.obstacles_updater_loop.interval = self.shared_properties.obstacle_updater_interval\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.update_scservo","title":"<code>update_scservo(servo)</code>  <code>async</code>","text":"<p>Update a SC Servo with the value sent by the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def update_scservo(self, servo: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update a SC Servo with the value sent by the dashboard.\n    \"\"\"\n    self.scservos.set(SCServoEnum[servo[\"name\"]], servo[\"value\"])\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.wizard_response","title":"<code>wizard_response(message)</code>  <code>async</code>","text":"<p>Handle wizard response sent from the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def wizard_response(self, message: dict[str, Any]):\n    \"\"\"\n    Handle wizard response sent from the dashboard.\n    \"\"\"\n    if (value := message[\"value\"]) is None:\n        return\n\n    match name := message.get(\"name\"):\n        case \"Choose Camp\":\n            new_camp = Camp.Colors[value]\n            if self.game_context.camp.color == new_camp:\n                return\n            previous_camp = self.game_context.camp.color\n            if self.shared_properties.table == TableEnum.Training.val and new_camp == Camp.Colors.yellow:\n                error_message = \"Yellow camp not compatible with training table\"\n                self.game_context.camp.color = previous_camp\n                logger.warning(f\"Wizard: {error_message}\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": message,\n                    },\n                )\n                return\n            self.game_context.camp.color = new_camp\n            await self.soft_reset()\n            logger.info(f\"Wizard: New camp: {self.game_context.camp.color.name}\")\n        case \"Choose Strategy\":\n            new_strategy = Strategy[value]\n            if self.shared_properties.strategy == new_strategy.val:\n                return\n            self.shared_properties.strategy = new_strategy.val\n            await self.soft_reset()\n            logger.info(f\"Wizard: New strategy: {value}\")\n        case \"Choose Avoidance\":\n            new_avoidance = AvoidanceStrategy[value]\n            if self.shared_properties.avoidance_strategy == new_avoidance.val:\n                return\n            self.shared_properties.avoidance_strategy = new_avoidance.val\n            logger.info(f\"Wizard: New avoidance strategy: {value}\")\n        case \"Choose Start Position\":\n            new_start_position = StartPosition[value]\n            if self.shared_properties.start_position == new_start_position.val:\n                return\n            if not self.game_context.is_valid_start_position(new_start_position):\n                message = f\"Start position {new_start_position.name} invalid in current table and camp\"\n                logger.warning(f\"Wizard: {message}\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": message,\n                    },\n                )\n                return\n            self.shared_properties.start_position = new_start_position.val\n            await self.soft_reset()\n        case \"Choose Table\":\n            new_table = TableEnum[value]\n            if self.shared_properties.table == new_table.val:\n                return\n            error_message = \"\"\n            previous_table = self.shared_properties.table\n            self.shared_properties.table = new_table.val\n            if not self.game_context.is_valid_start_position(StartPosition(self.shared_properties.start_position)):\n                error_message = (\n                    f\"Table {new_table.name} not compatible \"\n                    f\"with start position {StartPosition(self.shared_properties.start_position).name}\"\n                )\n            if new_table == TableEnum.Training and self.game_context.camp.color == Camp.Colors.yellow:\n                error_message = f\"Table {new_table.name} not compatible yellow camp\"\n            if error_message:\n                self.shared_properties.table = previous_table\n                logger.warning(f\"Wizard: {error_message}\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": error_message,\n                    },\n                )\n                return\n\n            self.shared_table_limits[0] = self.game_context.table.x_min\n            self.shared_table_limits[1] = self.game_context.table.x_max\n            self.shared_table_limits[2] = self.game_context.table.y_min\n            self.shared_table_limits[3] = self.game_context.table.y_max\n            await self.soft_reset()\n            logger.info(f\"Wizard: New table: {value}\")\n        case game_wizard_response if game_wizard_response.startswith(\"Game Wizard\"):\n            await self.game_wizard.response(message)\n        case wizard_test_response if wizard_test_response.startswith(\"Wizard Test\"):\n            logger.info(f\"Wizard test response: {name} = {value}\")\n        case _:\n            logger.warning(f\"Wizard: Unknown type: {name}\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/","title":"pose","text":""},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose","title":"<code>AdaptedPose</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Like a Pose, but its values are automatically adapted to selected camp during initialization. So to define static positions in actions, we can use this class to set pose related to the default camp, and if the camp changes, the pose will be adapted on reset.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>class AdaptedPose(Pose):\n    \"\"\"\n    Like a Pose, but its values are automatically adapted to selected camp\n    during initialization.\n    So to define static positions in actions, we can use this class to set pose related\n    to the default camp, and if the camp changes, the pose will be adapted on reset.\n    \"\"\"\n\n    _camp: ClassVar[Camp] = Camp()\n\n    @field_validator(\"y\")\n    @classmethod\n    def adapt_y(cls, v, **kwargs):\n        \"\"\"\n        Validator to adapt Y depending on the camp at initialization.\n        \"\"\"\n        return Camp().adapt_y(v)\n\n    @field_validator(\"O\")\n    @classmethod\n    def adapt_O(cls, v, **kwargs):\n        \"\"\"\n        Validator to adapt the angle depending on the camp at initialization.\n        \"\"\"\n        return Camp().adapt_angle(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose.adapt_O","title":"<code>adapt_O(v, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validator to adapt the angle depending on the camp at initialization.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@field_validator(\"O\")\n@classmethod\ndef adapt_O(cls, v, **kwargs):\n    \"\"\"\n    Validator to adapt the angle depending on the camp at initialization.\n    \"\"\"\n    return Camp().adapt_angle(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose.adapt_y","title":"<code>adapt_y(v, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validator to adapt Y depending on the camp at initialization.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@field_validator(\"y\")\n@classmethod\ndef adapt_y(cls, v, **kwargs):\n    \"\"\"\n    Validator to adapt Y depending on the camp at initialization.\n    \"\"\"\n    return Camp().adapt_y(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>PathPose</code></p> <p>Pose class used in actions. A function can be executed before moving and an other once it is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>class Pose(PathPose):\n    \"\"\"\n    Pose class used in actions.\n    A function can be executed before moving and an other once it is reached.\n    \"\"\"\n\n    before_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n    intermediate_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n    after_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n\n    @final\n    async def act_before_pose(self):\n        \"\"\"\n        Function executed before the robot starts moving.\n        \"\"\"\n        if self.before_pose_func:\n            await self.before_pose_func()\n\n    @final\n    async def act_intermediate_pose(self):\n        \"\"\"\n        Function executed once an intermediate pose is reached.\n        \"\"\"\n        if self.intermediate_pose_func:\n            await self.intermediate_pose_func()\n\n    @final\n    async def act_after_pose(self):\n        \"\"\"\n        Function executed once the pose is reached.\n        \"\"\"\n        if self.after_pose_func:\n            await self.after_pose_func()\n\n    @property\n    def path_pose(self) -&gt; PathPose:\n        \"\"\"\n        Convert the pose into its parent class.\n        \"\"\"\n        return PathPose(**self.model_dump())\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.path_pose","title":"<code>path_pose: PathPose</code>  <code>property</code>","text":"<p>Convert the pose into its parent class.</p>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_after_pose","title":"<code>act_after_pose()</code>  <code>async</code>","text":"<p>Function executed once the pose is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_after_pose(self):\n    \"\"\"\n    Function executed once the pose is reached.\n    \"\"\"\n    if self.after_pose_func:\n        await self.after_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_before_pose","title":"<code>act_before_pose()</code>  <code>async</code>","text":"<p>Function executed before the robot starts moving.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_before_pose(self):\n    \"\"\"\n    Function executed before the robot starts moving.\n    \"\"\"\n    if self.before_pose_func:\n        await self.before_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_intermediate_pose","title":"<code>act_intermediate_pose()</code>  <code>async</code>","text":"<p>Function executed once an intermediate pose is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_intermediate_pose(self):\n    \"\"\"\n    Function executed once an intermediate pose is reached.\n    \"\"\"\n    if self.intermediate_pose_func:\n        await self.intermediate_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/positions/","title":"positions","text":""},{"location":"reference/cogip/tools/planner/positions/#cogip.tools.planner.positions.StartPosition","title":"<code>StartPosition</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Enum for available start positions.</p> Source code in <code>cogip/tools/planner/positions.py</code> <pre><code>class StartPosition(ArgEnum):\n    \"\"\"\n    Enum for available start positions.\n    \"\"\"\n\n    Bottom = auto()\n    Top = auto()\n    Opposite = auto()\n    PAMI2 = auto()\n    PAMI3 = auto()\n    PAMI4 = auto()\n    PAMI5 = auto()\n    Center = auto()\n</code></pre>"},{"location":"reference/cogip/tools/planner/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/planner/scservos/","title":"scservos","text":""},{"location":"reference/cogip/tools/planner/scservos/#cogip.tools.planner.scservos.SCServoEnum","title":"<code>SCServoEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining SC Servo IDs</p> Source code in <code>cogip/tools/planner/scservos.py</code> <pre><code>class SCServoEnum(IntEnum):\n    \"\"\"Enum defining SC Servo IDs\"\"\"\n\n    MAGNET_SIDE_RIGHT = 1\n    ARM_RIGHT = 2\n    MAGNET_CENTER_RIGHT = 3\n    MAGNET_CENTER_LEFT = 4\n    ARM_LEFT = 5\n    MAGNET_SIDE_LEFT = 6\n    ARM_GRIP_LEFT = 7\n    ARM_GRIP_RIGHT = 8\n    GRIP_RIGHT = 9\n    GRIP_LEFT = 10\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__(\"/planner\")\n        self.planner = planner\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=0.2,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\", self.planner.virtual)\n        await self.emit(\"register_menu\", {\"name\": \"planner\", \"menu\": menu.model_dump()})\n        await self.emit(\"register_menu\", {\"name\": \"wizard\", \"menu\": wizard_test_menu.model_dump()})\n        if self.planner.robot_id == 1:\n            await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": robot_actuators_menu.model_dump()})\n            await self.emit(\n                \"register_menu\", {\"name\": \"actuators_multi\", \"menu\": robot_actuators_multi_menu.model_dump()}\n            )\n        else:\n            await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": pami_actuators_menu.model_dump()})\n        await self.emit(\"register_menu\", {\"name\": \"cameras\", \"menu\": cameras_menu.model_dump()})\n\n    async def on_disconnect(self):\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        await self.planner.stop()\n        logger.info(\"Disconnected from cogip-server\")\n\n    async def on_connect_error(self, data: dict[str, Any]):\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A planner is already connected\"\n        ):\n            logger.error(f\"Connection to cogip-server failed: {message}\")\n            self.planner.retry_connection = False\n            return\n        else:\n            logger.error(f\"Connection to cogip-server failed: {data = }\")\n\n    async def on_copilot_connected(self):\n        \"\"\"\n        Copilot connected, start planner.\n        \"\"\"\n        logger.info(\"[SIO] Copilot connected.\")\n        await self.planner.start()\n\n    async def on_copilot_disconnected(self):\n        \"\"\"\n        Copilot disconnected, stop planner.\n        \"\"\"\n        logger.info(\"[SIO] Copilot disconnected.\")\n        await self.planner.stop()\n\n    def on_starter_changed(self, pushed: bool):\n        \"\"\"\n        Signal received from the Monitor when the starter state changes in emulation mode.\n        \"\"\"\n        logger.info(f\"[SIO] Starter changed: {pushed}\")\n        if not self.planner.virtual:\n            return\n        if pushed:\n            self.planner.starter.pin.drive_low()\n        else:\n            self.planner.starter.pin.drive_high()\n\n    async def on_reset(self):\n        \"\"\"\n        Callback on reset message from copilot.\n        \"\"\"\n        logger.info(\"[SIO] Reset.\")\n        await self.planner.reset()\n\n    async def on_pose_reached(self):\n        \"\"\"\n        Callback on pose reached message.\n        \"\"\"\n        logger.info(\"[SIO] Pose reached.\")\n        asyncio.create_task(self.planner.set_pose_reached())\n\n    async def on_intermediate_pose_reached(self):\n        \"\"\"\n        Callback on intermediate pose reached message.\n        \"\"\"\n        logger.info(\"[SIO] Intermediate pose reached.\")\n        asyncio.create_task(self.planner.set_intermediate_pose_reached())\n\n    async def on_blocked(self):\n        \"\"\"\n        Callback on blocked message.\n        \"\"\"\n        logger.info(\"[SIO] Blocked.\")\n        asyncio.create_task(self.planner.blocked())\n\n    async def on_command(self, cmd: str, *args):\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        logger.info(f\"[SIO] Command: {cmd}\")\n        await self.planner.command(cmd, *args)\n\n    async def on_config_updated(self, config: dict[str, Any]):\n        \"\"\"\n        Callback on config update from dashboard.\n        \"\"\"\n        self.planner.update_config(config)\n\n    async def on_scservo_updated(self, scservo: dict[str, Any]):\n        \"\"\"\n        Callback on scservo update from dashboard.\n        \"\"\"\n        await self.planner.update_scservo(scservo)\n\n    async def on_wizard(self, message: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        await self.planner.wizard_response(message)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game end message.\n        \"\"\"\n        logger.info(\"[SIO] Game ended.\")\n        await self.planner.game_end()\n\n    async def on_actuator_state(self, actuator_state: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        try:\n            state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n        except ValidationError as exc:\n            logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n            return\n\n        await self.planner.update_actuator_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_actuator_state","title":"<code>on_actuator_state(actuator_state)</code>  <code>async</code>","text":"<p>Callback on actuator_state message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_actuator_state(self, actuator_state: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_state message.\n    \"\"\"\n    try:\n        state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n    except ValidationError as exc:\n        logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n        return\n\n    await self.planner.update_actuator_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_blocked","title":"<code>on_blocked()</code>  <code>async</code>","text":"<p>Callback on blocked message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_blocked(self):\n    \"\"\"\n    Callback on blocked message.\n    \"\"\"\n    logger.info(\"[SIO] Blocked.\")\n    asyncio.create_task(self.planner.blocked())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_command","title":"<code>on_command(cmd, *args)</code>  <code>async</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_command(self, cmd: str, *args):\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    logger.info(f\"[SIO] Command: {cmd}\")\n    await self.planner.command(cmd, *args)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config update from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]):\n    \"\"\"\n    Callback on config update from dashboard.\n    \"\"\"\n    self.planner.update_config(config)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=0.2,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\", self.planner.virtual)\n    await self.emit(\"register_menu\", {\"name\": \"planner\", \"menu\": menu.model_dump()})\n    await self.emit(\"register_menu\", {\"name\": \"wizard\", \"menu\": wizard_test_menu.model_dump()})\n    if self.planner.robot_id == 1:\n        await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": robot_actuators_menu.model_dump()})\n        await self.emit(\n            \"register_menu\", {\"name\": \"actuators_multi\", \"menu\": robot_actuators_multi_menu.model_dump()}\n        )\n    else:\n        await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": pami_actuators_menu.model_dump()})\n    await self.emit(\"register_menu\", {\"name\": \"cameras\", \"menu\": cameras_menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]):\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A planner is already connected\"\n    ):\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n        self.planner.retry_connection = False\n        return\n    else:\n        logger.error(f\"Connection to cogip-server failed: {data = }\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_copilot_connected","title":"<code>on_copilot_connected()</code>  <code>async</code>","text":"<p>Copilot connected, start planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_copilot_connected(self):\n    \"\"\"\n    Copilot connected, start planner.\n    \"\"\"\n    logger.info(\"[SIO] Copilot connected.\")\n    await self.planner.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_copilot_disconnected","title":"<code>on_copilot_disconnected()</code>  <code>async</code>","text":"<p>Copilot disconnected, stop planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_copilot_disconnected(self):\n    \"\"\"\n    Copilot disconnected, stop planner.\n    \"\"\"\n    logger.info(\"[SIO] Copilot disconnected.\")\n    await self.planner.stop()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_disconnect(self):\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    await self.planner.stop()\n    logger.info(\"Disconnected from cogip-server\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game end message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game end message.\n    \"\"\"\n    logger.info(\"[SIO] Game ended.\")\n    await self.planner.game_end()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_intermediate_pose_reached","title":"<code>on_intermediate_pose_reached()</code>  <code>async</code>","text":"<p>Callback on intermediate pose reached message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_intermediate_pose_reached(self):\n    \"\"\"\n    Callback on intermediate pose reached message.\n    \"\"\"\n    logger.info(\"[SIO] Intermediate pose reached.\")\n    asyncio.create_task(self.planner.set_intermediate_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_pose_reached","title":"<code>on_pose_reached()</code>  <code>async</code>","text":"<p>Callback on pose reached message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_pose_reached(self):\n    \"\"\"\n    Callback on pose reached message.\n    \"\"\"\n    logger.info(\"[SIO] Pose reached.\")\n    asyncio.create_task(self.planner.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_reset","title":"<code>on_reset()</code>  <code>async</code>","text":"<p>Callback on reset message from copilot.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_reset(self):\n    \"\"\"\n    Callback on reset message from copilot.\n    \"\"\"\n    logger.info(\"[SIO] Reset.\")\n    await self.planner.reset()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_scservo_updated","title":"<code>on_scservo_updated(scservo)</code>  <code>async</code>","text":"<p>Callback on scservo update from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_scservo_updated(self, scservo: dict[str, Any]):\n    \"\"\"\n    Callback on scservo update from dashboard.\n    \"\"\"\n    await self.planner.update_scservo(scservo)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_starter_changed","title":"<code>on_starter_changed(pushed)</code>","text":"<p>Signal received from the Monitor when the starter state changes in emulation mode.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>def on_starter_changed(self, pushed: bool):\n    \"\"\"\n    Signal received from the Monitor when the starter state changes in emulation mode.\n    \"\"\"\n    logger.info(f\"[SIO] Starter changed: {pushed}\")\n    if not self.planner.virtual:\n        return\n    if pushed:\n        self.planner.starter.pin.drive_low()\n    else:\n        self.planner.starter.pin.drive_high()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_wizard","title":"<code>on_wizard(message)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_wizard(self, message: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    await self.planner.wizard_response(message)\n</code></pre>"},{"location":"reference/cogip/tools/planner/table/","title":"table","text":""},{"location":"reference/cogip/tools/planner/table/#cogip.tools.planner.table.TableEnum","title":"<code>TableEnum</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Enum for available tables.</p> Source code in <code>cogip/tools/planner/table.py</code> <pre><code>class TableEnum(ArgEnum):\n    \"\"\"\n    Enum for available tables.\n    \"\"\"\n\n    Training = 0\n    Game = 1\n</code></pre>"},{"location":"reference/cogip/tools/planner/wizard/","title":"wizard","text":""},{"location":"reference/cogip/tools/planner/actions/action_align/","title":"action_align","text":""},{"location":"reference/cogip/tools/planner/actions/action_align/#cogip.tools.planner.actions.action_align.AlignBottomAction","title":"<code>AlignBottomAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to align the back of the robot on the border before game start. Only on Bottom start position.</p> Source code in <code>cogip/tools/planner/actions/action_align.py</code> <pre><code>class AlignBottomAction(Action):\n    \"\"\"\n    Action used to align the back of the robot on the border before game start.\n    Only on Bottom start position.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        actions: Actions,\n        *,\n        final_pose: models.Pose = Pose(x=-750, y=-250, O=0),\n        reset_countdown=False,\n        weight: float = 2000000.0,\n    ):\n        self.final_pose = final_pose\n        self.reset_countdown = reset_countdown\n        self.custom_weight = weight\n        super().__init__(\"Align Bottom action\", planner, actions)\n        self.before_action_func = self.init_poses\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def init_poses(self):\n        self.avoidance_backup = AvoidanceStrategy(self.planner.shared_properties.avoidance_strategy)\n\n        # On start, the robot is aligned on the right (blue camp) border of the Bottom start position\n        self.start_pose = AdaptedPose(\n            x=-750,\n            y=-500 + self.planner.shared_properties.robot_width / 2,\n            O=0,\n        )\n        await self.planner.sio_ns.emit(\"pose_start\", self.start_pose.model_dump())\n\n        # Align back\n        pose = Pose(\n            x=-1200,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=10,\n            max_speed_angular=10,\n            allow_reverse=True,\n            bypass_anti_blocking=True,\n            timeout_ms=0,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_align_back,\n            after_pose_func=self.after_align_back,\n        )\n        self.poses.append(pose)\n\n        # Step forward\n        pose = Pose(\n            x=-950 + self.planner.shared_properties.robot_length / 2,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=False,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_step_forward,\n            after_pose_func=self.after_step_forward,\n        )\n        self.poses.append(pose)\n\n        # Final pose\n        pose = AdaptedPose(\n            x=self.final_pose.x,\n            y=self.final_pose.y,\n            O=self.final_pose.O,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=True,\n            before_pose_func=self.before_final_pose,\n            after_pose_func=self.after_final_pose,\n        )\n        self.poses.append(pose)\n\n    async def before_align_back(self):\n        logger.info(f\"{self.name}: before_align_back\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_align_back(self):\n        logger.info(f\"{self.name}: after_align_back\")\n        current_pose = models.Pose(\n            x=-1000 + self.planner.shared_properties.robot_length / 2,\n            y=self.start_pose.y,\n            O=0,\n        )\n        await self.planner.sio_ns.emit(\"pose_start\", current_pose.model_dump())\n        await asyncio.sleep(1)\n\n    async def before_step_forward(self):\n        logger.info(f\"{self.name}: before_step_forward\")\n\n    async def after_step_forward(self):\n        logger.info(f\"{self.name}: after_step_forward\")\n\n    async def before_final_pose(self):\n        logger.info(f\"{self.name}: before_final_pose\")\n\n    async def after_final_pose(self):\n        logger.info(f\"{self.name}: after_final_pose\")\n        self.set_avoidance(self.avoidance_backup)\n        if self.reset_countdown:\n            now = datetime.now(UTC)\n            self.planner.countdown_start_timestamp = now\n            await self.planner.sio_ns.emit(\n                \"start_countdown\",\n                (self.planner.robot_id, self.game_context.game_duration, now.isoformat(), \"deepskyblue\"),\n            )\n\n    def weight(self) -&gt; float:\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x1/","title":"action_build_tribune_x1","text":""},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x1/#cogip.tools.planner.actions.action_build_tribune_x1.BuildTribuneX1Action","title":"<code>BuildTribuneX1Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to build a tribune.</p> Source code in <code>cogip/tools/planner/actions/action_build_tribune_x1.py</code> <pre><code>class BuildTribuneX1Action(Action):\n    \"\"\"\n    Action used to build a tribune.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        actions: Actions,\n        construction_area_id: ConstructionAreaID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"BuildTribuneX1 {construction_area_id.name}\", planner, actions)\n        self.before_action_func = self.before_action\n        self.construction_area = self.game_context.construction_areas[construction_area_id]\n        self.shift_build = 180\n        self.shift_approach = self.shift_build + 150\n        self.shift_step_back = self.shift_approach\n\n    async def recycle(self):\n        self.recycled = True\n\n    async def before_action(self):\n        logger.info(f\"{self.name}: before_action - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        self.start_pose = self.pose_current\n\n        # Approach\n        # Skip approach if the robot is already in front of the construction area\n        match self.construction_area.O:\n            case 0 | 180:\n                diff = abs(self.construction_area.y - self.start_pose.y)\n            case -90 | 90:\n                diff = abs(self.construction_area.x - self.start_pose.x)\n            case _:\n                diff = 1000\n\n        if diff &gt;= 5:\n            approach_pose = Pose(\n                **get_relative_pose(\n                    self.construction_area,\n                    front_offset=self.shift_approach,\n                    angular_offset=180,\n                ).model_dump(),\n                max_speed_linear=100,\n                max_speed_angular=100,\n                allow_reverse=True,\n                before_pose_func=self.before_approach,\n                after_pose_func=self.after_approach,\n            )\n            self.poses.append(approach_pose)\n        else:\n            logger.info(f\"{self.name}: skip approach (diff = {diff})\")\n            await self.before_approach()\n            await self.after_approach()\n\n        # Build\n        build_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=80,\n            max_speed_angular=80,\n            bypass_final_orientation=False,\n            allow_reverse=False,\n            after_pose_func=self.after_build,\n        )\n        self.poses.append(build_pose)\n\n        # Step back\n        step_back_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=True,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_step_back,\n            after_pose_func=self.after_step_back,\n        )\n        self.poses.append(step_back_pose)\n\n    async def before_approach(self):\n        logger.info(f\"{self.name}: before_approach\")\n\n    async def after_approach(self):\n        logger.info(f\"{self.name}: after_approach\")\n\n    async def after_build(self):\n        logger.info(f\"{self.name}: after_build - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        if self.game_context.tribunes_in_robot == 2:\n            # await actuators.tribune_spread(self.planner)\n            await actuators.arm_left_side(self.planner, 1500)\n            await actuators.arm_right_side(self.planner, 1500)\n            await actuators.magnet_side_left_out(self.planner, 1500)\n            await actuators.magnet_side_right_out(self.planner, 1500)\n            await asyncio.sleep(0.2)\n\n            await actuators.magnet_center_left_in(self.planner)\n            await actuators.magnet_center_right_in(self.planner)\n            await asyncio.sleep(0.2)\n\n            await actuators.arms_hold1(self.planner)\n            await asyncio.sleep(0.1)\n\n            await actuators.lift_5(self.planner)\n            await asyncio.sleep(0.2)\n        else:\n            await actuators.lift_0(self.planner)\n            self.planner.scservos.set(SCServoEnum.ARM_RIGHT, 223)\n            self.planner.scservos.set(SCServoEnum.ARM_LEFT, 703)\n            await asyncio.sleep(0.2)\n\n            await asyncio.gather(\n                actuators.magnet_side_right_in(self.planner),\n                actuators.magnet_side_left_in(self.planner),\n            )\n            await asyncio.sleep(0.2)\n\n            await actuators.arms_hold2(self.planner)\n            await asyncio.sleep(0.1)\n\n            await actuators.arms_release(self.planner)\n            await asyncio.sleep(0.1)\n\n            await actuators.arms_close(self.planner)\n            await asyncio.sleep(0.2)\n\n        self.game_context.tribunes_in_robot -= 1\n        self.construction_area.tribune_level += 1\n\n    async def before_step_back(self):\n        logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        logger.info(f\"{self.name}: after_step_back - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        self.construction_area.enabled = True\n        if self.game_context.tribunes_in_robot == 1:\n            await asyncio.gather(\n                actuators.arm_left_center(self.planner),\n                actuators.arm_right_center(self.planner),\n                actuators.magnet_side_left_center(self.planner),\n                actuators.magnet_side_right_center(self.planner),\n                actuators.lift_0(self.planner),\n            )\n        else:\n            await asyncio.gather(\n                actuators.arm_left_front(self.planner),\n                actuators.arm_right_front(self.planner),\n            )\n        self.game_context.score += 4\n\n    def weight(self) -&gt; float:\n        if self.game_context.tribunes_in_robot == 0 or self.construction_area.tribune_level != 0:\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge2\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x2/","title":"action_build_tribune_x2","text":""},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x2/#cogip.tools.planner.actions.action_build_tribune_x2.BuildTribuneX2Action","title":"<code>BuildTribuneX2Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to build a 2-story tribune.</p> Source code in <code>cogip/tools/planner/actions/action_build_tribune_x2.py</code> <pre><code>class BuildTribuneX2Action(Action):\n    \"\"\"\n    Action used to build a 2-story tribune.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        actions: Actions,\n        construction_area_id: ConstructionAreaID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"BuildTribuneX2 {construction_area_id.name}\", planner, actions)\n        self.before_action_func = self.before_action\n        self.construction_area = self.game_context.construction_areas[construction_area_id]\n        self.shift_build = 180\n        self.shift_approach = self.shift_build + 150\n        self.shift_step_back = self.shift_approach\n\n    async def recycle(self):\n        self.recycled = True\n\n    async def before_action(self):\n        logger.info(f\"{self.name}: before_action - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        self.start_pose = self.pose_current\n\n        # Approach\n        # Skip approach if the robot is already in front of the construction area\n        match self.construction_area.O:\n            case 0 | 180:\n                diff = abs(self.construction_area.y - self.start_pose.y)\n            case -90 | 90:\n                diff = abs(self.construction_area.x - self.start_pose.x)\n            case _:\n                diff = 1000\n\n        if diff &gt;= 5:\n            approach_pose = Pose(\n                **get_relative_pose(\n                    self.construction_area,\n                    front_offset=self.shift_approach,\n                    angular_offset=180,\n                ).model_dump(),\n                max_speed_linear=100,\n                max_speed_angular=100,\n                allow_reverse=True,\n                before_pose_func=self.before_approach,\n                after_pose_func=self.after_approach,\n            )\n            self.poses.append(approach_pose)\n        else:\n            logger.info(f\"{self.name}: skip approach (diff = {diff})\")\n            await self.before_approach()\n            await self.after_approach()\n\n        # Build\n        build_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=80,\n            max_speed_angular=80,\n            bypass_final_orientation=False,\n            allow_reverse=False,\n            before_pose_func=self.before_build,\n            after_pose_func=self.after_build,\n        )\n        self.poses.append(build_pose)\n\n        # Step back\n        step_back_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=True,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_step_back,\n            after_pose_func=self.after_step_back,\n        )\n        self.poses.append(step_back_pose)\n\n    async def before_approach(self):\n        logger.info(f\"{self.name}: before_approach\")\n\n    async def after_approach(self):\n        logger.info(f\"{self.name}: after_approach\")\n\n    async def before_build(self):\n        logger.info(f\"{self.name}: before_build\")\n\n    async def after_build(self):\n        logger.info(f\"{self.name}: after_build - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        await actuators.tribune_spread(self.planner)\n        await asyncio.sleep(0.2)\n\n        await actuators.arms_hold1(self.planner)\n        await asyncio.sleep(0.1)\n\n        await actuators.lift_140(self.planner)\n        await asyncio.sleep(1)\n\n        self.planner.scservos.set(SCServoEnum.ARM_RIGHT, 223)\n        self.planner.scservos.set(SCServoEnum.ARM_LEFT, 703)\n        await asyncio.sleep(0.2)\n\n        await asyncio.gather(\n            actuators.magnet_side_left_in(self.planner),\n            actuators.magnet_side_right_in(self.planner),\n        )\n        await asyncio.sleep(0.2)\n\n        await actuators.lift_125(self.planner)\n        await asyncio.sleep(0.5)\n\n        await actuators.arms_hold2(self.planner)\n        await asyncio.sleep(0.1)\n\n        await actuators.arms_release(self.planner)\n        await asyncio.sleep(0.1)\n\n        await asyncio.gather(\n            actuators.arms_close(self.planner),\n            actuators.arm_left_side(self.planner),\n            actuators.arm_right_side(self.planner),\n        )\n\n        self.game_context.tribunes_in_robot -= 2\n        self.construction_area.tribune_level += 2\n\n    async def before_step_back(self):\n        logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        logger.info(f\"{self.name}: after_step_back - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        self.construction_area.enabled = True\n        await asyncio.gather(\n            actuators.arm_left_center(self.planner),\n            actuators.arm_right_center(self.planner),\n            actuators.lift_0(self.planner),\n        )\n        self.game_context.score += 12\n\n    def weight(self) -&gt; float:\n        if self.game_context.tribunes_in_robot &lt; 2 or self.construction_area.tribune_level != 0:\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge2\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x3/","title":"action_build_tribune_x3","text":""},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x3/#cogip.tools.planner.actions.action_build_tribune_x3.BuildTribuneX3Action","title":"<code>BuildTribuneX3Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to build a 3-story tribune.</p> Source code in <code>cogip/tools/planner/actions/action_build_tribune_x3.py</code> <pre><code>class BuildTribuneX3Action(Action):\n    \"\"\"\n    Action used to build a 3-story tribune.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        actions: Actions,\n        construction_area_id: ConstructionAreaID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"BuildTribuneX3 {construction_area_id.name}\", planner, actions)\n        self.before_action_func = self.before_action\n        self.construction_area = self.game_context.construction_areas[construction_area_id]\n        self.shift_build_x3 = 160\n        self.shift_build_x2 = self.shift_build_x3 + 160\n        self.shift_approach_x2 = self.shift_build_x2 + 130\n        self.shift_step_back_x2 = self.shift_build_x2 + 20\n        self.shift_approach_x3 = self.shift_build_x2 - 20\n        self.shift_step_back_x3 = self.shift_approach_x3\n\n    async def recycle(self):\n        self.recycled = True\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        logger.info(f\"{self.name}: before_action - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        self.avoidance_backup = AvoidanceStrategy(self.planner.shared_properties.avoidance_strategy)\n        self.start_pose = self.pose_current\n\n        # Approach x2\n        approach_x2_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_approach_x2,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=True,\n            before_pose_func=self.before_approach_x2,\n            after_pose_func=self.after_approach_x2,\n        )\n        self.poses.append(approach_x2_pose)\n\n        # Build x2\n        build_x2_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build_x2,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=80,\n            max_speed_angular=80,\n            allow_reverse=False,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_build_x2,\n            after_pose_func=self.after_build_x2,\n        )\n        self.poses.append(build_x2_pose)\n\n        # Step back x2\n        step_back_x2_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back_x2,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=True,\n            before_pose_func=self.before_step_back_x2,\n            after_pose_func=self.after_step_back_x2,\n        )\n        self.poses.append(step_back_x2_pose)\n\n        # Approach x3\n        approach_x3_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_approach_x3,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=20,\n            max_speed_angular=20,\n            allow_reverse=False,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_approach_x3,\n            after_pose_func=self.after_approach_x3,\n        )\n        self.poses.append(approach_x3_pose)\n\n        # Build x3\n        build_x3_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build_x3,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=20,\n            max_speed_angular=20,\n            allow_reverse=False,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_build_x3,\n            after_pose_func=self.after_build_x3,\n        )\n        self.poses.append(build_x3_pose)\n\n        # Step back x3\n        step_back_x3_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back_x3,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            bypass_final_orientation=False,\n            allow_reverse=True,\n            before_pose_func=self.before_step_back_x3,\n            after_pose_func=self.after_step_back_x3,\n        )\n        self.poses.append(step_back_x3_pose)\n\n    async def before_approach_x2(self):\n        logger.info(f\"{self.name}: before_approach_x2\")\n\n    async def after_approach_x2(self):\n        logger.info(f\"{self.name}: after_approach_x2\")\n        self.construction_area.enabled = False\n\n    async def before_build_x2(self):\n        logger.info(f\"{self.name}: before_build_x2\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_build_x2(self):\n        logger.info(f\"{self.name}: after_build_x2 - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        await actuators.lift_5(self.planner)\n        await asyncio.sleep(0.2)\n\n        await actuators.arm_left_side(self.planner, 1500)\n        await actuators.arm_right_side(self.planner, 1500)\n        await actuators.magnet_side_left_out(self.planner, 1500)\n        await actuators.magnet_side_right_out(self.planner, 1500)\n        await asyncio.sleep(0.2)\n\n        await actuators.magnet_center_left_in(self.planner)\n        await actuators.magnet_center_right_in(self.planner)\n        await asyncio.sleep(0.2)\n\n        await actuators.arms_hold1(self.planner)\n        await asyncio.sleep(0.1)\n\n        await actuators.lift_140(self.planner)\n        await asyncio.sleep(1.2)\n\n        self.planner.scservos.set(SCServoEnum.ARM_RIGHT, 223)\n        self.planner.scservos.set(SCServoEnum.ARM_LEFT, 703)\n        await asyncio.sleep(0.2)\n\n        await asyncio.gather(\n            actuators.magnet_side_left_in(self.planner),\n            actuators.magnet_side_right_in(self.planner),\n        )\n        await asyncio.sleep(0.2)\n\n        await actuators.lift_125(self.planner)\n        await asyncio.sleep(0.2)\n\n        await actuators.arms_hold2(self.planner)\n        await asyncio.sleep(0.1)\n\n        await actuators.arms_release(self.planner)\n        await asyncio.sleep(0.2)\n\n        await asyncio.gather(\n            actuators.arms_close(self.planner),\n            actuators.arm_left_side(self.planner),\n            actuators.arm_right_side(self.planner),\n        )\n        await asyncio.sleep(0.5)\n\n    async def before_step_back_x2(self):\n        logger.info(f\"{self.name}: before_step_back_x2\")\n\n    async def after_step_back_x2(self):\n        logger.info(f\"{self.name}: after_step_back_x2\")\n        await actuators.lift_0(self.planner)\n        await asyncio.sleep(1)\n\n    async def before_approach_x3(self):\n        logger.info(f\"{self.name}: before_approach_x3\")\n        await actuators.arm_right_front(self.planner)\n        await actuators.arm_left_front(self.planner)\n        await actuators.magnet_side_right_in(self.planner)\n        await actuators.magnet_side_left_in(self.planner)\n        await actuators.magnet_center_left_out(self.planner)\n        await actuators.magnet_center_right_out(self.planner)\n\n    async def after_approach_x3(self):\n        logger.info(f\"{self.name}: after_approach_x3\")\n        await actuators.lift_140(self.planner)\n        await asyncio.sleep(1.2)\n\n    async def before_build_x3(self):\n        logger.info(f\"{self.name}: before_build_x3\")\n\n    async def after_build_x3(self):\n        logger.info(f\"{self.name}: after_build_x3\")\n        await actuators.lift_125(self.planner)\n        await asyncio.sleep(0.2)\n\n        await asyncio.gather(\n            actuators.magnet_center_left_in(self.planner),\n            actuators.magnet_center_right_in(self.planner),\n        )\n\n    async def before_step_back_x3(self):\n        logger.info(f\"{self.name}: before_step_back_x3\")\n\n    async def after_step_back_x3(self):\n        logger.info(f\"{self.name}: after_step_back - tribunes_in_robot={self.game_context.tribunes_in_robot}\")\n        self.construction_area.enabled = True\n        await asyncio.gather(\n            actuators.arm_left_center(self.planner),\n            actuators.arm_right_center(self.planner),\n            actuators.lift_0(self.planner),\n        )\n        self.game_context.tribunes_in_robot -= 2\n        self.construction_area.tribune_level += 2\n        self.game_context.score += 24\n        self.set_avoidance(self.avoidance_backup)\n\n    def weight(self) -&gt; float:\n        if self.game_context.tribunes_in_robot &lt; 2 or self.construction_area.tribune_level != 1:\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge3\n            and self.game_context.tribunes[TribuneID.LocalCenter].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge3\n            and self.game_context.tribunes[TribuneID.OppositeCenter].enabled\n        ):\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_capture_tribune/","title":"action_capture_tribune","text":""},{"location":"reference/cogip/tools/planner/actions/action_capture_tribune/#cogip.tools.planner.actions.action_capture_tribune.CaptureTribuneAction","title":"<code>CaptureTribuneAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to capture tribune using magnets.</p> Source code in <code>cogip/tools/planner/actions/action_capture_tribune.py</code> <pre><code>class CaptureTribuneAction(Action):\n    \"\"\"\n    Action used to capture tribune using magnets.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        actions: Actions,\n        tribune_id: artifacts.TribuneID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"CaptureTribune {tribune_id.name}\", planner, actions)\n        self.before_action_func = self.before_action\n        self.tribune = self.game_context.tribunes[tribune_id]\n        self.shift_capture = 140\n        self.shift_approach = self.shift_capture + 150\n        self.shift_step_back = self.shift_capture + 80\n\n    async def recycle(self):\n        self.tribune.enabled = True\n        self.recycled = True\n\n    async def before_action(self):\n        self.start_pose = self.pose_current\n\n        # Approach\n        approach_pose = Pose(\n            **get_relative_pose(\n                self.tribune,\n                front_offset=self.shift_approach,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=True,\n            before_pose_func=self.before_approach,\n            after_pose_func=self.after_approach,\n        )\n        self.poses.append(approach_pose)\n\n        # Capture\n        capture_pose = Pose(\n            **get_relative_pose(\n                self.tribune,\n                front_offset=self.shift_capture,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=20,\n            max_speed_angular=20,\n            allow_reverse=False,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_capture,\n            after_pose_func=self.after_capture,\n        )\n        self.poses.append(capture_pose)\n\n        if (\n            (\n                self.tribune.id == artifacts.TribuneID.LocalCenter\n                and self.planner.shared_properties.table == TableEnum.Training.val\n            )\n            or self.tribune.id == artifacts.TribuneID.LocalTop\n            or self.tribune.id == artifacts.TribuneID.LocalTopSide\n            or self.tribune.id == artifacts.TribuneID.LocalBottomSide\n            or self.tribune.id == artifacts.TribuneID.OppositeTop\n            or self.tribune.id == artifacts.TribuneID.OppositeTopSide\n            or self.tribune.id == artifacts.TribuneID.OppositeBottomSide\n        ):\n            # Step back\n            pose = Pose(\n                **get_relative_pose(\n                    self.tribune,\n                    front_offset=self.shift_step_back,\n                    angular_offset=180,\n                ).model_dump(),\n                max_speed_linear=50,\n                max_speed_angular=50,\n                allow_reverse=True,\n                bypass_final_orientation=False,\n                before_pose_func=self.before_step_back,\n                after_pose_func=self.after_step_back,\n            )\n            self.poses.append(pose)\n\n    async def before_approach(self):\n        logger.info(f\"{self.name}: before_approach\")\n        await actuators.arms_close(self.planner)\n\n    async def after_approach(self):\n        logger.info(f\"{self.name}: after_approach\")\n\n    async def before_capture(self):\n        logger.info(f\"{self.name}: before_capture\")\n        self.tribune.enabled = False\n        await actuators.lift_0(self.planner)\n        await asyncio.gather(\n            actuators.tribune_grab(self.planner),\n            actuators.arms_open(self.planner),\n        )\n        await asyncio.sleep(0.2)  # Make sure the obstacle is removed from avoidance\n\n    async def after_capture(self):\n        logger.info(f\"{self.name}: after_capture\")\n        await actuators.arms_hold2(self.planner)\n        await asyncio.sleep(0.1)\n        self.game_context.tribunes_in_robot = 2\n\n    async def before_step_back(self):\n        logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        logger.info(f\"{self.name}: after_step_back\")\n\n    def weight(self) -&gt; float:\n        if not self.tribune.enabled or self.game_context.tribunes_in_robot != 0:\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_drop_banner/","title":"action_drop_banner","text":""},{"location":"reference/cogip/tools/planner/actions/action_drop_banner/#cogip.tools.planner.actions.action_drop_banner.DropBannerAction","title":"<code>DropBannerAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to drop the banner on the table border.</p> Source code in <code>cogip/tools/planner/actions/action_drop_banner.py</code> <pre><code>class DropBannerAction(Action):\n    \"\"\"\n    Action used to drop the banner on the table border.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        actions: Actions,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(\"Drop banner action\", planner, actions)\n        self.before_action_func = self.before_action\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        logger.info(f\"{self.name}: before_action\")\n        self.avoidance_backup = AvoidanceStrategy(self.planner.shared_properties.avoidance_strategy)\n\n        # On start, the robot is facing the back of the table\n        self.start_pose = self.pose_current\n\n        # Go in contact of the border\n        drop_pose = Pose(\n            x=-1000 + 132,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=10,\n            max_speed_angular=10,\n            allow_reverse=False,\n            bypass_anti_blocking=False,\n            timeout_ms=0,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_drop,\n            after_pose_func=self.after_drop,\n        )\n        self.poses.append(drop_pose)\n\n        # Step back\n        step_back_pose = Pose(\n            x=-950 + self.planner.shared_properties.robot_length / 2,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=True,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_step_back,\n            after_pose_func=self.after_step_back,\n        )\n        self.poses.append(step_back_pose)\n\n    async def before_drop(self):\n        logger.info(f\"{self.name}: before_drop\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        await asyncio.gather(\n            actuators.arm_left_side(self.planner),\n            actuators.arm_right_side(self.planner),\n            actuators.magnet_center_right_in(self.planner),\n            actuators.magnet_center_left_in(self.planner),\n            actuators.magnet_side_right_in(self.planner),\n            actuators.magnet_side_left_in(self.planner),\n        )\n\n    async def after_drop(self):\n        logger.info(f\"{self.name}: after_drop\")\n        await actuators.lift_0(self.planner)\n        await asyncio.sleep(1)\n        self.game_context.score += 20\n\n    async def before_step_back(self):\n        logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        logger.info(f\"{self.name}: after_step_back\")\n        self.set_avoidance(self.avoidance_backup)\n        await asyncio.gather(\n            actuators.arm_left_center(self.planner),\n            actuators.arm_right_center(self.planner),\n        )\n\n    def weight(self) -&gt; float:\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_parking/","title":"action_parking","text":""},{"location":"reference/cogip/tools/planner/actions/actions/","title":"actions","text":""},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action","title":"<code>Action</code>","text":"<p>This class represents an action of the game. It contains a list of Pose to reach in order. A function can be executed before the action starts and after it ends.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>class Action:\n    \"\"\"\n    This class represents an action of the game.\n    It contains a list of Pose to reach in order.\n    A function can be executed before the action starts and after it ends.\n    \"\"\"\n\n    def __init__(self, name: str, planner: \"Planner\", actions: \"Actions\", interruptable: bool = True):\n        self.name = name\n        self.planner = planner\n        self.actions = actions\n        self.interruptable = interruptable\n        self.game_context = context.GameContext()\n        self.poses: list[Pose] = []\n        self.before_action_func: Callable[[], Awaitable[None]] | None = None\n        self.after_action_func: Callable[[], Awaitable[None]] | None = None\n        self.recycled: bool = False\n\n    def weight(self) -&gt; float:\n        \"\"\"\n        Weight of the action.\n        It can be used to choose the next action to select.\n        This is the generic implementation.\n        \"\"\"\n        raise NotImplementedError\n\n    @final\n    async def act_before_action(self):\n        \"\"\"\n        Function executed before the action starts.\n        \"\"\"\n        if self.before_action_func:\n            await self.before_action_func()\n\n    @final\n    async def act_after_action(self):\n        \"\"\"\n        Function executed after the action ends.\n        \"\"\"\n        if self.after_action_func:\n            await self.after_action_func()\n\n        # Re-enable all actions after a successful action\n        for action in self.actions:\n            action.recycled = False\n\n    async def recycle(self):\n        \"\"\"\n        Function called if the action is blocked and put back in the actions list\n        \"\"\"\n        self.recycled = True\n\n    @property\n    def pose_current(self) -&gt; models.Pose:\n        return self.planner.pose_current\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.act_after_action","title":"<code>act_after_action()</code>  <code>async</code>","text":"<p>Function executed after the action ends.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>@final\nasync def act_after_action(self):\n    \"\"\"\n    Function executed after the action ends.\n    \"\"\"\n    if self.after_action_func:\n        await self.after_action_func()\n\n    # Re-enable all actions after a successful action\n    for action in self.actions:\n        action.recycled = False\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.act_before_action","title":"<code>act_before_action()</code>  <code>async</code>","text":"<p>Function executed before the action starts.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>@final\nasync def act_before_action(self):\n    \"\"\"\n    Function executed before the action starts.\n    \"\"\"\n    if self.before_action_func:\n        await self.before_action_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.recycle","title":"<code>recycle()</code>  <code>async</code>","text":"<p>Function called if the action is blocked and put back in the actions list</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>async def recycle(self):\n    \"\"\"\n    Function called if the action is blocked and put back in the actions list\n    \"\"\"\n    self.recycled = True\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.weight","title":"<code>weight()</code>","text":"<p>Weight of the action. It can be used to choose the next action to select. This is the generic implementation.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>def weight(self) -&gt; float:\n    \"\"\"\n    Weight of the action.\n    It can be used to choose the next action to select.\n    This is the generic implementation.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Actions","title":"<code>Actions</code>","text":"<p>               Bases: <code>list[Action]</code></p> <p>List of actions. Just inherits from list for now.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>class Actions(list[Action]):\n    \"\"\"\n    List of actions.\n    Just inherits from list for now.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__()\n        self.planner = planner\n        self.game_context = context.GameContext()\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.WaitAction","title":"<code>WaitAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used if no other action is available. Reset recycled attribute of all actions at the end.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>class WaitAction(Action):\n    \"\"\"\n    Action used if no other action is available.\n    Reset recycled attribute of all actions at the end.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: \"Actions\"):\n        super().__init__(\"Wait action\", planner, actions)\n        self.before_action_func = self.before_wait\n        self.after_action_func = self.after_wait\n\n    def weight(self) -&gt; float:\n        return 1\n\n    async def before_wait(self):\n        logger.debug(f\"Robot {self.planner.robot_id}: WaitAction: before action\")\n\n    async def after_wait(self):\n        logger.debug(f\"Robot {self.planner.robot_id}: WaitAction: after action\")\n        await asyncio.sleep(2)\n\n        for action in self.actions:\n            action.recycled = False\n\n        self.actions.append(WaitAction(self.planner, self.actions))\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.get_relative_pose","title":"<code>get_relative_pose(reference_pose, *, front_offset, side_offset=0.0, angular_offset=0.0)</code>","text":"<p>Get a new pose relative to the reference pose with the specified linear and angular offsets.</p> <p>Parameters:</p> Name Type Description Default <code>reference_pose</code> <code>Pose</code> <p>The reference pose.</p> required <code>front_offset</code> <code>float</code> <p>The offset in the direction of the reference's front.</p> required <code>side_offset</code> <code>float</code> <p>The offset in the direction of the reference's side. Positive is to the left.</p> <code>0.0</code> <code>angular_offset</code> <code>float</code> <p>The angular offset in degrees.</p> <code>0.0</code> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>def get_relative_pose(\n    reference_pose: models.Pose,\n    *,\n    front_offset: float,\n    side_offset: float = 0.0,\n    angular_offset: float = 0.0,\n) -&gt; models.Pose:\n    \"\"\"\n    Get a new pose relative to the reference pose with the specified linear and angular offsets.\n\n    Args:\n        reference_pose: The reference pose.\n        front_offset: The offset in the direction of the reference's front.\n        side_offset: The offset in the direction of the reference's side. Positive is to the left.\n        angular_offset: The angular offset in degrees.\n    \"\"\"\n    # This function calculates a new pose relative to a reference pose.\n    new_x = (\n        reference_pose.x\n        + front_offset * math.cos(math.radians(reference_pose.O))\n        - side_offset * math.sin(math.radians(reference_pose.O))\n    )\n    new_y = (\n        reference_pose.y\n        + front_offset * math.sin(math.radians(reference_pose.O))\n        + side_offset * math.cos(math.radians(reference_pose.O))\n    )\n    # Normalize the angle to be between 0 and 360 degrees\n    new_angle = (reference_pose.O + angular_offset) % 360\n    return models.Pose(x=new_x, y=new_y, O=new_angle)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/camera_calibration/","title":"camera_calibration","text":""},{"location":"reference/cogip/tools/planner/actions/camera_calibration/#cogip.tools.planner.actions.camera_calibration.CameraCalibrationAction","title":"<code>CameraCalibrationAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>This action moves around the front right table marker, and take pictures to compute camera extrinsic parameters (ie, the position of the camera relative to the robot center).</p> Source code in <code>cogip/tools/planner/actions/camera_calibration.py</code> <pre><code>class CameraCalibrationAction(Action):\n    \"\"\"\n    This action moves around the front right table marker, and take pictures to compute\n    camera extrinsic parameters (ie, the position of the camera relative to the robot center).\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"CameraCalibration action\", planner, actions)\n        self.camera_positions: list[Vertex] = []\n        self.after_action_func = self.print_camera_positions\n\n        self.poses.append(\n            Pose(\n                x=-220,\n                y=-(1500 - 450 + self.planner.shared_properties.robot_width / 2),\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-220,\n                y=-800,\n                O=160,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-220,\n                y=-540,\n                O=-160,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-260,\n                y=-320,\n                O=-130,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-500,\n                y=-320,\n                O=-90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-710,\n                y=-460,\n                O=-70,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-810,\n                y=-760,\n                O=0,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-(1000 - 450 + self.planner.shared_properties.robot_width / 2),\n                y=-(1500 - 450 + self.planner.shared_properties.robot_width / 2),\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n    async def calibrate_camera(self):\n        await asyncio.sleep(1)\n        if pose := await calibrate_camera(self.planner):\n            self.camera_positions.append(pose)\n        await asyncio.sleep(0.5)\n\n    async def print_camera_positions(self):\n        x = 0\n        y = 0\n        z = 0\n        for i, p in enumerate(self.camera_positions):\n            logger.info(f\"Camera position {i: 2d}: X={p.x:.0f} Y={p.y:.0f} Z={p.z:.0f}\")\n            x += p.x\n            y += p.y\n            z += p.z\n\n        if n := len(self.camera_positions):\n            p = Vertex(x=x / n, y=y / n, z=z / n)\n            logger.info(f\"=&gt; Camera position mean: X={p.x:.0f} Y={p.y:.0f} Z={p.z:.0f}\")\n        else:\n            logger.warning(\"No camera position found\")\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/","title":"pami","text":""},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami2Action","title":"<code>Pami2Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 2 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami2Action(Action):\n    \"\"\"\n    PAMI 2 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, *, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 2 action\", planner, actions, interruptable=False)\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n        self.wait = wait\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose0 = Pose(\n            **get_relative_pose(\n                self.start_pose,\n                front_offset=self.planner.shared_properties.robot_length,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose0,\n            after_pose_func=self.after_pose0,\n        )\n        self.poses.append(pose0)\n\n        pose1 = AdaptedPose(\n            x=150,\n            y=-720,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        pose2 = AdaptedPose(\n            x=150,\n            y=0,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose2,\n            after_pose_func=self.after_pose2,\n        )\n        self.poses.append(pose2)\n\n        final_pose = AdaptedPose(\n            x=300,\n            y=240,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_final,\n            after_pose_func=self.after_final,\n        )\n        self.poses.append(final_pose)\n\n        if self.planner.shared_properties.table == TableEnum.Training.val:\n            pose0.x -= 1000\n            pose1.x -= 1000\n            pose2.x -= 1000\n            pose2.y = -380\n            final_pose.x = pose2.x\n            final_pose.y = -180\n\n    async def before_pose0(self):\n        logger.info(f\"{self.name}: before_pose0\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose0(self):\n        logger.info(f\"{self.name}: after_pose0\")\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n    async def before_pose1(self):\n        logger.info(f\"{self.name}: before_pose1\")\n\n    async def after_pose1(self):\n        logger.info(f\"{self.name}: after_pose1\")\n\n    async def before_pose2(self):\n        logger.info(f\"{self.name}: before_pose2\")\n\n    async def after_pose2(self):\n        logger.info(f\"{self.name}: after_pose2\")\n\n    async def before_final(self):\n        logger.info(f\"{self.name}: before_final\")\n\n    async def after_final(self):\n        logger.info(f\"{self.name}: after_final\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.planner.flag_motor.on()\n        self.actions.clear()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami3Action","title":"<code>Pami3Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 3 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami3Action(Action):\n    \"\"\"\n    PAMI 3 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, *, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 3 action\", planner, actions, interruptable=False)\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n        self.wait = wait\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose1 = Pose(\n            **get_relative_pose(\n                self.start_pose,\n                front_offset=self.planner.shared_properties.robot_length,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        pose2 = AdaptedPose(\n            x=340,\n            y=-850,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose2,\n            after_pose_func=self.after_pose2,\n        )\n        self.poses.append(pose2)\n\n        final_pose = AdaptedPose(\n            x=340,\n            y=-320,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_final,\n            after_pose_func=self.after_final,\n        )\n        self.poses.append(final_pose)\n\n        if self.planner.shared_properties.table == TableEnum.Training.val:\n            pose1.x -= 1000\n            pose2.x -= 1000\n            final_pose.x -= 1000\n\n    async def before_pose1(self):\n        logger.info(f\"{self.name}: before_pose1\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose1(self):\n        logger.info(f\"{self.name}: after_pose1\")\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n    async def before_pose2(self):\n        logger.info(f\"{self.name}: before_pose2\")\n\n    async def after_pose2(self):\n        logger.info(f\"{self.name}: after_pose2\")\n\n    async def before_final(self):\n        logger.info(f\"{self.name}: before_final\")\n\n    async def after_final(self):\n        logger.info(f\"{self.name}: after_final\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.planner.flag_motor.on()\n        self.actions.clear()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami4Action","title":"<code>Pami4Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 4 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami4Action(Action):\n    \"\"\"\n    PAMI 4 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, *, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 4 action\", planner, actions, interruptable=False)\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n        self.wait = wait\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose1 = Pose(\n            **get_relative_pose(\n                self.start_pose,\n                front_offset=self.planner.shared_properties.robot_length,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        final_pose = AdaptedPose(\n            x=530,\n            y=-730,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_final,\n            after_pose_func=self.after_final,\n        )\n        self.poses.append(final_pose)\n\n        if self.planner.shared_properties.table == TableEnum.Training.val:\n            pose1.x -= 1000\n            final_pose.x -= 1000\n\n    async def before_pose1(self):\n        logger.info(f\"{self.name}: before_pose1\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose1(self):\n        logger.info(f\"{self.name}: after_pose1\")\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n    async def before_final(self):\n        logger.info(f\"{self.name}: before_final\")\n\n    async def after_final(self):\n        logger.info(f\"{self.name}: after_final\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.planner.flag_motor.on()\n        self.actions.clear()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami5Action","title":"<code>Pami5Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 5 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami5Action(Action):\n    \"\"\"\n    PAMI 5 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 5 action\", planner, actions, interruptable=False)\n        self.wait = wait\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.planner.shared_properties.disable_fixed_obstacles = True\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose1 = AdaptedPose(\n            x=self.start_pose.x,\n            y=-300,\n            max_speed_linear=70,\n            max_speed_angular=70,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        pose2 = AdaptedPose(\n            x=610,\n            y=-300,\n            O=180,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            allow_reverse=False,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_pose2,\n            after_pose_func=self.after_pose2,\n        )\n        if self.planner.shared_properties.table == TableEnum.Training.val:\n            pose2.x -= 1000\n        self.poses.append(pose2)\n\n    async def before_pose1(self):\n        logger.info(f\"{self.name}: before_pose1\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose1(self):\n        logger.info(f\"{self.name}: after_pose1\")\n\n    async def before_pose2(self):\n        logger.info(f\"{self.name}: before_pose2\")\n\n    async def after_pose2(self):\n        logger.info(f\"{self.name}: after_pose2\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.actions.clear()\n        self.planner.shared_properties.disable_fixed_obstacles = False\n        self.planner.flag_motor.on()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pid_position_test/","title":"pid_position_test","text":""},{"location":"reference/cogip/tools/planner/actions/pid_position_test/#cogip.tools.planner.actions.pid_position_test.AngularPositionTestAction","title":"<code>AngularPositionTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to move the robot without table. First set start position on 0x0. Them rotate of 180\u00b0 in the same position. Then go back to start position. Do it in loop.</p> Source code in <code>cogip/tools/planner/actions/pid_position_test.py</code> <pre><code>class AngularPositionTestAction(Action):\n    \"\"\"\n    Action used to move the robot without table.\n    First set start position on 0x0.\n    Them rotate of 180\u00b0 in the same position.\n    Then go back to start position.\n    Do it in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"AngularPositionTest action\", planner, actions)\n        self.angular_distance = 180\n        self.linear_speed = 66\n        self.angular_speed = 66\n        self.allow_reverse = True\n        self.before_action_func = self.init_start_position\n        self.pose_init = models.Pose(\n            x=-500,\n            y=-300,\n            O=-90,\n            max_speed_linear=self.linear_speed,\n            max_speed_angular=self.angular_speed,\n            allow_reverse=self.allow_reverse,\n        )\n        self.pose_start = Pose(**self.pose_init.model_dump())\n        self.pose_start.after_pose_func = partial(self.append_pose, self.pose_start)\n        self.pose_end = self.pose_start.model_copy(update={\"O\": self.pose_start.O + self.angular_distance})\n        self.pose_end.after_pose_func = partial(self.append_pose, self.pose_end)\n        self.poses.append(self.pose_end)\n        self.poses.append(self.pose_start)\n\n    async def init_start_position(self):\n        await self.planner.set_pose_start(self.pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pid_position_test/#cogip.tools.planner.actions.pid_position_test.LinearPositionTestAction","title":"<code>LinearPositionTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to move the robot without table. First set start position on 0x0. Them move straight forward along 100 cm. Then go back to start position. Do it in loop.</p> Source code in <code>cogip/tools/planner/actions/pid_position_test.py</code> <pre><code>class LinearPositionTestAction(Action):\n    \"\"\"\n    Action used to move the robot without table.\n    First set start position on 0x0.\n    Them move straight forward along 100 cm.\n    Then go back to start position.\n    Do it in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"LinearPositionTest action\", planner, actions)\n        self.distance = 750\n        self.linear_speed = 66\n        self.angular_speed = 66\n        self.allow_reverse = True\n        self.before_action_func = self.init_start_position\n        self.pose_init = models.Pose(\n            x=-500,\n            y=-300,\n            O=-90,\n            max_speed_linear=self.linear_speed,\n            max_speed_angular=self.angular_speed,\n            allow_reverse=self.allow_reverse,\n        )\n        self.pose_start = Pose(**self.pose_init.model_dump())\n        self.pose_start.after_pose_func = partial(self.append_pose, self.pose_start)\n        self.pose_end = self.pose_start.model_copy(update={\"y\": self.pose_start.y - self.distance})\n        self.pose_end.after_pose_func = partial(self.append_pose, self.pose_end)\n        self.poses.append(self.pose_end)\n        self.poses.append(self.pose_start)\n\n    async def init_start_position(self):\n        await self.planner.set_pose_start(self.pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pid_speed_test/","title":"pid_speed_test","text":""},{"location":"reference/cogip/tools/planner/actions/pid_speed_test/#cogip.tools.planner.actions.pid_speed_test.SpeedTestAction","title":"<code>SpeedTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Dummy action for pid calibration. Same dummy pose in loop.</p> Source code in <code>cogip/tools/planner/actions/pid_speed_test.py</code> <pre><code>class SpeedTestAction(Action):\n    \"\"\"\n    Dummy action for pid calibration.\n    Same dummy pose in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"Pid calibration action\", planner, actions)\n        self.pose = Pose()\n        self.pose.after_pose_func = self.after_pose\n        self.poses = [self.pose]\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n\n    async def after_pose(self):\n        self.poses.append(self.pose)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_align_bottom/","title":"test_align_bottom","text":""},{"location":"reference/cogip/tools/planner/actions/test_align_bottom_banner/","title":"test_align_bottom_banner","text":""},{"location":"reference/cogip/tools/planner/actions/test_approval/","title":"test_approval","text":""},{"location":"reference/cogip/tools/planner/actions/test_back_and_forth/","title":"test_back_and_forth","text":""},{"location":"reference/cogip/tools/planner/actions/test_back_and_forth/#cogip.tools.planner.actions.test_back_and_forth.BackAndForthAction","title":"<code>BackAndForthAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Example action that generate its poses depending of the robot's pose at the beginning of the action. The robot will go from the current position to its opposite position in loop.</p> Source code in <code>cogip/tools/planner/actions/test_back_and_forth.py</code> <pre><code>class BackAndForthAction(Action):\n    \"\"\"\n    Example action that generate its poses depending of the robot's pose\n    at the beginning of the action.\n    The robot will go from the current position to its opposite position in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"BackAndForth action\", planner, actions)\n        self.before_action_func = self.compute_poses\n\n    async def compute_poses(self) -&gt; None:\n        x = self.planner.pose_current.x\n        y = self.game_context.table.y_min + self.game_context.table.y_max - self.planner.pose_current.y\n        angle = -self.planner.pose_current.O\n        pose1 = Pose(\n            x=x,\n            y=y,\n            O=angle,\n            max_speed_linear=66,\n            max_speed_angular=66,\n        )\n        pose2 = Pose(x=self.planner.pose_current.x, y=self.planner.pose_current.y, O=self.planner.pose_current.O)\n        pose1.after_pose_func = partial(self.append_pose, pose1)\n        pose2.after_pose_func = partial(self.append_pose, pose2)\n        self.poses.append(pose1)\n        self.poses.append(pose2)\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_drop_banner/","title":"test_drop_banner","text":""},{"location":"reference/cogip/tools/planner/actions/test_game_1/","title":"test_game_1","text":""},{"location":"reference/cogip/tools/planner/actions/test_game_2/","title":"test_game_2","text":""},{"location":"reference/cogip/tools/planner/actions/test_squares/","title":"test_squares","text":""},{"location":"reference/cogip/tools/planner/actions/test_squares/#cogip.tools.planner.actions.test_squares.TestSquaresAction","title":"<code>TestSquaresAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Run in square x times.</p> Source code in <code>cogip/tools/planner/actions/test_squares.py</code> <pre><code>class TestSquaresAction(Action):\n    \"\"\"\n    Run in square x times.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, *, count: int, size: int):\n        super().__init__(f\"TestSquares action x{count}\", planner, actions)\n        self.count = count\n        self.size = size\n        self.interruptable = False\n        self.before_action_func = self.before_action\n\n    async def before_action(self):\n        logger.info(f\"{self.name}: before_action\")\n        self.planner.shared_properties.avoidance_strategy = AvoidanceStrategy.Disabled.val\n        start_pose = self.pose_current\n        linear_speed = 50\n        angular_speed = 50\n\n        pose1 = Pose(\n            **get_relative_pose(\n                start_pose,\n                front_offset=self.size,\n                angular_offset=90,\n            ).model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            allow_reverse=False,\n        )\n\n        pose2 = Pose(\n            **get_relative_pose(\n                pose1,\n                front_offset=self.size,\n                angular_offset=90,\n            ).model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            allow_reverse=False,\n        )\n\n        pose3 = Pose(\n            **get_relative_pose(\n                pose2,\n                front_offset=self.size,\n                angular_offset=90,\n            ).model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            allow_reverse=False,\n        )\n\n        pose4 = Pose(\n            **start_pose.model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            allow_reverse=False,\n        )\n\n        for i in range(self.count):\n            self.poses.append(pose1)\n            self.poses.append(pose2)\n            self.poses.append(pose3)\n            self.poses.append(pose4)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_tribunes_1x2/","title":"test_tribunes_1x2","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_1x3/","title":"test_tribunes_1x3","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_2x1/","title":"test_tribunes_2x1","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_2x2/","title":"test_tribunes_2x2","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_2x3/","title":"test_tribunes_2x3","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_4x1/","title":"test_tribunes_4x1","text":""},{"location":"reference/cogip/tools/planner/actions/test_visit_starting_areas/","title":"test_visit_starting_areas","text":""},{"location":"reference/cogip/tools/planner/actions/test_visit_starting_areas/#cogip.tools.planner.actions.test_visit_starting_areas.VisitStartingAreasAction","title":"<code>VisitStartingAreasAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action that goes from the starting position to the next one.</p> Source code in <code>cogip/tools/planner/actions/test_visit_starting_areas.py</code> <pre><code>class VisitStartingAreasAction(Action):\n    \"\"\"\n    Action that goes from the starting position to the next one.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"VisitStartingAreas action\", planner, actions)\n        self.before_action_func = self.compute_poses\n\n    async def compute_poses(self) -&gt; None:\n        start_positions = [p.name for p in StartPosition if self.game_context.is_valid_start_position(p)]\n        start_positions_count = len(start_positions)\n        default_start_position_index = 0\n        for i in range(start_positions_count):\n            start_position = StartPosition((i + 1) % start_positions_count + 1)\n            if start_position.val == self.planner.shared_properties.start_position:\n                default_start_position_index = i\n            pose = self.game_context.start_poses[start_position]\n            new_pose = Pose(x=pose.x, y=pose.y, O=pose.O, max_speed_linear=66, max_speed_angular=66)\n            new_pose.after_pose_func = partial(self.append_pose, new_pose)\n            self.poses.append(new_pose)\n\n        self.poses = self.poses[default_start_position_index:] + self.poses[:default_start_position_index]\n        default_start_position = self.poses.pop(0)\n        self.poses.append(default_start_position)\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/avoidance/","title":"avoidance","text":""},{"location":"reference/cogip/tools/planner/avoidance/process/","title":"process","text":""},{"location":"reference/cogip/tools/robotcam/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/robotcam/app/","title":"app","text":""},{"location":"reference/cogip/tools/robotcam/app/#cogip.tools.robotcam.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/robotcam/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = CameraServer()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler","title":"<code>CameraHandler</code>","text":"<p>Camera handler.</p> <p>Handle camera initialization.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>class CameraHandler:\n    \"\"\"\n    Camera handler.\n\n    Handle camera initialization.\n    \"\"\"\n\n    _camera_capture: cv2.VideoCapture = None  # OpenCV video capture\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _frame_rate: float = 10  # Number of images processed by seconds\n    _exiting: bool = False  # Exit requested if True\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO client and connect to server.\n        \"\"\"\n        self.settings = Settings()\n        signal.signal(signal.SIGTERM, self.exit_handler)\n\n        self.record_filename: Path | None = None\n        self.record_writer: cv2.VideoWriter | None = None\n\n        self.sio = socketio.Client(logger=False, engineio_logger=False)\n        self.register_sio_events()\n        Thread(\n            target=lambda: polling2.poll(\n                self.sio_connect,\n                step=1,\n                ignore_exceptions=(socketio.exceptions.ConnectionError),\n                poll_forever=True,\n            )\n        ).start()\n\n    @staticmethod\n    def exit_handler(signum, frame):\n        \"\"\"\n        Function called when TERM signal is received.\n        \"\"\"\n        CameraHandler._exiting = True\n        raise ExitSignal()\n\n    def sio_connect(self) -&gt; bool:\n        \"\"\"\n        Connect to SocketIO server.\n        Returning True stops polling for connection to succeed.\n        \"\"\"\n        if self._exiting:\n            return True\n\n        self.sio.connect(\n            str(self.settings.socketio_server_url),\n            namespaces=[\"/robotcam\"],\n        )\n        return True\n\n    def open_camera(self):\n        \"\"\"\n        Initialize camera.\n        \"\"\"\n        camera_name = CameraName[self.settings.camera_name].val\n        if not camera_name.exists():\n            logger.error(f\"Camera not found: {camera_name}\")\n            return\n\n        self._camera_capture = cv2.VideoCapture(str(camera_name), cv2.CAP_V4L2)\n        if not self._camera_capture.isOpened():\n            logger.error(f\"Camera handler: Cannot open camera device {camera_name}\")\n            self._camera_capture.release()\n            self._camera_capture = None\n            return\n\n        camera_codec = VideoCodec[self.settings.camera_codec].val\n\n        fourcc = cv2.VideoWriter_fourcc(*camera_codec)\n        ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n        if not ret:\n            logger.warning(f\"Video codec {camera_codec} not supported\")\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n        if not ret:\n            logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n        if not ret:\n            logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n\n    def close_camera(self) -&gt; None:\n        \"\"\"\n        Release camera device.\n        \"\"\"\n        if self._camera_capture:\n            try:\n                self._camera_capture.release()\n                logger.info(\"Camera handler: Camera closed.\")\n            except Exception as exc:  # noqa\n                logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n        self._camera_capture = None\n\n    def open_last_frame(self, size: int) -&gt; None:\n        \"\"\"\n        Open the shared memory used to exchange last frame with the server.\n\n        Arguments:\n            size: Size of the shared memory\n        \"\"\"\n        if not self._last_frame:\n            try:\n                self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n                logger.info(\"Camera handler: shared memory for last_frame created.\")\n            except FileExistsError as exc:\n                logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n                self._last_frame = None\n\n    def close_last_frame(self) -&gt; None:\n        \"\"\"\n        Close last frame shared memory.\n        \"\"\"\n        if self._last_frame:\n            try:\n                self._last_frame.close()\n                self._last_frame.unlink()\n                logger.info(\"Camera handler: Shared memory for last frame closed.\")\n            except Exception as exc:\n                logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n        self._last_frame = None\n\n    def camera_handler(self) -&gt; None:\n        \"\"\"\n        Read and process frames from camera.\n        \"\"\"\n        interval = 1.0 / self._frame_rate\n\n        try:\n            while not self._exiting:\n                start = time.time()\n\n                if not self._camera_capture:\n                    self.open_camera()\n\n                if not self._camera_capture:\n                    logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                    sleep(1)\n                    continue\n\n                try:\n                    self.process_image()\n                except ExitSignal:\n                    break\n                except Exception as exc:\n                    logger.warning(f\"Unknown exception: {exc}\")\n                    self.close_camera()\n                    sleep(1)\n                    continue\n\n                now = time.time()\n                duration = now - start\n                if duration &gt; interval:\n                    logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n                else:\n                    wait = interval - duration\n                    time.sleep(wait)\n\n        except (KeyboardInterrupt, ExitSignal):\n            pass\n\n        logger.info(\"Camera handler: Exiting.\")\n\n        self.close_last_frame()\n        self.close_camera()\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def process_image(self) -&gt; None:\n        \"\"\"\n        Read one frame from camera, process it, send samples to cogip-server\n        and generate image to stream.\n        \"\"\"\n        image_color: np.ndarray\n        ret, image_color = self._camera_capture.read()\n        if not ret:\n            raise Exception(\"Camera handler: Cannot read frame.\")\n\n        image_stream: np.ndarray = image_color\n\n        # Encode the frame in BMP format (larger but faster than JPEG)\n        encoded_image: np.ndarray\n        ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n        if not ret:\n            raise Exception(\"Can't encode frame.\")\n\n        # frame = (b'--frame\\r\\n' b'Content-Type: image/bmp\\r\\n\\r\\n' + encoded_image.tobytes() + b'\\r\\n')\n        frame = encoded_image.tobytes()\n        self.open_last_frame(len(frame))\n\n        if self._last_frame:\n            self._last_frame.buf[0 : len(frame)] = frame\n\n        if self.record_writer:\n            self.record_writer.write(image_stream)\n\n    def start_video_record(self):\n        if self.record_writer:\n            self.stop_video_record()\n        records_dir = Path.home() / \"records\"\n        records_dir.mkdir(exist_ok=True)\n        # Keep only 20 last records\n        for old_record in sorted(records_dir.glob(\"*.mp4\"))[:-20]:\n            old_record.unlink()\n        timestamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n        self.record_filename = records_dir / f\"robot{self.settings.id}_{timestamp}.mp4\"\n\n        logger.info(f\"Start recording video in {self.record_filename}\")\n        self.record_writer = cv2.VideoWriter(\n            str(self.record_filename),\n            cv2.VideoWriter_fourcc(*\"mp4v\"),\n            self._frame_rate,\n            (self.settings.camera_width, self.settings.camera_height),\n        )\n\n    def stop_video_record(self):\n        if self.record_writer:\n            logger.info(\"Stop recording video\")\n            self.record_writer.release()\n            self.record_filename = None\n            self.record_writer = None\n\n    def register_sio_events(self) -&gt; None:\n        @self.sio.event(namespace=\"/robotcam\")\n        def connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Camera handler: connected to server\")\n            self.sio.emit(\"connected\", namespace=\"/robotcam\")\n\n        @self.sio.event(namespace=\"/robotcam\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            logger.info(\"Camera handler: connection to server failed.\")\n\n        @self.sio.event(namespace=\"/robotcam\")\n        def disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Camera handler: disconnected from server\")\n\n        @self.sio.on(\"start_video_record\", namespace=\"/robotcam\")\n        def start_video_record():\n            self.start_video_record()\n\n        @self.sio.on(\"stop_video_record\", namespace=\"/robotcam\")\n        def stop_video_record():\n            self.stop_video_record()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO client and connect to server.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO client and connect to server.\n    \"\"\"\n    self.settings = Settings()\n    signal.signal(signal.SIGTERM, self.exit_handler)\n\n    self.record_filename: Path | None = None\n    self.record_writer: cv2.VideoWriter | None = None\n\n    self.sio = socketio.Client(logger=False, engineio_logger=False)\n    self.register_sio_events()\n    Thread(\n        target=lambda: polling2.poll(\n            self.sio_connect,\n            step=1,\n            ignore_exceptions=(socketio.exceptions.ConnectionError),\n            poll_forever=True,\n        )\n    ).start()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.camera_handler","title":"<code>camera_handler()</code>","text":"<p>Read and process frames from camera.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def camera_handler(self) -&gt; None:\n    \"\"\"\n    Read and process frames from camera.\n    \"\"\"\n    interval = 1.0 / self._frame_rate\n\n    try:\n        while not self._exiting:\n            start = time.time()\n\n            if not self._camera_capture:\n                self.open_camera()\n\n            if not self._camera_capture:\n                logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                sleep(1)\n                continue\n\n            try:\n                self.process_image()\n            except ExitSignal:\n                break\n            except Exception as exc:\n                logger.warning(f\"Unknown exception: {exc}\")\n                self.close_camera()\n                sleep(1)\n                continue\n\n            now = time.time()\n            duration = now - start\n            if duration &gt; interval:\n                logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n            else:\n                wait = interval - duration\n                time.sleep(wait)\n\n    except (KeyboardInterrupt, ExitSignal):\n        pass\n\n    logger.info(\"Camera handler: Exiting.\")\n\n    self.close_last_frame()\n    self.close_camera()\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.close_camera","title":"<code>close_camera()</code>","text":"<p>Release camera device.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def close_camera(self) -&gt; None:\n    \"\"\"\n    Release camera device.\n    \"\"\"\n    if self._camera_capture:\n        try:\n            self._camera_capture.release()\n            logger.info(\"Camera handler: Camera closed.\")\n        except Exception as exc:  # noqa\n            logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n    self._camera_capture = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.close_last_frame","title":"<code>close_last_frame()</code>","text":"<p>Close last frame shared memory.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def close_last_frame(self) -&gt; None:\n    \"\"\"\n    Close last frame shared memory.\n    \"\"\"\n    if self._last_frame:\n        try:\n            self._last_frame.close()\n            self._last_frame.unlink()\n            logger.info(\"Camera handler: Shared memory for last frame closed.\")\n        except Exception as exc:\n            logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n    self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.exit_handler","title":"<code>exit_handler(signum, frame)</code>  <code>staticmethod</code>","text":"<p>Function called when TERM signal is received.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>@staticmethod\ndef exit_handler(signum, frame):\n    \"\"\"\n    Function called when TERM signal is received.\n    \"\"\"\n    CameraHandler._exiting = True\n    raise ExitSignal()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.open_camera","title":"<code>open_camera()</code>","text":"<p>Initialize camera.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def open_camera(self):\n    \"\"\"\n    Initialize camera.\n    \"\"\"\n    camera_name = CameraName[self.settings.camera_name].val\n    if not camera_name.exists():\n        logger.error(f\"Camera not found: {camera_name}\")\n        return\n\n    self._camera_capture = cv2.VideoCapture(str(camera_name), cv2.CAP_V4L2)\n    if not self._camera_capture.isOpened():\n        logger.error(f\"Camera handler: Cannot open camera device {camera_name}\")\n        self._camera_capture.release()\n        self._camera_capture = None\n        return\n\n    camera_codec = VideoCodec[self.settings.camera_codec].val\n\n    fourcc = cv2.VideoWriter_fourcc(*camera_codec)\n    ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {camera_codec} not supported\")\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.open_last_frame","title":"<code>open_last_frame(size)</code>","text":"<p>Open the shared memory used to exchange last frame with the server.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the shared memory</p> required Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def open_last_frame(self, size: int) -&gt; None:\n    \"\"\"\n    Open the shared memory used to exchange last frame with the server.\n\n    Arguments:\n        size: Size of the shared memory\n    \"\"\"\n    if not self._last_frame:\n        try:\n            self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n            logger.info(\"Camera handler: shared memory for last_frame created.\")\n        except FileExistsError as exc:\n            logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n            self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.process_image","title":"<code>process_image()</code>","text":"<p>Read one frame from camera, process it, send samples to cogip-server and generate image to stream.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def process_image(self) -&gt; None:\n    \"\"\"\n    Read one frame from camera, process it, send samples to cogip-server\n    and generate image to stream.\n    \"\"\"\n    image_color: np.ndarray\n    ret, image_color = self._camera_capture.read()\n    if not ret:\n        raise Exception(\"Camera handler: Cannot read frame.\")\n\n    image_stream: np.ndarray = image_color\n\n    # Encode the frame in BMP format (larger but faster than JPEG)\n    encoded_image: np.ndarray\n    ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n    if not ret:\n        raise Exception(\"Can't encode frame.\")\n\n    # frame = (b'--frame\\r\\n' b'Content-Type: image/bmp\\r\\n\\r\\n' + encoded_image.tobytes() + b'\\r\\n')\n    frame = encoded_image.tobytes()\n    self.open_last_frame(len(frame))\n\n    if self._last_frame:\n        self._last_frame.buf[0 : len(frame)] = frame\n\n    if self.record_writer:\n        self.record_writer.write(image_stream)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.sio_connect","title":"<code>sio_connect()</code>","text":"<p>Connect to SocketIO server. Returning True stops polling for connection to succeed.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def sio_connect(self) -&gt; bool:\n    \"\"\"\n    Connect to SocketIO server.\n    Returning True stops polling for connection to succeed.\n    \"\"\"\n    if self._exiting:\n        return True\n\n    self.sio.connect(\n        str(self.settings.socketio_server_url),\n        namespaces=[\"/robotcam\"],\n    )\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/main/","title":"main","text":""},{"location":"reference/cogip/tools/robotcam/main/#cogip.tools.robotcam.main.main","title":"<code>main()</code>","text":"<p>Launch COGIP Robot Camera.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-robotcam</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/robotcam/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Launch COGIP Robot Camera.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-robotcam` script using this function as entrypoint.\n    \"\"\"\n    settings = Settings()\n\n    # Start Camera handler process\n    p = Process(target=start_camera_handler)\n    p.start()\n\n    # Start web server\n    uvicorn.run(\n        \"cogip.tools.robotcam.app:app\",\n        host=\"0.0.0.0\",\n        port=8100 + settings.id,\n        workers=settings.nb_workers,\n        log_level=\"warning\",\n    )\n\n    p.terminate()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/","title":"server","text":""},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer","title":"<code>CameraServer</code>","text":"<p>Camera web server.</p> <p>Handle FastAPI server to stream camera video and SocketIO client to send detected samples to server.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>class CameraServer:\n    \"\"\"\n    Camera web server.\n\n    Handle FastAPI server to stream camera video and SocketIO client to send detected samples to server.\n    \"\"\"\n\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application and SocketIO client.\n        \"\"\"\n        self.settings = Settings()\n        CameraServer._exiting = False\n\n        self.app = FastAPI(title=\"COGIP Robot Camera Streamer\", debug=False)\n        self.register_endpoints()\n\n        UvicornServer.handle_exit = self.handle_exit\n\n        self.records_dir = Path.home() / \"records\"\n        self.records_dir.mkdir(exist_ok=True)\n        # Keep only 100 last records\n        for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n            old_record.unlink()\n\n        # Load camera intrinsic parameters\n        self.camera_matrix: cv2.typing.MatLike | None = None\n        self.dist_coefs: cv2.typing.MatLike | None = None\n        if self.settings.camera_intrinsic_params:\n            params_filename = self.settings.camera_intrinsic_params\n        else:\n            params_filename = get_camera_intrinsic_params_filename(\n                self.settings.id,\n                CameraName[self.settings.camera_name],\n                VideoCodec[self.settings.camera_codec],\n                self.settings.camera_width,\n                self.settings.camera_height,\n            )\n\n        if not params_filename.exists():\n            logger.warning(f\"Camera intrinsic parameters file not found: {params_filename}\")\n        else:\n            self.camera_matrix, self.dist_coefs = load_camera_intrinsic_params(params_filename)\n\n        # Load camera extrinsic parameters\n        self.extrinsic_params: CameraExtrinsicParameters | None = None\n        if self.settings.camera_extrinsic_params:\n            params_filename = self.settings.camera_extrinsic_params\n        else:\n            params_filename = get_camera_extrinsic_params_filename(\n                self.settings.id,\n                CameraName[self.settings.camera_name],\n                VideoCodec[self.settings.camera_codec],\n                self.settings.camera_width,\n                self.settings.camera_height,\n            )\n\n        if not params_filename.exists():\n            logger.warning(f\"Camera extrinsic parameters file not found: {params_filename}\")\n        else:\n            self.extrinsic_params = load_camera_extrinsic_params(params_filename)\n\n        self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n        self.parameters = cv2.aruco.DetectorParameters()\n        self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.parameters)\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        CameraServer._exiting = True\n\n        if CameraServer._last_frame:\n            try:\n                CameraServer._last_frame.close()\n                logger.info(\"Camera server: Detached shared memory for last frame.\")\n            except FileNotFoundError:\n                pass\n\n        CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def camera_connect(self) -&gt; bool:\n        if self._exiting:\n            return True\n\n        try:\n            CameraServer._last_frame = SharedMemory(name=\"last_frame\")\n        except Exception:\n            CameraServer._last_frame = None\n            logger.warning(\"Camera server: Failed to attach to shared memory last_frame, retrying in 1s.\")\n            return False\n        logger.info(\"Camera server: Attached to shared memory last_frame.\")\n        return True\n\n    async def camera_streamer(self):\n        \"\"\"\n        Frame generator.\n        Yield frames produced by [camera_handler][cogip.tools.robotcam.camera.CameraHandler.camera_handler].\n        \"\"\"\n        while not self._exiting:\n            yield b\"--frame\\r\\n\"\n            yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n            yield bytes(self._last_frame.buf)\n            yield b\"\\r\\n\"\n\n    def register_endpoints(self) -&gt; None:\n        @self.app.on_event(\"startup\")\n        async def startup_event():\n            \"\"\"\n            Function called at FastAPI server startup.\n            \"\"\"\n            # Poll in background to wait for camera server connection through shared memory.\n            Thread(\n                target=lambda: polling2.poll(\n                    self.camera_connect,\n                    step=1,\n                    poll_forever=True,\n                )\n            ).start()\n\n        @self.app.on_event(\"shutdown\")\n        async def shutdown_event():\n            \"\"\"\n            Function called at FastAPI server shutdown.\n            \"\"\"\n            pass\n\n        @self.app.get(\"/\")\n        def index():\n            \"\"\"\n            Camera stream.\n            \"\"\"\n            stream = self.camera_streamer() if CameraServer._last_frame else \"\"\n            return StreamingResponse(stream, media_type=\"multipart/x-mixed-replace;boundary=frame\")\n\n        @self.app.get(\"/snapshot\", status_code=200)\n        async def snapshot():\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-snapshot\"\n\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n        @self.app.get(\"/camera_calibration\", status_code=200)\n        async def camera_calibration(x: float, y: float, angle: float) -&gt; Vertex:\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-calibration\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                raise HTTPException(status_code=404, detail=\"No marker found\")\n\n            robot_pose = Pose(x=x, y=y, O=angle)\n\n            # Keep table markers only\n            table_markers = {\n                id[0]: corners for id, corners in zip(marker_ids, marker_corners) if id[0] in [20, 21, 22, 23]\n            }\n\n            if len(table_markers) == 0:\n                raise HTTPException(status_code=404, detail=\"No table marker found\")\n\n            # Compute camera position on table\n            table_camera_tvec, table_camera_angle = get_camera_position_on_table(\n                table_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n            )\n\n            # Compute camera position in robot if robot position is given\n            camera_position = get_camera_position_in_robot(\n                robot_pose,\n                table_camera_tvec,\n                table_camera_angle,\n            )\n\n            return camera_position\n\n        @self.app.get(\"/solar_panels\", status_code=200)\n        async def solar_panels(x: float, y: float, angle: float) -&gt; dict[int, float]:\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, rejected = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-panels\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                return {}\n\n            robot_pose = Pose(x=x, y=y, O=angle)\n\n            # Keep solar panel markers only\n            solar_panel_markers = [corners for id, corners in zip(marker_ids, marker_corners) if id[0] == 47]\n\n            if len(solar_panel_markers) == 0:\n                return {}\n\n            panels = get_solar_panel_positions(\n                solar_panel_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n                self.extrinsic_params,\n                robot_pose,\n            )\n\n            return panels\n\n        @self.app.get(\"/robot_position\", status_code=200)\n        async def robot_position() -&gt; Pose:\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-position\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                raise HTTPException(status_code=404, detail=\"No marker found\")\n\n            # Keep table markers only\n            table_markers = {\n                id[0]: corners for id, corners in zip(marker_ids, marker_corners) if id[0] in [20, 21, 22, 23]\n            }\n\n            if len(table_markers) == 0:\n                raise HTTPException(status_code=404, detail=\"No table marker found\")\n\n            # Compute camera position on table\n            camera_tvec, camera_angle = get_camera_position_on_table(\n                table_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n            )\n\n            # Compute robot position on table\n            delta_tvec = np.array([self.extrinsic_params.x, self.extrinsic_params.y])\n            camera_tvec_rotated = rotate_2d(camera_tvec[0:2], -camera_angle)\n            robot_tvec_rotated = camera_tvec_rotated + delta_tvec\n            robot_tvec = rotate_2d(robot_tvec_rotated, camera_angle)\n            camera_angle_degrees = np.rad2deg(camera_angle)\n            logger.info(\n                \"Robot position: \"\n                f\"X={robot_tvec[0]:.0f} Y={robot_tvec[1]:.0f} Z={camera_tvec[2]:.0f} Angle={camera_angle_degrees:.0f}\"\n            )\n            return Pose(x=robot_tvec[0], y=robot_tvec[1], z=camera_tvec[2], O=camera_angle_degrees)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application and SocketIO client.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application and SocketIO client.\n    \"\"\"\n    self.settings = Settings()\n    CameraServer._exiting = False\n\n    self.app = FastAPI(title=\"COGIP Robot Camera Streamer\", debug=False)\n    self.register_endpoints()\n\n    UvicornServer.handle_exit = self.handle_exit\n\n    self.records_dir = Path.home() / \"records\"\n    self.records_dir.mkdir(exist_ok=True)\n    # Keep only 100 last records\n    for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n        old_record.unlink()\n\n    # Load camera intrinsic parameters\n    self.camera_matrix: cv2.typing.MatLike | None = None\n    self.dist_coefs: cv2.typing.MatLike | None = None\n    if self.settings.camera_intrinsic_params:\n        params_filename = self.settings.camera_intrinsic_params\n    else:\n        params_filename = get_camera_intrinsic_params_filename(\n            self.settings.id,\n            CameraName[self.settings.camera_name],\n            VideoCodec[self.settings.camera_codec],\n            self.settings.camera_width,\n            self.settings.camera_height,\n        )\n\n    if not params_filename.exists():\n        logger.warning(f\"Camera intrinsic parameters file not found: {params_filename}\")\n    else:\n        self.camera_matrix, self.dist_coefs = load_camera_intrinsic_params(params_filename)\n\n    # Load camera extrinsic parameters\n    self.extrinsic_params: CameraExtrinsicParameters | None = None\n    if self.settings.camera_extrinsic_params:\n        params_filename = self.settings.camera_extrinsic_params\n    else:\n        params_filename = get_camera_extrinsic_params_filename(\n            self.settings.id,\n            CameraName[self.settings.camera_name],\n            VideoCodec[self.settings.camera_codec],\n            self.settings.camera_width,\n            self.settings.camera_height,\n        )\n\n    if not params_filename.exists():\n        logger.warning(f\"Camera extrinsic parameters file not found: {params_filename}\")\n    else:\n        self.extrinsic_params = load_camera_extrinsic_params(params_filename)\n\n    self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n    self.parameters = cv2.aruco.DetectorParameters()\n    self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.parameters)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.camera_streamer","title":"<code>camera_streamer()</code>  <code>async</code>","text":"<p>Frame generator. Yield frames produced by camera_handler.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>async def camera_streamer(self):\n    \"\"\"\n    Frame generator.\n    Yield frames produced by [camera_handler][cogip.tools.robotcam.camera.CameraHandler.camera_handler].\n    \"\"\"\n    while not self._exiting:\n        yield b\"--frame\\r\\n\"\n        yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n        yield bytes(self._last_frame.buf)\n        yield b\"\\r\\n\"\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    CameraServer._exiting = True\n\n    if CameraServer._last_frame:\n        try:\n            CameraServer._last_frame.close()\n            logger.info(\"Camera server: Detached shared memory for last frame.\")\n        except FileNotFoundError:\n            pass\n\n    CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/settings/","title":"settings","text":""},{"location":"reference/cogip/tools/scservo/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/scservo/__main__/#cogip.tools.scservo.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SCServo Tools.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-scservo</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/scservo/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SCServo Tools.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-scservo` script using this function as entrypoint.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"reference/cogip/tools/scservo/common/","title":"common","text":""},{"location":"reference/cogip/tools/scservo/ping/","title":"ping","text":""},{"location":"reference/cogip/tools/scservo/read/","title":"read","text":""},{"location":"reference/cogip/tools/scservo/reg_write/","title":"reg_write","text":""},{"location":"reference/cogip/tools/scservo/sync_write/","title":"sync_write","text":""},{"location":"reference/cogip/tools/scservo/wheel/","title":"wheel","text":""},{"location":"reference/cogip/tools/scservo/write/","title":"write","text":""},{"location":"reference/cogip/tools/server/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/server/__main__/#cogip.tools.server.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SocketIO/Web server.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-server</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/server/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SocketIO/Web server.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-server` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/server/app/","title":"app","text":""},{"location":"reference/cogip/tools/server/app/#cogip.tools.server.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return ASGIApp application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/server/app.py</code> <pre><code>def create_app() -&gt; ASGIApp:\n    \"\"\"\n    Create server and return ASGIApp application for uvicorn/gunicorn.\n    \"\"\"\n    server = Server()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/server/context/","title":"context","text":""},{"location":"reference/cogip/tools/server/context/#cogip.tools.server.context.Context","title":"<code>Context</code>  <code>dataclass</code>","text":"<p>Server context class recording variables using in multiple namespaces.</p> <p>Attributes:</p> Name Type Description <code>robot_id</code> <code>int | None</code> <p>Robot ID</p> <code>planner_sid</code> <code>str | None</code> <p>Planner sid</p> <code>copilot_sid</code> <code>str | None</code> <p>Copilot sid</p> <code>detector_sid</code> <code>str | None</code> <p>Detector sid</p> <code>robotcam_sid</code> <code>str | None</code> <p>Robotcam sid</p> <code>beacon_sid</code> <code>str | None</code> <p>Beacon server sid</p> <code>monitor_sid</code> <code>str | None</code> <p>Monitor sid</p> <code>tool_menus</code> <code>dict[str, ShellMenu]</code> <p>all registered tool menus</p> <code>current_tool_menu</code> <code>str | None</code> <p>name of the currently selected tool menu</p> <code>shell_menu</code> <code>ShellMenu | None</code> <p>last received shell menu</p> <code>virtual</code> <p>Whether robot is virtual or not</p> <code>virtual_planner</code> <p>Whether planner is virtual or not</p> <code>virtual_detector</code> <p>Whether detector is virtual or not</p> Source code in <code>cogip/tools/server/context.py</code> <pre><code>@dataclass\nclass Context(metaclass=Singleton):\n    \"\"\"\n    Server context class recording variables using in multiple namespaces.\n\n    Attributes:\n        robot_id:           Robot ID\n        planner_sid:        Planner sid\n        copilot_sid:        Copilot sid\n        detector_sid:       Detector sid\n        robotcam_sid:       Robotcam sid\n        beacon_sid:         Beacon server sid\n        monitor_sid:        Monitor sid\n        tool_menus:         all registered tool menus\n        current_tool_menu:  name of the currently selected tool menu\n        shell_menu:         last received shell menu\n        virtual:            Whether robot is virtual or not\n        virtual_planner:    Whether planner is virtual or not\n        virtual_detector:   Whether detector is virtual or not\n    \"\"\"\n\n    robot_id: int | None = None\n    planner_sid: str | None = None\n    copilot_sid: str | None = None\n    detector_sid: str | None = None\n    robotcam_sid: str | None = None\n    beacon_sid: str | None = None\n    monitor_sid: str | None = None\n    tool_menus: dict[str, models.ShellMenu] = field(default_factory=dict)\n    current_tool_menu: str | None = None\n    shell_menu: models.ShellMenu | None = None\n    virtual = platform.machine() != \"aarch64\"\n    virtual_planner = False\n    virtual_detector = False\n</code></pre>"},{"location":"reference/cogip/tools/server/server/","title":"server","text":""},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server","title":"<code>Server</code>","text":"Source code in <code>cogip/tools/server/server.py</code> <pre><code>class Server:\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit  # Backup of original exit handler to overload it\n    _shared_memory: SharedMemory | None = None  # Shared memory instance\n    _shared_pose_current_buffer: SharedPoseBuffer | None = None\n    _shared_circle_obstacles: SharedObstacleCircleList | None = None\n    _shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n    _shared_avoidance_path: SharedPoseOrderList | None = None\n    _shared_avoidance_path_lock: WritePriorityLock | None = None\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Server._shared_avoidance_path = None\n        Server._shared_avoidance_path_lock = None\n        Server._shared_rectangle_obstacles = None\n        Server._shared_circle_obstacles = None\n        Server._shared_pose_current_buffer = None\n        Server._shared_memory = None\n        Server._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO server.\n        \"\"\"\n        self.context = context.Context()\n        self.context.robot_id = int(os.environ[\"ROBOT_ID\"])\n        self.root_menu = models.ShellMenu(name=\"Root Menu\", entries=[])\n        self.context.tool_menus[\"root\"] = self.root_menu\n        self.context.current_tool_menu = \"root\"\n        self.dashboard_updater_loop = AsyncLoop(\n            \"Dashboard updater loop\",\n            float(os.getenv(\"SERVER_DASHBOARD_UPDATE_INTERVAL\", 0.2)),\n            self.update_dashboard,\n        )\n\n        if Server._shared_memory is None:\n            Server._shared_memory = SharedMemory(f\"cogip_{self.context.robot_id}\", owner=True)\n            Server._shared_pose_current_buffer = Server._shared_memory.get_pose_current_buffer()\n            Server._shared_circle_obstacles = Server._shared_memory.get_circle_obstacles()\n            Server._shared_rectangle_obstacles = Server._shared_memory.get_rectangle_obstacles()\n            Server._shared_avoidance_path = Server._shared_memory.get_avoidance_path()\n            Server._shared_avoidance_path_lock = Server._shared_memory.get_lock(LockName.AvoidancePath)\n            Server._shared_avoidance_path_lock.register_consumer()\n\n        self.sio = socketio.AsyncServer(\n            always_connect=False,\n            async_mode=\"asgi\",\n            cors_allowed_origins=\"*\",\n            logger=False,\n            engineio_logger=False,\n        )\n        self.app = socketio.ASGIApp(self.sio)\n        self.sio.register_namespace(namespaces.DashboardNamespace(self))\n        self.sio.register_namespace(namespaces.MonitorNamespace(self))\n        self.sio.register_namespace(namespaces.CopilotNamespace(self))\n        self.sio.register_namespace(namespaces.DetectorNamespace(self))\n        self.sio.register_namespace(namespaces.PlannerNamespace(self))\n        self.sio.register_namespace(namespaces.RobotcamNamespace(self))\n        self.sio.register_namespace(namespaces.BeaconNamespace(self))\n\n        self.dashboard_updater_loop.start()\n\n        self.new_path_event_task = asyncio.create_task(\n            self.new_path_event_loop(),\n            name=\"Server: Task New Path Event Watcher Loop\",\n        )\n\n        # Overload default Uvicorn exit handler\n        UvicornServer.handle_exit = Server.handle_exit\n\n        @self.sio.event\n        def connect(sid, environ, auth):\n            logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n            raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n        @self.sio.on(\"*\")\n        def catch_all(event, sid, data):\n            logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n\n    async def register_menu(self, namespace: str, data: dict[str, Any]) -&gt; None:\n        if not (name := data.get(\"name\")):\n            logger.warning(f\"register_menu: missing 'name' in data: {data}\")\n            return\n        if not (menu_dict := data.get(\"menu\")):\n            logger.warning(f\"register_menu: missing 'menu' in data: {data}\")\n            return\n        try:\n            menu = models.ShellMenu.model_validate(menu_dict)\n        except ValidationError as exc:\n            logger.warning(f\"register_menu: cannot validate 'menu': {exc}\")\n            return\n\n        ns_name = f\"{namespace}/{name}\"\n        entry = models.MenuEntry(cmd=ns_name, desc=f\"{menu.name} Menu\")\n        if ns_name not in self.context.tool_menus:\n            self.root_menu.entries.append(entry)\n        exit_entry = models.MenuEntry(cmd=\"exit\", desc=\"Exit Menu\")\n        menu.entries.append(exit_entry)\n        self.context.tool_menus[ns_name] = menu\n        await self.sio.emit(\n            \"tool_menu\",\n            self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n            namespace=\"/dashboard\",\n        )\n\n    async def update_dashboard(self):\n        shared_pose_current = Server._shared_pose_current_buffer.last\n        pose_current = {\n            \"x\": shared_pose_current.x,\n            \"y\": shared_pose_current.y,\n            \"O\": shared_pose_current.angle,\n        }\n        await self.sio.emit(\"pose_current\", (self.context.robot_id, pose_current), namespace=\"/dashboard\")\n        obstacles = []\n        obstacles += [\n            {\n                \"x\": obstacle.center.x,\n                \"y\": obstacle.center.y,\n                \"angle\": 0,\n                \"radius\": obstacle.radius,\n                \"bounding_box\": [{\"x\": p.x, \"y\": p.y} for p in obstacle.bounding_box],\n                \"id\": obstacle.id,\n            }\n            for obstacle in Server._shared_circle_obstacles\n        ]\n        obstacles += [\n            {\n                \"x\": obstacle.center.x,\n                \"y\": obstacle.center.y,\n                \"angle\": obstacle.center.angle,\n                \"length_x\": obstacle.length_x,\n                \"length_y\": obstacle.length_y,\n                \"bounding_box\": [{\"x\": p.x, \"y\": p.y} for p in obstacle.bounding_box],\n                \"id\": obstacle.id,\n            }\n            for obstacle in Server._shared_rectangle_obstacles\n        ]\n        await self.sio.emit(\"obstacles\", (self.context.robot_id, obstacles), namespace=\"/dashboard\")\n\n    async def new_path_event_loop(self):\n        logger.info(\"Server: Task New Path Event Watcher Loop started\")\n        try:\n            while True:\n                await asyncio.to_thread(Server._shared_avoidance_path_lock.wait_update)\n                shared_pose_current = Server._shared_pose_current_buffer.last\n                path = [{\"x\": shared_pose_current.x, \"y\": shared_pose_current.y, \"O\": shared_pose_current.angle}]\n                for pose in Server._shared_avoidance_path:\n                    path.append({\"x\": pose.x, \"y\": pose.y, \"O\": pose.angle})\n                if len(path) &gt; 1:\n                    await self.sio.emit(\"pose_order\", (self.context.robot_id, path[1]), namespace=\"/dashboard\")\n                    await self.sio.emit(\"path\", (self.context.robot_id, path), namespace=\"/dashboard\")\n        except asyncio.CancelledError:\n            logger.info(\"Server: Task New Path Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Server: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO server.</p> Source code in <code>cogip/tools/server/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO server.\n    \"\"\"\n    self.context = context.Context()\n    self.context.robot_id = int(os.environ[\"ROBOT_ID\"])\n    self.root_menu = models.ShellMenu(name=\"Root Menu\", entries=[])\n    self.context.tool_menus[\"root\"] = self.root_menu\n    self.context.current_tool_menu = \"root\"\n    self.dashboard_updater_loop = AsyncLoop(\n        \"Dashboard updater loop\",\n        float(os.getenv(\"SERVER_DASHBOARD_UPDATE_INTERVAL\", 0.2)),\n        self.update_dashboard,\n    )\n\n    if Server._shared_memory is None:\n        Server._shared_memory = SharedMemory(f\"cogip_{self.context.robot_id}\", owner=True)\n        Server._shared_pose_current_buffer = Server._shared_memory.get_pose_current_buffer()\n        Server._shared_circle_obstacles = Server._shared_memory.get_circle_obstacles()\n        Server._shared_rectangle_obstacles = Server._shared_memory.get_rectangle_obstacles()\n        Server._shared_avoidance_path = Server._shared_memory.get_avoidance_path()\n        Server._shared_avoidance_path_lock = Server._shared_memory.get_lock(LockName.AvoidancePath)\n        Server._shared_avoidance_path_lock.register_consumer()\n\n    self.sio = socketio.AsyncServer(\n        always_connect=False,\n        async_mode=\"asgi\",\n        cors_allowed_origins=\"*\",\n        logger=False,\n        engineio_logger=False,\n    )\n    self.app = socketio.ASGIApp(self.sio)\n    self.sio.register_namespace(namespaces.DashboardNamespace(self))\n    self.sio.register_namespace(namespaces.MonitorNamespace(self))\n    self.sio.register_namespace(namespaces.CopilotNamespace(self))\n    self.sio.register_namespace(namespaces.DetectorNamespace(self))\n    self.sio.register_namespace(namespaces.PlannerNamespace(self))\n    self.sio.register_namespace(namespaces.RobotcamNamespace(self))\n    self.sio.register_namespace(namespaces.BeaconNamespace(self))\n\n    self.dashboard_updater_loop.start()\n\n    self.new_path_event_task = asyncio.create_task(\n        self.new_path_event_loop(),\n        name=\"Server: Task New Path Event Watcher Loop\",\n    )\n\n    # Overload default Uvicorn exit handler\n    UvicornServer.handle_exit = Server.handle_exit\n\n    @self.sio.event\n    def connect(sid, environ, auth):\n        logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n        raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n    @self.sio.on(\"*\")\n    def catch_all(event, sid, data):\n        logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n</code></pre>"},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/server/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Server._shared_avoidance_path = None\n    Server._shared_avoidance_path_lock = None\n    Server._shared_rectangle_obstacles = None\n    Server._shared_circle_obstacles = None\n    Server._shared_pose_current_buffer = None\n    Server._shared_memory = None\n    Server._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace","title":"<code>BeaconNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to beacon server.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>class BeaconNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to beacon server.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/beacon\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        if self.context.beacon_sid:\n            message = \"A beacon server is already connected\"\n            logger.error(f\"Beacon verser connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.beacon_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Beacon connected.\")\n\n    def on_disconnect(self, sid):\n        self.context.beacon_sid = None\n        logger.info(\"Beacon disconnected.\")\n\n    async def on_reset(self, sid):\n        \"\"\"\n        Callback on reset message.\n        \"\"\"\n        logger.info(\"[beacon =&gt; planner] reset.\")\n        await self.emit(\"reset\", namespace=\"/planner\")\n\n    async def on_command(self, sid, cmd, *args):\n        \"\"\"\n        Callback on command.\n        \"\"\"\n        logger.info(f\"[beacon =&gt; planner] Command: {cmd}\")\n        await self.emit(\"command\", (cmd, *args), namespace=\"/planner\")\n\n    async def on_wizard(self, sid, message):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        await self.emit(\"wizard\", message, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_command","title":"<code>on_command(sid, cmd, *args)</code>  <code>async</code>","text":"<p>Callback on command.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_command(self, sid, cmd, *args):\n    \"\"\"\n    Callback on command.\n    \"\"\"\n    logger.info(f\"[beacon =&gt; planner] Command: {cmd}\")\n    await self.emit(\"command\", (cmd, *args), namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_reset","title":"<code>on_reset(sid)</code>  <code>async</code>","text":"<p>Callback on reset message.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_reset(self, sid):\n    \"\"\"\n    Callback on reset message.\n    \"\"\"\n    logger.info(\"[beacon =&gt; planner] reset.\")\n    await self.emit(\"reset\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_wizard","title":"<code>on_wizard(sid, message)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_wizard(self, sid, message):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    await self.emit(\"wizard\", message, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace","title":"<code>CopilotNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to copilot.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>class CopilotNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to copilot.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/copilot\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.copilot_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.copilot_sid:\n            message = \"A copilot is already connected\"\n            logger.error(f\"Copilot connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n\n    async def on_connected(self, sid):\n        logger.info(\"Copilot connected.\")\n        self.context.copilot_sid = sid\n        if self.context.planner_sid:\n            await self.emit(\"copilot_connected\", namespace=\"/planner\")\n\n    async def on_disconnect(self, sid):\n        self.context.copilot_sid = None\n        self.context.shell_menu = None\n        await self.emit(\"copilot_disconnected\", namespace=\"/planner\")\n        logger.info(\"Copilot disconnected.\")\n\n    async def on_reset(self, sid) -&gt; None:\n        \"\"\"\n        Callback on reset event.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] reset.\")\n        await self.emit(\"reset\", namespace=\"/planner\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"copilot\", data)\n\n    async def on_pose_reached(self, sid) -&gt; None:\n        \"\"\"\n        Callback on pose reached message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Pose reached.\")\n        await self.emit(\"pose_reached\", namespace=\"/planner\")\n\n    async def on_intermediate_pose_reached(self, sid) -&gt; None:\n        \"\"\"\n        Callback on intermediate pose reached message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Intermediate pose reached.\")\n        await self.emit(\"intermediate_pose_reached\", namespace=\"/planner\")\n\n    async def on_blocked(self, sid) -&gt; None:\n        \"\"\"\n        Callback on blocked message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Blocked.\")\n        await self.emit(\"blocked\", namespace=\"/planner\")\n\n    async def on_menu(self, sid, menu):\n        \"\"\"\n        Callback on menu event.\n        \"\"\"\n        self.context.shell_menu = models.ShellMenu.model_validate(menu)\n        await self.emit(\"shell_menu\", (self.context.robot_id, menu), namespace=\"/dashboard\")\n\n    async def on_state(self, sid, state):\n        \"\"\"\n        Callback on state event.\n        \"\"\"\n        await self.emit(\"state\", (self.context.robot_id, state), namespace=\"/dashboard\")\n\n    async def on_actuator_state(self, sid, actuator_state: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        await self.emit(\"actuator_state\", actuator_state, namespace=\"/planner\")\n        await self.emit(\"actuator_state\", actuator_state, namespace=\"/dashboard\")\n\n    async def on_pid(self, sid, pid: dict[str, Any]):\n        \"\"\"\n        Callback on pid message.\n        \"\"\"\n        await self.emit(\"pid\", pid, namespace=\"/dashboard\")\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n\n    async def on_game_end(self, sid) -&gt; None:\n        \"\"\"\n        Callback on game end message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Game end.\")\n        await self.emit(\"game_end\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_actuator_state","title":"<code>on_actuator_state(sid, actuator_state)</code>  <code>async</code>","text":"<p>Callback on actuator_state message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_actuator_state(self, sid, actuator_state: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_state message.\n    \"\"\"\n    await self.emit(\"actuator_state\", actuator_state, namespace=\"/planner\")\n    await self.emit(\"actuator_state\", actuator_state, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_blocked","title":"<code>on_blocked(sid)</code>  <code>async</code>","text":"<p>Callback on blocked message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_blocked(self, sid) -&gt; None:\n    \"\"\"\n    Callback on blocked message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Blocked.\")\n    await self.emit(\"blocked\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_game_end","title":"<code>on_game_end(sid)</code>  <code>async</code>","text":"<p>Callback on game end message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_game_end(self, sid) -&gt; None:\n    \"\"\"\n    Callback on game end message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Game end.\")\n    await self.emit(\"game_end\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_intermediate_pose_reached","title":"<code>on_intermediate_pose_reached(sid)</code>  <code>async</code>","text":"<p>Callback on intermediate pose reached message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_intermediate_pose_reached(self, sid) -&gt; None:\n    \"\"\"\n    Callback on intermediate pose reached message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Intermediate pose reached.\")\n    await self.emit(\"intermediate_pose_reached\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_menu","title":"<code>on_menu(sid, menu)</code>  <code>async</code>","text":"<p>Callback on menu event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_menu(self, sid, menu):\n    \"\"\"\n    Callback on menu event.\n    \"\"\"\n    self.context.shell_menu = models.ShellMenu.model_validate(menu)\n    await self.emit(\"shell_menu\", (self.context.robot_id, menu), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pid","title":"<code>on_pid(sid, pid)</code>  <code>async</code>","text":"<p>Callback on pid message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pid(self, sid, pid: dict[str, Any]):\n    \"\"\"\n    Callback on pid message.\n    \"\"\"\n    await self.emit(\"pid\", pid, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pose_reached","title":"<code>on_pose_reached(sid)</code>  <code>async</code>","text":"<p>Callback on pose reached message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pose_reached(self, sid) -&gt; None:\n    \"\"\"\n    Callback on pose reached message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Pose reached.\")\n    await self.emit(\"pose_reached\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"copilot\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_reset","title":"<code>on_reset(sid)</code>  <code>async</code>","text":"<p>Callback on reset event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_reset(self, sid) -&gt; None:\n    \"\"\"\n    Callback on reset event.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] reset.\")\n    await self.emit(\"reset\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_state","title":"<code>on_state(sid, state)</code>  <code>async</code>","text":"<p>Callback on state event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_state(self, sid, state):\n    \"\"\"\n    Callback on state event.\n    \"\"\"\n    await self.emit(\"state\", (self.context.robot_id, state), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace","title":"<code>DashboardNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to dashboards.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>class DashboardNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to dashboards.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/dashboard\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(\"Dashboard connected.\")\n        await self.emit(\"tool_menu\", self.context.tool_menus[self.context.current_tool_menu].model_dump(), to=sid)\n\n        if self.context.shell_menu:\n            await self.emit(\"shell_menu\", (self.context.robot_id, self.context.shell_menu.model_dump()), to=sid)\n\n        if self.context.virtual_planner:\n            await self.emit(\"virtual\", (self.context.robot_id, self.context.virtual), to=sid)\n\n    def on_disconnect(self, sid):\n        logger.info(\"Dashboard disconnected.\")\n\n    async def on_tool_cmd(self, sid, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on tool command message from dashboard.\n        \"\"\"\n        # Find entry in current menu\n        entry = None\n        for entry in self.context.tool_menus[self.context.current_tool_menu].entries:\n            if entry.cmd == cmd:\n                break\n\n        # Check if it corresponds to a menu or a command\n        if entry and entry.cmd in self.context.tool_menus:\n            # Enter a menu\n            self.context.current_tool_menu = cmd\n            await self.emit(\n                \"tool_menu\",\n                self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                namespace=\"/dashboard\",\n            )\n        else:\n            # Forward command to corresponding namespace\n            if cmd == \"exit\":\n                self.context.current_tool_menu = \"root\"\n                await self.emit(\n                    \"tool_menu\",\n                    self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                    namespace=\"/dashboard\",\n                )\n            else:\n                split_ns = self.context.current_tool_menu.split(\"/\")\n                namespace = split_ns.pop(0)\n                logger.info(f\"[dashboard =&gt; {namespace}] Forwarding command: {cmd}\")\n                await self.emit(\"command\", cmd, namespace=f\"/{namespace}\")\n\n    async def on_config_updated(self, sid, config: dict[str, Any]) -&gt; None:\n        namespace = config.pop(\"namespace\")\n        sio_event = config.pop(\"sio_event\")\n        await self.emit(sio_event, config, namespace=namespace)\n\n    async def on_actuators_start(self, sid):\n        \"\"\"\n        Callback on actuators_start message.\n        \"\"\"\n        await self.emit(\"actuators_start\", namespace=\"/copilot\")\n\n    async def on_actuators_stop(self, sid):\n        \"\"\"\n        Callback on actuators_stop message.\n        \"\"\"\n        await self.emit(\"actuators_stop\", namespace=\"/copilot\")\n\n    async def on_actuator_command(self, sid, data):\n        \"\"\"\n        Callback on actuator_command message.\n        \"\"\"\n        await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n\n    async def on_wizard(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        namespace = data.pop(\"namespace\")\n        await self.emit(\"wizard\", data, namespace=namespace)\n        await self.emit(\"close_wizard\")\n\n    async def on_starter_changed(self, sid, pushed: bool):\n        \"\"\"\n        Callback on starter_changed message.\n        \"\"\"\n        logger.info(f\"[dashboard =&gt; planner] Starter changed: {pushed}\")\n        await self.emit(\"starter_changed\", pushed, namespace=\"/planner\")\n        await self.emit(\"starter_changed\", (self.context.robot_id, pushed), namespace=\"/dashboard\", skip_sid=[sid])\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuator_command","title":"<code>on_actuator_command(sid, data)</code>  <code>async</code>","text":"<p>Callback on actuator_command message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuator_command(self, sid, data):\n    \"\"\"\n    Callback on actuator_command message.\n    \"\"\"\n    await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuators_start","title":"<code>on_actuators_start(sid)</code>  <code>async</code>","text":"<p>Callback on actuators_start message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuators_start(self, sid):\n    \"\"\"\n    Callback on actuators_start message.\n    \"\"\"\n    await self.emit(\"actuators_start\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuators_stop","title":"<code>on_actuators_stop(sid)</code>  <code>async</code>","text":"<p>Callback on actuators_stop message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuators_stop(self, sid):\n    \"\"\"\n    Callback on actuators_stop message.\n    \"\"\"\n    await self.emit(\"actuators_stop\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_starter_changed","title":"<code>on_starter_changed(sid, pushed)</code>  <code>async</code>","text":"<p>Callback on starter_changed message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_starter_changed(self, sid, pushed: bool):\n    \"\"\"\n    Callback on starter_changed message.\n    \"\"\"\n    logger.info(f\"[dashboard =&gt; planner] Starter changed: {pushed}\")\n    await self.emit(\"starter_changed\", pushed, namespace=\"/planner\")\n    await self.emit(\"starter_changed\", (self.context.robot_id, pushed), namespace=\"/dashboard\", skip_sid=[sid])\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_tool_cmd","title":"<code>on_tool_cmd(sid, cmd)</code>  <code>async</code>","text":"<p>Callback on tool command message from dashboard.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_tool_cmd(self, sid, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on tool command message from dashboard.\n    \"\"\"\n    # Find entry in current menu\n    entry = None\n    for entry in self.context.tool_menus[self.context.current_tool_menu].entries:\n        if entry.cmd == cmd:\n            break\n\n    # Check if it corresponds to a menu or a command\n    if entry and entry.cmd in self.context.tool_menus:\n        # Enter a menu\n        self.context.current_tool_menu = cmd\n        await self.emit(\n            \"tool_menu\",\n            self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n            namespace=\"/dashboard\",\n        )\n    else:\n        # Forward command to corresponding namespace\n        if cmd == \"exit\":\n            self.context.current_tool_menu = \"root\"\n            await self.emit(\n                \"tool_menu\",\n                self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                namespace=\"/dashboard\",\n            )\n        else:\n            split_ns = self.context.current_tool_menu.split(\"/\")\n            namespace = split_ns.pop(0)\n            logger.info(f\"[dashboard =&gt; {namespace}] Forwarding command: {cmd}\")\n            await self.emit(\"command\", cmd, namespace=f\"/{namespace}\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_wizard","title":"<code>on_wizard(sid, data)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_wizard(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    namespace = data.pop(\"namespace\")\n    await self.emit(\"wizard\", data, namespace=namespace)\n    await self.emit(\"close_wizard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace","title":"<code>DetectorNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to detector.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>class DetectorNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to detector.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/detector\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        if self.context.detector_sid:\n            message = \"A detector is already connected\"\n            logger.error(f\"Detector connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n\n        self.context.detector_sid = sid\n\n    async def on_connected(self, sid, virtual: bool):\n        logger.info(f\"Detector connected (virtual={virtual}).\")\n        self.context.virtual_detector = virtual\n\n    async def on_disconnect(self, sid):\n        self.context.detector_sid = None\n        logger.info(\"Detector disconnected.\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"detector\", data)\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"detector\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/monitor/","title":"monitor","text":""},{"location":"reference/cogip/tools/server/namespaces/monitor/#cogip.tools.server.namespaces.monitor.MonitorNamespace","title":"<code>MonitorNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to monitor.</p> Source code in <code>cogip/tools/server/namespaces/monitor.py</code> <pre><code>class MonitorNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to monitor.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/monitor\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.monitor_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.monitor_sid:\n            message = \"A monitor is already connected\"\n            logger.error(f\"Monitor connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.monitor_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Monitor connected.\")\n        await self.emit(\n            \"add_robot\",\n            (self.context.robot_id, self.context.virtual_planner, self.context.virtual_detector),\n            namespace=\"/monitor\",\n        )\n\n    def on_disconnect(self, sid):\n        self.context.monitor_sid = None\n        logger.info(\"Monitor disconnected.\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/","title":"planner","text":""},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace","title":"<code>PlannerNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to planner.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>class PlannerNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to planner.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/planner\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.connected = False\n        self.context.planner_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.planner_sid:\n            logger.error(\"Planner connection refused: a planner is already connected\")\n            raise ConnectionRefusedError(\"A planner is already connected\")\n\n    async def on_connected(self, sid, virtual: bool):\n        logger.info(f\"Planner connected (virtual={virtual}).\")\n        self.context.planner_sid = sid\n        self.context.virtual_planner = virtual\n        if self.context.copilot_sid:\n            await self.emit(\"copilot_connected\", namespace=\"/planner\")\n\n    def on_disconnect(self, sid):\n        self.context.planner_sid = None\n        logger.info(\"Planner disconnected.\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"planner\", data)\n\n    async def on_pose_start(self, sid, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose start.\n        Forward to pose to copilot.\n        \"\"\"\n        logger.info(f\"[planner =&gt; copilot] Pose start: {pose}\")\n        await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n\n    async def on_wizard(self, sid, message: list[dict[str, Any]]):\n        \"\"\"\n        Callback on wizard message.\n        Forward to dashboard.\n        \"\"\"\n        message[\"namespace\"] = \"/planner\"\n        await self.emit(\"wizard\", message, namespace=\"/dashboard\")\n\n    async def on_set_controller(self, sid, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to copilot.\n        \"\"\"\n        await self.emit(\"set_controller\", controller, namespace=\"/copilot\")\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n\n    async def on_cmd_reset(self, sid):\n        \"\"\"\n        Callback on cmd_reset message.\n        \"\"\"\n        await self.emit(\"cmd_reset\", namespace=\"/monitor\")\n\n    async def on_starter_changed(self, sid, pushed: bool):\n        \"\"\"\n        Callback on starter_pushed message.\n        \"\"\"\n        await self.emit(\"starter_changed\", (self.context.robot_id, pushed), namespace=\"/dashboard\")\n\n    async def on_close_wizard(self, sid):\n        \"\"\"\n        Callback on close_wizard message.\n        \"\"\"\n        await self.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n    async def on_game_start(self, sid):\n        \"\"\"\n        Callback on game_start message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Game started.\")\n        await self.emit(\"game_start\", namespace=\"/copilot\")\n\n    async def on_game_end(self, sid):\n        \"\"\"\n        Callback on game_end message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Game ended.\")\n        await self.emit(\"game_end\", namespace=\"/copilot\")\n\n    async def on_robot_end(self, sid):\n        \"\"\"\n        Callback on robot_end message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Robot ended.\")\n        await self.emit(\"game_end\", namespace=\"/copilot\")\n\n    async def on_game_reset(self, sid):\n        \"\"\"\n        Callback on game_reset message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Game reset.\")\n        await self.emit(\"game_reset\", namespace=\"/copilot\")\n\n    async def on_score(self, sid, score: int):\n        \"\"\"\n        Callback on score message.\n        \"\"\"\n        await self.emit(\"score\", score, namespace=\"/dashboard\")\n\n    async def on_start_countdown(self, sid, robot_id: int, countdown: int, timestamp: str, color: str | None):\n        \"\"\"\n        Callback on start_countdown message.\n        \"\"\"\n        logger.info(f\"[planner =&gt; beacon] Start countdown: {countdown}.\")\n        await self.emit(\"start_countdown\", (robot_id, countdown, timestamp, color), namespace=\"/beacon\")\n\n    async def on_actuator_command(self, sid, data):\n        \"\"\"\n        Callback on actuator_command message.\n        \"\"\"\n        logger.info(f\"[planner =&gt; copilot] Actuator command: {data}\")\n        await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n\n    async def on_actuator_init(self, sid):\n        \"\"\"\n        Callback on actuator_init message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Actuator init.\")\n        await self.emit(\"actuator_init\", namespace=\"/copilot\")\n\n    async def on_start_video_record(self, sid):\n        \"\"\"\n        Callback on start_video_record message.\n        \"\"\"\n        await self.emit(\"start_video_record\", namespace=\"/robotcam\")\n\n    async def on_stop_video_record(self, sid):\n        \"\"\"\n        Callback on stop_video_record message.\n        \"\"\"\n        await self.emit(\"stop_video_record\", namespace=\"/robotcam\")\n\n    async def on_brake(self, sid):\n        \"\"\"\n        Callback on brake message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Brake.\")\n        await self.emit(\"brake\", namespace=\"/copilot\")\n\n    async def on_pami_reset(self, sid):\n        \"\"\"\n        Callback on pami_reset message.\n        \"\"\"\n        logger.info(\"[planner =&gt; beacon] PAMI reset.\")\n        await self.emit(\"pami_reset\", namespace=\"/beacon\")\n\n    async def on_pami_camp(self, sid, data):\n        \"\"\"\n        Callback on pami_camp message.\n        \"\"\"\n        await self.emit(\"pami_camp\", data, namespace=\"/beacon\")\n\n    async def on_pami_table(self, sid, data):\n        \"\"\"\n        Callback on pami_table message.\n        \"\"\"\n        await self.emit(\"pami_table\", data, namespace=\"/beacon\")\n\n    async def on_pami_play(self, sid, timestamp: str):\n        \"\"\"\n        Callback on pami_play message.\n        \"\"\"\n        logger.info(\"[planner =&gt; beacon] PAMI play.\")\n        await self.emit(\"pami_play\", timestamp, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_actuator_command","title":"<code>on_actuator_command(sid, data)</code>  <code>async</code>","text":"<p>Callback on actuator_command message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_actuator_command(self, sid, data):\n    \"\"\"\n    Callback on actuator_command message.\n    \"\"\"\n    logger.info(f\"[planner =&gt; copilot] Actuator command: {data}\")\n    await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_actuator_init","title":"<code>on_actuator_init(sid)</code>  <code>async</code>","text":"<p>Callback on actuator_init message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_actuator_init(self, sid):\n    \"\"\"\n    Callback on actuator_init message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Actuator init.\")\n    await self.emit(\"actuator_init\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_brake","title":"<code>on_brake(sid)</code>  <code>async</code>","text":"<p>Callback on brake message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_brake(self, sid):\n    \"\"\"\n    Callback on brake message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Brake.\")\n    await self.emit(\"brake\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_close_wizard","title":"<code>on_close_wizard(sid)</code>  <code>async</code>","text":"<p>Callback on close_wizard message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_close_wizard(self, sid):\n    \"\"\"\n    Callback on close_wizard message.\n    \"\"\"\n    await self.emit(\"close_wizard\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_cmd_reset","title":"<code>on_cmd_reset(sid)</code>  <code>async</code>","text":"<p>Callback on cmd_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_cmd_reset(self, sid):\n    \"\"\"\n    Callback on cmd_reset message.\n    \"\"\"\n    await self.emit(\"cmd_reset\", namespace=\"/monitor\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_end","title":"<code>on_game_end(sid)</code>  <code>async</code>","text":"<p>Callback on game_end message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_end(self, sid):\n    \"\"\"\n    Callback on game_end message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Game ended.\")\n    await self.emit(\"game_end\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_reset","title":"<code>on_game_reset(sid)</code>  <code>async</code>","text":"<p>Callback on game_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_reset(self, sid):\n    \"\"\"\n    Callback on game_reset message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Game reset.\")\n    await self.emit(\"game_reset\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_start","title":"<code>on_game_start(sid)</code>  <code>async</code>","text":"<p>Callback on game_start message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_start(self, sid):\n    \"\"\"\n    Callback on game_start message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Game started.\")\n    await self.emit(\"game_start\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_camp","title":"<code>on_pami_camp(sid, data)</code>  <code>async</code>","text":"<p>Callback on pami_camp message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_camp(self, sid, data):\n    \"\"\"\n    Callback on pami_camp message.\n    \"\"\"\n    await self.emit(\"pami_camp\", data, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_play","title":"<code>on_pami_play(sid, timestamp)</code>  <code>async</code>","text":"<p>Callback on pami_play message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_play(self, sid, timestamp: str):\n    \"\"\"\n    Callback on pami_play message.\n    \"\"\"\n    logger.info(\"[planner =&gt; beacon] PAMI play.\")\n    await self.emit(\"pami_play\", timestamp, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_reset","title":"<code>on_pami_reset(sid)</code>  <code>async</code>","text":"<p>Callback on pami_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_reset(self, sid):\n    \"\"\"\n    Callback on pami_reset message.\n    \"\"\"\n    logger.info(\"[planner =&gt; beacon] PAMI reset.\")\n    await self.emit(\"pami_reset\", namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_table","title":"<code>on_pami_table(sid, data)</code>  <code>async</code>","text":"<p>Callback on pami_table message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_table(self, sid, data):\n    \"\"\"\n    Callback on pami_table message.\n    \"\"\"\n    await self.emit(\"pami_table\", data, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pose_start","title":"<code>on_pose_start(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose start. Forward to pose to copilot.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pose_start(self, sid, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose start.\n    Forward to pose to copilot.\n    \"\"\"\n    logger.info(f\"[planner =&gt; copilot] Pose start: {pose}\")\n    await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"planner\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_robot_end","title":"<code>on_robot_end(sid)</code>  <code>async</code>","text":"<p>Callback on robot_end message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_robot_end(self, sid):\n    \"\"\"\n    Callback on robot_end message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Robot ended.\")\n    await self.emit(\"game_end\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_score","title":"<code>on_score(sid, score)</code>  <code>async</code>","text":"<p>Callback on score message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_score(self, sid, score: int):\n    \"\"\"\n    Callback on score message.\n    \"\"\"\n    await self.emit(\"score\", score, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_set_controller","title":"<code>on_set_controller(sid, controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_set_controller(self, sid, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to copilot.\n    \"\"\"\n    await self.emit(\"set_controller\", controller, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_start_countdown","title":"<code>on_start_countdown(sid, robot_id, countdown, timestamp, color)</code>  <code>async</code>","text":"<p>Callback on start_countdown message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_start_countdown(self, sid, robot_id: int, countdown: int, timestamp: str, color: str | None):\n    \"\"\"\n    Callback on start_countdown message.\n    \"\"\"\n    logger.info(f\"[planner =&gt; beacon] Start countdown: {countdown}.\")\n    await self.emit(\"start_countdown\", (robot_id, countdown, timestamp, color), namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_start_video_record","title":"<code>on_start_video_record(sid)</code>  <code>async</code>","text":"<p>Callback on start_video_record message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_start_video_record(self, sid):\n    \"\"\"\n    Callback on start_video_record message.\n    \"\"\"\n    await self.emit(\"start_video_record\", namespace=\"/robotcam\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_starter_changed","title":"<code>on_starter_changed(sid, pushed)</code>  <code>async</code>","text":"<p>Callback on starter_pushed message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_starter_changed(self, sid, pushed: bool):\n    \"\"\"\n    Callback on starter_pushed message.\n    \"\"\"\n    await self.emit(\"starter_changed\", (self.context.robot_id, pushed), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_stop_video_record","title":"<code>on_stop_video_record(sid)</code>  <code>async</code>","text":"<p>Callback on stop_video_record message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_stop_video_record(self, sid):\n    \"\"\"\n    Callback on stop_video_record message.\n    \"\"\"\n    await self.emit(\"stop_video_record\", namespace=\"/robotcam\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_wizard","title":"<code>on_wizard(sid, message)</code>  <code>async</code>","text":"<p>Callback on wizard message. Forward to dashboard.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_wizard(self, sid, message: list[dict[str, Any]]):\n    \"\"\"\n    Callback on wizard message.\n    Forward to dashboard.\n    \"\"\"\n    message[\"namespace\"] = \"/planner\"\n    await self.emit(\"wizard\", message, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/robotcam/","title":"robotcam","text":""},{"location":"reference/cogip/tools/server/namespaces/robotcam/#cogip.tools.server.namespaces.robotcam.RobotcamNamespace","title":"<code>RobotcamNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to robotcam.</p> Source code in <code>cogip/tools/server/namespaces/robotcam.py</code> <pre><code>class RobotcamNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to robotcam.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/robotcam\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.robotcam_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.robotcam_sid:\n            message = \"A robotcam is already connected\"\n            logger.error(f\"Robotcam connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.robotcam_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Robotcam connected.\")\n\n    def on_disconnect(self, sid):\n        self.context.robotcam_sid = None\n        logger.info(\"Robotcam disconnected.\")\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/server_beacon/__main__/#cogip.tools.server_beacon.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SocketIO beacon server.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-server-beacon</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/server_beacon/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SocketIO beacon server.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-server-beacon` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/app/","title":"app","text":""},{"location":"reference/cogip/tools/server_beacon/app/#cogip.tools.server_beacon.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return ASGIApp application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/server_beacon/app.py</code> <pre><code>def create_app() -&gt; ASGIApp:\n    \"\"\"\n    Create server and return ASGIApp application for uvicorn/gunicorn.\n    \"\"\"\n    server = Server()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/server_beacon/robot/","title":"robot","text":""},{"location":"reference/cogip/tools/server_beacon/server/","title":"server","text":""},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server","title":"<code>Server</code>","text":"Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>class Server:\n    original_uvicorn_exit_handler = UvicornServer.handle_exit\n    exiting: bool = False\n    robots: dict[int, Robot] = {}\n    robot_tasks: set[asyncio.Task] = set()\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO server and robot servers connections\n        \"\"\"\n        UvicornServer.handle_exit = Server.handle_exit\n\n        self.sio = socketio.AsyncServer(\n            always_connect=False,\n            async_mode=\"asgi\",\n            cors_allowed_origins=\"*\",\n            logger=False,\n            engineio_logger=False,\n        )\n        self.app = socketio.ASGIApp(self.sio)\n        self.sio.register_namespace(namespaces.DashboardNamespace(self))\n\n        self.camp = Camp.Colors.blue\n        self.table = TableEnum.Game\n\n        for i in range(1, int(os.environ[\"SERVER_BEACON_MAX_ROBOTS\"]) + 1):\n            robot = Robot(self, i)\n            task = asyncio.create_task(robot.run())\n            Server.robots[i] = robot\n            Server.robot_tasks.add(task)\n            task.add_done_callback(Server.robot_tasks.discard)\n\n        @self.sio.event\n        def connect(sid, environ, auth):\n            logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n            raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n        @self.sio.on(\"*\")\n        def catch_all(event, sid, data):\n            logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Server.exiting = True\n        for _, robot in Server.robots.items():\n            robot.exiting = True\n            robot.sio.reconnection_attempts = -1\n        for task in Server.robot_tasks:\n            task.cancel()\n\n        Server.original_uvicorn_exit_handler(*args, **kwargs)\n\n    async def choose_camp(self):\n        \"\"\"\n        Choose camp command from the menu.\n        Send camp wizard message.\n        \"\"\"\n        await self.sio.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Camp\",\n                \"type\": \"camp\",\n                \"value\": self.camp.name,\n            },\n            namespace=\"/dashboard\",\n        )\n\n    async def choose_table(self):\n        \"\"\"\n        Choose table command from the menu.\n        Send table wizard message.\n        \"\"\"\n        await self.sio.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Table\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in TableEnum],\n                \"value\": self.table.name,\n            },\n            namespace=\"/dashboard\",\n        )\n\n    async def reset_robots(self):\n        for robot_id, robot in self.robots.items():\n            if robot.sio.connected:\n                position: StartPosition | None = None\n                match robot_id:\n                    case 1:\n                        position = StartPosition.Bottom\n                    case 2:\n                        position = StartPosition.PAMI2\n                    case 3:\n                        position = StartPosition.PAMI3\n                    case 4:\n                        position = StartPosition.PAMI4\n                    case 5:\n                        position = StartPosition.PAMI5\n                if position:\n                    await robot.sio.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Choose Start Position\",\n                            \"value\": position.name,\n                        },\n                        namespace=\"/beacon\",\n                    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO server and robot servers connections</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO server and robot servers connections\n    \"\"\"\n    UvicornServer.handle_exit = Server.handle_exit\n\n    self.sio = socketio.AsyncServer(\n        always_connect=False,\n        async_mode=\"asgi\",\n        cors_allowed_origins=\"*\",\n        logger=False,\n        engineio_logger=False,\n    )\n    self.app = socketio.ASGIApp(self.sio)\n    self.sio.register_namespace(namespaces.DashboardNamespace(self))\n\n    self.camp = Camp.Colors.blue\n    self.table = TableEnum.Game\n\n    for i in range(1, int(os.environ[\"SERVER_BEACON_MAX_ROBOTS\"]) + 1):\n        robot = Robot(self, i)\n        task = asyncio.create_task(robot.run())\n        Server.robots[i] = robot\n        Server.robot_tasks.add(task)\n        task.add_done_callback(Server.robot_tasks.discard)\n\n    @self.sio.event\n    def connect(sid, environ, auth):\n        logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n        raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n    @self.sio.on(\"*\")\n    def catch_all(event, sid, data):\n        logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.choose_camp","title":"<code>choose_camp()</code>  <code>async</code>","text":"<p>Choose camp command from the menu. Send camp wizard message.</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>async def choose_camp(self):\n    \"\"\"\n    Choose camp command from the menu.\n    Send camp wizard message.\n    \"\"\"\n    await self.sio.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Camp\",\n            \"type\": \"camp\",\n            \"value\": self.camp.name,\n        },\n        namespace=\"/dashboard\",\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.choose_table","title":"<code>choose_table()</code>  <code>async</code>","text":"<p>Choose table command from the menu. Send table wizard message.</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>async def choose_table(self):\n    \"\"\"\n    Choose table command from the menu.\n    Send table wizard message.\n    \"\"\"\n    await self.sio.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Table\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in TableEnum],\n            \"value\": self.table.name,\n        },\n        namespace=\"/dashboard\",\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Server.exiting = True\n    for _, robot in Server.robots.items():\n        robot.exiting = True\n        robot.sio.reconnection_attempts = -1\n    for task in Server.robot_tasks:\n        task.cancel()\n\n    Server.original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/#cogip.tools.server_beacon.namespaces.dashboard.DashboardNamespace","title":"<code>DashboardNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to Beacon dashboard.</p> Source code in <code>cogip/tools/server_beacon/namespaces/dashboard.py</code> <pre><code>class DashboardNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to Beacon dashboard.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/dashboard\")\n        self.cogip_server = cogip_server\n\n    def on_connect(self, sid, environ):\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(\"Dashboard connected.\")\n        for robot_id, robot in self.cogip_server.robots.items():\n            if robot.sio.connected:\n                await self.cogip_server.sio.emit(\"add_robot\", robot_id, namespace=\"/dashboard\")\n        await self.emit(\n            \"tool_menu\",\n            menu.model_dump(),\n            namespace=\"/dashboard\",\n        )\n\n    def on_disconnect(self, sid):\n        logger.info(\"Dashboard disconnected.\")\n\n    async def on_tool_cmd(self, sid, cmd: str):\n        match cmd:\n            case \"choose_camp\":\n                await self.cogip_server.choose_camp()\n            case \"choose_table\":\n                await self.cogip_server.choose_table()\n            case \"reset\":\n                await self.cogip_server.reset_robots()\n            case \"start\":\n                for _, robot in self.cogip_server.robots.items():\n                    if robot.sio.connected:\n                        await robot.sio.emit(\"command\", \"play\", namespace=\"/beacon\")\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_wizard(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        for _, robot in self.cogip_server.robots.items():\n            if robot.sio.connected:\n                await robot.sio.emit(\"wizard\", data, namespace=\"/beacon\")\n        await self.cogip_server.sio.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n        match data.get(\"name\"):\n            case \"Choose Camp\":\n                self.cogip_server.camp = Camp.Colors[data[\"value\"]]\n            case \"Choose Table\":\n                self.cogip_server.table = TableEnum[data[\"value\"]]\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/#cogip.tools.server_beacon.namespaces.dashboard.DashboardNamespace.on_wizard","title":"<code>on_wizard(sid, data)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server_beacon/namespaces/dashboard.py</code> <pre><code>async def on_wizard(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    for _, robot in self.cogip_server.robots.items():\n        if robot.sio.connected:\n            await robot.sio.emit(\"wizard\", data, namespace=\"/beacon\")\n    await self.cogip_server.sio.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n    match data.get(\"name\"):\n        case \"Choose Camp\":\n            self.cogip_server.camp = Camp.Colors[data[\"value\"]]\n        case \"Choose Table\":\n            self.cogip_server.table = TableEnum[data[\"value\"]]\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/ydlidar_g2/__main__/#cogip.tools.ydlidar_g2.__main__.main","title":"<code>main()</code>","text":"<p>Tool demonstrating usage of ydlidar_g2 C++ driver.</p> <p>During installation of cogip-tools, a script called <code>cogip-ydlidar-g2</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/ydlidar_g2/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Tool demonstrating usage of ydlidar_g2 C++ driver.\n\n    During installation of cogip-tools, a script called `cogip-ydlidar-g2`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/","title":"gui","text":""},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker","title":"<code>LidarObstacleTracker</code>","text":"Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>class LidarObstacleTracker:\n    def __init__(\n        self,\n        lidar_coords: NDArray,\n        lidar_offset: tuple[float, float],\n        eps: float = 30.0,\n        min_samples: int = 6,\n        update_interval: int = 100,\n    ):\n        \"\"\"\n        Initialize the real-time Lidar obstacle tracker\n\n        Args:\n            lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n            lidar_offset: Lidar offset from robot center\n            eps: DBSCAN clustering parameter\n            min_samples: Minimum points for cluster formation\n            update_interval: Visualization update interval\n        \"\"\"\n        # Use default pose if not provided\n        self.lidar_coords = lidar_coords\n        self.lidar_offset = lidar_offset\n        self.eps = eps\n        self.min_samples = min_samples\n        self.update_interval = update_interval\n        self.view_radius = 2500\n        self.clusters: list[NDArray] = []\n        self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n        # Initialize plot and data containers\n        self.fig, self.ax = plt.subplots(figsize=(10, 10))\n        self.setup_plot()\n\n        # Connect the scroll event to the handler\n        self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n        # Visualization elements\n        self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n        self.cluster_scatters: list[PathCollection] = []\n        self.obstacle_circles: list[Ellipse] = []\n\n        # Robot and Lidar markers\n        self.robot_marker = self.ax.scatter(\n            0,\n            0,\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Robot\",\n        )\n\n        # Calculate Lidar position\n        self.lidar_marker = self.ax.scatter(\n            self.lidar_offset[1],\n            self.lidar_offset[0],\n            c=\"blue\",\n            s=80,\n            marker=\"o\",\n            label=\"Lidar\",\n        )\n\n        # Animation setup\n        self.animation: FuncAnimation | None = None\n\n    def setup_plot(self):\n        \"\"\"Configure the plot appearance with dark theme\"\"\"\n        # Set figure and axes background color\n        self.fig.patch.set_facecolor(\"#2E2E2E\")\n        self.ax.set_facecolor(\"#1E1E1E\")\n\n        # Set labels and title with light colors\n        self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n        self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n        self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n        # Customize grid\n        self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n        # Customize axis appearance\n        self.ax.spines[\"bottom\"].set_color(\"#555555\")\n        self.ax.spines[\"top\"].set_color(\"#555555\")\n        self.ax.spines[\"left\"].set_color(\"#555555\")\n        self.ax.spines[\"right\"].set_color(\"#555555\")\n\n        # Customize tick parameters\n        self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n        # Invert x-axis and set equal aspect ratio\n        self.ax.invert_xaxis()\n        self.ax.axis(\"equal\")\n\n        # Configure legend with dark theme colors\n        self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n        # Set initial view range\n        self.ax.set_xlim((self.view_radius, -self.view_radius))\n        self.ax.set_ylim((-self.view_radius, self.view_radius))\n\n    def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n        \"\"\"\n        Groups points into obstacle clusters using DBSCAN\n\n        Args:\n            points: NDArray of (x, y) points representing detected obstacles\n\n        Returns:\n            List of clusters, each cluster being a set of points belonging to the same obstacle\n        \"\"\"\n        if len(points) == 0:\n            return []\n\n        db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n        labels = db.labels_\n\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n        clusters = []\n        for i in range(n_clusters):\n            cluster_points = points[labels == i]\n            clusters.append(cluster_points)\n\n        return clusters\n\n    def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Estimates position and size of obstacles from clusters\n\n        Args:\n            clusters: List of clusters, each cluster being a set of points\n\n        Returns:\n            List of tuples (center_x, center_y, radius) for each obstacle\n        \"\"\"\n        obstacle_properties = []\n\n        for cluster in clusters:\n            center_x = np.mean(cluster[:, 0])\n            center_y = np.mean(cluster[:, 1])\n\n            # Calculate the maximum distance from center in x and y directions\n            # This will be used as the radius of the circle\n            radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n            radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n            radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n            obstacle_properties.append((center_x, center_y, radius))\n\n        return obstacle_properties\n\n    def update_plot(self, frame):\n        \"\"\"Updates the visualization with current data\"\"\"\n        lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n        self.clusters = self.cluster_obstacles(lidar_coords)\n        self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n        # Update points scatter\n        self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n        # Clear previous cluster scatters and obstacle visualizations\n        for scatter in self.cluster_scatters:\n            scatter.remove()\n        self.cluster_scatters = []\n\n        for circle in self.obstacle_circles:\n            circle.remove()\n        self.obstacle_circles = []\n\n        # Create color map for clusters that works well with dark theme\n        colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n        # Draw new clusters\n        for i, cluster in enumerate(self.clusters):\n            scatter = self.ax.scatter(\n                cluster[:, 1],\n                cluster[:, 0],\n                c=[colors[i]],\n                s=20,\n                label=f\"Cluster {i}\" if i == 0 else \"\",\n            )\n            self.cluster_scatters.append(scatter)\n\n        # Draw obstacle circles and labels\n        for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n            # Create ellipse for the obstacle\n            circle = Ellipse(\n                (center_y, center_x),\n                width=radius * 2,\n                height=radius * 2,\n                fill=False,\n                edgecolor=colors[i],\n                linewidth=2,\n                alpha=0.8,\n            )\n            self.ax.add_patch(circle)\n            self.obstacle_circles.append(circle)\n\n        # Redraw the figure\n        self.fig.canvas.draw_idle()\n\n    def start_animation(self):\n        \"\"\"Starts the real-time visualization\"\"\"\n        # Set dark theme for the color map (for clusters)\n        plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n        # Continue with original animation code\n        self.animation = FuncAnimation(\n            self.fig,\n            self.update_plot,\n            interval=self.update_interval,\n            blit=False,\n            cache_frame_data=False,\n        )\n\n    def on_scroll(self, event: MouseEvent):\n        # Ignore if the mouse is not over the axes\n        if event.inaxes != self.ax:\n            return\n\n        # Get the current limits\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        # Get mouse position in data coordinates\n        x_data, y_data = event.xdata, event.ydata\n\n        # Calculate zoom factor\n        zoom_factor = 1.1 if event.button == \"down\" else 0.9  # Zoom in/out\n\n        # Calculate new limits maintaining the mouse position as center\n        x_left = x_data - zoom_factor * (x_data - xlim[0])\n        x_right = x_data + zoom_factor * (xlim[1] - x_data)\n        y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n        y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n        # Limit the zoom range\n        x_left = max(-self.view_radius, x_left)\n        x_right = min(self.view_radius, x_right)\n        y_bottom = max(-self.view_radius, y_bottom)\n        y_top = min(self.view_radius, y_top)\n\n        # Apply the new limits\n        self.ax.set_xlim(x_left, x_right)\n        self.ax.set_ylim(y_bottom, y_top)\n\n        # Redraw the plot\n        plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.__init__","title":"<code>__init__(lidar_coords, lidar_offset, eps=30.0, min_samples=6, update_interval=100)</code>","text":"<p>Initialize the real-time Lidar obstacle tracker</p> <p>Parameters:</p> Name Type Description Default <code>lidar_coords</code> <code>NDArray</code> <p>2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates</p> required <code>lidar_offset</code> <code>tuple[float, float]</code> <p>Lidar offset from robot center</p> required <code>eps</code> <code>float</code> <p>DBSCAN clustering parameter</p> <code>30.0</code> <code>min_samples</code> <code>int</code> <p>Minimum points for cluster formation</p> <code>6</code> <code>update_interval</code> <code>int</code> <p>Visualization update interval</p> <code>100</code> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def __init__(\n    self,\n    lidar_coords: NDArray,\n    lidar_offset: tuple[float, float],\n    eps: float = 30.0,\n    min_samples: int = 6,\n    update_interval: int = 100,\n):\n    \"\"\"\n    Initialize the real-time Lidar obstacle tracker\n\n    Args:\n        lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n        lidar_offset: Lidar offset from robot center\n        eps: DBSCAN clustering parameter\n        min_samples: Minimum points for cluster formation\n        update_interval: Visualization update interval\n    \"\"\"\n    # Use default pose if not provided\n    self.lidar_coords = lidar_coords\n    self.lidar_offset = lidar_offset\n    self.eps = eps\n    self.min_samples = min_samples\n    self.update_interval = update_interval\n    self.view_radius = 2500\n    self.clusters: list[NDArray] = []\n    self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n    # Initialize plot and data containers\n    self.fig, self.ax = plt.subplots(figsize=(10, 10))\n    self.setup_plot()\n\n    # Connect the scroll event to the handler\n    self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n    # Visualization elements\n    self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n    self.cluster_scatters: list[PathCollection] = []\n    self.obstacle_circles: list[Ellipse] = []\n\n    # Robot and Lidar markers\n    self.robot_marker = self.ax.scatter(\n        0,\n        0,\n        c=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"Robot\",\n    )\n\n    # Calculate Lidar position\n    self.lidar_marker = self.ax.scatter(\n        self.lidar_offset[1],\n        self.lidar_offset[0],\n        c=\"blue\",\n        s=80,\n        marker=\"o\",\n        label=\"Lidar\",\n    )\n\n    # Animation setup\n    self.animation: FuncAnimation | None = None\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.cluster_obstacles","title":"<code>cluster_obstacles(points)</code>","text":"<p>Groups points into obstacle clusters using DBSCAN</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray</code> <p>NDArray of (x, y) points representing detected obstacles</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points belonging to the same obstacle</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n    \"\"\"\n    Groups points into obstacle clusters using DBSCAN\n\n    Args:\n        points: NDArray of (x, y) points representing detected obstacles\n\n    Returns:\n        List of clusters, each cluster being a set of points belonging to the same obstacle\n    \"\"\"\n    if len(points) == 0:\n        return []\n\n    db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n    labels = db.labels_\n\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    clusters = []\n    for i in range(n_clusters):\n        cluster_points = points[labels == i]\n        clusters.append(cluster_points)\n\n    return clusters\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.estimate_obstacle_properties","title":"<code>estimate_obstacle_properties(clusters)</code>","text":"<p>Estimates position and size of obstacles from clusters</p> <p>Parameters:</p> Name Type Description Default <code>clusters</code> <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points</p> required <p>Returns:</p> Type Description <code>list[tuple[float, float, float]]</code> <p>List of tuples (center_x, center_y, radius) for each obstacle</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n    \"\"\"\n    Estimates position and size of obstacles from clusters\n\n    Args:\n        clusters: List of clusters, each cluster being a set of points\n\n    Returns:\n        List of tuples (center_x, center_y, radius) for each obstacle\n    \"\"\"\n    obstacle_properties = []\n\n    for cluster in clusters:\n        center_x = np.mean(cluster[:, 0])\n        center_y = np.mean(cluster[:, 1])\n\n        # Calculate the maximum distance from center in x and y directions\n        # This will be used as the radius of the circle\n        radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n        radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n        radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n        obstacle_properties.append((center_x, center_y, radius))\n\n    return obstacle_properties\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.setup_plot","title":"<code>setup_plot()</code>","text":"<p>Configure the plot appearance with dark theme</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def setup_plot(self):\n    \"\"\"Configure the plot appearance with dark theme\"\"\"\n    # Set figure and axes background color\n    self.fig.patch.set_facecolor(\"#2E2E2E\")\n    self.ax.set_facecolor(\"#1E1E1E\")\n\n    # Set labels and title with light colors\n    self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n    self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n    self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n    # Customize grid\n    self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Customize axis appearance\n    self.ax.spines[\"bottom\"].set_color(\"#555555\")\n    self.ax.spines[\"top\"].set_color(\"#555555\")\n    self.ax.spines[\"left\"].set_color(\"#555555\")\n    self.ax.spines[\"right\"].set_color(\"#555555\")\n\n    # Customize tick parameters\n    self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n    # Invert x-axis and set equal aspect ratio\n    self.ax.invert_xaxis()\n    self.ax.axis(\"equal\")\n\n    # Configure legend with dark theme colors\n    self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n    # Set initial view range\n    self.ax.set_xlim((self.view_radius, -self.view_radius))\n    self.ax.set_ylim((-self.view_radius, self.view_radius))\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.start_animation","title":"<code>start_animation()</code>","text":"<p>Starts the real-time visualization</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def start_animation(self):\n    \"\"\"Starts the real-time visualization\"\"\"\n    # Set dark theme for the color map (for clusters)\n    plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n    # Continue with original animation code\n    self.animation = FuncAnimation(\n        self.fig,\n        self.update_plot,\n        interval=self.update_interval,\n        blit=False,\n        cache_frame_data=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.update_plot","title":"<code>update_plot(frame)</code>","text":"<p>Updates the visualization with current data</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def update_plot(self, frame):\n    \"\"\"Updates the visualization with current data\"\"\"\n    lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n    self.clusters = self.cluster_obstacles(lidar_coords)\n    self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n    # Update points scatter\n    self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n    # Clear previous cluster scatters and obstacle visualizations\n    for scatter in self.cluster_scatters:\n        scatter.remove()\n    self.cluster_scatters = []\n\n    for circle in self.obstacle_circles:\n        circle.remove()\n    self.obstacle_circles = []\n\n    # Create color map for clusters that works well with dark theme\n    colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n    # Draw new clusters\n    for i, cluster in enumerate(self.clusters):\n        scatter = self.ax.scatter(\n            cluster[:, 1],\n            cluster[:, 0],\n            c=[colors[i]],\n            s=20,\n            label=f\"Cluster {i}\" if i == 0 else \"\",\n        )\n        self.cluster_scatters.append(scatter)\n\n    # Draw obstacle circles and labels\n    for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n        # Create ellipse for the obstacle\n        circle = Ellipse(\n            (center_y, center_x),\n            width=radius * 2,\n            height=radius * 2,\n            fill=False,\n            edgecolor=colors[i],\n            linewidth=2,\n            alpha=0.8,\n        )\n        self.ax.add_patch(circle)\n        self.obstacle_circles.append(circle)\n\n    # Redraw the figure\n    self.fig.canvas.draw_idle()\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/web/","title":"web","text":""},{"location":"reference/cogip/utils/argenum/","title":"argenum","text":""},{"location":"reference/cogip/utils/argenum/#cogip.utils.argenum.ArgEnum","title":"<code>ArgEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>This base class can be used to define Enum argument for Typer. It allows to use the Enum name of the enum in the command line arguments instead the Enum value. To get the Enum value, use <code>ArgEnum.val</code> property instead of <code>ArgEnum.value</code>.</p> <p>This workaround is explained here: https://github.com/tiangolo/typer/issues/151#issuecomment-1755370085. There is a pending merge request here: https://github.com/tiangolo/typer/pull/224.</p> Source code in <code>cogip/utils/argenum.py</code> <pre><code>class ArgEnum(Enum):\n    \"\"\"\n    This base class can be used to define Enum argument for Typer.\n    It allows to use the Enum name of the enum in the command line arguments instead the Enum value.\n    To get the Enum value, use `ArgEnum.val` property instead of `ArgEnum.value`.\n\n    This workaround is explained here: https://github.com/tiangolo/typer/issues/151#issuecomment-1755370085.\n    There is a pending merge request here: https://github.com/tiangolo/typer/pull/224.\n    \"\"\"\n\n    def __init__(self, val):\n        self.val = val\n\n    @property\n    def value(self):\n        return self.name\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/","title":"asyncloop","text":""},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop","title":"<code>AsyncLoop</code>","text":"<p>This class creates a async task to execute a function in loop and wait after the function until the defined loop interval is reached. A warning is emitted if the function duration is longer than the loop interval.</p> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>class AsyncLoop:\n    \"\"\"\n    This class creates a async task to execute a function in loop and wait after\n    the function until the defined loop interval is reached.\n    A warning is emitted if the function duration is longer than the loop\n    interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        interval: float,\n        func: Callable,\n        logger: bool | logging.Logger = False,\n        args: list[Any] | None = None,\n        kwargs: dict[str, Any] | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: Name to identify the thread in the logs\n            interval: time between each iteration of the loop, in seconds\n            func: function to execute in the loop\n            logger: an optional custom logger\n            args: arguments of the function\n            kwargs: named arguments of the function\n        \"\"\"\n        self._name = name\n        self.interval = interval\n        self._func = func\n        self._args = args or []\n        self._kwargs = kwargs or {}\n        self._logger = logging.getLogger(f\"AsyncLoop: {name}\")\n        self._task: asyncio.Task | None = None\n        self.exit: bool = False\n\n        if not isinstance(logger, bool):\n            self._logger = logger\n        else:\n            if self._logger.level == logging.NOTSET:\n                if logger:\n                    self._logger.setLevel(logging.DEBUG)\n                else:\n                    self._logger.setLevel(logging.INFO)\n\n    async def task(self) -&gt; None:\n        \"\"\"\n        Loop function executed in the task.\n        \"\"\"\n        self._logger.info(\"Task started\")\n\n        try:\n            while not self.exit:\n                start = time.time()\n                await self._func(*self._args, **self._kwargs)\n                now = time.time()\n                duration = now - start\n                if duration &gt; self.interval:\n                    self._logger.warning(f\"Function too long: {duration} &gt; {self.interval}\")\n                else:\n                    wait = self.interval - duration\n                    await asyncio.sleep(wait)\n        except asyncio.CancelledError:\n            self._logger.info(\"Task cancelled\")\n            raise\n\n    def start(self):\n        if self._task:\n            self._logger.warning(\"Already started\")\n            return\n\n        self.exit = False\n        self._task = asyncio.create_task(self.task(), name=self._name)\n\n    async def stop(self):\n        if not self._task:\n            self._logger.warning(\"Not running\")\n            return\n\n        self._task.cancel()\n        try:\n            await self._task\n        except asyncio.CancelledError:\n            self._logger.info(\"Task cancelled\")\n\n        self._task = None\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop.__init__","title":"<code>__init__(name, interval, func, logger=False, args=None, kwargs=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the thread in the logs</p> required <code>interval</code> <code>float</code> <p>time between each iteration of the loop, in seconds</p> required <code>func</code> <code>Callable</code> <p>function to execute in the loop</p> required <code>logger</code> <code>bool | Logger</code> <p>an optional custom logger</p> <code>False</code> <code>args</code> <code>list[Any] | None</code> <p>arguments of the function</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>named arguments of the function</p> <code>None</code> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    interval: float,\n    func: Callable,\n    logger: bool | logging.Logger = False,\n    args: list[Any] | None = None,\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: Name to identify the thread in the logs\n        interval: time between each iteration of the loop, in seconds\n        func: function to execute in the loop\n        logger: an optional custom logger\n        args: arguments of the function\n        kwargs: named arguments of the function\n    \"\"\"\n    self._name = name\n    self.interval = interval\n    self._func = func\n    self._args = args or []\n    self._kwargs = kwargs or {}\n    self._logger = logging.getLogger(f\"AsyncLoop: {name}\")\n    self._task: asyncio.Task | None = None\n    self.exit: bool = False\n\n    if not isinstance(logger, bool):\n        self._logger = logger\n    else:\n        if self._logger.level == logging.NOTSET:\n            if logger:\n                self._logger.setLevel(logging.DEBUG)\n            else:\n                self._logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop.task","title":"<code>task()</code>  <code>async</code>","text":"<p>Loop function executed in the task.</p> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>async def task(self) -&gt; None:\n    \"\"\"\n    Loop function executed in the task.\n    \"\"\"\n    self._logger.info(\"Task started\")\n\n    try:\n        while not self.exit:\n            start = time.time()\n            await self._func(*self._args, **self._kwargs)\n            now = time.time()\n            duration = now - start\n            if duration &gt; self.interval:\n                self._logger.warning(f\"Function too long: {duration} &gt; {self.interval}\")\n            else:\n                wait = self.interval - duration\n                await asyncio.sleep(wait)\n    except asyncio.CancelledError:\n        self._logger.info(\"Task cancelled\")\n        raise\n</code></pre>"},{"location":"reference/cogip/utils/lidartablemodel/","title":"lidartablemodel","text":""},{"location":"reference/cogip/utils/lidartablemodel/#cogip.utils.lidartablemodel.LidarTableModel","title":"<code>LidarTableModel</code>","text":"<p>               Bases: <code>QAbstractTableModel</code></p> <p>Model class providing access to data to update the table view.</p> Source code in <code>cogip/utils/lidartablemodel.py</code> <pre><code>class LidarTableModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Model class providing access to data to update the table view.\n    \"\"\"\n\n    headers = [\"Angle\", \"Distance\", \"Intensity\"]\n\n    def __init__(\n        self,\n        angle_values: list[float],\n        distance_values: list[int],\n        intensity_values: list[int],\n        distance_color: QtGui.QColor,\n        intensity_color: QtGui.QColor,\n        nb_angles: int = 360,\n    ):\n        \"\"\"Class constructor\n\n        Arguments:\n            angle_values: angle values list\n            distance_values: distance values list\n            intensity_values: intensity values list\n            distance_color: distance color\n            intensity_color: intensity color\n            nb_angles: number of angles\n        \"\"\"\n        super().__init__()\n        self.angle_values = angle_values\n        self.distance_values = distance_values\n        self.intensity_values = intensity_values\n        self.distance_color = distance_color\n        self.intensity_color = intensity_color\n        self.nb_angles = nb_angles\n\n    def rowCount(self, parent):\n        return self.nb_angles\n\n    def columnCount(self, parent):\n        return 3\n\n    def data(self, index, role):\n        row, column = index.row(), index.column()\n\n        if role == QtCore.Qt.BackgroundRole:\n            if column == 0:\n                return QtGui.QColor(\"lightgray\")\n            if column == 1:\n                return self.distance_color\n            if column == 2:\n                return self.intensity_color\n            return None\n\n        if role == QtCore.Qt.TextAlignmentRole:\n            return QtCore.Qt.AlignRight\n\n        if role == QtCore.Qt.DisplayRole:\n            if column == 0:\n                return self.angle_values[row]\n            if column == 1:\n                return self.distance_values[row]\n            if column == 2:\n                return self.intensity_values[row]\n            return None\n\n        return None\n\n    def headerData(self, section, orientation, role):\n        if role == QtCore.Qt.BackgroundRole:\n            return QtGui.QColor(\"lightgray\")\n\n        if role == QtCore.Qt.FontRole:\n            font = QtWidgets.QApplication.font()\n            font.setPointSize(font.pointSize() - 2)\n            return font\n\n        if role != QtCore.Qt.DisplayRole or orientation != QtCore.Qt.Horizontal:\n            return None\n        return self.headers[section]\n</code></pre>"},{"location":"reference/cogip/utils/lidartablemodel/#cogip.utils.lidartablemodel.LidarTableModel.__init__","title":"<code>__init__(angle_values, distance_values, intensity_values, distance_color, intensity_color, nb_angles=360)</code>","text":"<p>Class constructor</p> <p>Parameters:</p> Name Type Description Default <code>angle_values</code> <code>list[float]</code> <p>angle values list</p> required <code>distance_values</code> <code>list[int]</code> <p>distance values list</p> required <code>intensity_values</code> <code>list[int]</code> <p>intensity values list</p> required <code>distance_color</code> <code>QColor</code> <p>distance color</p> required <code>intensity_color</code> <code>QColor</code> <p>intensity color</p> required <code>nb_angles</code> <code>int</code> <p>number of angles</p> <code>360</code> Source code in <code>cogip/utils/lidartablemodel.py</code> <pre><code>def __init__(\n    self,\n    angle_values: list[float],\n    distance_values: list[int],\n    intensity_values: list[int],\n    distance_color: QtGui.QColor,\n    intensity_color: QtGui.QColor,\n    nb_angles: int = 360,\n):\n    \"\"\"Class constructor\n\n    Arguments:\n        angle_values: angle values list\n        distance_values: distance values list\n        intensity_values: intensity values list\n        distance_color: distance color\n        intensity_color: intensity color\n        nb_angles: number of angles\n    \"\"\"\n    super().__init__()\n    self.angle_values = angle_values\n    self.distance_values = distance_values\n    self.intensity_values = intensity_values\n    self.distance_color = distance_color\n    self.intensity_color = intensity_color\n    self.nb_angles = nb_angles\n</code></pre>"},{"location":"reference/cogip/utils/logger/","title":"logger","text":""},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger","title":"<code>Logger</code>","text":"<p>A Python class that integrates with C++ logging functionality. This class manages a Python logger and connects it to C++ logging streams.</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>class Logger:\n    \"\"\"\n    A Python class that integrates with C++ logging functionality.\n    This class manages a Python logger and connects it to C++ logging streams.\n    \"\"\"\n\n    def __init__(self, name: str, *, level: int = logging.INFO, enable_cpp: bool = True):\n        \"\"\"\n        Initialize the logger with a specific name and level.\n\n        Args:\n            name: Name of the logger (appears in log output)\n            level: Minimum logging level\n            enable_cpp: If True, enables C++ logging integration\n        \"\"\"\n        self.name = name\n        self.is_destroyed = False  # Flag to track destruction\n\n        # Create the Python logger\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(level)\n\n        # Prevent the log messages from being handled by parent loggers\n        self.logger.propagate = False\n\n        # Remove existing handlers if any\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n\n        formatter = logging.Formatter(\"[%(asctime)s][%(name)s][%(threadName)s] %(levelname)s: %(message)s\")\n\n        # Add console handler\n        console_handler = logging.StreamHandler()\n        console_handler.setFormatter(formatter)\n        self.logger.addHandler(console_handler)\n\n        # Add file handler\n        # Check if user has root permissions\n        if os.geteuid() == 0:\n            # If user has root permissions, like on Raspberry Pi,\n            # use /var/log/cogip to allow log persistence\n            log_dir = Path(\"/var/log/cogip\")\n        else:\n            # If user does not have root permissions, like in Docker stack,\n            # use /tmp since no persistent storage is required\n            log_dir = Path(\"/tmp/cogip-logs\")\n        log_dir.mkdir(parents=True, exist_ok=True)\n        robot_id = os.getenv(\"ROBOT_ID\", \"X\")\n        file_handler = logging.handlers.RotatingFileHandler(\n            log_dir / f\"robot{robot_id}-{name}.log\",\n            maxBytes=10 * 1024 * 1024,\n            backupCount=5,\n        )\n        file_handler.setLevel(level)\n        file_handler.setFormatter(formatter)\n        self.logger.addHandler(file_handler)\n\n        # Add syslog handler\n        if Path(\"/dev/log\").exists():\n            syslog_handler = logging.handlers.SysLogHandler(address=\"/dev/log\")\n            syslog_handler.setLevel(level)\n            syslog_handler.setFormatter(formatter)\n            self.logger.addHandler(syslog_handler)\n\n        if enable_cpp:\n            self.enable_cpp_logging()\n\n        atexit.register(self.cleanup)  # Register cleanup function\n\n    def __del__(self):\n        self.cleanup()\n\n    def enable_cpp_logging(self):\n        \"\"\"Enable C++ logging integration.\"\"\"\n        if not self.is_destroyed:\n            cpp_logger.set_logger_callback(self.log_callback)\n\n    def cleanup(self):\n        \"\"\"Cleanup function to unregister the callback.\"\"\"\n        if not self.is_destroyed:\n            self.is_destroyed = True\n            cpp_logger.unset_logger_callback()  # Unregister the callback\n\n    def log_callback(self, message: str, level: cpp_logger.LogLevel):\n        \"\"\"\n        Callback function for C++ logging.\n        Routes C++ log messages to the appropriate Python logger method.\n\n        Args:\n            message: The log message from C++\n            level: Logging level from C++\n        \"\"\"\n        # Avoid processing if the logger is destroyed\n        if self.is_destroyed:\n            return\n        if not message:\n            return\n        logger_func = getattr(self.logger, level.name.lower(), self.logger.info)\n        logger_func(f\"[C++] {message}\")\n\n    def debug(self, message):\n        \"\"\"Log a debug message from Python\"\"\"\n        self.logger.debug(message)\n\n    def info(self, message):\n        \"\"\"Log an info message from Python\"\"\"\n        self.logger.info(message)\n\n    def warning(self, message):\n        \"\"\"Log a warning message from Python\"\"\"\n        self.logger.warning(message)\n\n    def error(self, message):\n        \"\"\"Log an error message from Python\"\"\"\n        self.logger.error(message)\n\n    def setLevel(self, level: int):\n        \"\"\"\n        Set the logging level for the logger.\n\n        Args:\n            level: The logging level to set\n        \"\"\"\n        self.logger.setLevel(level)\n        for handler in self.logger.handlers:\n            handler.setLevel(level)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.__init__","title":"<code>__init__(name, *, level=logging.INFO, enable_cpp=True)</code>","text":"<p>Initialize the logger with a specific name and level.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the logger (appears in log output)</p> required <code>level</code> <code>int</code> <p>Minimum logging level</p> <code>INFO</code> <code>enable_cpp</code> <code>bool</code> <p>If True, enables C++ logging integration</p> <code>True</code> Source code in <code>cogip/utils/logger.py</code> <pre><code>def __init__(self, name: str, *, level: int = logging.INFO, enable_cpp: bool = True):\n    \"\"\"\n    Initialize the logger with a specific name and level.\n\n    Args:\n        name: Name of the logger (appears in log output)\n        level: Minimum logging level\n        enable_cpp: If True, enables C++ logging integration\n    \"\"\"\n    self.name = name\n    self.is_destroyed = False  # Flag to track destruction\n\n    # Create the Python logger\n    self.logger = logging.getLogger(name)\n    self.logger.setLevel(level)\n\n    # Prevent the log messages from being handled by parent loggers\n    self.logger.propagate = False\n\n    # Remove existing handlers if any\n    for handler in self.logger.handlers[:]:\n        self.logger.removeHandler(handler)\n\n    formatter = logging.Formatter(\"[%(asctime)s][%(name)s][%(threadName)s] %(levelname)s: %(message)s\")\n\n    # Add console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    self.logger.addHandler(console_handler)\n\n    # Add file handler\n    # Check if user has root permissions\n    if os.geteuid() == 0:\n        # If user has root permissions, like on Raspberry Pi,\n        # use /var/log/cogip to allow log persistence\n        log_dir = Path(\"/var/log/cogip\")\n    else:\n        # If user does not have root permissions, like in Docker stack,\n        # use /tmp since no persistent storage is required\n        log_dir = Path(\"/tmp/cogip-logs\")\n    log_dir.mkdir(parents=True, exist_ok=True)\n    robot_id = os.getenv(\"ROBOT_ID\", \"X\")\n    file_handler = logging.handlers.RotatingFileHandler(\n        log_dir / f\"robot{robot_id}-{name}.log\",\n        maxBytes=10 * 1024 * 1024,\n        backupCount=5,\n    )\n    file_handler.setLevel(level)\n    file_handler.setFormatter(formatter)\n    self.logger.addHandler(file_handler)\n\n    # Add syslog handler\n    if Path(\"/dev/log\").exists():\n        syslog_handler = logging.handlers.SysLogHandler(address=\"/dev/log\")\n        syslog_handler.setLevel(level)\n        syslog_handler.setFormatter(formatter)\n        self.logger.addHandler(syslog_handler)\n\n    if enable_cpp:\n        self.enable_cpp_logging()\n\n    atexit.register(self.cleanup)  # Register cleanup function\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleanup function to unregister the callback.</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def cleanup(self):\n    \"\"\"Cleanup function to unregister the callback.\"\"\"\n    if not self.is_destroyed:\n        self.is_destroyed = True\n        cpp_logger.unset_logger_callback()  # Unregister the callback\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.debug","title":"<code>debug(message)</code>","text":"<p>Log a debug message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def debug(self, message):\n    \"\"\"Log a debug message from Python\"\"\"\n    self.logger.debug(message)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.enable_cpp_logging","title":"<code>enable_cpp_logging()</code>","text":"<p>Enable C++ logging integration.</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def enable_cpp_logging(self):\n    \"\"\"Enable C++ logging integration.\"\"\"\n    if not self.is_destroyed:\n        cpp_logger.set_logger_callback(self.log_callback)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.error","title":"<code>error(message)</code>","text":"<p>Log an error message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def error(self, message):\n    \"\"\"Log an error message from Python\"\"\"\n    self.logger.error(message)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.info","title":"<code>info(message)</code>","text":"<p>Log an info message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def info(self, message):\n    \"\"\"Log an info message from Python\"\"\"\n    self.logger.info(message)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.log_callback","title":"<code>log_callback(message, level)</code>","text":"<p>Callback function for C++ logging. Routes C++ log messages to the appropriate Python logger method.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The log message from C++</p> required <code>level</code> <code>LogLevel</code> <p>Logging level from C++</p> required Source code in <code>cogip/utils/logger.py</code> <pre><code>def log_callback(self, message: str, level: cpp_logger.LogLevel):\n    \"\"\"\n    Callback function for C++ logging.\n    Routes C++ log messages to the appropriate Python logger method.\n\n    Args:\n        message: The log message from C++\n        level: Logging level from C++\n    \"\"\"\n    # Avoid processing if the logger is destroyed\n    if self.is_destroyed:\n        return\n    if not message:\n        return\n    logger_func = getattr(self.logger, level.name.lower(), self.logger.info)\n    logger_func(f\"[C++] {message}\")\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.setLevel","title":"<code>setLevel(level)</code>","text":"<p>Set the logging level for the logger.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The logging level to set</p> required Source code in <code>cogip/utils/logger.py</code> <pre><code>def setLevel(self, level: int):\n    \"\"\"\n    Set the logging level for the logger.\n\n    Args:\n        level: The logging level to set\n    \"\"\"\n    self.logger.setLevel(level)\n    for handler in self.logger.handlers:\n        handler.setLevel(level)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.warning","title":"<code>warning(message)</code>","text":"<p>Log a warning message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def warning(self, message):\n    \"\"\"Log a warning message from Python\"\"\"\n    self.logger.warning(message)\n</code></pre>"},{"location":"reference/cogip/utils/singleton/","title":"singleton","text":""},{"location":"reference/cogip/utils/singleton/#cogip.utils.singleton.Singleton","title":"<code>Singleton</code>","text":"<p>               Bases: <code>type</code></p> <p>Meta class used to declare singleton</p> <p>Example:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Data(metaclass=Singleton):\n    name: str = \"\"\n\n\ndata = Data()\nprint(data)            # output: Data(name='')\ndata.name = \"foo\"\nprint(data)            # output: Data(name='foo')\nprint(Data())          # output: Data(name='foo')\nprint(data is Data())  # output: True\n</code></pre> Source code in <code>cogip/utils/singleton.py</code> <pre><code>class Singleton(type):\n    \"\"\"\n    Meta class used to declare singleton\n\n    Example:\n\n        from dataclasses import dataclass\n\n\n        @dataclass\n        class Data(metaclass=Singleton):\n            name: str = \"\"\n\n\n        data = Data()\n        print(data)            # output: Data(name='')\n        data.name = \"foo\"\n        print(data)            # output: Data(name='foo')\n        print(Data())          # output: Data(name='foo')\n        print(data is Data())  # output: True\n    \"\"\"\n\n    _instance = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instance:\n            cls._instance[cls] = super().__call__(*args, **kwargs)\n        return cls._instance[cls]\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/","title":"threadloop","text":""},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop","title":"<code>ThreadLoop</code>","text":"<p>This class creates a thread to execute a function in loop and wait after the function until the defined loop interval is reached. A warning is emitted if the function duration is longer than the loop interval.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>class ThreadLoop:\n    \"\"\"\n    This class creates a thread to execute a function in loop and wait after\n    the function until the defined loop interval is reached.\n    A warning is emitted if the function duration is longer than the loop\n    interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        interval: float,\n        func: Callable,\n        logger: bool | logging.Logger = False,\n        args: list[Any] | None = None,\n        kwargs: dict[str, Any] | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: Name to identify the thread in the logs\n            interval: time between each iteration of the loop, in seconds\n                      if 0, the function is supposed to have its own sleep time.\n                      if &lt; 0, like 0 but always display a loop duration\n            func: function to execute in the loop\n            logger: an optional custom logger\n            args: arguments of the function\n            kwargs: named arguments of the function\n        \"\"\"\n        self._name = name\n        self._interval = interval\n        self._func = func\n        self._args = args or []\n        self._kwargs = kwargs or {}\n        self._thread = threading.Thread(target=self.repeat)\n        self._cancel = False\n        self._logger = logging.getLogger(f\"ThreadLoop: {name}\")\n\n        if not isinstance(logger, bool):\n            self._logger = logger\n        else:\n            if self._logger.level == logging.NOTSET:\n                if logger:\n                    self._logger.setLevel(logging.INFO)\n                else:\n                    self._logger.setLevel(logging.ERROR)\n                self._logger.addHandler(logging.StreamHandler())\n\n    @property\n    def interval(self) -&gt; float:\n        return self._interval\n\n    @interval.setter\n    def interval(self, value: float) -&gt; None:\n        self._interval = value\n\n    def repeat(self) -&gt; None:\n        \"\"\"\n        Loop function executed in the thread.\n        \"\"\"\n        while not self._cancel:\n            start = time.time()\n            self._func(*self._args, **self._kwargs)\n            now = time.time()\n            duration = now - start\n            if self._interval &gt; 0:\n                if duration &gt; self._interval:\n                    self._logger.warning(f\"Function too long: {duration} &gt; {self._interval}\")\n                else:\n                    wait = self._interval - duration\n                    time.sleep(wait)\n            elif self._interval &lt; 0:\n                self._logger.info(f\"Function duration: {duration}\")\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the thread loop.\n        \"\"\"\n        if self._thread.is_alive():\n            self._logger.warning(f\"Already {'canceled' if self._cancel else 'running'}\")\n            return\n        if self._cancel:\n            self._thread = threading.Thread(target=self.repeat)\n            self._cancel = False\n        self._thread.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the thread loop.\n        \"\"\"\n        self._logger.debug(\"Stopping...\")\n        if self._thread.is_alive():\n            self._cancel = True\n            try:\n                self._thread.join()\n            except KeyboardInterrupt:\n                pass\n            self._logger.debug(\"Stopped.\")\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.__init__","title":"<code>__init__(name, interval, func, logger=False, args=None, kwargs=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the thread in the logs</p> required <code>interval</code> <code>float</code> <p>time between each iteration of the loop, in seconds       if 0, the function is supposed to have its own sleep time.       if &lt; 0, like 0 but always display a loop duration</p> required <code>func</code> <code>Callable</code> <p>function to execute in the loop</p> required <code>logger</code> <code>bool | Logger</code> <p>an optional custom logger</p> <code>False</code> <code>args</code> <code>list[Any] | None</code> <p>arguments of the function</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>named arguments of the function</p> <code>None</code> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    interval: float,\n    func: Callable,\n    logger: bool | logging.Logger = False,\n    args: list[Any] | None = None,\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: Name to identify the thread in the logs\n        interval: time between each iteration of the loop, in seconds\n                  if 0, the function is supposed to have its own sleep time.\n                  if &lt; 0, like 0 but always display a loop duration\n        func: function to execute in the loop\n        logger: an optional custom logger\n        args: arguments of the function\n        kwargs: named arguments of the function\n    \"\"\"\n    self._name = name\n    self._interval = interval\n    self._func = func\n    self._args = args or []\n    self._kwargs = kwargs or {}\n    self._thread = threading.Thread(target=self.repeat)\n    self._cancel = False\n    self._logger = logging.getLogger(f\"ThreadLoop: {name}\")\n\n    if not isinstance(logger, bool):\n        self._logger = logger\n    else:\n        if self._logger.level == logging.NOTSET:\n            if logger:\n                self._logger.setLevel(logging.INFO)\n            else:\n                self._logger.setLevel(logging.ERROR)\n            self._logger.addHandler(logging.StreamHandler())\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.repeat","title":"<code>repeat()</code>","text":"<p>Loop function executed in the thread.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def repeat(self) -&gt; None:\n    \"\"\"\n    Loop function executed in the thread.\n    \"\"\"\n    while not self._cancel:\n        start = time.time()\n        self._func(*self._args, **self._kwargs)\n        now = time.time()\n        duration = now - start\n        if self._interval &gt; 0:\n            if duration &gt; self._interval:\n                self._logger.warning(f\"Function too long: {duration} &gt; {self._interval}\")\n            else:\n                wait = self._interval - duration\n                time.sleep(wait)\n        elif self._interval &lt; 0:\n            self._logger.info(f\"Function duration: {duration}\")\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.start","title":"<code>start()</code>","text":"<p>Start the thread loop.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the thread loop.\n    \"\"\"\n    if self._thread.is_alive():\n        self._logger.warning(f\"Already {'canceled' if self._cancel else 'running'}\")\n        return\n    if self._cancel:\n        self._thread = threading.Thread(target=self.repeat)\n        self._cancel = False\n    self._thread.start()\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.stop","title":"<code>stop()</code>","text":"<p>Stop the thread loop.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the thread loop.\n    \"\"\"\n    self._logger.debug(\"Stopping...\")\n    if self._thread.is_alive():\n        self._cancel = True\n        try:\n            self._thread.join()\n        except KeyboardInterrupt:\n            pass\n        self._logger.debug(\"Stopped.\")\n</code></pre>"},{"location":"usage/beaconcam/","title":"Beaconcam","text":"<p>Not yet available.</p>"},{"location":"usage/camera/","title":"Camera","text":"<p>The <code>Camera</code> tool provides different commands to get information about cameras, calibrate them and detect Aruco tags.</p> <p>Use <code>--help</code> argument to show available commands:</p> <pre><code>$ cogip-camera --help\nUsage: cogip-camera [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -d, --debug           Turn on debug messages\n                        env var: COGIP_DEBUG, CAMERA_DEBUG\n\n  --help                Show this message and exit.\n\nCommands:\n  calibrate  Calibrate camera using images captured by the 'capture' command\n  capture    Capture images to be used by the 'calibrate' command\n  info       Get properties of connected cameras\n</code></pre>"},{"location":"usage/camera/#info-command","title":"Info Command","text":"<p>Display properties of connected cameras.</p> <p>If a camera name is provided, only display properties of this camera and preview its video stream. Codec, width and height arguments apply only in this context.</p> <pre><code>$ cogip-camera info --help\nUsage: cogip-camera info [OPTIONS]\n\n  Get properties of connected cameras\n\nOptions:\n  --camera-name [hbv|sonix]   Name of the camera (all if not specified)\n                              env var: CAMERA_NAME\n\n  --camera-codec [mjpg|yuyv]  Camera video codec\n                              env var: CAMERA_CODEC\n                              default: yuyv\n\n  --camera-width INTEGER      Camera frame width\n                              env var: CAMERA_WIDTH\n                              default: 640\n\n  --camera-height INTEGER     Camera frame height\n                              env var: CAMERA_HEIGHT\n                              default: 480\n\n  --help                      Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#capture-command","title":"Capture Command","text":"<p>Capture images to be used by the <code>calibrate</code> command.</p> <p>Use <code>--max-frames</code> and <code>--capture-interval</code> options to customize the number of images to capture and the frequency of capture.</p> <p>To be valid for calibration, the images must contained a charuco board with different orientations on each image. Use <code>--charuco-*</code> options to configure the Charuco board used for calibration.</p> <p>The captured images will be displayed after charuco board detection.</p> <p>The Charuco board generated for detection is also displayed for comparison with the board on images.</p> <p>Images are stored in <code>cameras/&lt;robot_id&gt;/&lt;camera_name&gt;_&lt;camera_codec&gt;_&lt;camera_width&gt;x&lt;camera_height&gt;/images</code>.</p> <pre><code>$ cogip-camera capture --help\nUsage: cogip-camera capture [OPTIONS]\n\n  Capture images to be used by the 'calibrate' command\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 640\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 480\n\n  --max-frames INTEGER            Maximum number of frames to read before exiting\n                                  env var: CAMERA_MAX_FRAMES\n                                  default: 120\n\n  --capture-interval INTEGER      Capture an image every 'capture_interval' frames\n                                  env var: CAMERA_CAPTURE_INTERVAL\n                                  default: 10\n\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: no-charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#calibrate-command","title":"Calibrate Command","text":"<p>Generate intrinsic calibration parameters using images recorded by the <code>capture</code> command.</p> <p>The parameter file is written in <code>cameras/&lt;robot_id&gt;/&lt;camera_name&gt;_&lt;camera_codec&gt;_&lt;camera_width&gt;x&lt;camera_height&gt;/params.yaml</code>.</p> <pre><code>$ cogip-camera calibrate --help\nUsage: cogip-camera calibrate [OPTIONS]\n\n  Calibrate camera using images captured by the 'capture' command\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 640\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 480\n\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: no-charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/cansend/","title":"cansend","text":"<p>Helper tool to send CAN command on a CAN bus using COGIP messages.</p> <p>Use <code>--help</code> argument to show available commands:</p> <pre><code>$ cogip-cansend --help\nUsage: cogip-cansend [OPTIONS]\n\nOptions:\n  -c, --can-channel TEXT      CAN channel connected to STM32 modules\n                              env var: CANSEND_CAN_CHANNEL\n                              default: vcan0\n\n  -b, --can-bitrate INTEGER   CAN bitrate\n                              env var: CANSEND_CAN_BITRATE\n                              default: 500000\n\n  -B, --data-bitrate INTEGER  CAN FD data bitrate\n                              env var: CANSEND_CANFD_DATA_BITRATE\n                              default: 1000000\n\n  -c, --commands FILENAME     YAML file containing\n                              env var: CANSEND_COMMANDS\n                              default: 1000000\n\n  --help                      Show this message and exit.\n</code></pre> <p>The list of commands to send is provided using a YAML file.</p> <p>The commands are defined in <code>cogip/models/actuators.py</code>, like ServoCommand and PositionalActuatorCommand.</p> <p>Enum attributes can be specified by their name or value.</p> <p>Example:</p> <pre><code>- kind: 0\n  id: LXSERVO_LEFT_CART\n  command: 100\n\n- kind: POSITIONAL\n  id: 2\n  command: 1\n</code></pre>"},{"location":"usage/copilot/","title":"Copilot","text":"<p>The <code>Copilot</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates with <code>mcu-firmware</code> on the robot's STM32 over a serial port using Protobuf messages.</p> <p>It communicates on the <code>/copilot</code> namespace of the SocketIO server running on the central beacon over Wifi.</p>"},{"location":"usage/copilot/#data-flow","title":"Data Flow","text":""},{"location":"usage/copilot/#run-copilot","title":"Run Copilot","text":"<pre><code>$ cogip-copilot\n</code></pre>"},{"location":"usage/copilot/#parameters","title":"Parameters","text":"<p><code>Copilot</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-copilot --help\nUsage: cogip-copilot [OPTIONS]\n\nOptions:\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, COPILOT_ID\n                                  default: 1; x&gt;=1\n\n  -p, --serial-port PATH          Serial port connected to STM32 device\n                                  env var: COPILOT_SERIAL_PORT\n                                  default: /dev/ttyUSB0\n\n  -b, --serial-baudrate INTEGER   Baud rate\n                                  env var: COPILOT_BAUD_RATE\n                                  default: 230400\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, COPILOT_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, COPILOT_DEBUG\n</code></pre>"},{"location":"usage/dashboard/","title":"Dashboard","text":"<p>The <code>Dashboard</code> is a web site displayed on the touchscreens embedded in the robots and on the beacon.</p> <p>The web server can also be accessed from any devices (PC, smartphones) connected to the same network.</p> <p>The web server listen on port <code>8080 + robot_id</code>, ie <code>8080</code> on beacon and <code>8081</code> on robot 1.</p> <p></p>"},{"location":"usage/dashboard/#data-flow","title":"Data Flow","text":""},{"location":"usage/detector/","title":"Detector","text":"<p>The <code>Detector</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates on the <code>/detector</code> namespace of the SocketIO server running on the central beacon over Wifi.</p> <p>It builds dynamic obstacles used by <code>Monitor</code>/<code>Dashboards</code> for display and by <code>mcu-firmware</code> to compute avoidance path.</p> <p><code>Detector</code> can operate in monitoring or emulation mode.</p>"},{"location":"usage/detector/#monitoring-mode","title":"Monitoring Mode","text":"<p>Read data from lidar connected on a serial port of the Raspberry Pi. This is the default mode when a Lidar is connected, since the YDLidar SDK automatically detects the serial port to use.</p>"},{"location":"usage/detector/#emulation-mode","title":"Emulation Mode","text":"<p>Ask the <code>Monitor</code> to emulate the Lidar which sends its data through the SocketIO server. The emulation mode is enabled if no Lidar is detected at startup. In case of a false detection, use the <code>--emulation</code> option.</p>"},{"location":"usage/detector/#data-flow","title":"Data Flow","text":""},{"location":"usage/detector/#run-detector","title":"Run Detector","text":"<pre><code>$ cogip-detector\n</code></pre>"},{"location":"usage/detector/#parameters","title":"Parameters","text":"<p><code>Detector</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-detector --help\nUsage: cogip-detector [OPTIONS]\n\nOptions:\n  -i, --robot-id INTEGER RANGE    Robot ID.\n                                  env var: ROBOT_ID, DETECTOR_ID\n                                  default: 1; x&gt;=1\n\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  -p, --lidar-port PATH           Serial port connected to the Lidar\n                                  env var: DETECTOR_LIDAR_PORT\n                                  default: None (autodetect)\n\n  --min-distance INTEGER          Minimum distance to detect an obstacle\n                                  env var: DETECTOR_MIN_DISTANCE\n                                  default: 150\n\n  --max-distance INTEGER          Maximum distance to detect an obstacle\n                                  env var: DETECTOR_MAX_DISTANCE\n                                  default: 2500\n\n  --min-intensity INTEGER         Minimum intensity to detect an obstacle\n                                  env var: DETECTOR_MIN_INTENSITY\n                                  default: 0; x&gt;=1; x&lt;=255\n\n  --refresh-interval FLOAT        Interval between each update of the obstacle list (in seconds)\n                                  env var: DETECTOR_REFRESH_INTERVAL\n                                  default: 0.1; x&gt;=-1.0; x&lt;=2.0\n\n  --sensor-delay INTEGER          Delay to compensate the delay between sensor data fetch and obstacle positions computation.\n                                  Unit is the index of pose current to get in the past\n                                  env var: DETECTOR_SENSOR_DELAY\n                                  default: 0; x&gt;=0; x&lt;=100\n\n  --cluster-min-samples INTEGER RANGE\n                                  Minimum number of samples to form a cluster\n                                  env var: DETECTOR_CLUSTER_MIN_SAMPLES\n                                  default: 4; 1&lt;=x&lt;=20\n\n  --cluster-eps FLOAT RANGE       Maximum distance between two samples to form a cluster (mm)\n                                  env var: DETECTOR_CLUSTER_EPS\n                                  default: 40.0; 1.0&lt;=x&lt;=100.0\n\n  -g, --gui                       Launch the GUI.\n                                  env var: DETECTOR_GUI\n\n  -w, --web                       Launch the web server.\n                                  env var: DETECTOR_WEB\n\n  -r, --reload                    Reload app on source file changes.\n                                  env var: COGIP_RELOAD, DETECTOR_RELOAD\n\n  -d, --debug                     Turn on debug messages.\n                                  env var: COGIP_DEBUG, DETECTOR_DEBUG\n</code></pre>"},{"location":"usage/monitor/","title":"Monitor","text":"<p>The <code>Monitor</code> is used to monitor the robot behavior during the game.</p> <p>It communicates on the <code>/monitor</code> and <code>/dashboard</code> namespaces of the SocketIO server running on the central beacon over Wifi.</p> <p>Only one <code>Monitor</code> can be connected to the SocketIO server at the same time.</p> <p>It can also provide fake Lidar data to <code>Detector</code> in emulation mode.</p> <p>The monitor provides a graphical interface, featuring:</p> <ul> <li> <p>a 3D view of the table and the robot</p> </li> <li> <p>a menu giving access to the planner menu and firmware's shell menu</p> </li> <li> <p>a button to add obstacles (in grey), move and resize them</p> </li> <li> <p>save and load obstacles using JSON files</p> </li> <li> <p>visualization of ToF (red dots) and LIDAR (blue dots) sensors detections</p> </li> <li> <p>visualization of obstacles detected using the Lidar (in transparent red)</p> </li> <li> <p>charts window to visualize calibration data</p> </li> <li> <p>dashboard window to visualize the <code>Dashboard</code></p> </li> <li> <p>different artifacts depending of current game rules</p> </li> </ul> <p></p> <p></p>"},{"location":"usage/monitor/#data-flow","title":"Data Flow","text":""},{"location":"usage/monitor/#run-monitor","title":"Run Monitor","text":"<p>To connect the <code>Monitor</code> to the <code>Server</code> running on the same development PC, run:</p> <pre><code>cogip-monitor http://localhost:8091\n</code></pre> <p>To connect the <code>Monitor</code> to the <code>Server</code> running on the Raspberry Pi in the robot, run:</p> <pre><code>cogip-monitor http://robot1:8091\n</code></pre> <p>Adapt URL and port depending on <code>Server</code> configuration</p>"},{"location":"usage/monitor/#command-line-options","title":"Command line options","text":"<pre><code>$ cogip-monitor --help\nUsage: cogip-monitor [URL]\n\n  Launch COGIP Monitor.\n\nArguments:\n  [URL]        Socket.IO Server URL\n               env var: COGIP_SOCKETIO_SERVER_URL\n               default: http://localhost:8091\n</code></pre>"},{"location":"usage/planner/","title":"Planner","text":"<p>The <code>Planner</code> tool is running on the Raspberry Pi embedded in the central beacon.</p> <p>It is in charge computing the strategy and giving orders to the robot during the game.</p> <p>It communicates on the <code>/planner</code> namespace of the SocketIO server.</p>"},{"location":"usage/planner/#data-flow","title":"Data Flow","text":""},{"location":"usage/planner/#run-planner","title":"Run Planner","text":"<pre><code>$ cogip-planner\n</code></pre>"},{"location":"usage/planner/#parameters","title":"Parameters","text":"<p><code>Planner</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-planner --help\nUsage: cogip-planner [OPTIONS]\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID\n                                  default: 1; x&gt;=1\n\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  --obstacle-radius INTEGER       Radius of a dynamic obstacle\n                                  env var: PLANNER_OBSTACLE_RADIUS\n                                  default: 500\n\n  --obstacle-bb-margin FLOAT      Obstacle bounding box margin in percent of the radius\n                                  env var: PLANNER_OBSTACLE_BB_MARGIN\n                                  default: 0.2\n\n  --obstacle-bb-vertices INTEGER  Number of obstacle bounding box vertices\n                                  env var: PLANNER_OBSTACLE_BB_VERTICES\n                                  default: 6\n\n  --obstacle-updater-interval FLOAT\n                                  Interval between each obstacles list update (in seconds)\n                                  env var: PLANNER_OBSTACLE_UPDATER_INTERVAL\n                                  default: 0.2\n\n  --path-refresh-interval FLOAT   Interval between each update of robot paths (in seconds)\n                                  env var: PLANNER_PATH_REFRESH_INTERVAL\n                                  default: 0.2\n\n  -bd, --bypass-detector          Use perfect obstacles from monitor instead of detected obstacles by Lidar\n                                  env var: PLANNER_BYPASS_DETECTOR\n                                  default: False\n\n  -sp, --scservos-port PATH       SC Servos serial port\n                                  env var: PLANNER_SCSERVOS_PORT\n                                  default: None\n\n  -sb, --scservos-baud-rate INTEGER\n                                  SC Servos baud rate (usually 921600 or 1000000)\n                                  env var: PLANNER_SCSERVOS_BAUD_RATE\n                                  default: 921600\n\n  -df, --scservos-baud-rate       Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance.\n                                  env var: PLANNER_DISABLE_FIXED_OBSTACLES\n                                  default: False\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, PLANNER_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, PLANNER_DEBUG\n</code></pre>"},{"location":"usage/replay/","title":"Replay","text":"<p>The replay tool is used to replay a game from a trace file.</p> <p></p> <p>After installation (see Install), the replay tool is launched with:</p> <pre><code>$ cogip-replay\n</code></pre> <p>The replay tool is used to replay a game from a trace file.</p>"},{"location":"usage/replay/#command-line-options","title":"Command line options","text":"<pre><code>$ $ cogip-replay --help\nUsage: cogip-replay [OPTIONS] [TRACE_FILE]\n\n  Starts replay.\n\nArguments:\n  [TRACE_FILE]\n\nOptions:\n  --help                          Show this message and exit.\n</code></pre> <p>The trace file can be given on the command line or loaded from the UI.</p>"},{"location":"usage/robotcam/","title":"RobotCam","text":"<p>The <code>RobotCam</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates on the <code>/robotcam</code> namespace of the SocketIO server running on the central beacon over Wifi.</p> <p>It handles the robot camera, detect game elements using Aruco markers and stream the video to a web server.</p> <p>The web server listen on port <code>8100 + robot_id</code>, ie <code>8100</code> on the beacon or <code>8101</code> on robot 1.</p>"},{"location":"usage/robotcam/#run-robotcam","title":"Run RobotCam","text":"<pre><code>$ cogip-robocam\n</code></pre>"},{"location":"usage/robotcam/#parameters","title":"Parameters","text":"<p>RobotCam default parameters can be modified using environment variables. All variables can be defined in the <code>.env</code> file.</p> <p>Example of <code>.env</code> file with all default values:</p> <pre><code># Socket.IO Server URL\nCOGIP_SOCKETIO_SERVER_URL=\"http://localhost:8091\"\n\n# Robot ID\nROBOTCAM_ID=1\n\n# Camera name\nROBOTCAM_CAMERA_NAME=\"hbv\"\n\n# Camera frame width\nROBOTCAM_CAMERA_WIDTH=640\n\n# Camera frame height\nROBOTCAM_CAMERA_HEIGHT=480\n\n# Camera video codec\nROBOTCAM_CAMERA_CODEC=\"yuyv\"\n\n# Number of uvicorn workers (ignored if launched by gunicorn)\nROBOTCAM_NB_WORKERS=1\n\n# Size of the shared memory storing the last frame to stream on server\n# (size for a frame in BMP format, black and white, 640x480 pixels)\nROBOTCAM_FRAME_SIZE=308316\n</code></pre>"},{"location":"usage/server/","title":"Server","text":"<p>The <code>Server</code> tool is running on the Raspberry Pi embedded in a robot.</p> <p>It implements a Socket.IO server on which all other tools from robot and central beacon are connected on their own namespace. This server is only used to redirect messages from a tool to another.</p> <p>The Socket.IO server listen on port <code>8090 + robot_id</code>, ie <code>8091</code> on robot 1.</p>"},{"location":"usage/server/#run-server","title":"Run Server","text":"<pre><code>$ cogip-server\n</code></pre>"},{"location":"usage/server/#parameters","title":"Parameters","text":"<p><code>Server</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-server --help\nUsage: cogip-server [OPTIONS]\n\n  --id , -i INTEGER RANGE         Robot ID\n                                  env var: ROBOT_ID, SERVER_ID\n                                  default: 0; 0&lt;=x&lt;=9\n\n  --dashboard_update_interval FLOAT RANGE\n                                  Interval between messages to dashboard (in seconds)\n                                  env var: SERVER_DASHBOARD_UPDATE_INTERVAL\n                                  default: 0.2\n\n  --record-dir PATH               Directory where games will be recorded\n                                  env var: SERVER_RECORD_DIR\n                                  default: /var/tmp/cogip\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, PLANNER_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, PLANNER_DEBUG\n</code></pre>"},{"location":"usage/server_beacon/","title":"Beacon Server","text":"<p>The <code>Beacon Server</code> tool is running on the Raspberry Pi embedded in the central beacon.</p> <p>It implements a Socket.IO server connected to the <code>Beacon Dashboard</code>.</p> <p>The Socket.IO server listens on port <code>8090</code>.</p> <p>It also implements Socket.IO clients connected to the Socket.IO server of each robot.</p> <p>Socket.IO clients consider that robot hostnames are <code>robot1</code> to <code>robotN</code>, resolved by the DNS server or defined in <code>/etc/hosts</code> and their ports are <code>8090 + robot_id</code>.</p>"},{"location":"usage/server_beacon/#run-server","title":"Run Server","text":"<pre><code>$ cogip-server-beacon\n</code></pre>"},{"location":"usage/server_beacon/#parameters","title":"Parameters","text":"<p><code>Beacon Server</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-server --help\nUsage: cogip-server [OPTIONS]\n\n  --max-robots                    Maximum number of robots to detect (from 1 to max)\n                                  env var: SERVER_BEACON_MAX_ROBOTS\n                                  default: 4; x&gt;=1\n\n  --record-dir PATH               Directory where games will be recorded\n                                  env var: SERVER_BEACON_RECORD_DIR\n                                  default: /var/tmp/cogip\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, SERVER_BEACON_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, SERVER_BEACON_DEBUG\n</code></pre>"}]}