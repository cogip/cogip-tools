{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>This repository provides all Python tools developed by the COGIP robotic team. The team is developing a robot for Eurobot, French robotic contest.</p> <p>All the tools are used during the game itself, or for development, debugging and monitoring of the robot and other test platforms.</p>"},{"location":"#robot-software-architecture","title":"Robot Software Architecture","text":"<p>The main components of the robot are:</p> <ul> <li>a STM32 that runs <code>mcu-firmware</code>,</li> <li>a Raspberry Pi 4 that controls a camera, a touchscreen and a Lidar.</li> </ul> <p>The robot is associated with a central beacon having an upper view of the game area, composed of a Raspberry Pi 4, a camera and a touchscreen.</p> <p></p> <p>Tools running on the robot's Raspberry Pi 4 are:</p> <ul> <li><code>Server</code> connecting all components through a SocketIO server.</li> <li><code>Dashboard</code> a web server providing a dashboard to control and monitor the robot.</li> <li><code>Planner</code> in charge of the game strategy.</li> <li><code>Copilot</code> driving the robot moves by communicating     with <code>mcu-firmware</code> (on STM32) using Protobuf messages over a serial port.</li> <li><code>Detector</code> generating obstacles based on Lidar data.</li> <li><code>Robotcam</code> reading and analyzing images from the camera.</li> </ul> <p>Tools running on the central beacon's Raspberry Pi 4 are:</p> <ul> <li><code>Server Beacon</code> connecting all beacon components through a SocketIO server,   and connected to the SocketIO server of all robots.     It also runs a web server providing a <code>Dashboard</code> to control and monitor the robot.</li> <li><code>Dashboard</code>, a web server providing a dashboard to control and monitor the beacon, and display the dashboard of all robots.</li> <li><code>Beaconcam</code> reading and analyzing images of the game area from the camera.</li> </ul> <p>Beacon services will be redesigned and are not yet available. Robots can run standalone.</p> <p><code>Monitor</code> is running on a PC connected to the SocketIO server.</p> <p><code>Camera</code> provides different commands to get information about cameras, calibrate them and detect Aruco tags.</p> <p>The touchscreens display the <code>Dashboard</code> using an web browser embedded in the Raspberry Pi.</p>"},{"location":"#emulation-software-architecture","title":"Emulation Software Architecture","text":"<p>During development, an emulation environment is also available. In this case, all robot and beacon components are running on the development PC.</p> <p></p> <p>In this mode, fake Lidar data are provided by the <code>Monitor</code>.</p>"},{"location":"install/","title":"Setup","text":"<p>There are two ways to setup the environment to develop and run the tools.</p> <ul> <li> <p>The Manual method requires to configure the environment on the development computer and to run tools one by one. This method also briefly explains how to build the firmware for the real MCU.</p> </li> <li> <p>The Docker method provides a complete Docker Compose stack that configure, compile and run each tool using only one command.</p> </li> </ul> <p>To prepare SDCards for Raspberry Pi SDCards for robots and beacon, refer to the Raspberry Pi OS section.</p>"},{"location":"install/#common-setup","title":"Common Setup","text":""},{"location":"install/#os","title":"OS","text":"<p>Linux only.</p> <p>Tested on Ubuntu 25.10.</p>"},{"location":"install/#debian-packages","title":"Debian packages","text":"<pre><code>sudo apt install git build-essential\n</code></pre>"},{"location":"install/#git-submodules","title":"Git Submodules","text":"<p>The tools depend on the compatible version of cogip/mcu-firmware which also depends on a specific version of RIOT-OS/RIOT. So to avoid struggle in finding the correct versions of the dependencies, we use git submodules to fix the versions of <code>mcu-firmware</code> and <code>RIOT</code>. Do not forget to fetch the submodules after <code>git clone</code>:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"install/#manual-method","title":"Manual Method","text":""},{"location":"install/#debian-packages_1","title":"Debian packages","text":"<pre><code>sudo apt install libxcb-xinerama0 socat protobuf-compiler build-essential swig cmake pkg-config libserial-dev liblgpio-devg libsystemd-dev\n</code></pre>"},{"location":"install/#build-mcu-firmware","title":"Build mcu-firmware","text":"<p>See the <code>Requirements</code> section of <code>submodules/mcu-firmware/README.md</code> to setup the build environment.</p> <p>Use the following command to build the native version of the firmware:</p>"},{"location":"install/#native-build","title":"Native build","text":"<pre><code>make -C submodules/mcu-firmware/applications/cup2023 BOARD=cogip-native\n</code></pre>"},{"location":"install/#arm-build","title":"ARM build","text":"<p>Use the following command to build the ARM version of the firmware:</p> <pre><code>make -C submodules/mcu-firmware/applications/cup2023 BOARD=cogip-board-ng\n</code></pre>"},{"location":"install/#installation","title":"Installation","text":"<p>All tools can be installed on the development PC.</p> <p>Python installation is managed by uv, so it is independent from Python version provided by the OS.</p> <ul> <li>Install uv following the official documentation, like with the following command:</li> </ul> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Read carefully advices to make uv accessible on your PATH.</p> <ul> <li>Install the package in dev/editable mode (default mode for uv):</li> </ul> <pre><code>uv sync\n</code></pre>"},{"location":"install/#linting-and-formatting","title":"Linting and Formatting","text":"<p>While installing the <code>dev</code> environment, <code>ruff</code> and <code>pre-commit</code> package have been installed.</p> <p>To run <code>ruff</code> manually, just run:</p> <pre><code>uv run ruff check [--fix]\nuv run ruff format\n</code></pre> <p>To enable pre-commit hooks prevent committing code not respecting linting and formatting rules, run:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#packaging-and-deployment","title":"Packaging and Deployment","text":"<p>This section explains how to build a new binary package and deploy it on a Raspberry Pi.</p> <p>A Docker Compose service is provided to build a binary distribution package for linux/arm64 platform.</p> <pre><code>docker compose up --build build_wheel\n</code></pre> <p>This will produce <code>dist/cogip_tools-1.0.0-cp313-abi3-linux_aarch64.whl</code>.</p> <p>This package can be copied to the Raspberry Pi and installed to deploy the Python tools:</p> <pre><code>uv pip install cogip_tools-1.0.0-cp313-abi3-linux_aarch64.whl\n</code></pre> <p>Docker image for linux/arm64</p> <p>The <code>build_wheel</code> service is based on a image built from a Ubuntu image. If this image was already pulled for the <code>linux/amd64</code> platform, the <code>linux/arm64</code> may not be pulled automatically. If the <code>docker compose</code> command is failing for this reason, the required image can be pulled manually: <code>bash docker pull --platform \"linux/arm64\" debian:13</code></p>"},{"location":"install/#docker-method","title":"Docker Method","text":""},{"location":"install/#docker-installation","title":"Docker Installation","text":"<p>See Docker installation instructions.</p>"},{"location":"install/#virtual-can-interface-setup","title":"Virtual CAN Interface Setup","text":"<p><code>Firmware</code> communicates with <code>Copilot</code> using a CAN interface. In emulation mode, a virtual CAN interface (<code>vcan</code>) must be configured on host for each robot before running the Compose stack.</p> <p>Configure <code>vcan1</code> using the two following files:</p> <ul> <li><code>/etc/systemd/network/80-vcan.network</code></li> </ul> <pre><code>[Match]\nName=vcan*\n\n[CAN]\nBitRate=500000\nDataBitRate=1000000\nSamplePoint=87.5%\nFDMode=yes\n</code></pre> <ul> <li><code>/etc/systemd/network/vcan1.netdev</code></li> </ul> <pre><code>[NetDev]\nName=vcan1\nKind=vcan\nMTUBytes=72\nDescription=Virtual CAN1 network interface\n</code></pre> <p>Up to 5 robots are supported, so 5 vcan interfaces are required. Create a <code>vcanX.netdev</code> for each interfaces from <code>vcan1</code> to <code>vcan5</code>.</p> <p>Restart systemd-networkd service to setup:</p> <pre><code>sudo systemctl restart systemd-networkd\n</code></pre> <p>Check <code>vcan</code> interfaces are up:</p> <pre><code>$ networkctl | grep vcan\n  3 vcan1           can      carrier     configured\n  3 vcan2           can      carrier     configured\n  3 vcan3           can      carrier     configured\n  3 vcan4           can      carrier     configured\n  3 vcan5           can      carrier     configured\n\n$ ip address show dev vcan1\n3: vcan0: &lt;NOARP,UP,LOWER_UP&gt; mtu 72 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/can\n</code></pre>"},{"location":"install/#x-server","title":"X Server","text":"<p>The <code>Monitor</code> is working with X11 but does not behave correctly with Wayland.</p> <p>To allow the <code>Monitor</code> process running in a Docker container to access the X Server running on the host, you need to run the following command in a terminal:</p> <p><code>$ xhost +local:</code></p>"},{"location":"install/#configuration","title":"Configuration","text":"<p>The configuration of the tools is done by setting environment variables in the <code>.env</code> file.</p> <p>All variables supported by the tools are forwarded inside Docker containers.</p>"},{"location":"install/#usergroup-ids-mapping","title":"User/Group IDs Mapping","text":"<p>The user/group ID used inside Docker containers to run COGIP tools must match those of the host system to ensure that shared memory segments created by the tools are owned by the same user/group as on the host.</p> <p>Default UID/GID is <code>1000</code>, change them if needed in the <code>.env</code> file:</p> <pre><code>UID=1001\nGID=1001\n</code></pre>"},{"location":"install/#compose-profiles","title":"Compose Profiles","text":"<p>Several profiles are defined to select which containers to run:</p> <ul> <li><code>beacon</code>: for the beacon container</li> <li><code>robotX</code>: for robot X containers (1 &lt;= X &lt;= 5)</li> <li><code>monitorX</code>: for <code>Monitor</code> container of robot X (1 &lt;= X &lt;= 5)</li> </ul> <p>Profiles are set in the <code>.env</code> file:</p> <p><code>COMPOSE_PROFILES=beacon,robot1,robot2</code></p>"},{"location":"install/#build-images","title":"Build Images","text":"<p>Build Docker images:</p> <p><code>docker compose build</code></p>"},{"location":"install/#run-all-tools","title":"Run All Tools","text":"<p>Start the Compose stack:</p> <p><code>docker compose up</code></p> <p>Use <code>--build</code> option to build images and start the stack:</p> <p><code>docker compose up --build</code></p>"},{"location":"install/#automatic-restart-on-changes","title":"Automatic Restart on Changes","text":"<p>To automatically restart the services on Python source files changes or rebuild C++ extensions on C++ source files changes, use the <code>--watch</code> option:</p> <p><code>docker compose up --build --watch</code></p>"},{"location":"install/#dashboards-access","title":"Dashboards Access","text":"<p>The <code>Beacon Dashboard</code> (if enabled in <code>.env</code>) is accessible using a web browser at <code>http://localhost:8080</code>.</p> <p>The <code>Dashboard</code> for robot X (if enabled in <code>.env</code>) is accessible using a web browser at <code>http://localhost:808X</code>.</p>"},{"location":"install/#running-monitor","title":"Running Monitor","text":"<p>Instead of running <code>Monitor</code> from the Compose stack, it can be launched for robot X (if enabled in <code>.env</code>) with:</p> <pre><code>uv run cogip-monitor http://localhost:809X\n</code></pre>"},{"location":"raspios/","title":"Raspberry Pi OS Customization","text":"<p>The <code>raspios</code> directory provides a series of scripts to build and flash a custom Raspberry Pi OS images running COGIP tools on the Pi 4 embedded in the beacon and robots.</p> <p>It works by creating a Docker image based on Raspberry Pi OS Lite, use Dockerfiles to install/configure/remove softwares and services, extract and build the customized image, and flash it on a SDCard.</p>"},{"location":"raspios/#network-configuration","title":"Network Configuration","text":"<p>Default network configuration is represented on the following schema:</p> <p></p>"},{"location":"raspios/#requirements","title":"Requirements","text":"<ul> <li>Docker</li> </ul> <p>See Docker installation instructions.</p> <ul> <li>ARM Emulation</li> </ul> <pre><code>$ sudo apt-get install binfmt-support qemu-user-static zerofree\n$ docker run --rm --privileged tonistiigi/binfmt --install all\n</code></pre>"},{"location":"raspios/#configuration","title":"Configuration","text":"<p>Two configuration profiles are provided:   - <code>cup</code>: a configuration for the cup, to setup robots and beacon   - <code>dev</code>: a configuration for development environment without beacon Select a profile by setting the <code>PROFILE</code> variable to either <code>cup</code> or <code>dev</code>.</p> <p>The following variables must be set before running any script:   - ROBOT_ID   - PUBLIC_WLAN_SSID   - PUBLIC_WLAN_PSK Those variables are set to <code>NOT_SET</code> by default and will be checked will loading the config files.</p> <p><code>ROBOT_ID</code> possible values:   - 0:   for the beacon   - 1-9: for the robots</p> <p>The PSK value can be generated from the WiFi password using the following command:</p> <pre><code>$ wpa_passphrase MYSSID passphrase\nnetwork={\n        ssid=\"MYSSID\"\n        #psk=\"passphrase\"\n        psk=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d\n}\n</code></pre> <p>The micro SD card device can be customized using related environment variables Example for micro-SD card to SD card adapter on <code>/dev/mmcblk0</code> (default values):</p> <pre><code>SDCARD_DEV=/dev/mmcblk0\nSDCARD_DEV_BOOT=${SDCARD_DEV}p1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}p2\n</code></pre> <p>Example for micro-SD card to USB adapter on <code>/dev/sda</code>:</p> <pre><code>SDCARD_DEV=/dev/sda\nSDCARD_DEV_BOOT=${SDCARD_DEV}1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}2\n</code></pre> <p>Customized variables can be set in the environment or in a local, not-committed <code>.env</code> file in the <code>raspios</code> directory.</p> <p>Example of a complete <code>.env</code> file:</p> <pre><code>PROFILE=dev\nROBOT_ID=1\nPUBLIC_WLAN_SSID=MYSSID\nPUBLIC_WLAN_PSK=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d\nSDCARD_DEV=/dev/sda\nSDCARD_DEV_BOOT=${SDCARD_DEV}1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}2\n</code></pre>"},{"location":"raspios/#stage-0","title":"Stage 0","text":"<p>First stage builds a docker image from original Raspios image.</p> <pre><code>$ ./stage0_base_image.sh\n</code></pre>"},{"location":"raspios/#stage-1","title":"Stage 1","text":"<p>Build a customized docker image:  - install required Debian and Python packages  - configure required services  - install COGIP tools</p> <pre><code>$ ./stage1_customize_image.sh\n</code></pre>"},{"location":"raspios/#stage-1b-under-development","title":"Stage 1b (under development)","text":"<p>This stage is optional and allow to build a custom kernel image. It is not working yet so not documented.</p>"},{"location":"raspios/#stage-2","title":"Stage 2","text":"<p>Create the custom filesystem image.</p> <pre><code>$ ./stage2_create_image.sh\n</code></pre>"},{"location":"raspios/#stage-3","title":"Stage 3","text":"<p>Flash the filesystem image on SDCard.</p> <pre><code>$ ./stage3_flash_image.sh\n</code></pre>"},{"location":"developers/dashboard/","title":"Dashboard documentation","text":"<p>The dashboard is written with vanilla JS, CSS and HTML (and love). We made the choice to not used any frameworks like Angular or Vue.js... because dashboard is a very small web site.</p> <p>This dashboard uses only two externals frameworks, which are TailwindCSS and Socket.io.</p> <p>Socket.io is useful to dynamically receive events from Copilot and display them.</p> <p>TailwindCSS is a utility-first CSS framework packed with classes like flex, pt-4, text-center and rotate-90 that can be composed to build any design.</p> <p>The manipulation below needs to be done each time we add or remove a class in html, css or js files in server.</p> <p>This command line has to be executed in <code>cogip-tools/cogip/tools/dashboard</code>.</p> <ol> <li> <p>Install npm    <code>sudo apt install npm</code></p> </li> <li> <p>Install PurgeCSS as CLI (you may need to be super user)    <code>npm install</code></p> </li> <li> <p>Run command to generate css file according to what we use in our html, js and css files    <code>npx tailwindcss -i cogip/tools/dashboard/static/css/input.css -o cogip/tools/dashboard/static/css/prod/output.css --watch --minify</code></p> </li> </ol> <p>Useful documentation:</p> <p>- https://purgecss.com/CLI.html</p>"},{"location":"developers/developers/","title":"Developer's Documentation","text":"<p>This documentation provides information for developers who would like to contribute to the project. It tries to explain how modules are organized and how <code>PySide6</code> and <code>Qt3D</code> are used.</p> <p>COGIP tools are developed in Python 3.12+, using <code>Pyside6</code>, the Qt for Python package.</p> <p>The 3D view is based on the <code>Qt3D framework</code>. To have a better understanding of the code, it is important to understand Qt concepts like Signals and Slots, and the Qt3D Entity Component System (ECS).</p> <p>Here are some interesting blogs and docs to understand the Qt3D architecture:</p> <ul> <li>https://doc.qt.io/qt-6/qt3d-overview.html#qt-3d-architecture</li> <li>https://www.kdab.com/overview-qt3d-2-0-part-1/</li> <li>https://www.kdab.com/overview-qt3d-2-0-part-2/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-1-guido-piasenza/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-2-guido-piasenza/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-3-guido-piasenza/</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cogip<ul> <li>models<ul> <li>actuators</li> <li>artifacts</li> <li>firmware_parameter</li> <li>firmware_telemetry</li> <li>models</li> <li>odometry_calibration</li> </ul> </li> <li>scservo_sdk<ul> <li>group_sync_read</li> <li>group_sync_write</li> <li>port_handler</li> <li>protocol_packet_handler</li> <li>scscl</li> <li>scservo_def</li> <li>sms_sts</li> </ul> </li> <li>tools<ul> <li>beaconcam<ul> <li>__main__</li> <li>app</li> <li>camera</li> <li>codecs</li> <li>main</li> <li>server</li> <li>settings</li> </ul> </li> <li>camera<ul> <li>__main__</li> <li>arguments</li> <li>calibrate</li> <li>camera</li> <li>capture</li> <li>charuco</li> <li>detect</li> <li>info</li> <li>utils</li> </ul> </li> <li>cansend<ul> <li>__main__</li> </ul> </li> <li>copilot<ul> <li>__main__</li> <li>controller</li> <li>copilot</li> <li>menu</li> <li>pbcom</li> <li>pid</li> <li>sio_events</li> </ul> </li> <li>cpp_cython_example<ul> <li>__main__</li> </ul> </li> <li>cpp_logger_example<ul> <li>__main__</li> </ul> </li> <li>cpp_nanobind_example<ul> <li>__main__</li> </ul> </li> <li>cpp_shm_example<ul> <li>__main__</li> </ul> </li> <li>dashboard<ul> <li>__main__</li> <li>app</li> <li>dashboard</li> <li>routes<ul> <li>beacon</li> </ul> </li> </ul> </li> <li>detector<ul> <li>__main__</li> <li>check_lidar_status</li> <li>detector</li> <li>gui</li> <li>menu</li> <li>properties</li> <li>sio_events</li> <li>web</li> </ul> </li> <li>firmware_odometry_calibration<ul> <li>__main__</li> <li>calculator</li> <li>firmware_adapter</li> <li>odometry_calibration</li> <li>sio_events</li> <li>types</li> </ul> </li> <li>firmware_parameter_manager<ul> <li>__main__</li> <li>firmware_parameter_manager</li> <li>sio_events</li> </ul> </li> <li>firmware_telemetry<ul> <li>__main__</li> <li>firmware_telemetry_manager</li> <li>sio_events</li> </ul> </li> <li>lidar_ld19<ul> <li>__main__</li> <li>gui</li> <li>web</li> </ul> </li> <li>mcu_logger<ul> <li>__main__</li> </ul> </li> <li>monitor<ul> <li>__main__</li> <li>artifacts<ul> <li>artifacts</li> </ul> </li> <li>main</li> <li>obstacle</li> <li>robots<ul> <li>ninja_manual</li> <li>pami_manual</li> <li>robot</li> <li>robot_manual</li> <li>robot_order</li> </ul> </li> <li>shared_memory</li> <li>sio_client</li> <li>table</li> <li>view3D</li> </ul> </li> <li>planner<ul> <li>__main__</li> <li>actions<ul> <li>action</li> <li>action_align</li> <li>action_build_tribune_x1</li> <li>action_build_tribune_x2</li> <li>action_build_tribune_x3</li> <li>action_capture_tribune</li> <li>action_drop_banner</li> <li>action_parking</li> <li>action_wait</li> <li>camera_calibration</li> <li>pami</li> <li>pid_position_test</li> <li>pid_speed_test</li> <li>strategy</li> <li>test_align_bottom</li> <li>test_align_bottom_banner</li> <li>test_approval</li> <li>test_back_and_forth</li> <li>test_drop_banner</li> <li>test_game_1</li> <li>test_game_2</li> <li>test_rectangle_alternating</li> <li>test_squares</li> <li>test_tribunes_1x2</li> <li>test_tribunes_1x3</li> <li>test_tribunes_2x1</li> <li>test_tribunes_2x2</li> <li>test_tribunes_2x3</li> <li>test_tribunes_4x1</li> <li>test_visit_starting_areas</li> <li>utils</li> </ul> </li> <li>actuators</li> <li>avoidance<ul> <li>avoidance</li> <li>process</li> </ul> </li> <li>cameras</li> <li>camp</li> <li>context</li> <li>event_manager</li> <li>menu</li> <li>planner</li> <li>pose</li> <li>properties</li> <li>scservos</li> <li>sio_events</li> <li>start_positions</li> <li>table</li> <li>wizard</li> </ul> </li> <li>robotcam<ul> <li>__main__</li> <li>app</li> <li>camera</li> <li>main</li> <li>server</li> <li>settings</li> </ul> </li> <li>scservo<ul> <li>__main__</li> <li>common</li> <li>ping</li> <li>read</li> <li>reg_write</li> <li>sync_write</li> <li>wheel</li> <li>write</li> </ul> </li> <li>server<ul> <li>__main__</li> <li>app</li> <li>context</li> <li>namespaces<ul> <li>beacon</li> <li>copilot</li> <li>dashboard</li> <li>detector</li> <li>firmware_calibration</li> <li>firmware_parameters</li> <li>firmware_telemetry</li> <li>monitor</li> <li>planner</li> <li>robotcam</li> </ul> </li> <li>server</li> </ul> </li> <li>server_beacon<ul> <li>__main__</li> <li>app</li> <li>menu</li> <li>namespaces<ul> <li>dashboard</li> </ul> </li> <li>robot</li> <li>server</li> </ul> </li> <li>ydlidar_g2<ul> <li>__main__</li> <li>gui</li> <li>web</li> </ul> </li> </ul> </li> <li>utils<ul> <li>argenum</li> <li>asyncloop</li> <li>console_ui</li> <li>fnv1a</li> <li>lidartablemodel</li> <li>logger</li> <li>mock</li> <li>singleton</li> <li>threadloop</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cogip/models/actuators/","title":"actuators","text":""},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ActuatorBase","title":"<code>ActuatorBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ActuatorBase(BaseModel):\n    \"\"\"Base model for actuators\"\"\"\n\n    enabled: bool = Field(\n        False,\n        title=\"Enabled\",\n        description=\"An actuator is enabled if it has been initialized with its current value\",\n    )\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ActuatorsKindEnum","title":"<code>ActuatorsKindEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining actuators kind</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ActuatorsKindEnum(IntEnum):\n    \"\"\"Enum defining actuators kind\"\"\"\n\n    servo = 0\n    positional_actuator = 1\n    bool_sensor = 2\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.BoolSensor","title":"<code>BoolSensor</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining bool sensor state</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class BoolSensor(BaseModel):\n    \"\"\"Model defining bool sensor state\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.bool_sensor] = ActuatorsKindEnum.bool_sensor\n    id: Annotated[\n        BoolSensorEnum,\n        Field(\n            title=\"Id\",\n            description=\"Bool sensor identifier\",\n        ),\n    ]\n    state: Annotated[\n        bool,\n        Field(\n            title=\"State\",\n            description=\"Bool sensor state\",\n        ),\n    ] = False\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.BoolSensorEnum","title":"<code>BoolSensorEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining bool sensors IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class BoolSensorEnum(IntEnum):\n    \"\"\"Enum defining bool sensors IDs\"\"\"\n\n    UNDEFINED = 0\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuator","title":"<code>PositionalActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>PositionalActuatorCommand</code></p> <p>Full model for positional actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuator(ActuatorBase, PositionalActuatorCommand):\n    \"Full model for positional actuators\"\n\n    pass\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorCommand","title":"<code>PositionalActuatorCommand</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining a command to send to positional actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuatorCommand(BaseModel):\n    \"\"\"Model defining a command to send to positional actuators\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.positional_actuator] = ActuatorsKindEnum.positional_actuator\n    id: PositionalActuatorEnum = Field(..., title=\"Id\", description=\"Positional Actuator identifier\")\n    command: int = Field(\n        0,\n        ge=-100,\n        le=999,\n        title=\"Position Command\",\n        description=\"Current positional actuator position command\",\n    )\n    speed: int = Field(\n        100,\n        ge=1,\n        le=100,\n        title=\"Speed\",\n        description=\"Speed\",\n    )\n    timeout: int = Field(\n        2000,\n        ge=100,\n        le=5000,\n        title=\"Timeout\",\n        description=\"Timeout\",\n    )\n\n    @field_validator(\"kind\", mode=\"before\")\n    @classmethod\n    def validate_kind(cls, v: str) -&gt; ActuatorsKindEnum:\n        try:\n            value = ActuatorsKindEnum[v]\n        except KeyError:\n            try:\n                value = ActuatorsKindEnum(v)\n            except Exception:\n                raise ValueError(\"Not a ActuatorsKindEnum\")\n        if value != ActuatorsKindEnum.positional_actuator:\n            raise ValueError(\"Not ActuatorsKindEnum.positional_actuator value\")\n        return value\n\n    @field_validator(\"id\", mode=\"before\")\n    @classmethod\n    def validate_id(cls, v: str) -&gt; PositionalActuatorEnum:\n        try:\n            return PositionalActuatorEnum[v]\n        except KeyError:\n            try:\n                return PositionalActuatorEnum(v)\n            except Exception:\n                raise ValueError(\"Not a PositionalActuatorEnum\")\n\n    def pb_copy(self, message: PB_PositionalActuatorCommand) -&gt; None:\n        \"\"\"Copy values to Protobuf message\"\"\"\n        message.id = self.id\n        message.command = self.command\n        message.speed = self.speed\n        message.timeout = self.timeout\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorCommand.pb_copy","title":"<code>pb_copy(message)</code>","text":"<p>Copy values to Protobuf message</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>def pb_copy(self, message: PB_PositionalActuatorCommand) -&gt; None:\n    \"\"\"Copy values to Protobuf message\"\"\"\n    message.id = self.id\n    message.command = self.command\n    message.speed = self.speed\n    message.timeout = self.timeout\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorEnum","title":"<code>PositionalActuatorEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining positional actuators IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuatorEnum(IntEnum):\n    \"\"\"Enum defining positional actuators IDs\"\"\"\n\n    MOTOR_LIFT = 0\n</code></pre>"},{"location":"reference/cogip/models/artifacts/","title":"artifacts","text":""},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionArea","title":"<code>ConstructionArea</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Model for construction area. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionArea(Pose):\n    \"\"\"\n    Model for construction area.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    id: ConstructionAreaID\n    length: float\n    width: float = 450\n    tribune_level: int = 0\n    enabled: bool = True\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionAreaID","title":"<code>ConstructionAreaID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify construction areas.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionAreaID(IntEnum):\n    \"\"\"\n    Enum to identify construction areas.\n    \"\"\"\n\n    LocalBottomSmall = auto()\n    LocalBottomLarge1 = auto()\n    LocalBottomLarge2 = auto()\n    LocalBottomLarge3 = auto()\n    OppositeBottomSmall = auto()\n    OppositeSideLarge1 = auto()\n    OppositeSideLarge2 = auto()\n    OppositeSideLarge3 = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionAreaLarge","title":"<code>ConstructionAreaLarge</code>","text":"<p>               Bases: <code>ConstructionArea</code></p> <p>Model for large construction area. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionAreaLarge(ConstructionArea):\n    \"\"\"\n    Model for large construction area.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    length: float = 450\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.ConstructionAreaSmall","title":"<code>ConstructionAreaSmall</code>","text":"<p>               Bases: <code>ConstructionArea</code></p> <p>Model for small construction area. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class ConstructionAreaSmall(ConstructionArea):\n    \"\"\"\n    Model for small construction area.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    length: float = 150\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.FixedObstacle","title":"<code>FixedObstacle</code>","text":"<p>               Bases: <code>Vertex</code></p> <p>Model for fixed obstacles.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class FixedObstacle(Vertex):\n    \"\"\"\n    Model for fixed obstacles.\n    \"\"\"\n\n    id: FixedObstacleID\n    length: float\n    width: float\n    enabled: bool = True\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.FixedObstacleID","title":"<code>FixedObstacleID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify fixed obstacles.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class FixedObstacleID(IntEnum):\n    \"\"\"\n    Enum to identify fixed obstacles.\n    \"\"\"\n\n    Ramp = auto()\n    Scene = auto()\n    PitArea = auto()\n    PamiStartArea = auto()\n    Pami5Path = auto()\n    OpponentRamp = auto()\n    OpponentScene = auto()\n    OpponentPitArea = auto()\n    Backstage = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.Tribune","title":"<code>Tribune</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Model for raw material stock. Coordinates indicate the center of the tribune.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class Tribune(Pose):\n    \"\"\"\n    Model for raw material stock.\n    Coordinates indicate the center of the tribune.\n    \"\"\"\n\n    id: TribuneID\n    length: float = 400.0\n    width: float = 100.0\n    column_count: int = 4\n    platform_count: int = 2\n    levels: int = 0\n    construction_area: ConstructionAreaID | None = None\n    private: bool = False\n    enabled: bool = True\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.TribuneID","title":"<code>TribuneID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify raw material stock.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class TribuneID(IntEnum):\n    \"\"\"\n    Enum to identify raw material stock.\n    \"\"\"\n\n    LocalCenter = auto()\n    LocalTop = auto()\n    LocalTopTraining = auto()\n    LocalBottom = auto()\n    LocalTopSide = auto()\n    LocalBottomSide = auto()\n    OppositeCenter = auto()\n    OppositeTop = auto()\n    OppositeBottom = auto()\n    OppositeTopSide = auto()\n    OppositeBottomSide = auto()\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/","title":"firmware_parameter","text":""},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameter","title":"<code>FirmwareParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Firmware parameter model with discriminated union for type-safe values.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The firmware parameter name</p> <code>value</code> <code>float | int | bool</code> <p>The firmware parameter content value (float, int, or bool)</p> <code>value_obj</code> <code>Annotated[FirmwareParameterValueType, Field(alias=value, discriminator=type)]</code> <p>The firmware parameter value object with its type</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameter(BaseModel):\n    \"\"\"Firmware parameter model with discriminated union for type-safe values.\n\n    Attributes:\n        name: The firmware parameter name\n        value: The firmware parameter content value (float, int, or bool)\n        value_obj: The firmware parameter value object with its type\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    name: str\n    value_obj: Annotated[FirmwareParameterValueType, Field(alias=\"value\", discriminator=\"type\")]\n\n    def __hash__(self):\n        return fnv1a_hash(self.name)\n\n    @property\n    def value(self) -&gt; float | int | bool:\n        \"\"\"Get the firmware parameter content value.\n\n        Returns:\n            The actual content value (float, int, or bool)\n        \"\"\"\n        return self.value_obj.content\n\n    @value.setter\n    def value(self, content: float | int | bool) -&gt; None:\n        \"\"\"Set the firmware parameter content value.\n\n        Args:\n            content: The new content value to set\n\n        Note:\n            The type of the firmware parameter remains unchanged. The content must be\n            compatible with the existing parameter type.\n        \"\"\"\n        self.value_obj.content = content\n\n    def pb_copy(self, message: PB_ParameterSetRequest | PB_ParameterGetRequest) -&gt; None:\n        \"\"\"Copy values to Protobuf message\"\"\"\n        message.key_hash = hash(self)\n\n        if isinstance(message, PB_ParameterSetRequest):\n            setattr(message.value, f\"{self.value_obj.type}_value\", self.value_obj.content)\n\n    def pb_read(self, message: PB_ParameterSetResponse | PB_ParameterGetResponse) -&gt; None:\n        \"\"\"Read values from Protobuf message and update firmware parameter content.\n\n        Args:\n            message: The ParameterSetResponse or ParameterGetResponse containing the value to read\n\n        Raises:\n            ValueError: If the key_hash doesn't match the firmware parameter name or no value set\n            FirmwareParameterValidationFailed: If firmware parameter validation failed on the embedded side\n            FirmwareParameterReadOnly: If firmware parameter is read-only on the embedded side\n            FirmwareParameterNotFound: If firmware parameter not found on the embedded side\n        \"\"\"\n\n        # Verify that the name matches\n        if message.key_hash != hash(self):\n            raise ValueError(f\"Key hash mismatch: expected '{hash(self)}', got '{message.key_hash}'\")\n\n        if isinstance(message, PB_ParameterSetResponse):\n            # Check status and raise appropriate exceptions\n            match message.status:\n                case PB_ParameterStatus.VALIDATION_FAILED:\n                    raise FirmwareParameterValidationFailed(f\"Firmware parameter '{self.name}' validation failed\")\n                case PB_ParameterStatus.NOT_FOUND:\n                    raise FirmwareParameterNotFound(f\"Firmware parameter '{self.name}' not found in registry\")\n                case PB_ParameterStatus.SUCCESS:\n                    pass  # Operation succeeded, nothing to do\n        elif isinstance(message, PB_ParameterGetResponse):\n            # Get the name of the field defined in the oneof\n            which_field = message.value.WhichOneof(\"value\")\n\n            if which_field is None:\n                raise ValueError(\"No value set in ParameterGetResponse, firmware parameter not found\")\n\n            # Get the value of the active field\n            content = getattr(message.value, which_field)\n\n            # Update the firmware parameter content\n            self.value_obj.content = content\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameter.value","title":"<code>value</code>  <code>property</code> <code>writable</code>","text":"<p>Get the firmware parameter content value.</p> <p>Returns:</p> Type Description <code>float | int | bool</code> <p>The actual content value (float, int, or bool)</p>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameter.pb_copy","title":"<code>pb_copy(message)</code>","text":"<p>Copy values to Protobuf message</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def pb_copy(self, message: PB_ParameterSetRequest | PB_ParameterGetRequest) -&gt; None:\n    \"\"\"Copy values to Protobuf message\"\"\"\n    message.key_hash = hash(self)\n\n    if isinstance(message, PB_ParameterSetRequest):\n        setattr(message.value, f\"{self.value_obj.type}_value\", self.value_obj.content)\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameter.pb_read","title":"<code>pb_read(message)</code>","text":"<p>Read values from Protobuf message and update firmware parameter content.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>PB_ParameterSetResponse | PB_ParameterGetResponse</code> <p>The ParameterSetResponse or ParameterGetResponse containing the value to read</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the key_hash doesn't match the firmware parameter name or no value set</p> <code>FirmwareParameterValidationFailed</code> <p>If firmware parameter validation failed on the embedded side</p> <code>FirmwareParameterReadOnly</code> <p>If firmware parameter is read-only on the embedded side</p> <code>FirmwareParameterNotFound</code> <p>If firmware parameter not found on the embedded side</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def pb_read(self, message: PB_ParameterSetResponse | PB_ParameterGetResponse) -&gt; None:\n    \"\"\"Read values from Protobuf message and update firmware parameter content.\n\n    Args:\n        message: The ParameterSetResponse or ParameterGetResponse containing the value to read\n\n    Raises:\n        ValueError: If the key_hash doesn't match the firmware parameter name or no value set\n        FirmwareParameterValidationFailed: If firmware parameter validation failed on the embedded side\n        FirmwareParameterReadOnly: If firmware parameter is read-only on the embedded side\n        FirmwareParameterNotFound: If firmware parameter not found on the embedded side\n    \"\"\"\n\n    # Verify that the name matches\n    if message.key_hash != hash(self):\n        raise ValueError(f\"Key hash mismatch: expected '{hash(self)}', got '{message.key_hash}'\")\n\n    if isinstance(message, PB_ParameterSetResponse):\n        # Check status and raise appropriate exceptions\n        match message.status:\n            case PB_ParameterStatus.VALIDATION_FAILED:\n                raise FirmwareParameterValidationFailed(f\"Firmware parameter '{self.name}' validation failed\")\n            case PB_ParameterStatus.NOT_FOUND:\n                raise FirmwareParameterNotFound(f\"Firmware parameter '{self.name}' not found in registry\")\n            case PB_ParameterStatus.SUCCESS:\n                pass  # Operation succeeded, nothing to do\n    elif isinstance(message, PB_ParameterGetResponse):\n        # Get the name of the field defined in the oneof\n        which_field = message.value.WhichOneof(\"value\")\n\n        if which_field is None:\n            raise ValueError(\"No value set in ParameterGetResponse, firmware parameter not found\")\n\n        # Get the value of the active field\n        content = getattr(message.value, which_field)\n\n        # Update the firmware parameter content\n        self.value_obj.content = content\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterBase","title":"<code>FirmwareParameterBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base firmware parameter type</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterBase(BaseModel):\n    \"\"\"Base firmware parameter type\"\"\"\n\n    model_config = ConfigDict(validate_assignment=True)\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterBool","title":"<code>FirmwareParameterBool</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Boolean firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterBool(FirmwareParameterBase):\n    \"\"\"Boolean firmware parameter value.\"\"\"\n\n    type: Literal[\"bool\"] = \"bool\"\n    content: StrictBool\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterDouble","title":"<code>FirmwareParameterDouble</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Double firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterDouble(FirmwareParameterBase):\n    \"\"\"Double firmware parameter value.\"\"\"\n\n    type: Literal[\"double\"] = \"double\"\n    content: StrictFloat\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterFloat","title":"<code>FirmwareParameterFloat</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Float firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterFloat(FirmwareParameterBase):\n    \"\"\"Float firmware parameter value.\"\"\"\n\n    type: Literal[\"float\"] = \"float\"\n    content: StrictFloat\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterInt32","title":"<code>FirmwareParameterInt32</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Signed 32-bit integer firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterInt32(FirmwareParameterBase):\n    \"\"\"Signed 32-bit integer firmware parameter value.\"\"\"\n\n    type: Literal[\"int32\"] = \"int32\"\n    content: StrictInt\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterInt64","title":"<code>FirmwareParameterInt64</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Signed 64-bit integer firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterInt64(FirmwareParameterBase):\n    \"\"\"Signed 64-bit integer firmware parameter value.\"\"\"\n\n    type: Literal[\"int64\"] = \"int64\"\n    content: StrictInt\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterNotFound","title":"<code>FirmwareParameterNotFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a requested firmware parameter is not found.</p> <p>This exception is raised when trying to access or modify a firmware parameter that does not exist in the parameter registry on the embedded side.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterNotFound(Exception):\n    \"\"\"Exception raised when a requested firmware parameter is not found.\n\n    This exception is raised when trying to access or modify a firmware parameter\n    that does not exist in the parameter registry on the embedded side.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterUInt32","title":"<code>FirmwareParameterUInt32</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Unsigned 32-bit integer firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterUInt32(FirmwareParameterBase):\n    \"\"\"Unsigned 32-bit integer firmware parameter value.\"\"\"\n\n    type: Literal[\"uint32\"] = \"uint32\"\n    content: Annotated[NonNegativeInt, Strict()]\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterUInt64","title":"<code>FirmwareParameterUInt64</code>","text":"<p>               Bases: <code>FirmwareParameterBase</code></p> <p>Unsigned 64-bit integer firmware parameter value.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterUInt64(FirmwareParameterBase):\n    \"\"\"Unsigned 64-bit integer firmware parameter value.\"\"\"\n\n    type: Literal[\"uint64\"] = \"uint64\"\n    content: Annotated[NonNegativeInt, Strict()]\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParameterValidationFailed","title":"<code>FirmwareParameterValidationFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when firmware parameter validation fails.</p> <p>This exception is raised when a firmware parameter value does not meet the validation constraints defined for that parameter value range on the embedded side.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParameterValidationFailed(Exception):\n    \"\"\"Exception raised when firmware parameter validation fails.\n\n    This exception is raised when a firmware parameter value does not meet\n    the validation constraints defined for that parameter value range on the embedded side.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup","title":"<code>FirmwareParametersGroup</code>","text":"<p>               Bases: <code>RootModel</code></p> <p>Container for a group of firmware parameters with name-based access.</p> <p>This class manages a collection of firmware parameters and provides convenient get/set methods using firmware parameter names.</p> <p>The model directly represents a list of FirmwareParameter objects.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>class FirmwareParametersGroup(RootModel):\n    \"\"\"Container for a group of firmware parameters with name-based access.\n\n    This class manages a collection of firmware parameters and provides convenient\n    get/set methods using firmware parameter names.\n\n    The model directly represents a list of FirmwareParameter objects.\n    \"\"\"\n\n    root: Annotated[list[FirmwareParameter], Field(default_factory=list)]\n\n    def model_post_init(self, __context) -&gt; None:\n        \"\"\"Build index after initialization.\"\"\"\n        super().model_post_init(__context)\n        self._rebuild_index()\n\n    def _rebuild_index(self) -&gt; None:\n        \"\"\"Rebuild the internal index for firmware parameter name lookup.\"\"\"\n        self._index: dict[str, int] = {param.name: idx for idx, param in enumerate(self.root)}\n\n    def get(self, name: str) -&gt; FirmwareParameter:\n        \"\"\"Get a firmware parameter by its name.\n\n        Args:\n            name: The firmware parameter name\n\n        Returns:\n            The FirmwareParameter object\n\n        Raises:\n            KeyError: If the firmware parameter name is not found\n        \"\"\"\n        if name not in self._index:\n            raise KeyError(f\"Firmware parameter '{name}' not found\")\n        return self.root[self._index[name]]\n\n    def __contains__(self, name: str) -&gt; bool:\n        \"\"\"Check if a firmware parameter name exists in the list.\n\n        Args:\n            name: The firmware parameter name to check\n\n        Returns:\n            True if the firmware parameter exists, False otherwise\n        \"\"\"\n        return name in self._index\n\n    def __getitem__(self, name: str) -&gt; float | int | bool:\n        \"\"\"Get a firmware parameter's value using bracket notation.\n\n        Args:\n            name: The firmware parameter name\n\n        Returns:\n            The firmware parameter's content value\n\n        Raises:\n            KeyError: If the firmware parameter name is not found\n        \"\"\"\n        return self.get(name).value\n\n    def __setitem__(self, name: str, value: float | int | bool) -&gt; None:\n        \"\"\"Set a firmware parameter's value using bracket notation.\n\n        Args:\n            name: The firmware parameter name\n            value: The new content value\n\n        Raises:\n            KeyError: If the firmware parameter name is not found\n        \"\"\"\n        self.get(name).value = value\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of firmware parameters in the list.\"\"\"\n        return len(self.root)\n\n    def __iter__(self):\n        \"\"\"Iterate over all firmware parameters.\"\"\"\n        return iter(self.root)\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Check if a firmware parameter name exists in the list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The firmware parameter name to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the firmware parameter exists, False otherwise</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def __contains__(self, name: str) -&gt; bool:\n    \"\"\"Check if a firmware parameter name exists in the list.\n\n    Args:\n        name: The firmware parameter name to check\n\n    Returns:\n        True if the firmware parameter exists, False otherwise\n    \"\"\"\n    return name in self._index\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Get a firmware parameter's value using bracket notation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The firmware parameter name</p> required <p>Returns:</p> Type Description <code>float | int | bool</code> <p>The firmware parameter's content value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the firmware parameter name is not found</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def __getitem__(self, name: str) -&gt; float | int | bool:\n    \"\"\"Get a firmware parameter's value using bracket notation.\n\n    Args:\n        name: The firmware parameter name\n\n    Returns:\n        The firmware parameter's content value\n\n    Raises:\n        KeyError: If the firmware parameter name is not found\n    \"\"\"\n    return self.get(name).value\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over all firmware parameters.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over all firmware parameters.\"\"\"\n    return iter(self.root)\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of firmware parameters in the list.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of firmware parameters in the list.\"\"\"\n    return len(self.root)\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.__setitem__","title":"<code>__setitem__(name, value)</code>","text":"<p>Set a firmware parameter's value using bracket notation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The firmware parameter name</p> required <code>value</code> <code>float | int | bool</code> <p>The new content value</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the firmware parameter name is not found</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def __setitem__(self, name: str, value: float | int | bool) -&gt; None:\n    \"\"\"Set a firmware parameter's value using bracket notation.\n\n    Args:\n        name: The firmware parameter name\n        value: The new content value\n\n    Raises:\n        KeyError: If the firmware parameter name is not found\n    \"\"\"\n    self.get(name).value = value\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.get","title":"<code>get(name)</code>","text":"<p>Get a firmware parameter by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The firmware parameter name</p> required <p>Returns:</p> Type Description <code>FirmwareParameter</code> <p>The FirmwareParameter object</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the firmware parameter name is not found</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def get(self, name: str) -&gt; FirmwareParameter:\n    \"\"\"Get a firmware parameter by its name.\n\n    Args:\n        name: The firmware parameter name\n\n    Returns:\n        The FirmwareParameter object\n\n    Raises:\n        KeyError: If the firmware parameter name is not found\n    \"\"\"\n    if name not in self._index:\n        raise KeyError(f\"Firmware parameter '{name}' not found\")\n    return self.root[self._index[name]]\n</code></pre>"},{"location":"reference/cogip/models/firmware_parameter/#cogip.models.firmware_parameter.FirmwareParametersGroup.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Build index after initialization.</p> Source code in <code>cogip/models/firmware_parameter.py</code> <pre><code>def model_post_init(self, __context) -&gt; None:\n    \"\"\"Build index after initialization.\"\"\"\n    super().model_post_init(__context)\n    self._rebuild_index()\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/","title":"firmware_telemetry","text":"<p>Firmware Telemetry Models.</p> <p>This module provides models for parsing generic telemetry data received from the robot's MCU firmware via Protobuf messages using FNV-1a key hashes.</p>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryData","title":"<code>TelemetryData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic telemetry data point with key hash, timestamp, and value.</p> <p>Attributes:</p> Name Type Description <code>key_hash</code> <code>int</code> <p>FNV-1a hash of the telemetry key.</p> <code>timestamp_ms</code> <code>int</code> <p>Timestamp in milliseconds when the data was captured.</p> <code>value</code> <code>TelemetryValue</code> <p>The telemetry value (float or int depending on type).</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>class TelemetryData(BaseModel):\n    \"\"\"\n    Generic telemetry data point with key hash, timestamp, and value.\n\n    Attributes:\n        key_hash: FNV-1a hash of the telemetry key.\n        timestamp_ms: Timestamp in milliseconds when the data was captured.\n        value: The telemetry value (float or int depending on type).\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    key_hash: int\n    timestamp_ms: int\n    value: TelemetryValue\n\n    @classmethod\n    def from_protobuf(cls, message: PB_TelemetryData) -&gt; \"TelemetryData\":\n        \"\"\"\n        Parse a TelemetryData from a PB_TelemetryData protobuf message.\n\n        Args:\n            message: The PB_TelemetryData protobuf message.\n\n        Returns:\n            TelemetryData instance with parsed values.\n        \"\"\"\n        key_hash = message.key_hash\n        timestamp_ms = message.timestamp_ms\n\n        # Extract the value from the oneof field\n        which_value = message.WhichOneof(\"value\")\n        if which_value is None:\n            value: TelemetryValue = 0\n        else:\n            value = getattr(message, which_value)\n\n        return cls(key_hash=key_hash, timestamp_ms=timestamp_ms, value=value)\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryData.from_protobuf","title":"<code>from_protobuf(message)</code>  <code>classmethod</code>","text":"<p>Parse a TelemetryData from a PB_TelemetryData protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>PB_TelemetryData</code> <p>The PB_TelemetryData protobuf message.</p> required <p>Returns:</p> Type Description <code>TelemetryData</code> <p>TelemetryData instance with parsed values.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>@classmethod\ndef from_protobuf(cls, message: PB_TelemetryData) -&gt; \"TelemetryData\":\n    \"\"\"\n    Parse a TelemetryData from a PB_TelemetryData protobuf message.\n\n    Args:\n        message: The PB_TelemetryData protobuf message.\n\n    Returns:\n        TelemetryData instance with parsed values.\n    \"\"\"\n    key_hash = message.key_hash\n    timestamp_ms = message.timestamp_ms\n\n    # Extract the value from the oneof field\n    which_value = message.WhichOneof(\"value\")\n    if which_value is None:\n        value: TelemetryValue = 0\n    else:\n        value = getattr(message, which_value)\n\n    return cls(key_hash=key_hash, timestamp_ms=timestamp_ms, value=value)\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict","title":"<code>TelemetryDict</code>","text":"<p>Dict-like store for telemetry data points indexed by key hash.</p> <p>This class collects telemetry data and provides access by key name.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>class TelemetryDict:\n    \"\"\"\n    Dict-like store for telemetry data points indexed by key hash.\n\n    This class collects telemetry data and provides access by key name.\n    \"\"\"\n\n    def __init__(self):\n        self._data: dict[int, TelemetryData] = {}\n\n    def update(self, data: TelemetryData) -&gt; None:\n        \"\"\"\n        Update the store with a new telemetry data point.\n\n        Args:\n            data: The telemetry data point to store.\n        \"\"\"\n        self._data[data.key_hash] = data\n\n    def get_model(self, key: str) -&gt; TelemetryData:\n        \"\"\"\n        Get telemetry data model by key name.\n\n        Args:\n            key: The telemetry key name to look up.\n\n        Returns:\n            TelemetryData for the key.\n\n        Raises:\n            KeyError: If the key is not found in the store.\n        \"\"\"\n        return self._data[fnv1a_hash(key)]\n\n    def __getitem__(self, key: str) -&gt; TelemetryValue:\n        \"\"\"\n        Get telemetry value by key name. Raises KeyError if not found.\n\n        Args:\n            key: The telemetry key name to look up.\n\n        Returns:\n            The telemetry value for the key.\n\n        Raises:\n            KeyError: If the key is not found in the store.\n        \"\"\"\n        return self._data[fnv1a_hash(key)].value\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if a key exists in the store.\n\n        Args:\n            key: The telemetry key name to check.\n\n        Returns:\n            True if the key exists, False otherwise.\n        \"\"\"\n        return fnv1a_hash(key) in self._data\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of telemetry entries.\"\"\"\n        return len(self._data)\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Return True if the store contains any data.\"\"\"\n        return bool(self._data)\n\n    def items(self):\n        \"\"\"Iterate over (key_hash, TelemetryData) tuples.\"\"\"\n        return self._data.items()\n\n    def values(self):\n        \"\"\"Iterate over TelemetryData values.\"\"\"\n        return self._data.values()\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True if the store contains any data.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Return True if the store contains any data.\"\"\"\n    return bool(self._data)\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a key exists in the store.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The telemetry key name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"\n    Check if a key exists in the store.\n\n    Args:\n        key: The telemetry key name to check.\n\n    Returns:\n        True if the key exists, False otherwise.\n    \"\"\"\n    return fnv1a_hash(key) in self._data\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get telemetry value by key name. Raises KeyError if not found.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The telemetry key name to look up.</p> required <p>Returns:</p> Type Description <code>TelemetryValue</code> <p>The telemetry value for the key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the store.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def __getitem__(self, key: str) -&gt; TelemetryValue:\n    \"\"\"\n    Get telemetry value by key name. Raises KeyError if not found.\n\n    Args:\n        key: The telemetry key name to look up.\n\n    Returns:\n        The telemetry value for the key.\n\n    Raises:\n        KeyError: If the key is not found in the store.\n    \"\"\"\n    return self._data[fnv1a_hash(key)].value\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of telemetry entries.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of telemetry entries.\"\"\"\n    return len(self._data)\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.get_model","title":"<code>get_model(key)</code>","text":"<p>Get telemetry data model by key name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The telemetry key name to look up.</p> required <p>Returns:</p> Type Description <code>TelemetryData</code> <p>TelemetryData for the key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the store.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def get_model(self, key: str) -&gt; TelemetryData:\n    \"\"\"\n    Get telemetry data model by key name.\n\n    Args:\n        key: The telemetry key name to look up.\n\n    Returns:\n        TelemetryData for the key.\n\n    Raises:\n        KeyError: If the key is not found in the store.\n    \"\"\"\n    return self._data[fnv1a_hash(key)]\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.items","title":"<code>items()</code>","text":"<p>Iterate over (key_hash, TelemetryData) tuples.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def items(self):\n    \"\"\"Iterate over (key_hash, TelemetryData) tuples.\"\"\"\n    return self._data.items()\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.update","title":"<code>update(data)</code>","text":"<p>Update the store with a new telemetry data point.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TelemetryData</code> <p>The telemetry data point to store.</p> required Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def update(self, data: TelemetryData) -&gt; None:\n    \"\"\"\n    Update the store with a new telemetry data point.\n\n    Args:\n        data: The telemetry data point to store.\n    \"\"\"\n    self._data[data.key_hash] = data\n</code></pre>"},{"location":"reference/cogip/models/firmware_telemetry/#cogip.models.firmware_telemetry.TelemetryDict.values","title":"<code>values()</code>","text":"<p>Iterate over TelemetryData values.</p> Source code in <code>cogip/models/firmware_telemetry.py</code> <pre><code>def values(self):\n    \"\"\"Iterate over TelemetryData values.\"\"\"\n    return self._data.values()\n</code></pre>"},{"location":"reference/cogip/models/models/","title":"models","text":"<p>This module contains all data models used in the monitor.</p> <p>The models are based on Pydantic models, allowing them to be loaded from/exported to JSON strings/files. All values are automatically verified and converted to the expected data type, an exception being raised if impossible.</p>"},{"location":"reference/cogip/models/models/#cogip.models.models.CameraExtrinsicParameters","title":"<code>CameraExtrinsicParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing camera extrinsic properties</p> Source code in <code>cogip/models/models.py</code> <pre><code>class CameraExtrinsicParameters(BaseModel):\n    \"\"\"Model representing camera extrinsic properties\"\"\"\n\n    x: float\n    y: float\n    z: float\n    roll: float = 0.0\n    pitch: float = 0.0\n    yaw: float = 0.0\n\n    @property\n    def tvec(self) -&gt; ArrayLike:\n        return np.array([self.x, self.y, self.z])\n\n    @property\n    def rvec(self) -&gt; ArrayLike:\n        return np.array([self.roll, self.pitch, self.yaw])\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynObstacleRect","title":"<code>DynObstacleRect</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dynamic rectangle obstacle created by the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X coordinate of the obstacle center</p> <code>y</code> <code>float</code> <p>Y coordinate of the obstacle center</p> <code>angle</code> <code>float</code> <p>Orientation of the obstacle</p> <code>length_x</code> <code>float</code> <p>length along X axis</p> <code>length_y</code> <code>float</code> <p>length along Y axis</p> <code>bb</code> <code>list[Vertex]</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class DynObstacleRect(BaseModel):\n    \"\"\"\n    A dynamic rectangle obstacle created by the robot.\n\n    Attributes:\n        x: X coordinate of the obstacle center\n        y: Y coordinate of the obstacle center\n        angle: Orientation of the obstacle\n        length_x: length along X axis\n        length_y: length along Y axis\n        bb: bounding box\n    \"\"\"\n\n    x: float\n    y: float\n    angle: float\n    length_x: float\n    length_y: float\n    bb: list[Vertex] = []\n\n    def contains(self, point: Vertex) -&gt; bool:\n        half_length_x = self.length_x / 2\n        half_length_y = self.length_y / 2\n\n        return (self.x - half_length_x &lt;= point.x &lt;= self.x + half_length_x) and (\n            self.y - half_length_y &lt;= point.y &lt;= self.y + half_length_y\n        )\n\n    def create_bounding_box(self, bb_radius: float, nb_vertices: int = 4):\n        half_length_x = self.length_x / 2\n        half_length_y = self.length_y / 2\n\n        self.bb = [\n            Vertex(x=self.x - half_length_x - bb_radius, y=self.y + half_length_y + bb_radius),\n            Vertex(x=self.x + half_length_x + bb_radius, y=self.y + half_length_y + bb_radius),\n            Vertex(x=self.x + half_length_x + bb_radius, y=self.y - half_length_y - bb_radius),\n            Vertex(x=self.x - half_length_x - bb_radius, y=self.y - half_length_y - bb_radius),\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        Hash function to allow this class to be used as a key in a dict.\n        \"\"\"\n        return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynObstacleRect.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash function to allow this class to be used as a key in a dict.</p> Source code in <code>cogip/models/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash function to allow this class to be used as a key in a dict.\n    \"\"\"\n    return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynRoundObstacle","title":"<code>DynRoundObstacle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dynamic round obstacle created by the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Center X position</p> <code>y</code> <code>float</code> <p>Center Y position</p> <code>radius</code> <code>float</code> <p>Radius of the obstacle</p> <code>bb</code> <code>list[Vertex]</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class DynRoundObstacle(BaseModel):\n    \"\"\"\n    A dynamic round obstacle created by the robot.\n\n    Attributes:\n        x: Center X position\n        y: Center Y position\n        radius: Radius of the obstacle\n        bb: bounding box\n    \"\"\"\n\n    x: float\n    y: float\n    radius: float\n    bb: list[Vertex] = []\n\n    def contains(self, point: Vertex) -&gt; bool:\n        return (point.x - self.x) * (point.x - self.x) + (point.y - self.y) * (point.y - self.y) &lt;= self.radius**2\n\n    def create_bounding_box(self, bb_radius, nb_vertices):\n        self.bb = [\n            Vertex(\n                x=self.x + bb_radius * math.cos(tmp := (i * 2 * math.pi) / nb_vertices),\n                y=self.y + bb_radius * math.sin(tmp),\n            )\n            for i in reversed(range(nb_vertices))\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        Hash function to allow this class to be used as a key in a dict.\n        \"\"\"\n        return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynRoundObstacle.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash function to allow this class to be used as a key in a dict.</p> Source code in <code>cogip/models/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash function to allow this class to be used as a key in a dict.\n    \"\"\"\n    return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.EmergencyStopStatus","title":"<code>EmergencyStopStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing the emergency stop button status.</p> <p>Attributes:</p> Name Type Description <code>emergency_stop</code> <code>bool</code> <p>Emergency stop button status (True = released, False = engaged)</p> Source code in <code>cogip/models/models.py</code> <pre><code>class EmergencyStopStatus(BaseModel):\n    \"\"\"\n    Model representing the emergency stop button status.\n\n    Attributes:\n        emergency_stop: Emergency stop button status (True = released, False = engaged)\n    \"\"\"\n\n    emergency_stop: bool = False\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.MenuEntry","title":"<code>MenuEntry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents one entry in a firmware's shell menu</p> <p>Attributes:</p> Name Type Description <code>cmd</code> <code>str</code> <p>Command name</p> <code>desc</code> <code>str</code> <p>Description of the command</p> <p>Examples:</p> <p>The following line shows how to initialize this class from a JSON string received on the serial port:</p> <pre><code>MenuEntry.model_validate_json(\"{\\\"cmd\\\": \\\"_state\\\", \\\"desc\\\": \\\"Print current state\\\"}\")\n</code></pre> Source code in <code>cogip/models/models.py</code> <pre><code>class MenuEntry(BaseModel):\n    \"\"\"\n    Represents one entry in a firmware's shell menu\n\n    Attributes:\n        cmd: Command name\n        desc: Description of the command\n\n    Examples:\n        The following line shows how to initialize this class from a JSON\n        string received on the serial port:\n        ```py\n        MenuEntry.model_validate_json(\"{\\\\\"cmd\\\\\": \\\\\"_state\\\\\", \\\\\"desc\\\\\": \\\\\"Print current state\\\\\"}\")\n        ```\n    \"\"\"\n\n    cmd: str\n    desc: str\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.MotionDirection","title":"<code>MotionDirection</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Motion direction mode for path navigation.</p> Source code in <code>cogip/models/models.py</code> <pre><code>class MotionDirection(IntEnum):\n    \"\"\"Motion direction mode for path navigation.\"\"\"\n\n    BIDIRECTIONAL = 0  # Robot can move forward or backward (choose optimal)\n    FORWARD_ONLY = 1  # Force forward motion only\n    BACKWARD_ONLY = 2  # Force backward motion only\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Obstacle","title":"<code>Obstacle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains the properties of an obstacle added on the table.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int</code> <p>X position</p> <code>y</code> <code>int</code> <p>Y position</p> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>length</code> <code>int</code> <p>Length</p> <code>width</code> <code>int</code> <p>Width</p> <code>height</code> <code>int</code> <p>Height</p> <code>bb</code> <code>int</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Obstacle(BaseModel):\n    \"\"\"\n    Contains the properties of an obstacle added on the table.\n\n    Attributes:\n        x: X position\n        y: Y position\n        rotation: Rotation\n        length: Length\n        width: Width\n        height: Height\n        bb: bounding box\n    \"\"\"\n\n    x: int = 0\n    y: int = 1000\n    rotation: int = 0\n    length: int = 200\n    width: int = 200\n    height: int = 600\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose","title":"<code>PathPose</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Class representing a position in a path.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X coordinate</p> <code>y</code> <code>float</code> <p>Y coordinate</p> <code>O</code> <code>float | None</code> <p>0-orientation</p> <code>max_speed_linear</code> <code>int</code> <p>max linear speed in percentage of the robot max linear speed</p> <code>max_speed_angular</code> <code>int</code> <p>max angular speed in percentage of the robot max angular speed</p> <code>motion_direction</code> <code>MotionDirection</code> <p>motion direction mode (bidirectional, forward_only, or backward_only)</p> <code>bypass_anti_blocking</code> <code>bool</code> <p>send pose_reached if robot is blocked</p> <code>timeout_ms</code> <code>int</code> <p>max time is milliseconds to reach the pose, the robot stops if timeout is reached, 0 for no timeout</p> <code>bypass_final_orientation</code> <code>bool</code> <p>do not set orientation pose order</p> <code>is_intermediate</code> <code>bool</code> <p>whether this pose is an intermediate pose in a path</p> Source code in <code>cogip/models/models.py</code> <pre><code>class PathPose(Pose):\n    \"\"\"\n    Class representing a position in a path.\n\n    Attributes:\n        x: X coordinate\n        y: Y coordinate\n        O: 0-orientation\n        max_speed_linear: max linear speed in percentage of the robot max linear speed\n        max_speed_angular: max angular speed in percentage of the robot max angular speed\n        motion_direction: motion direction mode (bidirectional, forward_only, or backward_only)\n        bypass_anti_blocking: send pose_reached if robot is blocked\n        timeout_ms: max time is milliseconds to reach the pose, the robot stops if timeout is reached, 0 for no timeout\n        bypass_final_orientation: do not set orientation pose order\n        is_intermediate: whether this pose is an intermediate pose in a path\n    \"\"\"\n\n    max_speed_linear: int = 66\n    max_speed_angular: int = 66\n    motion_direction: MotionDirection = MotionDirection.BIDIRECTIONAL\n    bypass_anti_blocking: bool = False\n    timeout_ms: int = 0\n    bypass_final_orientation: bool = False\n    is_intermediate: bool = False\n\n    @property\n    def pose(self) -&gt; Pose:\n        return Pose(**self.model_dump())\n\n    def copy_pb(self, pb_path_pose: PB_PathPose) -&gt; None:\n        \"\"\"\n        Copy data in a Protobuf message.\n\n        Arguments:\n            pb_path_pose: Protobuf message to fill\n        \"\"\"\n        pb_path_pose.pose.x = int(self.x)\n        pb_path_pose.pose.y = int(self.y)\n        pb_path_pose.pose.O = int(self.O)  # noqa\n        pb_path_pose.max_speed_ratio_linear = self.max_speed_linear\n        pb_path_pose.max_speed_ratio_angular = self.max_speed_angular\n        pb_path_pose.motion_direction = self.motion_direction.value\n        pb_path_pose.bypass_anti_blocking = self.bypass_anti_blocking\n        pb_path_pose.timeout_ms = self.timeout_ms\n        pb_path_pose.bypass_final_orientation = self.bypass_final_orientation\n        pb_path_pose.is_intermediate = self.is_intermediate\n\n    def to_shared(self, shared_pose_order: SharedPoseOrder | None) -&gt; None:\n        \"\"\"\n        Copy data in a Protobuf message.\n\n        Arguments:\n            shared_pose_order: Protobuf message to fill\n        \"\"\"\n        if shared_pose_order is None:\n            return\n        shared_pose_order.x = int(self.x)\n        shared_pose_order.y = int(self.y)\n        shared_pose_order.angle = int(self.O)  # noqa\n        shared_pose_order.max_speed_linear = self.max_speed_linear\n        shared_pose_order.max_speed_angular = self.max_speed_angular\n        shared_pose_order.motion_direction = self.motion_direction.value\n        shared_pose_order.bypass_anti_blocking = self.bypass_anti_blocking\n        shared_pose_order.bypass_final_orientation = self.bypass_final_orientation\n        shared_pose_order.timeout_ms = self.timeout_ms\n        shared_pose_order.is_intermediate = self.is_intermediate\n\n    @classmethod\n    def from_shared(cls, shared_pose: SharedPose | SharedPoseOrder) -&gt; \"PathPose\":\n        \"\"\"\n        Create a PathPose from a SharedPoseOrder.\n\n        Arguments:\n            shared_pose: SharedPoseOrder to convert\n\n        Returns:\n            A PathPose instance with the data from the SharedPoseOrder.\n        \"\"\"\n        path_pose = cls(\n            x=shared_pose.x,\n            y=shared_pose.y,\n            O=shared_pose.angle,  # noqa\n        )\n        if isinstance(shared_pose, SharedPoseOrder):\n            path_pose.max_speed_linear = shared_pose.max_speed_linear\n            path_pose.max_speed_angular = shared_pose.max_speed_angular\n            path_pose.motion_direction = shared_pose.motion_direction\n            path_pose.bypass_anti_blocking = shared_pose.bypass_anti_blocking\n            path_pose.timeout_ms = shared_pose.timeout_ms\n            path_pose.bypass_final_orientation = shared_pose.bypass_final_orientation\n            path_pose.is_intermediate = shared_pose.is_intermediate\n\n        return path_pose\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.copy_pb","title":"<code>copy_pb(pb_path_pose)</code>","text":"<p>Copy data in a Protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>pb_path_pose</code> <code>PB_PathPose</code> <p>Protobuf message to fill</p> required Source code in <code>cogip/models/models.py</code> <pre><code>def copy_pb(self, pb_path_pose: PB_PathPose) -&gt; None:\n    \"\"\"\n    Copy data in a Protobuf message.\n\n    Arguments:\n        pb_path_pose: Protobuf message to fill\n    \"\"\"\n    pb_path_pose.pose.x = int(self.x)\n    pb_path_pose.pose.y = int(self.y)\n    pb_path_pose.pose.O = int(self.O)  # noqa\n    pb_path_pose.max_speed_ratio_linear = self.max_speed_linear\n    pb_path_pose.max_speed_ratio_angular = self.max_speed_angular\n    pb_path_pose.motion_direction = self.motion_direction.value\n    pb_path_pose.bypass_anti_blocking = self.bypass_anti_blocking\n    pb_path_pose.timeout_ms = self.timeout_ms\n    pb_path_pose.bypass_final_orientation = self.bypass_final_orientation\n    pb_path_pose.is_intermediate = self.is_intermediate\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.from_shared","title":"<code>from_shared(shared_pose)</code>  <code>classmethod</code>","text":"<p>Create a PathPose from a SharedPoseOrder.</p> <p>Parameters:</p> Name Type Description Default <code>shared_pose</code> <code>Pose | PoseOrder</code> <p>SharedPoseOrder to convert</p> required <p>Returns:</p> Type Description <code>PathPose</code> <p>A PathPose instance with the data from the SharedPoseOrder.</p> Source code in <code>cogip/models/models.py</code> <pre><code>@classmethod\ndef from_shared(cls, shared_pose: SharedPose | SharedPoseOrder) -&gt; \"PathPose\":\n    \"\"\"\n    Create a PathPose from a SharedPoseOrder.\n\n    Arguments:\n        shared_pose: SharedPoseOrder to convert\n\n    Returns:\n        A PathPose instance with the data from the SharedPoseOrder.\n    \"\"\"\n    path_pose = cls(\n        x=shared_pose.x,\n        y=shared_pose.y,\n        O=shared_pose.angle,  # noqa\n    )\n    if isinstance(shared_pose, SharedPoseOrder):\n        path_pose.max_speed_linear = shared_pose.max_speed_linear\n        path_pose.max_speed_angular = shared_pose.max_speed_angular\n        path_pose.motion_direction = shared_pose.motion_direction\n        path_pose.bypass_anti_blocking = shared_pose.bypass_anti_blocking\n        path_pose.timeout_ms = shared_pose.timeout_ms\n        path_pose.bypass_final_orientation = shared_pose.bypass_final_orientation\n        path_pose.is_intermediate = shared_pose.is_intermediate\n\n    return path_pose\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.to_shared","title":"<code>to_shared(shared_pose_order)</code>","text":"<p>Copy data in a Protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>shared_pose_order</code> <code>PoseOrder | None</code> <p>Protobuf message to fill</p> required Source code in <code>cogip/models/models.py</code> <pre><code>def to_shared(self, shared_pose_order: SharedPoseOrder | None) -&gt; None:\n    \"\"\"\n    Copy data in a Protobuf message.\n\n    Arguments:\n        shared_pose_order: Protobuf message to fill\n    \"\"\"\n    if shared_pose_order is None:\n        return\n    shared_pose_order.x = int(self.x)\n    shared_pose_order.y = int(self.y)\n    shared_pose_order.angle = int(self.O)  # noqa\n    shared_pose_order.max_speed_linear = self.max_speed_linear\n    shared_pose_order.max_speed_angular = self.max_speed_angular\n    shared_pose_order.motion_direction = self.motion_direction.value\n    shared_pose_order.bypass_anti_blocking = self.bypass_anti_blocking\n    shared_pose_order.bypass_final_orientation = self.bypass_final_orientation\n    shared_pose_order.timeout_ms = self.timeout_ms\n    shared_pose_order.is_intermediate = self.is_intermediate\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>Vertex</code></p> <p>A position of the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X position</p> <code>y</code> <code>float</code> <p>Y position</p> <code>O</code> <code>float | None</code> <p>Rotation</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Pose(Vertex):\n    \"\"\"\n    A position of the robot.\n\n    Attributes:\n        x: X position\n        y: Y position\n        O: Rotation\n    \"\"\"\n\n    O: float | None = 0.0  # noqa\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PowerRailsStatus","title":"<code>PowerRailsStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing the status of power rails.</p> <p>Attributes:</p> Name Type Description <code>p3V3_pgood</code> <code>bool</code> <p>3.3V power good status (True = OK, False = fault)</p> <code>p5V0_pgood</code> <code>bool</code> <p>5.0V power good status (True = OK, False = fault)</p> <code>p7V5_pgood</code> <code>bool</code> <p>7.5V power good status (True = OK, False = fault)</p> <code>pxVx_pgood</code> <code>bool</code> <p>Variable voltage power good status (True = OK, False = fault)</p> Source code in <code>cogip/models/models.py</code> <pre><code>class PowerRailsStatus(BaseModel):\n    \"\"\"\n    Model representing the status of power rails.\n\n    Attributes:\n        p3V3_pgood: 3.3V power good status (True = OK, False = fault)\n        p5V0_pgood: 5.0V power good status (True = OK, False = fault)\n        p7V5_pgood: 7.5V power good status (True = OK, False = fault)\n        pxVx_pgood: Variable voltage power good status (True = OK, False = fault)\n    \"\"\"\n\n    p3V3_pgood: bool = False\n    p5V0_pgood: bool = False\n    p7V5_pgood: bool = False\n    pxVx_pgood: bool = False\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PowerSourceStatus","title":"<code>PowerSourceStatus</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing the power source validity status.</p> <p>Attributes:</p> Name Type Description <code>battery_valid</code> <code>bool</code> <p>Battery validity status (True = connected, False = disconnected)</p> <code>dc_supply_valid</code> <code>bool</code> <p>DC supply validity status (True = connected, False = disconnected)</p> Source code in <code>cogip/models/models.py</code> <pre><code>class PowerSourceStatus(BaseModel):\n    \"\"\"\n    Model representing the power source validity status.\n\n    Attributes:\n        battery_valid: Battery validity status (True = connected, False = disconnected)\n        dc_supply_valid: DC supply validity status (True = connected, False = disconnected)\n    \"\"\"\n\n    battery_valid: bool = False\n    dc_supply_valid: bool = False\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.RobotState","title":"<code>RobotState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>This contains information about robot state, like mode, cycle, positions, speed, path and obstacles. It is given by the firmware through the serial port.</p> <p>Attributes:</p> Name Type Description <code>pose_order</code> <code>Pose</code> <p>Position to reach</p> <code>cycle</code> <code>int</code> <p>Current cycle</p> <code>speed_current</code> <code>Speed</code> <p>Current speed</p> <code>speed_order</code> <code>Speed</code> <p>Speed order</p> <code>path</code> <code>Speed</code> <p>Computed path</p> Source code in <code>cogip/models/models.py</code> <pre><code>class RobotState(BaseModel):\n    \"\"\"\n    This contains information about robot state,\n    like mode, cycle, positions, speed, path and obstacles.\n    It is given by the firmware through the serial port.\n\n    Attributes:\n        pose_order: Position to reach\n        cycle: Current cycle\n        speed_current: Current speed\n        speed_order: Speed order\n        path: Computed path\n    \"\"\"\n\n    pose_current: Pose = Pose()\n    pose_order: Pose = Pose()\n    cycle: int = 0\n    speed_current: Speed = Speed()\n    speed_order: Speed = Speed()\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.ShellMenu","title":"<code>ShellMenu</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a firmware's shell menu.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the menu</p> <code>entries</code> <code>list[MenuEntry]</code> <p>List of the menu entries</p> <p>Examples:</p> <p>The following line shows how to initialize this class from a JSON string received on the serial port:</p> <pre><code>ShellMenu.model_validate_json(\n    \"{\\\"name\\\": \\\"planner\\\",\"\n    \" \\\"entries\\\": [\"\n    \"    {\\\"cmd\\\": \\\"_help_json\\\", \\\"desc\\\": \\\"Display available commands in JSON format\\\"},\"\n    \"    {\\\"cmd\\\": \\\"_state\\\", \\\"desc\\\": \\\"Print current state\\\"}\n    \"]}\"\n)\n</code></pre> Source code in <code>cogip/models/models.py</code> <pre><code>class ShellMenu(BaseModel):\n    \"\"\"\n    Represents a firmware's shell menu.\n\n    Attributes:\n        name: Name of the menu\n        entries: List of the menu entries\n\n    Examples:\n        The following line shows how to initialize this class from a JSON\n        string received on the serial port:\n        ```py\n        ShellMenu.model_validate_json(\n            \"{\\\\\"name\\\\\": \\\\\"planner\\\\\",\"\n            \" \\\\\"entries\\\\\": [\"\n            \"    {\\\\\"cmd\\\\\": \\\\\"_help_json\\\\\", \\\\\"desc\\\\\": \\\\\"Display available commands in JSON format\\\\\"},\"\n            \"    {\\\\\"cmd\\\\\": \\\\\"_state\\\\\", \\\\\"desc\\\\\": \\\\\"Print current state\\\\\"}\n            \"]}\"\n        )\n        ```\n    \"\"\"\n\n    name: str\n    entries: list[MenuEntry]\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Speed","title":"<code>Speed</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A speed value.</p> <p>Attributes:</p> Name Type Description <code>distance</code> <code>float</code> <p>Linear speed</p> <code>angle</code> <code>float</code> <p>Angular speed</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Speed(BaseModel):\n    \"\"\"\n    A speed value.\n\n    Attributes:\n        distance: Linear speed\n        angle: Angular speed\n    \"\"\"\n\n    distance: float = 0.0\n    angle: float = 0.0\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Vertex","title":"<code>Vertex</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a point in 2D/3D coordinates.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X position</p> <code>y</code> <code>float</code> <p>Y position</p> <code>z</code> <code>float</code> <p>Z position (optional)</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Vertex(BaseModel):\n    \"\"\"\n    Represents a point in 2D/3D coordinates.\n\n    Attributes:\n        x: X position\n        y: Y position\n        z: Z position (optional)\n    \"\"\"\n\n    x: float = 0.0\n    y: float = 0.0\n    z: float = 0.0\n\n    def __hash__(self):\n        return hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"reference/cogip/models/odometry_calibration/","title":"odometry_calibration","text":"<p>Odometry Calibration Models</p> <p>Pydantic models for odometry calibration data.</p>"},{"location":"reference/cogip/models/odometry_calibration/#cogip.models.odometry_calibration.CalibrationResult","title":"<code>CalibrationResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result of a calibration computation.</p> Source code in <code>cogip/models/odometry_calibration.py</code> <pre><code>class CalibrationResult(BaseModel):\n    \"\"\"Result of a calibration computation.\"\"\"\n\n    wheels_distance: float\n    right_wheel_radius: float\n    left_wheel_radius: float\n</code></pre>"},{"location":"reference/cogip/models/odometry_calibration/#cogip.models.odometry_calibration.CalibrationState","title":"<code>CalibrationState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>State container for calibration intermediate values.</p> <p>Tracks alpha and beta coefficients computed during calibration phases.</p> Source code in <code>cogip/models/odometry_calibration.py</code> <pre><code>class CalibrationState(BaseModel):\n    \"\"\"\n    State container for calibration intermediate values.\n\n    Tracks alpha and beta coefficients computed during calibration phases.\n    \"\"\"\n\n    alpha_l: float = 0.0\n    alpha_r: float = 0.0\n    beta: float = 0.0\n</code></pre>"},{"location":"reference/cogip/models/odometry_calibration/#cogip.models.odometry_calibration.EncoderDeltas","title":"<code>EncoderDeltas</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Encoder tick deltas captured during a motion sequence.</p> Source code in <code>cogip/models/odometry_calibration.py</code> <pre><code>class EncoderDeltas(BaseModel):\n    \"\"\"Encoder tick deltas captured during a motion sequence.\"\"\"\n\n    left: int\n    right: int\n</code></pre>"},{"location":"reference/cogip/models/odometry_calibration/#cogip.models.odometry_calibration.OdometryParameters","title":"<code>OdometryParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Container for odometry parameters.</p> <p>Holds all parameters needed for odometry calibration.</p> Source code in <code>cogip/models/odometry_calibration.py</code> <pre><code>class OdometryParameters(BaseModel):\n    \"\"\"\n    Container for odometry parameters.\n\n    Holds all parameters needed for odometry calibration.\n    \"\"\"\n\n    wheels_distance: float = 0.0\n    right_wheel_radius: float = 0.0\n    left_wheel_radius: float = 0.0\n    left_polarity: float = 0.0\n    right_polarity: float = 0.0\n    encoder_ticks: float = 0.0\n</code></pre>"},{"location":"reference/cogip/scservo_sdk/group_sync_read/","title":"group_sync_read","text":""},{"location":"reference/cogip/scservo_sdk/group_sync_write/","title":"group_sync_write","text":""},{"location":"reference/cogip/scservo_sdk/port_handler/","title":"port_handler","text":""},{"location":"reference/cogip/scservo_sdk/protocol_packet_handler/","title":"protocol_packet_handler","text":""},{"location":"reference/cogip/scservo_sdk/scscl/","title":"scscl","text":""},{"location":"reference/cogip/scservo_sdk/scservo_def/","title":"scservo_def","text":""},{"location":"reference/cogip/scservo_sdk/sms_sts/","title":"sms_sts","text":""},{"location":"reference/cogip/tools/beaconcam/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/beaconcam/app/","title":"app","text":""},{"location":"reference/cogip/tools/beaconcam/app/#cogip.tools.beaconcam.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/beaconcam/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = CameraServer()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler","title":"<code>CameraHandler</code>","text":"<p>Camera handler.</p> <p>Handle camera initialization, sample detection.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>class CameraHandler:\n    \"\"\"\n    Camera handler.\n\n    Handle camera initialization, sample detection.\n    \"\"\"\n\n    _camera_device: Path = None  # Camera device\n    _camera_codec: VideoCodec = None  # Video codec\n    _camera_frame_width: int = None  # Camera frame width\n    _camera_frame_height: int = None  # Camera frame height\n    _camera_capture: cv2.VideoCapture = None  # OpenCV video capture\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _frame_rate: float = 6  # Number of images processed by seconds\n    _exiting: bool = False  # Exit requested if True\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO client and connect to server.\n        \"\"\"\n        self.settings = Settings()\n        signal.signal(signal.SIGTERM, self.exit_handler)\n\n        self.record_filename: Path | None = None\n        self.record_writer: cv2.VideoWriter | None = None\n\n        self.sio = socketio.Client(logger=False, engineio_logger=False)\n        self.register_sio_events()\n        Thread(\n            target=lambda: polling2.poll(\n                self.sio_connect,\n                step=1,\n                ignore_exceptions=(socketio.exceptions.ConnectionError),\n                poll_forever=True,\n            )\n        ).start()\n\n    @staticmethod\n    def exit_handler(signum, frame):\n        \"\"\"\n        Function called when TERM signal is received.\n        \"\"\"\n        CameraHandler._exiting = True\n        raise ExitSignal()\n\n    def sio_connect(self) -&gt; bool:\n        \"\"\"\n        Connect to SocketIO server.\n        Returning True stops polling for connection to succeed.\n        \"\"\"\n        if self._exiting:\n            return True\n\n        self.sio.connect(str(self.settings.socketio_server_url), namespaces=[\"/beaconcam\"])\n        return True\n\n    def open_camera(self):\n        \"\"\"\n        Initialize camera and aruco markers detection parameters.\n        \"\"\"\n        self._camera_capture = cv2.VideoCapture(str(self.settings.camera_device), cv2.CAP_V4L2)\n        if not self._camera_capture.isOpened():\n            logger.error(f\"Camera handler: Cannot open camera device {self.settings.camera_device}\")\n            self._camera_capture.release()\n            self._camera_capture = None\n            return\n\n        fourcc = cv2.VideoWriter_fourcc(*self.settings.camera_codec.value)\n        ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n        if not ret:\n            logger.warning(f\"Video codec {self.settings.camera_codec} not supported\")\n            self.settings.camera_codec = None\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n        if not ret:\n            logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n            self.settings.camera_width = None\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n        if not ret:\n            logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n            self.settings.camera_height = None\n\n    def close_camera(self) -&gt; None:\n        \"\"\"\n        Release camera device.\n        \"\"\"\n        if self._camera_capture:\n            try:\n                self._camera_capture.release()\n                logger.info(\"Camera handler: Camera closed.\")\n            except Exception as exc:  # noqa\n                logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n        self._camera_capture = None\n\n    def open_last_frame(self, size: int) -&gt; None:\n        \"\"\"\n        Open the shared memory used to exchange last frame with the server.\n\n        Arguments:\n            size: Size of the shared memory\n        \"\"\"\n        if not self._last_frame:\n            try:\n                self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n                logger.info(\"Camera handler: shared memory for last_frame created.\")\n            except FileExistsError as exc:\n                logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n                self._last_frame = None\n\n    def close_last_frame(self) -&gt; None:\n        \"\"\"\n        Close last frame shared memory.\n        \"\"\"\n        if self._last_frame:\n            try:\n                self._last_frame.close()\n                self._last_frame.unlink()\n                logger.info(\"Camera handler: Shared memory for last frame closed.\")\n            except Exception as exc:\n                logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n        self._last_frame = None\n\n    def camera_handler(self) -&gt; None:\n        \"\"\"\n        Read and process frames from camera.\n        \"\"\"\n        interval = 1.0 / self._frame_rate\n\n        try:\n            while not self._exiting:\n                start = time.time()\n\n                if not self._camera_capture:\n                    self.open_camera()\n\n                if not self._camera_capture:\n                    logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                    sleep(1)\n                    continue\n\n                try:\n                    self.process_image()\n                except ExitSignal:\n                    break\n                except Exception as exc:\n                    logger.warning(f\"Unknown exception: {exc}\")\n                    self.close_camera()\n                    sleep(1)\n                    continue\n\n                now = time.time()\n                duration = now - start\n                if duration &gt; interval:\n                    logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n                else:\n                    wait = interval - duration\n                    time.sleep(wait)\n\n        except (KeyboardInterrupt, ExitSignal):\n            pass\n\n        logger.info(\"Camera handler: Exiting.\")\n\n        self.close_last_frame()\n        self.close_camera()\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def process_image(self) -&gt; None:\n        \"\"\"\n        Read one frame from camera, process it, send samples to cogip-server\n        and generate image to stream.\n        \"\"\"\n        image_color: np.ndarray\n        ret, image_color = self._camera_capture.read()\n        if not ret:\n            raise Exception(\"Camera handler: Cannot read frame.\")\n\n        image_stream: np.ndarray = image_color\n\n        # Encode the frame in BMP format (larger but faster than JPEG)\n        encoded_image: np.ndarray\n        ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n        if not ret:\n            raise Exception(\"Can't encode frame.\")\n\n        frame = encoded_image.tobytes()\n        self.open_last_frame(len(frame))\n\n        if self._last_frame:\n            self._last_frame.buf[0 : len(frame)] = frame\n\n        if self.record_writer:\n            self.record_writer.write(image_stream)\n\n    def start_video_record(self):\n        if self.record_writer:\n            self.stop_video_record()\n        records_dir = Path.home() / \"records\"\n        records_dir.mkdir(exist_ok=True)\n        # Keep only 20 last records\n        for old_record in sorted(records_dir.glob(\"*.mp4\"))[:-20]:\n            old_record.unlink()\n        timestamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n        self.record_filename = records_dir / f\"beacon_{timestamp}.mp4\"\n\n        logger.info(f\"Start recording video in {self.record_filename}\")\n        self.record_writer = cv2.VideoWriter(\n            str(self.record_filename),\n            cv2.VideoWriter_fourcc(*\"mp4v\"),\n            self._frame_rate,\n            (self.settings.camera_width, self.settings.camera_height),\n        )\n\n    def stop_video_record(self):\n        if self.record_writer:\n            logger.info(\"Stop recording video\")\n            self.record_writer.release()\n            self.record_filename = None\n            self.record_writer = None\n\n    def register_sio_events(self) -&gt; None:\n        @self.sio.event(namespace=\"/beaconcam\")\n        def connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Camera handler: connected to server\")\n            self.sio.emit(\"connected\", namespace=\"/beaconcam\")\n\n        @self.sio.event(namespace=\"/beaconcam\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            logger.info(\"Camera handler: connection to server failed.\")\n\n        @self.sio.event(namespace=\"/beaconcam\")\n        def disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Camera handler: disconnected from server\")\n\n        @self.sio.on(\"start_video_record\", namespace=\"/beaconcam\")\n        def start_video_record():\n            self.start_video_record()\n\n        @self.sio.on(\"stop_video_record\", namespace=\"/beaconcam\")\n        def stop_video_record():\n            self.stop_video_record()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO client and connect to server.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO client and connect to server.\n    \"\"\"\n    self.settings = Settings()\n    signal.signal(signal.SIGTERM, self.exit_handler)\n\n    self.record_filename: Path | None = None\n    self.record_writer: cv2.VideoWriter | None = None\n\n    self.sio = socketio.Client(logger=False, engineio_logger=False)\n    self.register_sio_events()\n    Thread(\n        target=lambda: polling2.poll(\n            self.sio_connect,\n            step=1,\n            ignore_exceptions=(socketio.exceptions.ConnectionError),\n            poll_forever=True,\n        )\n    ).start()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.camera_handler","title":"<code>camera_handler()</code>","text":"<p>Read and process frames from camera.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def camera_handler(self) -&gt; None:\n    \"\"\"\n    Read and process frames from camera.\n    \"\"\"\n    interval = 1.0 / self._frame_rate\n\n    try:\n        while not self._exiting:\n            start = time.time()\n\n            if not self._camera_capture:\n                self.open_camera()\n\n            if not self._camera_capture:\n                logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                sleep(1)\n                continue\n\n            try:\n                self.process_image()\n            except ExitSignal:\n                break\n            except Exception as exc:\n                logger.warning(f\"Unknown exception: {exc}\")\n                self.close_camera()\n                sleep(1)\n                continue\n\n            now = time.time()\n            duration = now - start\n            if duration &gt; interval:\n                logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n            else:\n                wait = interval - duration\n                time.sleep(wait)\n\n    except (KeyboardInterrupt, ExitSignal):\n        pass\n\n    logger.info(\"Camera handler: Exiting.\")\n\n    self.close_last_frame()\n    self.close_camera()\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.close_camera","title":"<code>close_camera()</code>","text":"<p>Release camera device.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def close_camera(self) -&gt; None:\n    \"\"\"\n    Release camera device.\n    \"\"\"\n    if self._camera_capture:\n        try:\n            self._camera_capture.release()\n            logger.info(\"Camera handler: Camera closed.\")\n        except Exception as exc:  # noqa\n            logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n    self._camera_capture = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.close_last_frame","title":"<code>close_last_frame()</code>","text":"<p>Close last frame shared memory.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def close_last_frame(self) -&gt; None:\n    \"\"\"\n    Close last frame shared memory.\n    \"\"\"\n    if self._last_frame:\n        try:\n            self._last_frame.close()\n            self._last_frame.unlink()\n            logger.info(\"Camera handler: Shared memory for last frame closed.\")\n        except Exception as exc:\n            logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n    self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.exit_handler","title":"<code>exit_handler(signum, frame)</code>  <code>staticmethod</code>","text":"<p>Function called when TERM signal is received.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>@staticmethod\ndef exit_handler(signum, frame):\n    \"\"\"\n    Function called when TERM signal is received.\n    \"\"\"\n    CameraHandler._exiting = True\n    raise ExitSignal()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.open_camera","title":"<code>open_camera()</code>","text":"<p>Initialize camera and aruco markers detection parameters.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def open_camera(self):\n    \"\"\"\n    Initialize camera and aruco markers detection parameters.\n    \"\"\"\n    self._camera_capture = cv2.VideoCapture(str(self.settings.camera_device), cv2.CAP_V4L2)\n    if not self._camera_capture.isOpened():\n        logger.error(f\"Camera handler: Cannot open camera device {self.settings.camera_device}\")\n        self._camera_capture.release()\n        self._camera_capture = None\n        return\n\n    fourcc = cv2.VideoWriter_fourcc(*self.settings.camera_codec.value)\n    ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {self.settings.camera_codec} not supported\")\n        self.settings.camera_codec = None\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n        self.settings.camera_width = None\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n        self.settings.camera_height = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.open_last_frame","title":"<code>open_last_frame(size)</code>","text":"<p>Open the shared memory used to exchange last frame with the server.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the shared memory</p> required Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def open_last_frame(self, size: int) -&gt; None:\n    \"\"\"\n    Open the shared memory used to exchange last frame with the server.\n\n    Arguments:\n        size: Size of the shared memory\n    \"\"\"\n    if not self._last_frame:\n        try:\n            self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n            logger.info(\"Camera handler: shared memory for last_frame created.\")\n        except FileExistsError as exc:\n            logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n            self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.process_image","title":"<code>process_image()</code>","text":"<p>Read one frame from camera, process it, send samples to cogip-server and generate image to stream.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def process_image(self) -&gt; None:\n    \"\"\"\n    Read one frame from camera, process it, send samples to cogip-server\n    and generate image to stream.\n    \"\"\"\n    image_color: np.ndarray\n    ret, image_color = self._camera_capture.read()\n    if not ret:\n        raise Exception(\"Camera handler: Cannot read frame.\")\n\n    image_stream: np.ndarray = image_color\n\n    # Encode the frame in BMP format (larger but faster than JPEG)\n    encoded_image: np.ndarray\n    ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n    if not ret:\n        raise Exception(\"Can't encode frame.\")\n\n    frame = encoded_image.tobytes()\n    self.open_last_frame(len(frame))\n\n    if self._last_frame:\n        self._last_frame.buf[0 : len(frame)] = frame\n\n    if self.record_writer:\n        self.record_writer.write(image_stream)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.sio_connect","title":"<code>sio_connect()</code>","text":"<p>Connect to SocketIO server. Returning True stops polling for connection to succeed.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def sio_connect(self) -&gt; bool:\n    \"\"\"\n    Connect to SocketIO server.\n    Returning True stops polling for connection to succeed.\n    \"\"\"\n    if self._exiting:\n        return True\n\n    self.sio.connect(str(self.settings.socketio_server_url), namespaces=[\"/beaconcam\"])\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/codecs/","title":"codecs","text":""},{"location":"reference/cogip/tools/beaconcam/codecs/#cogip.tools.beaconcam.codecs.VideoCodec","title":"<code>VideoCodec</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Video codecs supported by our cameras</p> Source code in <code>cogip/tools/beaconcam/codecs.py</code> <pre><code>class VideoCodec(str, Enum):\n    \"\"\"Video codecs supported by our cameras\"\"\"\n\n    mjpg = \"MJPG\"\n    yuyv = \"YUYV\"\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/main/","title":"main","text":""},{"location":"reference/cogip/tools/beaconcam/main/#cogip.tools.beaconcam.main.main","title":"<code>main()</code>","text":"<p>Launch COGIP Beacon Camera.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-beaconcam</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/beaconcam/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Launch COGIP Beacon Camera.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-beaconcam` script using this function as entrypoint.\n    \"\"\"\n    settings = Settings()\n\n    # Start Camera handler process\n    p = Process(target=start_camera_handler)\n    p.start()\n\n    # Start web server\n    uvicorn.run(\n        \"cogip.tools.beaconcam.app:app\",\n        host=\"0.0.0.0\",\n        port=8100,\n        workers=settings.nb_workers,\n        log_level=\"warning\",\n    )\n\n    p.terminate()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/","title":"server","text":""},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer","title":"<code>CameraServer</code>","text":"<p>Camera web server.</p> <p>Handle FastAPI server to stream camera video and SocketIO client.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>class CameraServer:\n    \"\"\"\n    Camera web server.\n\n    Handle FastAPI server to stream camera video and SocketIO client.\n    \"\"\"\n\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application and SocketIO client.\n        \"\"\"\n        self.settings = Settings()\n        CameraServer._exiting = False\n\n        self.app = FastAPI(title=\"COGIP Beacon Camera Streamer\", debug=False)\n        self.register_endpoints()\n\n        UvicornServer.handle_exit = self.handle_exit\n\n        self.records_dir = Path.home() / \"records\"\n        self.records_dir.mkdir(exist_ok=True)\n        # Keep only 100 last records\n        for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n            old_record.unlink()\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        CameraServer._exiting = True\n\n        if CameraServer._last_frame:\n            try:\n                CameraServer._last_frame.close()\n                logger.info(\"Camera server: Detached shared memory for last frame.\")\n            except FileNotFoundError:\n                pass\n\n        CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def camera_connect(self) -&gt; bool:\n        if self._exiting:\n            return True\n\n        try:\n            CameraServer._last_frame = SharedMemory(name=\"last_frame\")\n        except Exception:\n            CameraServer._last_frame = None\n            logger.warning(\"Camera server: Failed to attach to shared memory last_frame, retrying in 1s.\")\n            return False\n        logger.info(\"Camera server: Attached to shared memory last_frame.\")\n        return True\n\n    async def camera_streamer(self):\n        \"\"\"\n        Frame generator.\n        Yield frames produced by [camera_handler][cogip.tools.beaconcam.camera.CameraHandler.camera_handler].\n        \"\"\"\n        while not self._exiting:\n            yield b\"--frame\\r\\n\"\n            yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n            yield bytes(self._last_frame.buf)\n            yield b\"\\r\\n\"\n\n    def register_endpoints(self) -&gt; None:\n        @self.app.on_event(\"startup\")\n        async def startup_event():\n            \"\"\"\n            Function called at FastAPI server startup.\n            \"\"\"\n            # Poll in background to wait for camera server connection through shared memory.\n            Thread(\n                target=lambda: polling2.poll(\n                    self.camera_connect,\n                    step=1,\n                    poll_forever=True,\n                )\n            ).start()\n\n        @self.app.on_event(\"shutdown\")\n        async def shutdown_event():\n            \"\"\"\n            Function called at FastAPI server shutdown.\n            \"\"\"\n            pass\n\n        @self.app.get(\"/\")\n        def index():\n            \"\"\"\n            Camera stream.\n            \"\"\"\n            stream = self.camera_streamer() if CameraServer._last_frame else \"\"\n            return StreamingResponse(stream, media_type=\"multipart/x-mixed-replace;boundary=frame\")\n\n        @self.app.get(\"/snapshot\", status_code=200)\n        async def snapshot(camp: Camp.Colors):\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"beacon-snapshot-{timestamp}-{camp.name}\"\n\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            record_filename_full = self.records_dir / f\"{basename}_full.jpg\"\n            cv2.imwrite(str(record_filename_full), frame)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application and SocketIO client.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application and SocketIO client.\n    \"\"\"\n    self.settings = Settings()\n    CameraServer._exiting = False\n\n    self.app = FastAPI(title=\"COGIP Beacon Camera Streamer\", debug=False)\n    self.register_endpoints()\n\n    UvicornServer.handle_exit = self.handle_exit\n\n    self.records_dir = Path.home() / \"records\"\n    self.records_dir.mkdir(exist_ok=True)\n    # Keep only 100 last records\n    for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n        old_record.unlink()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.camera_streamer","title":"<code>camera_streamer()</code>  <code>async</code>","text":"<p>Frame generator. Yield frames produced by camera_handler.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>async def camera_streamer(self):\n    \"\"\"\n    Frame generator.\n    Yield frames produced by [camera_handler][cogip.tools.beaconcam.camera.CameraHandler.camera_handler].\n    \"\"\"\n    while not self._exiting:\n        yield b\"--frame\\r\\n\"\n        yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n        yield bytes(self._last_frame.buf)\n        yield b\"\\r\\n\"\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    CameraServer._exiting = True\n\n    if CameraServer._last_frame:\n        try:\n            CameraServer._last_frame.close()\n            logger.info(\"Camera server: Detached shared memory for last frame.\")\n        except FileNotFoundError:\n            pass\n\n    CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/settings/","title":"settings","text":""},{"location":"reference/cogip/tools/camera/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/camera/__main__/#cogip.tools.camera.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Camera Tools.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-camera</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/camera/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Camera Tools.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-camera` script using this function as entrypoint.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"reference/cogip/tools/camera/arguments/","title":"arguments","text":""},{"location":"reference/cogip/tools/camera/arguments/#cogip.tools.camera.arguments.CameraName","title":"<code>CameraName</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Supported cameras</p> Source code in <code>cogip/tools/camera/arguments.py</code> <pre><code>class CameraName(ArgEnum):\n    \"\"\"Supported cameras\"\"\"\n\n    hbv = Path(\"/dev/v4l/by-id/usb-HBV_HD_CAMERA_HBV_HD_CAMERA-video-index0\")\n    sonix = Path(\"/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_2.0_Camera_SN0001-video-index0\")\n    rpicam = Path(\"/sys/class/video4linux/v4l-subdev0/name\")\n    simcam = Path(\"/dev/null\")\n</code></pre>"},{"location":"reference/cogip/tools/camera/arguments/#cogip.tools.camera.arguments.VideoCodec","title":"<code>VideoCodec</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Video codecs supported by our cameras</p> Source code in <code>cogip/tools/camera/arguments.py</code> <pre><code>class VideoCodec(ArgEnum):\n    \"\"\"Video codecs supported by our cameras\"\"\"\n\n    mjpg = \"MJPG\"\n    yuyv = \"YUYV\"\n</code></pre>"},{"location":"reference/cogip/tools/camera/calibrate/","title":"calibrate","text":""},{"location":"reference/cogip/tools/camera/calibrate/#cogip.tools.camera.calibrate.cmd_calibrate","title":"<code>cmd_calibrate(ctx, id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=1920, camera_height=1080, charuco_rows=8, charuco_cols=13, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=True)</code>","text":"<p>Calibrate camera using images captured by the 'capture' command</p> Source code in <code>cogip/tools/camera/calibrate.py</code> <pre><code>def cmd_calibrate(\n    ctx: typer.Context,\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 1920,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 1080,\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 8,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 13,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = True,\n):\n    \"\"\"Calibrate camera using images captured by the 'capture' command\"\"\"\n    obj = ctx.ensure_object(dict)\n    debug = obj.get(\"debug\", False)\n\n    if camera_name == CameraName.rpicam:\n        CameraClass = RPiCamera\n    else:\n        CameraClass = USBCamera\n    camera = CameraClass(id, camera_name, camera_codec, camera_width, camera_height)\n\n    if not camera.capture_path.exists():\n        logger.error(f\"Captured images directory not found: {camera.capture_path}\")\n        return\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_cols, charuco_rows),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    board.setLegacyPattern(charuco_legacy)\n\n    captured_images = list(camera.capture_path.glob(\"image_*.jpg\"))\n    if (nb_img := len(captured_images)) &lt; 10:\n        logger.error(f\"Not enough images: {nb_img} &lt; 10\")\n        return\n\n    object_points = []\n    image_points: list[cv2.typing.MatLike] = []\n\n    board_detector = cv2.aruco.CharucoDetector(board)\n\n    for im in sorted(captured_images)[0:]:\n        frame = cv2.imread(str(im))\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        char_corners, char_ids, _, _ = board_detector.detectBoard(gray)\n        if char_corners is None or len(char_corners) == 0:\n            logger.info(f\"{im}: KO\")\n            continue\n\n        frame_obj_points, frame_img_points = board.matchImagePoints(char_corners, char_ids)\n\n        if len(frame_obj_points) &lt; 4:\n            logger.info(f\"{im}: KO (not enough points: {len(frame_obj_points)})\")\n            continue\n\n        logger.info(f\"{im}: OK ({len(frame_obj_points)} points)\")\n        object_points.append(frame_obj_points)\n        image_points.append(frame_img_points)\n\n        if debug:\n            cv2.aruco.drawDetectedCornersCharuco(frame, char_corners, char_ids)\n            cv2.imshow(\"img\", frame)\n            cv2.waitKey(1000)\n\n    ret, camera_matrix, dist_coefs, _, _ = cv2.calibrateCamera(\n        object_points,\n        image_points,\n        (camera_width, camera_height),\n        None,\n        None,\n    )\n\n    logger.debug(f\"Camera calibration status: {ret}\")\n    logger.debug(\"- camera matrix:\")\n    logger.debug(camera_matrix)\n    logger.debug(\"- dist coefs:\")\n    logger.debug(dist_coefs)\n\n    save_camera_intrinsic_params(camera_matrix, dist_coefs, camera.intrinsic_params_filename)\n    logger.info(f\"Calibration parameters stored in: {camera.intrinsic_params_filename}\")\n</code></pre>"},{"location":"reference/cogip/tools/camera/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/camera/capture/","title":"capture","text":""},{"location":"reference/cogip/tools/camera/capture/#cogip.tools.camera.capture.cmd_capture","title":"<code>cmd_capture(id=1, camera_name=CameraName.rpicam.name, camera_codec=VideoCodec.yuyv.name, camera_width=728, camera_height=544, max_frames=120, capture_interval=10, charuco_rows=8, charuco_cols=13, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=True)</code>","text":"<p>Capture images to be used by the 'calibrate' command</p> Source code in <code>cogip/tools/camera/capture.py</code> <pre><code>def cmd_capture(\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.rpicam.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 728,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 544,\n    max_frames: Annotated[\n        int,\n        typer.Option(\n            help=\"Maximum number of frames to read before exiting\",\n            envvar=\"CAMERA_MAX_FRAMES\",\n        ),\n    ] = 120,\n    capture_interval: Annotated[\n        int,\n        typer.Option(\n            help=\"Capture an image every 'capture_interval' frames\",\n            envvar=\"CAMERA_CAPTURE_INTERVAL\",\n        ),\n    ] = 10,\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 8,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 13,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = True,\n):\n    \"\"\"Capture images to be used by the 'calibrate' command\"\"\"\n    exit_key = 27  # use this key (Esc) to exit before max_frames\n    captures_frames: list[cv2.typing.MatLike] = []  # Captured frames\n    preview_window_name = \"Detection Preview - Press Esc to exit\"\n\n    cv2.namedWindow(preview_window_name, cv2.WINDOW_NORMAL)\n    cv2.setWindowProperty(preview_window_name, cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)\n\n    if not Path(camera_name.val).exists():\n        logger.error(f\"Camera not found: {camera_name.val}\")\n        return\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_cols, charuco_rows),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    board.setLegacyPattern(charuco_legacy)\n\n    if camera_name == CameraName.rpicam:\n        CameraClass = RPiCamera\n    else:\n        CameraClass = USBCamera\n    camera = CameraClass(id, camera_name, camera_codec, camera_width, camera_height)\n    camera.open()\n\n    i = capture_interval\n    while True:\n        frame, stream_frame = camera.read()\n        if frame is None:\n            continue\n\n        board_detector = cv2.aruco.CharucoDetector(board)\n\n        k = cv2.waitKey(1)\n        if k == exit_key:\n            break\n        elif i == 0:\n            i = capture_interval\n            captures_frames.append(frame)\n            logger.info(f\"Frame captured: {len(captures_frames)}\")\n            if len(captures_frames) == max_frames:\n                break\n        i -= 1\n\n        _, _, marker_corners, marker_ids = board_detector.detectBoard(frame)\n        cv2.aruco.drawDetectedMarkers(stream_frame, marker_corners, marker_ids)\n\n        cv2.imshow(preview_window_name, stream_frame)\n\n    camera.close()\n    logger.info(f\"Writing captured frames in: {camera.capture_path}\")\n    shutil.rmtree(camera.capture_path, ignore_errors=True)\n    camera.capture_path.mkdir(parents=True, exist_ok=True)\n    for n, frame in enumerate(captures_frames):\n        filename = camera.capture_path / f\"image_{n:03}.jpg\"\n        cv2.imwrite(str(filename), frame)\n</code></pre>"},{"location":"reference/cogip/tools/camera/charuco/","title":"charuco","text":""},{"location":"reference/cogip/tools/camera/charuco/#cogip.tools.camera.charuco.cmd_charuco","title":"<code>cmd_charuco(charuco_rows=8, charuco_cols=13, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=True)</code>","text":"<p>Display charuco board to check if is corresponds to the board used for calibration.</p> Source code in <code>cogip/tools/camera/charuco.py</code> <pre><code>def cmd_charuco(\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 8,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 13,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = True,\n):\n    \"\"\"Display charuco board to check if is corresponds to the board used for calibration.\"\"\"\n    charuco_window_name = \"Charuco Board\"\n\n    cv2.namedWindow(charuco_window_name, cv2.WINDOW_NORMAL)\n    cv2.setWindowProperty(charuco_window_name, cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_cols, charuco_rows),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    board.setLegacyPattern(charuco_legacy)\n    board_image = board.generateImage((charuco_cols * charuco_square_length, charuco_rows * charuco_square_length))\n    cv2.imshow(charuco_window_name, board_image)\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/","title":"detect","text":""},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.cmd_detect","title":"<code>cmd_detect(id=1, camera_name=CameraName.rpicam.name, camera_codec=VideoCodec.yuyv.name, camera_width=728, camera_height=544, robot_position=None)</code>","text":"<p>Detect Aruco tags and estimate their positions</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def cmd_detect(\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.rpicam.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 728,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 544,\n    robot_position: Annotated[\n        Optional[int],  # noqa\n        typer.Option(\n            help=\"Define the robot position\",\n            envvar=\"CAMERA_ROBOT_POSITION\",\n            min=1,\n            max=6,\n        ),\n    ] = None,\n):\n    \"\"\"Detect Aruco tags and estimate their positions\"\"\"\n    exit_key = 27  # use this key (Esc) to exit before max_frames\n\n    if not camera_name.val.exists():\n        logger.error(f\"Camera not found: {camera_name.val}\")\n        return\n\n    if camera_name == CameraName.rpicam:\n        CameraClass = RPiCamera\n    else:\n        CameraClass = USBCamera\n    camera = CameraClass(id, camera_name, camera_codec, camera_width, camera_height)\n    camera.open()\n\n    # Load intrinsic parameters (mandatory)\n    if not camera.intrinsic_params_filename.exists():\n        logger.warning(f\"Intrinsic parameters file not found: {camera.intrinsic_params_filename}\")\n        camera_matrix, dist_coefs = None, None\n    else:\n        camera_matrix, dist_coefs = load_camera_intrinsic_params(camera.intrinsic_params_filename)\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n    parameters = cv2.aruco.DetectorParameters()\n\n    # Speed optimizations\n    # Use a single window size for adaptive thresholding to avoid multiple passes\n    parameters.adaptiveThreshWinSizeMin = 13\n    parameters.adaptiveThreshWinSizeMax = 13\n    parameters.adaptiveThreshWinSizeStep = 1\n\n    # Reduce accuracy of polygonal approximation (faster contour processing)\n    parameters.polygonalApproxAccuracyRate = 0.05  # Default 0.03\n\n    # Disable corner refinement if not strictly necessary (SUBPIX is slow)\n    parameters.cornerRefinementMethod = cv2.aruco.CORNER_REFINE_NONE\n\n    detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)\n\n    cv2.namedWindow(\"Marker Detection\", cv2.WINDOW_NORMAL)\n    cv2.setWindowProperty(\"Marker Detection\", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)\n\n    while True:\n        frame, stream_frame = camera.read()\n        if frame is None:\n            continue\n\n        if len(frame.shape) == 2:\n            dst = frame\n        else:\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        if stream_frame is None:\n            if len(frame.shape) == 2:\n                stream_frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)\n            else:\n                stream_frame = frame\n\n        # Detect marker corners\n        marker_corners, marker_ids, _ = detector.detectMarkers(dst)\n\n        # Classify detected markers by id and size\n        corners_by_id = {}\n        corners_by_size = {}\n        if marker_ids is not None:\n            for id, corners in zip(marker_ids, marker_corners):\n                size = marker_sizes.get(id[0])\n                if not size:\n                    continue\n                if id[0] not in corners_by_id:\n                    corners_by_id[id[0]] = []\n                corners_by_id[id[0]].append(corners)\n                if size not in corners_by_size:\n                    corners_by_size[size] = []\n                corners_by_size[size].append((id[0], corners))\n\n        if robot_position is not None and camera_matrix is not None and dist_coefs is not None:\n            # Handle table markers\n            table_markers = {\n                id: corners[0]  # There can be only one marker of each id\n                for id, corners in corners_by_id.items()\n                if id in [20, 21, 22, 23]\n            }\n            handle_table_markers(\n                table_markers,\n                camera_matrix,\n                dist_coefs,\n                get_robot_position(robot_position),\n            )\n\n        if marker_ids is not None:\n            # Draw all markers borders\n            for i, corners in enumerate(marker_corners):\n                cv2.polylines(stream_frame, [corners[0].astype(np.int32)], True, (255, 0, 255), 10)\n                cv2.putText(\n                    stream_frame,\n                    str(marker_ids[i][0]),\n                    tuple(corners[0][0].astype(int)),\n                    cv2.FONT_HERSHEY_SIMPLEX,\n                    1.0,\n                    (255, 0, 255),\n                    2,\n                )\n\n            # Draw all markers axes\n            if camera_matrix is not None and dist_coefs is not None:\n                for id, corner in zip(marker_ids, marker_corners):\n                    marker_id = id[0]\n                    if marker_id not in marker_sizes:\n                        logger.warning(f\"Unknown marker found: {marker_id}\")\n                        continue\n\n                    _, rvec, tvec = cv2.solvePnP(\n                        get_marker_points(marker_sizes[marker_id]),\n                        corner,\n                        camera_matrix,\n                        dist_coefs,\n                        False,\n                        cv2.SOLVEPNP_IPPE_SQUARE,\n                    )\n                    cv2.drawFrameAxes(stream_frame, camera_matrix, dist_coefs, rvec, tvec, 50, 5)\n\n        cv2.imshow(\"Marker Detection\", stream_frame)\n\n        k = cv2.waitKey(1)\n        if k == exit_key:\n            break\n\n    camera.close()\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_camera_position_in_robot","title":"<code>get_camera_position_in_robot(robot_position, table_camera_tvec, table_camera_rvec)</code>","text":"<p>Compute camera extrinsic parameters (position relative to robot center) using the known robot position on the table.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_camera_position_in_robot(\n    robot_position: Pose,\n    table_camera_tvec: ArrayLike,\n    table_camera_rvec: ArrayLike,\n) -&gt; CameraExtrinsicParameters:\n    \"\"\"\n    Compute camera extrinsic parameters (position relative to robot center)\n    using the known robot position on the table.\n    \"\"\"\n\n    # Robot in Table frame (Transformation T_rt)\n    robot_angle_rad = np.deg2rad(robot_position.O)\n    R_rt = np.array(\n        [\n            [np.cos(robot_angle_rad), -np.sin(robot_angle_rad), 0],\n            [np.sin(robot_angle_rad), np.cos(robot_angle_rad), 0],\n            [0, 0, 1],\n        ]\n    )\n    T_rt = np.array([robot_position.x, robot_position.y, 0])\n    M_rt = make_transform_matrix(R_rt, T_rt)\n\n    # Camera in Table frame (Transformation T_ct)\n    # Reconstruct rotation matrix from Euler angles.\n    # Note: table_camera_rvec was computed using R_flip * R_tc, so we reverse it here.\n    R_ct_flipped = euler_angles_to_rotation_matrix(np.deg2rad(table_camera_rvec))\n    R_ct = R_flip @ R_ct_flipped\n    M_ct = make_transform_matrix(R_ct, table_camera_tvec)\n\n    # Camera in Robot frame (Transformation T_cr)\n    # M_cr = M_rt^(-1) * M_ct\n    M_cr = np.linalg.inv(M_rt) @ M_ct\n\n    # Extract results\n    R_cr, T_cr = decompose_transform_matrix(M_cr)\n\n    # Convert R_cr to Euler angles.\n    # Apply R_flip again to maintain consistency with the storage convention.\n    R_cr_flipped = R_flip @ R_cr\n    rvec_cr = rotation_matrix_to_euler_angles(R_cr_flipped)\n    rvec_cr_degrees = np.rad2deg(rvec_cr)\n\n    logger.info(\n        f\"Camera extrinsic parameters: X={T_cr[0]:.0f} Y={T_cr[1]:.0f} Z={T_cr[2]:.0f} \"\n        f\"Roll={rvec_cr_degrees[0]:.0f} Pitch={rvec_cr_degrees[1]:.0f} Yaw={rvec_cr_degrees[2]:.0f}\"\n    )\n    return CameraExtrinsicParameters(\n        x=T_cr[0],\n        y=T_cr[1],\n        z=T_cr[2],\n        roll=rvec_cr_degrees[0],\n        pitch=rvec_cr_degrees[1],\n        yaw=rvec_cr_degrees[2],\n        angle=rvec_cr_degrees[2],  # Backward compatibility\n    )\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_camera_position_on_table","title":"<code>get_camera_position_on_table(table_markers, camera_matrix, dist_coefs)</code>","text":"<p>Return a 2-tuple of 3D NDArray of camera position and its rotation in degrees in the table coordinate system.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_camera_position_on_table(\n    table_markers: dict[int, MatLike],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n) -&gt; tuple[ArrayLike, ArrayLike]:\n    \"\"\"\n    Return a 2-tuple of 3D NDArray of camera position and its rotation in degrees\n    in the table coordinate system.\n    \"\"\"\n    tvecs = {}\n    rvecs = {}\n    distances = {}\n\n    for id, corners in table_markers.items():\n        # Get marker coordinates in the camera coordinate system\n        _, rvec, tvec = cv2.solvePnP(\n            get_marker_points(marker_sizes[id]),\n            corners,\n            camera_matrix,\n            dist_coefs,\n            False,\n            cv2.SOLVEPNP_IPPE_SQUARE,\n        )\n\n        # Distance from the camera to the marker\n        distance = np.sqrt(tvec[0] ** 2 + tvec[1] ** 2 + tvec[2] ** 2)\n\n        # Keep the nearest marker for each id\n        if id not in distances or distances[id] &gt; distance:\n            distances[id] = distance\n            tvecs[id] = tvec\n            rvecs[id] = rvec\n\n    # Get nearest marker: sort by value (distance) in ascending order, and take first element key (id)\n    marker_id, _ = sorted(distances.items(), key=lambda x: x[1])[0]\n    marker_tvec = tvecs[marker_id][:, 0]\n    marker_rvec = rvecs[marker_id][:, 0]\n\n    # Marker in Camera frame (from solvePnP)\n    R_cm = cv2.Rodrigues(marker_rvec)[0]\n    M_cm = make_transform_matrix(R_cm, marker_tvec)\n\n    # Camera in Marker frame (inverse transformation)\n    M_mc = np.linalg.inv(M_cm)\n\n    # Rotation matrix from Marker frame to Table frame.\n    # Marker frame (defined in get_marker_points): X Right, Y Up, Z Out (Up)\n    # Table frame: X Up, Y Left, Z Up\n    # Mapping: X_table = Y_marker, Y_table = -X_marker, Z_table = Z_marker\n    R_tm = np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])\n    M_tm = make_transform_matrix(R_tm, table_markers_tvecs[marker_id])\n\n    # Camera in Table frame\n    M_tc = M_tm @ M_mc\n\n    # Extract results\n    R_tc, T_table = decompose_transform_matrix(M_tc)\n\n    # Convert rotation matrix to Euler angles (degrees).\n    # Apply R_flip (180 deg rotation around X) to match the convention expected\n    # by rotation_matrix_to_euler_angles.\n    camera_rvec = rotation_matrix_to_euler_angles(R_flip @ R_tc)\n    camera_rvec_degrees = np.rad2deg(camera_rvec)\n\n    logger.info(\n        \"- Camera position in table coordinate system: \"\n        f\"X={T_table[0]:.0f} \"\n        f\"Y={T_table[1]:.0f} \"\n        f\"Z={T_table[2]:.0f} \"\n        f\"Roll={camera_rvec_degrees[0]:.0f} \"\n        f\"Pitch={camera_rvec_degrees[1]:.0f} \"\n        f\"Yaw={camera_rvec_degrees[2]:.0f}\"\n    )\n\n    return (T_table, camera_rvec_degrees)\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_marker_points","title":"<code>get_marker_points(marker_size)</code>  <code>cached</code>","text":"<p>Get marker points matrix based on marker size, as used by cv2.solvePnP</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>@lru_cache\ndef get_marker_points(marker_size: float):\n    \"\"\"Get marker points matrix based on marker size, as used by cv2.solvePnP\"\"\"\n    return np.array(\n        [\n            [-marker_size / 2, marker_size / 2, 0],\n            [marker_size / 2, marker_size / 2, 0],\n            [marker_size / 2, -marker_size / 2, 0],\n            [-marker_size / 2, -marker_size / 2, 0],\n        ],\n        dtype=np.float32,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_robot_position","title":"<code>get_robot_position(n)</code>","text":"<p>Define the possible start positions.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_robot_position(n: int) -&gt; Pose | None:\n    \"\"\"\n    Define the possible start positions.\n    \"\"\"\n    match n:\n        case 1:  # Back left (yellow)\n            return Pose(\n                x=1000 - 450 + robot_width / 2,\n                y=1500 - 450 + robot_width / 2,\n                O=-90,\n            )\n        case 2:  # Front left (yellow)\n            return Pose(\n                x=-(1000 - 450 + robot_width / 2),\n                y=1500 - 450 + robot_width / 2,\n                O=-90,\n            )\n        case 3:  # Middle right (yellow)\n            return Pose(\n                x=robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 4:  # Back right (blue)\n            return Pose(\n                x=1000 - 450 + robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 5:  # Front right (blue)\n            return Pose(\n                x=-(1000 - 450 + robot_width / 2),\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 6:  # Middle left (blue)\n            return Pose(\n                x=robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n\n    logger.error(f\"Unknown robot position: {n}\")\n\n    return None\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.handle_table_markers","title":"<code>handle_table_markers(markers, camera_matrix, dist_coefs, robot_position)</code>","text":"<p>Compute camera position on table and camera position in robot if robot position is given</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def handle_table_markers(\n    markers: dict[int, MatLike],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n    robot_position: Pose | None,\n):\n    \"\"\"Compute camera position on table and camera position in robot if robot position is given\"\"\"\n    if len(markers) == 0:\n        logger.debug(\"No table marker found, skip robot positioning.\")\n        return\n\n    # Compute camera position on table\n    table_camera_tvec, table_camera_rvec_degrees = get_camera_position_on_table(\n        markers,\n        camera_matrix,\n        dist_coefs,\n    )\n\n    # Compute camera position in robot if robot position is given\n    if robot_position:\n        get_camera_position_in_robot(\n            robot_position,\n            table_camera_tvec,\n            table_camera_rvec_degrees,\n        )\n</code></pre>"},{"location":"reference/cogip/tools/camera/info/","title":"info","text":""},{"location":"reference/cogip/tools/camera/info/#cogip.tools.camera.info.cmd_info","title":"<code>cmd_info(ctx, id=1, camera_name=None, camera_codec=VideoCodec.yuyv.name, camera_width=728, camera_height=544)</code>","text":"<p>Get properties of connected cameras</p> Source code in <code>cogip/tools/camera/info.py</code> <pre><code>def cmd_info(\n    ctx: typer.Context,\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        Optional[CameraName],  # noqa\n        typer.Option(\n            help=\"Name of the camera (all if not specified)\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = None,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 728,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 544,\n):\n    \"\"\"Get properties of connected cameras\"\"\"\n    obj = ctx.ensure_object(dict)\n    debug = obj.get(\"debug\", False)\n\n    if debug:\n        logging.getLogger(\"linuxpy.video\").setLevel(logging.DEBUG)\n    else:\n        logging.getLogger(\"linuxpy.video\").setLevel(logging.INFO)\n\n    if camera_name:\n        if not Path(camera_name.val).exists():\n            logger.error(f\"Camera not found: {camera_name}\")\n            return\n\n        if camera_name != CameraName.rpicam:\n            camera = device.Device(camera_name.val)\n            try:\n                camera.open()\n            except OSError:\n                logger.error(f\"Failed to open {camera_name.val}\")\n                return\n            USBCamera.print_device_info(camera)\n            camera.close()\n        else:\n            RPiCamera.print_device_info()\n\n        show_stream(id, camera_name, camera_codec, camera_width, camera_height)\n        return\n\n    for camera in device.iter_video_capture_devices():\n        try:\n            camera.open()\n        except OSError:\n            pass\n        else:\n            USBCamera.print_device_info(camera)\n            camera.close()\n            print()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/","title":"utils","text":""},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.decompose_transform_matrix","title":"<code>decompose_transform_matrix(M)</code>","text":"<p>Decompose a 4x4 transformation matrix into rotation matrix and translation vector.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def decompose_transform_matrix(M: np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Decompose a 4x4 transformation matrix into rotation matrix and translation vector.\"\"\"\n    return M[:3, :3].copy(), M[:3, 3].copy()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.euler_angles_to_rotation_matrix","title":"<code>euler_angles_to_rotation_matrix(theta)</code>","text":"<p>Calculates rotation matrix from euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>ArrayLike</code> <p>Euler angles in radians (roll, pitch, yaw)</p> required Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def euler_angles_to_rotation_matrix(theta: ArrayLike) -&gt; cv2.typing.MatLike:\n    \"\"\"\n    Calculates rotation matrix from euler angles.\n\n    Arguments:\n        theta: Euler angles in radians (roll, pitch, yaw)\n    \"\"\"\n    R_x = np.array(\n        [\n            [1, 0, 0],\n            [0, np.cos(theta[0]), -np.sin(theta[0])],\n            [0, np.sin(theta[0]), np.cos(theta[0])],\n        ]\n    )\n\n    R_y = np.array(\n        [\n            [np.cos(theta[1]), 0, np.sin(theta[1])],\n            [0, 1, 0],\n            [-np.sin(theta[1]), 0, np.cos(theta[1])],\n        ]\n    )\n\n    R_z = np.array(\n        [\n            [np.cos(theta[2]), -np.sin(theta[2]), 0],\n            [np.sin(theta[2]), np.cos(theta[2]), 0],\n            [0, 0, 1],\n        ]\n    )\n\n    R = np.dot(R_z, np.dot(R_y, R_x))\n\n    return R\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.extrinsic_params_to_matrix","title":"<code>extrinsic_params_to_matrix(params)</code>","text":"<p>Convert camera extrinsic parameters to a 4x4 transformation matrix.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def extrinsic_params_to_matrix(params: CameraExtrinsicParameters) -&gt; np.ndarray:\n    \"\"\"Convert camera extrinsic parameters to a 4x4 transformation matrix.\"\"\"\n    rvec_degrees = np.array([params.roll, params.pitch, params.yaw])\n    R_flipped = euler_angles_to_rotation_matrix(np.deg2rad(rvec_degrees))\n    R = R_flip @ R_flipped\n    t = np.array([params.x, params.y, params.z])\n    return make_transform_matrix(R, t)\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.is_rotation_matrix","title":"<code>is_rotation_matrix(R)</code>","text":"<p>Checks if a matrix is a valid rotation matrix</p> <p>Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def is_rotation_matrix(R):\n    \"\"\"\n    Checks if a matrix is a valid rotation matrix\n\n    Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/\n    \"\"\"\n    Rt = np.transpose(R)\n    shouldBeIdentity = np.dot(Rt, R)\n    ident = np.identity(3, dtype=R.dtype)\n    n = np.linalg.norm(ident - shouldBeIdentity)\n    return n &lt; 1e-6\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.load_camera_extrinsic_params","title":"<code>load_camera_extrinsic_params(path)</code>","text":"<p>Loads camera position relative to robot center.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def load_camera_extrinsic_params(path: Path) -&gt; CameraExtrinsicParameters:\n    \"\"\"Loads camera position relative to robot center.\"\"\"\n    return CameraExtrinsicParameters.model_validate_json(path.read_text())\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.load_camera_intrinsic_params","title":"<code>load_camera_intrinsic_params(path)</code>","text":"<p>Loads camera matrix and distortion coefficients.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def load_camera_intrinsic_params(path: Path) -&gt; tuple[cv2.typing.MatLike, cv2.typing.MatLike]:\n    \"\"\"Loads camera matrix and distortion coefficients.\"\"\"\n    cv_file = cv2.FileStorage(str(path), cv2.FILE_STORAGE_READ)\n    camera_matrix = cv_file.getNode(\"K\").mat()\n    dist_coefs = cv_file.getNode(\"D\").mat()\n    cv_file.release()\n    return camera_matrix, dist_coefs\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.make_transform_matrix","title":"<code>make_transform_matrix(R, t)</code>","text":"<p>Create a 4x4 transformation matrix from rotation matrix and translation vector.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def make_transform_matrix(R: ArrayLike, t: ArrayLike) -&gt; np.ndarray:\n    \"\"\"Create a 4x4 transformation matrix from rotation matrix and translation vector.\"\"\"\n    M = np.eye(4)\n    M[:3, :3] = R\n    M[:3, 3] = np.asarray(t).flatten()\n    return M\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.rotation_matrix_to_euler_angles","title":"<code>rotation_matrix_to_euler_angles(R)</code>","text":"<p>Calculates rotation matrix to euler angles. The result is the same as MATLAB except the order of the euler angles (x and z are swapped).</p> <p>Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def rotation_matrix_to_euler_angles(R):\n    \"\"\"\n    Calculates rotation matrix to euler angles.\n    The result is the same as MATLAB except the order\n    of the euler angles (x and z are swapped).\n\n    Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/\n    \"\"\"\n    assert is_rotation_matrix(R)\n\n    sy = np.sqrt(R[0, 0] * R[0, 0] + R[1, 0] * R[1, 0])\n\n    singular = sy &lt; 1e-6\n\n    if not singular:\n        x = np.arctan2(R[2, 1], R[2, 2])\n        y = np.arctan2(-R[2, 0], sy)\n        z = np.arctan2(R[1, 0], R[0, 0])\n    else:\n        x = np.arctan2(-R[1, 2], R[1, 1])\n        y = np.arctan2(-R[2, 0], sy)\n        z = 0\n\n    return np.array([x, y, z])\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.save_camera_extrinsic_params","title":"<code>save_camera_extrinsic_params(params, path)</code>","text":"<p>Save the camera position relative to robot center to given path/file.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def save_camera_extrinsic_params(params: CameraExtrinsicParameters, path: Path):\n    \"\"\"Save the camera position relative to robot center to given path/file.\"\"\"\n    path.write_text(params.model_dump_json(indent=2))\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.save_camera_intrinsic_params","title":"<code>save_camera_intrinsic_params(camera_matrix, dist_coefs, path)</code>","text":"<p>Save the camera matrix and the distortion coefficients to given path/file.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def save_camera_intrinsic_params(camera_matrix: cv2.typing.MatLike, dist_coefs: cv2.typing.MatLike, path: Path):\n    \"\"\"Save the camera matrix and the distortion coefficients to given path/file.\"\"\"\n    cv_file = cv2.FileStorage(str(path), cv2.FILE_STORAGE_WRITE)\n    cv_file.write(\"K\", camera_matrix)\n    cv_file.write(\"D\", dist_coefs)\n    cv_file.release()\n</code></pre>"},{"location":"reference/cogip/tools/cansend/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cansend/__main__/#cogip.tools.cansend.__main__.main","title":"<code>main()</code>","text":"<p>Run cansend utility.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-cansend</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/cansend/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Run cansend utility.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-cansend` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/copilot/__main__/#cogip.tools.copilot.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-copilot</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/copilot/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-copilot` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/controller/","title":"controller","text":""},{"location":"reference/cogip/tools/copilot/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot","title":"<code>Copilot</code>","text":"<p>Main copilot class.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>class Copilot:\n    \"\"\"\n    Main copilot class.\n    \"\"\"\n\n    loop: asyncio.AbstractEventLoop = None  # Event loop to use for all coroutines\n\n    def __init__(self, server_url: str, id: int, can_channel: str, can_bitrate: int, canfd_data_bitrate: int):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            server_url: server URL\n            id: robot id\n            can_channel: CAN channel connected to STM32 device\n            can_bitrate: CAN bitrate\n            canfd_data_bitrate: CAN data bitrate\n        \"\"\"\n        self.server_url = server_url\n        self.id = id\n        self.retry_connection = True\n        self.shell_menu: models.ShellMenu | None = None\n        self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_pose_current_lock: WritePriorityLock | None = None\n        self.shared_avoidance_path: SharedPoseOrderList | None = None\n        self.shared_avoidance_path_lock: WritePriorityLock | None = None\n        self.new_path_event_task: asyncio.Task | None = None\n\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_events = SioEvents(self)\n        self.sio.register_namespace(self.sio_events)\n\n        pb_message_handlers = {\n            reset_uuid: self.handle_reset,\n            pose_order_uuid: self.handle_message_pose,\n            state_uuid: self.handle_message_state,\n            pose_reached_uuid: self.handle_pose_reached,\n            intermediate_pose_reached_uuid: self.handle_intermediate_pose_reached,\n            actuator_state_uuid: self.handle_actuator_state,\n            pid_uuid: self.handle_pid,\n            blocked_uuid: self.handle_blocked,\n            parameter_get_response_uuid: self.handle_parameter_get_response,\n            parameter_set_response_uuid: self.handle_parameter_set_response,\n            telemetry_data_uuid: self.handle_telemetry_data,\n            emergency_stop_status_uuid: self.handle_emergency_stop_status,\n            power_source_status_uuid: self.handle_power_source_status,\n            power_rails_status_uuid: self.handle_power_rails_status,\n        }\n\n        self.pbcom = PBCom(can_channel, can_bitrate, canfd_data_bitrate, pb_message_handlers)\n\n    def create_shared_memory(self):\n        self.shared_memory = SharedMemory(f\"cogip_{self.id}\")\n        self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n        self.shared_pose_current_lock = self.shared_memory.get_lock(LockName.PoseCurrent)\n        self.shared_avoidance_path = self.shared_memory.get_avoidance_path()\n        self.shared_avoidance_path_lock = self.shared_memory.get_lock(LockName.AvoidancePath)\n        self.shared_avoidance_path_lock.register_consumer()\n        self.new_path_event_task = asyncio.create_task(\n            self.new_path_event_loop(),\n            name=\"Robot: Task New Path Event Watcher Loop\",\n        )\n\n    async def delete_shared_memory(self):\n        if self.new_path_event_task:\n            self.new_path_event_task.cancel()\n            try:\n                await self.new_path_event_task\n            except asyncio.CancelledError:\n                logger.info(\"Copilot: Task New Path Event Watcher Loop stopped\")\n            except Exception as exc:\n                logger.warning(f\"Copilot: Unexpected exception {exc}\")\n                traceback.print_exc()\n        self.new_path_event_task = None\n\n        self.shared_avoidance_path_lock = None\n        self.shared_avoidance_path = None\n        self.shared_pose_current_buffer = None\n        self.shared_pose_current_lock = None\n        self.shared_memory = None\n\n    async def run(self):\n        \"\"\"\n        Start copilot.\n        \"\"\"\n        self.loop = asyncio.get_running_loop()\n\n        self.retry_connection = True\n        await self.try_connect()\n\n        await self.pbcom.send_can_message(copilot_connected_uuid, None)\n\n        await self.pbcom.run()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    async def handle_reset(self) -&gt; None:\n        \"\"\"\n        Handle reset message. This means that the robot has just booted.\n\n        Send a reset message to all connected clients.\n        \"\"\"\n        logger.info(\"[CAN] Received reset\")\n        await self.pbcom.send_can_message(copilot_connected_uuid, None)\n        await self.sio_events.emit(\"reset\")\n\n    @pb_exception_handler\n    async def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot pose received from the robot to connected monitors and detector.\n        \"\"\"\n        pb_pose = PB_Pose()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n        pose = MessageToDict(\n            pb_pose,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio_events.connected:\n            self.shared_pose_current_lock.start_writing()\n            self.shared_pose_current_buffer.push(pose[\"x\"], pose[\"y\"], pose[\"O\"])\n            self.shared_pose_current_lock.finish_writing()\n\n    @pb_exception_handler\n    async def handle_message_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot state received from the robot to connected monitors.\n        \"\"\"\n        pb_state = PB_State()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n        state = MessageToDict(\n            pb_state,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"state\", state)\n\n    @pb_exception_handler\n    async def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send actuator state received from the robot.\n        \"\"\"\n        pb_actuator_state = PB_ActuatorState()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n        kind = pb_actuator_state.WhichOneof(\"type\")\n        actuator_state = MessageToDict(\n            getattr(pb_actuator_state, kind),\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"actuator_state\", actuator_state)\n\n    @pb_exception_handler\n    async def handle_pid(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send pids state received from the robot to connected dashboards.\n        \"\"\"\n        pb_pid = PB_Pid()\n        if message:\n            await self.loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n        self.pb_pids[pb_pid.id] = pb_pid\n        pid = Pid(\n            id=pb_pid.id,\n            kp=pb_pid.kp,\n            ki=pb_pid.ki,\n            kd=pb_pid.kd,\n            integral_term_limit=pb_pid.integral_term_limit,\n        )\n\n        # Get JSON Schema\n        pid_schema = pid.model_json_schema()\n        # Add namespace in JSON Schema\n        pid_schema[\"namespace\"] = \"/copilot\"\n        pid_schema[\"sio_event\"] = \"config_updated\"\n        # Add current values in JSON Schema\n        pid_schema[\"title\"] = pid.id.name\n        for prop, value in pid.model_dump().items():\n            if prop == \"id\":\n                continue\n            pid_schema[\"properties\"][prop][\"value\"] = value\n            pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n            del pid_schema[\"properties\"][prop]\n        # Send config\n        await self.sio_events.emit(\"config\", pid_schema)\n\n    async def handle_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle pose reached message.\n\n        Forward info to the planner.\n        \"\"\"\n        logger.info(\"[CAN] Received pose reached\")\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"pose_reached\")\n\n    async def handle_intermediate_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle intermediate pose reached message.\n\n        Forward info to the planner.\n        \"\"\"\n        logger.info(\"[CAN] Received intermediate pose reached\")\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"intermediate_pose_reached\")\n\n    async def handle_blocked(self) -&gt; None:\n        \"\"\"\n        Handle blocked message.\n\n        Forward info to the planner.\n        \"\"\"\n        logger.info(\"[CAN] Received blocked\")\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"blocked\")\n\n    @pb_exception_handler\n    async def handle_parameter_get_response(self, message: bytes | None = None):\n        \"\"\"\n        Handle parameter get response from firmware.\n\n        Forward response to the firmware_parameter_manager.\n        \"\"\"\n        pb_response = PB_ParameterGetResponse()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_response.ParseFromString, message)\n\n        response = MessageToDict(\n            pb_response,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        logger.info(f\"[CAN] get_response: {response}\")\n\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"get_parameter_response\", response)\n\n    @pb_exception_handler\n    async def handle_parameter_set_response(self, message: bytes | None = None):\n        \"\"\"\n        Handle parameter set response from firmware.\n\n        Forward response to the firmware_parameter_manager.\n        \"\"\"\n        pb_response = PB_ParameterSetResponse()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_response.ParseFromString, message)\n\n        response = MessageToDict(\n            pb_response,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        logger.info(f\"[CAN] set_response: {response}\")\n\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"set_parameter_response\", response)\n\n    @pb_exception_handler\n    async def handle_telemetry_data(self, message: bytes | None = None):\n        \"\"\"\n        Handle parameter telemetry data from firmware.\n\n        Forward response to the TODO:\n        \"\"\"\n        pb_telemetry = PB_TelemetryData()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_telemetry.ParseFromString, message)\n\n        telemetry = MessageToDict(\n            pb_telemetry,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        logger.debug(f\"[CAN] telemetry data: {telemetry}\")\n\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"telemetry_data\", telemetry)\n\n    @pb_exception_handler\n    async def handle_emergency_stop_status(self, message: bytes | None = None):\n        \"\"\"\n        Handle emergency stop status from power supply board.\n\n        Forward status to connected clients.\n        \"\"\"\n        pb_status = PB_EmergencyStopStatus()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_status.ParseFromString, message)\n\n        status = MessageToDict(\n            pb_status,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        logger.debug(f\"[CAN] emergency stop status: {status}\")\n\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"emergency_stop_status\", status)\n\n    @pb_exception_handler\n    async def handle_power_source_status(self, message: bytes | None = None):\n        \"\"\"\n        Handle power source status from power supply board.\n\n        Forward status to connected clients.\n        \"\"\"\n        pb_status = PB_PowerSourceStatus()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_status.ParseFromString, message)\n\n        status = MessageToDict(\n            pb_status,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        logger.debug(f\"[CAN] power source status: {status}\")\n\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"power_source_status\", status)\n\n    @pb_exception_handler\n    async def handle_power_rails_status(self, message: bytes | None = None):\n        \"\"\"\n        Handle power rails status from power supply board.\n\n        Forward status to connected clients.\n        \"\"\"\n        pb_status = PB_PowerRailsStatus()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_status.ParseFromString, message)\n\n        status = MessageToDict(\n            pb_status,\n            always_print_fields_with_no_presence=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        logger.debug(f\"[CAN] power rails status: {status}\")\n\n        if self.sio_events.connected:\n            await self.sio_events.emit(\"power_rails_status\", status)\n\n    async def new_path_event_loop(self):\n        \"\"\"\n        Async worker watching for new path orders in shared memory.\n        When a new path is available, its first pose is sent to the firmware.\n        \"\"\"\n        logger.info(\"Copilot: Task New Path Event Watcher Loop started\")\n        try:\n            while True:\n                await asyncio.to_thread(self.shared_avoidance_path_lock.wait_update)\n                if len(self.shared_avoidance_path) == 0:\n                    continue\n                pose_order = models.PathPose.from_shared(self.shared_avoidance_path[0])\n                if self.id &gt; 1:\n                    pose_order.motion_direction = models.MotionDirection.FORWARD_ONLY\n                pb_pose_order = PB_PathPose()\n                pose_order.copy_pb(pb_pose_order)\n                await self.pbcom.send_can_message(pose_order_uuid, pb_pose_order)\n\n        except asyncio.CancelledError:\n            logger.info(\"Copilot: Task New Path Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Copilot: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.__init__","title":"<code>__init__(server_url, id, can_channel, can_bitrate, canfd_data_bitrate)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>server URL</p> required <code>id</code> <code>int</code> <p>robot id</p> required <code>can_channel</code> <code>str</code> <p>CAN channel connected to STM32 device</p> required <code>can_bitrate</code> <code>int</code> <p>CAN bitrate</p> required <code>canfd_data_bitrate</code> <code>int</code> <p>CAN data bitrate</p> required Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>def __init__(self, server_url: str, id: int, can_channel: str, can_bitrate: int, canfd_data_bitrate: int):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        server_url: server URL\n        id: robot id\n        can_channel: CAN channel connected to STM32 device\n        can_bitrate: CAN bitrate\n        canfd_data_bitrate: CAN data bitrate\n    \"\"\"\n    self.server_url = server_url\n    self.id = id\n    self.retry_connection = True\n    self.shell_menu: models.ShellMenu | None = None\n    self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_pose_current_lock: WritePriorityLock | None = None\n    self.shared_avoidance_path: SharedPoseOrderList | None = None\n    self.shared_avoidance_path_lock: WritePriorityLock | None = None\n    self.new_path_event_task: asyncio.Task | None = None\n\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_events = SioEvents(self)\n    self.sio.register_namespace(self.sio_events)\n\n    pb_message_handlers = {\n        reset_uuid: self.handle_reset,\n        pose_order_uuid: self.handle_message_pose,\n        state_uuid: self.handle_message_state,\n        pose_reached_uuid: self.handle_pose_reached,\n        intermediate_pose_reached_uuid: self.handle_intermediate_pose_reached,\n        actuator_state_uuid: self.handle_actuator_state,\n        pid_uuid: self.handle_pid,\n        blocked_uuid: self.handle_blocked,\n        parameter_get_response_uuid: self.handle_parameter_get_response,\n        parameter_set_response_uuid: self.handle_parameter_set_response,\n        telemetry_data_uuid: self.handle_telemetry_data,\n        emergency_stop_status_uuid: self.handle_emergency_stop_status,\n        power_source_status_uuid: self.handle_power_source_status,\n        power_rails_status_uuid: self.handle_power_rails_status,\n    }\n\n    self.pbcom = PBCom(can_channel, can_bitrate, canfd_data_bitrate, pb_message_handlers)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_actuator_state","title":"<code>handle_actuator_state(message=None)</code>  <code>async</code>","text":"<p>Send actuator state received from the robot.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send actuator state received from the robot.\n    \"\"\"\n    pb_actuator_state = PB_ActuatorState()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n    kind = pb_actuator_state.WhichOneof(\"type\")\n    actuator_state = MessageToDict(\n        getattr(pb_actuator_state, kind),\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"actuator_state\", actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_blocked","title":"<code>handle_blocked()</code>  <code>async</code>","text":"<p>Handle blocked message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_blocked(self) -&gt; None:\n    \"\"\"\n    Handle blocked message.\n\n    Forward info to the planner.\n    \"\"\"\n    logger.info(\"[CAN] Received blocked\")\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"blocked\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_emergency_stop_status","title":"<code>handle_emergency_stop_status(message=None)</code>  <code>async</code>","text":"<p>Handle emergency stop status from power supply board.</p> <p>Forward status to connected clients.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_emergency_stop_status(self, message: bytes | None = None):\n    \"\"\"\n    Handle emergency stop status from power supply board.\n\n    Forward status to connected clients.\n    \"\"\"\n    pb_status = PB_EmergencyStopStatus()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_status.ParseFromString, message)\n\n    status = MessageToDict(\n        pb_status,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    logger.debug(f\"[CAN] emergency stop status: {status}\")\n\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"emergency_stop_status\", status)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_intermediate_pose_reached","title":"<code>handle_intermediate_pose_reached()</code>  <code>async</code>","text":"<p>Handle intermediate pose reached message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_intermediate_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle intermediate pose reached message.\n\n    Forward info to the planner.\n    \"\"\"\n    logger.info(\"[CAN] Received intermediate pose reached\")\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"intermediate_pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_pose","title":"<code>handle_message_pose(message=None)</code>  <code>async</code>","text":"<p>Send robot pose received from the robot to connected monitors and detector.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot pose received from the robot to connected monitors and detector.\n    \"\"\"\n    pb_pose = PB_Pose()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n    pose = MessageToDict(\n        pb_pose,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio_events.connected:\n        self.shared_pose_current_lock.start_writing()\n        self.shared_pose_current_buffer.push(pose[\"x\"], pose[\"y\"], pose[\"O\"])\n        self.shared_pose_current_lock.finish_writing()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_state","title":"<code>handle_message_state(message=None)</code>  <code>async</code>","text":"<p>Send robot state received from the robot to connected monitors.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot state received from the robot to connected monitors.\n    \"\"\"\n    pb_state = PB_State()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n    state = MessageToDict(\n        pb_state,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"state\", state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_parameter_get_response","title":"<code>handle_parameter_get_response(message=None)</code>  <code>async</code>","text":"<p>Handle parameter get response from firmware.</p> <p>Forward response to the firmware_parameter_manager.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_parameter_get_response(self, message: bytes | None = None):\n    \"\"\"\n    Handle parameter get response from firmware.\n\n    Forward response to the firmware_parameter_manager.\n    \"\"\"\n    pb_response = PB_ParameterGetResponse()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_response.ParseFromString, message)\n\n    response = MessageToDict(\n        pb_response,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    logger.info(f\"[CAN] get_response: {response}\")\n\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"get_parameter_response\", response)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_parameter_set_response","title":"<code>handle_parameter_set_response(message=None)</code>  <code>async</code>","text":"<p>Handle parameter set response from firmware.</p> <p>Forward response to the firmware_parameter_manager.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_parameter_set_response(self, message: bytes | None = None):\n    \"\"\"\n    Handle parameter set response from firmware.\n\n    Forward response to the firmware_parameter_manager.\n    \"\"\"\n    pb_response = PB_ParameterSetResponse()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_response.ParseFromString, message)\n\n    response = MessageToDict(\n        pb_response,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    logger.info(f\"[CAN] set_response: {response}\")\n\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"set_parameter_response\", response)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_pid","title":"<code>handle_pid(message=None)</code>  <code>async</code>","text":"<p>Send pids state received from the robot to connected dashboards.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_pid(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send pids state received from the robot to connected dashboards.\n    \"\"\"\n    pb_pid = PB_Pid()\n    if message:\n        await self.loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n    self.pb_pids[pb_pid.id] = pb_pid\n    pid = Pid(\n        id=pb_pid.id,\n        kp=pb_pid.kp,\n        ki=pb_pid.ki,\n        kd=pb_pid.kd,\n        integral_term_limit=pb_pid.integral_term_limit,\n    )\n\n    # Get JSON Schema\n    pid_schema = pid.model_json_schema()\n    # Add namespace in JSON Schema\n    pid_schema[\"namespace\"] = \"/copilot\"\n    pid_schema[\"sio_event\"] = \"config_updated\"\n    # Add current values in JSON Schema\n    pid_schema[\"title\"] = pid.id.name\n    for prop, value in pid.model_dump().items():\n        if prop == \"id\":\n            continue\n        pid_schema[\"properties\"][prop][\"value\"] = value\n        pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n        del pid_schema[\"properties\"][prop]\n    # Send config\n    await self.sio_events.emit(\"config\", pid_schema)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_pose_reached","title":"<code>handle_pose_reached()</code>  <code>async</code>","text":"<p>Handle pose reached message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle pose reached message.\n\n    Forward info to the planner.\n    \"\"\"\n    logger.info(\"[CAN] Received pose reached\")\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_power_rails_status","title":"<code>handle_power_rails_status(message=None)</code>  <code>async</code>","text":"<p>Handle power rails status from power supply board.</p> <p>Forward status to connected clients.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_power_rails_status(self, message: bytes | None = None):\n    \"\"\"\n    Handle power rails status from power supply board.\n\n    Forward status to connected clients.\n    \"\"\"\n    pb_status = PB_PowerRailsStatus()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_status.ParseFromString, message)\n\n    status = MessageToDict(\n        pb_status,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    logger.debug(f\"[CAN] power rails status: {status}\")\n\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"power_rails_status\", status)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_power_source_status","title":"<code>handle_power_source_status(message=None)</code>  <code>async</code>","text":"<p>Handle power source status from power supply board.</p> <p>Forward status to connected clients.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_power_source_status(self, message: bytes | None = None):\n    \"\"\"\n    Handle power source status from power supply board.\n\n    Forward status to connected clients.\n    \"\"\"\n    pb_status = PB_PowerSourceStatus()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_status.ParseFromString, message)\n\n    status = MessageToDict(\n        pb_status,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    logger.debug(f\"[CAN] power source status: {status}\")\n\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"power_source_status\", status)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_reset","title":"<code>handle_reset()</code>  <code>async</code>","text":"<p>Handle reset message. This means that the robot has just booted.</p> <p>Send a reset message to all connected clients.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_reset(self) -&gt; None:\n    \"\"\"\n    Handle reset message. This means that the robot has just booted.\n\n    Send a reset message to all connected clients.\n    \"\"\"\n    logger.info(\"[CAN] Received reset\")\n    await self.pbcom.send_can_message(copilot_connected_uuid, None)\n    await self.sio_events.emit(\"reset\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_telemetry_data","title":"<code>handle_telemetry_data(message=None)</code>  <code>async</code>","text":"<p>Handle parameter telemetry data from firmware.</p> <p>Forward response to the TODO:</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_telemetry_data(self, message: bytes | None = None):\n    \"\"\"\n    Handle parameter telemetry data from firmware.\n\n    Forward response to the TODO:\n    \"\"\"\n    pb_telemetry = PB_TelemetryData()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_telemetry.ParseFromString, message)\n\n    telemetry = MessageToDict(\n        pb_telemetry,\n        always_print_fields_with_no_presence=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    logger.debug(f\"[CAN] telemetry data: {telemetry}\")\n\n    if self.sio_events.connected:\n        await self.sio_events.emit(\"telemetry_data\", telemetry)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.new_path_event_loop","title":"<code>new_path_event_loop()</code>  <code>async</code>","text":"<p>Async worker watching for new path orders in shared memory. When a new path is available, its first pose is sent to the firmware.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def new_path_event_loop(self):\n    \"\"\"\n    Async worker watching for new path orders in shared memory.\n    When a new path is available, its first pose is sent to the firmware.\n    \"\"\"\n    logger.info(\"Copilot: Task New Path Event Watcher Loop started\")\n    try:\n        while True:\n            await asyncio.to_thread(self.shared_avoidance_path_lock.wait_update)\n            if len(self.shared_avoidance_path) == 0:\n                continue\n            pose_order = models.PathPose.from_shared(self.shared_avoidance_path[0])\n            if self.id &gt; 1:\n                pose_order.motion_direction = models.MotionDirection.FORWARD_ONLY\n            pb_pose_order = PB_PathPose()\n            pose_order.copy_pb(pb_pose_order)\n            await self.pbcom.send_can_message(pose_order_uuid, pb_pose_order)\n\n    except asyncio.CancelledError:\n        logger.info(\"Copilot: Task New Path Event Watcher Loop cancelled\")\n        raise\n    except Exception as exc:  # noqa\n        logger.warning(f\"Copilot: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start copilot.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start copilot.\n    \"\"\"\n    self.loop = asyncio.get_running_loop()\n\n    self.retry_connection = True\n    await self.try_connect()\n\n    await self.pbcom.send_can_message(copilot_connected_uuid, None)\n\n    await self.pbcom.run()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/copilot/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/copilot/pbcom/","title":"pbcom","text":""},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom","title":"<code>PBCom</code>","text":"Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>class PBCom:\n    can_is_fd: bool = True  # CAN frames are FD frames\n\n    def __init__(\n        self,\n        can_channel: str,\n        can_bitrate: int,\n        canfd_data_bitrate: int,\n        message_handlers: dict[int, Callable],\n    ):\n        self.can_bus = can.Bus(\n            interface=\"socketcan\",\n            channel=can_channel,\n            bitrate=can_bitrate,\n            data_bitrate=canfd_data_bitrate,\n            fd=self.can_is_fd,\n        )\n        self.message_handlers = message_handlers\n\n        # Create asyncio queues\n        self.messages_received = asyncio.Queue()  # Queue for messages received\n        self.messages_to_send = asyncio.Queue()  # Queue for messages waiting to be sent\n\n    def register_message_handler(self, uuid: int, handler: Callable) -&gt; None:\n        \"\"\"\n        Register a message handler at runtime.\n\n        Args:\n            uuid: The message UUID to handle.\n            handler: The async callable to handle the message.\n\n        Raises:\n            ValueError: If a handler for this UUID is already registered.\n        \"\"\"\n        if uuid in self.message_handlers:\n            raise ValueError(f\"Handler for UUID 0x{uuid:04x} is already registered\")\n        self.message_handlers[uuid] = handler\n\n    async def run(self):\n        \"\"\"\n        Start PBCom.\n        \"\"\"\n        self.loop = asyncio.get_running_loop()\n        self.can_reader = can.AsyncBufferedReader()\n        self.notifier = can.Notifier(bus=self.can_bus, listeners=[self.can_reader], timeout=None, loop=self.loop)\n\n        try:\n            await asyncio.gather(\n                self.payload_decoder(),\n                self.can_receiver(),\n                self.can_sender(),\n            )\n        except asyncio.CancelledError:\n            self.can_bus.shutdown()\n\n    async def payload_decoder(self):\n        \"\"\"\n        Async worker decoding messages received from the robot.\n        \"\"\"\n        uuid: int\n        encoded_payload: bytes\n\n        try:\n            while True:\n                uuid, encoded_payload = await self.messages_received.get()\n                request_handler = self.message_handlers.get(uuid)\n                if not request_handler:\n                    logger.warning(f\"No handler found for message uuid '0x{uuid:04x}'\")\n                else:\n                    if not encoded_payload:\n                        await request_handler()\n                    else:\n                        await request_handler(encoded_payload)\n\n                self.messages_received.task_done()\n        except asyncio.CancelledError:\n            raise\n\n    async def send_can_message(self, *args) -&gt; None:\n        await self.messages_to_send.put(args)\n\n    async def can_receiver(self):\n        \"\"\"\n        Async worker reading messages from the robot on CAN bus.\n\n        Messages is base64-encoded.\n        After decoding, first byte is the message type, following bytes are\n        the Protobuf encoded message (if any).\n        \"\"\"\n        try:\n            while True:\n                # Read next message\n                can_message = await self.can_reader.get_message()\n\n                # Get message uuid on first bytes\n                uuid = can_message.arbitration_id\n\n                if can_message.dlc == 0:\n                    await self.messages_received.put((uuid, None))\n                    continue\n\n                # Base64 decoding\n                try:\n                    pb_message = base64.decodebytes(can_message.data)\n                except binascii.Error:\n                    logger.error(\"Failed to decode base64 message.\")\n                    continue\n\n                # Send Protobuf message for decoding\n                await self.messages_received.put((uuid, pb_message))\n        except asyncio.CancelledError:\n            raise\n\n    async def can_sender(self):\n        \"\"\"\n        Async worker encoding and sending Protobuf messages to the robot on CAN bus.\n\n        See `can_receiver` for message encoding.\n        \"\"\"\n        try:\n            while True:\n                uuid, pb_message = await self.messages_to_send.get()\n                logger.info(f\"Send 0x{uuid:04x}:\\n{pb_message}\")\n                if pb_message:\n                    response_serialized = await self.loop.run_in_executor(None, pb_message.SerializeToString)\n                    response_base64 = await self.loop.run_in_executor(None, base64.encodebytes, response_serialized)\n                else:\n                    response_base64 = None\n                try:\n                    self.can_bus.send(can.Message(arbitration_id=uuid, data=response_base64, is_fd=self.can_is_fd))\n                except Exception as e:\n                    logger.error(e)\n                self.messages_to_send.task_done()\n        except asyncio.CancelledError:\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.can_receiver","title":"<code>can_receiver()</code>  <code>async</code>","text":"<p>Async worker reading messages from the robot on CAN bus.</p> <p>Messages is base64-encoded. After decoding, first byte is the message type, following bytes are the Protobuf encoded message (if any).</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def can_receiver(self):\n    \"\"\"\n    Async worker reading messages from the robot on CAN bus.\n\n    Messages is base64-encoded.\n    After decoding, first byte is the message type, following bytes are\n    the Protobuf encoded message (if any).\n    \"\"\"\n    try:\n        while True:\n            # Read next message\n            can_message = await self.can_reader.get_message()\n\n            # Get message uuid on first bytes\n            uuid = can_message.arbitration_id\n\n            if can_message.dlc == 0:\n                await self.messages_received.put((uuid, None))\n                continue\n\n            # Base64 decoding\n            try:\n                pb_message = base64.decodebytes(can_message.data)\n            except binascii.Error:\n                logger.error(\"Failed to decode base64 message.\")\n                continue\n\n            # Send Protobuf message for decoding\n            await self.messages_received.put((uuid, pb_message))\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.can_sender","title":"<code>can_sender()</code>  <code>async</code>","text":"<p>Async worker encoding and sending Protobuf messages to the robot on CAN bus.</p> <p>See <code>can_receiver</code> for message encoding.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def can_sender(self):\n    \"\"\"\n    Async worker encoding and sending Protobuf messages to the robot on CAN bus.\n\n    See `can_receiver` for message encoding.\n    \"\"\"\n    try:\n        while True:\n            uuid, pb_message = await self.messages_to_send.get()\n            logger.info(f\"Send 0x{uuid:04x}:\\n{pb_message}\")\n            if pb_message:\n                response_serialized = await self.loop.run_in_executor(None, pb_message.SerializeToString)\n                response_base64 = await self.loop.run_in_executor(None, base64.encodebytes, response_serialized)\n            else:\n                response_base64 = None\n            try:\n                self.can_bus.send(can.Message(arbitration_id=uuid, data=response_base64, is_fd=self.can_is_fd))\n            except Exception as e:\n                logger.error(e)\n            self.messages_to_send.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.payload_decoder","title":"<code>payload_decoder()</code>  <code>async</code>","text":"<p>Async worker decoding messages received from the robot.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def payload_decoder(self):\n    \"\"\"\n    Async worker decoding messages received from the robot.\n    \"\"\"\n    uuid: int\n    encoded_payload: bytes\n\n    try:\n        while True:\n            uuid, encoded_payload = await self.messages_received.get()\n            request_handler = self.message_handlers.get(uuid)\n            if not request_handler:\n                logger.warning(f\"No handler found for message uuid '0x{uuid:04x}'\")\n            else:\n                if not encoded_payload:\n                    await request_handler()\n                else:\n                    await request_handler(encoded_payload)\n\n            self.messages_received.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.register_message_handler","title":"<code>register_message_handler(uuid, handler)</code>","text":"<p>Register a message handler at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>int</code> <p>The message UUID to handle.</p> required <code>handler</code> <code>Callable</code> <p>The async callable to handle the message.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a handler for this UUID is already registered.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>def register_message_handler(self, uuid: int, handler: Callable) -&gt; None:\n    \"\"\"\n    Register a message handler at runtime.\n\n    Args:\n        uuid: The message UUID to handle.\n        handler: The async callable to handle the message.\n\n    Raises:\n        ValueError: If a handler for this UUID is already registered.\n    \"\"\"\n    if uuid in self.message_handlers:\n        raise ValueError(f\"Handler for UUID 0x{uuid:04x} is already registered\")\n    self.message_handlers[uuid] = handler\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start PBCom.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start PBCom.\n    \"\"\"\n    self.loop = asyncio.get_running_loop()\n    self.can_reader = can.AsyncBufferedReader()\n    self.notifier = can.Notifier(bus=self.can_bus, listeners=[self.can_reader], timeout=None, loop=self.loop)\n\n    try:\n        await asyncio.gather(\n            self.payload_decoder(),\n            self.can_receiver(),\n            self.can_sender(),\n        )\n    except asyncio.CancelledError:\n        self.can_bus.shutdown()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pid/","title":"pid","text":""},{"location":"reference/cogip/tools/copilot/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, copilot: \"copilot.Copilot\"):\n        super().__init__(\"/copilot\")\n        self.copilot = copilot\n        self.connected = False\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=1,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n\n        self.copilot.create_shared_memory()\n        self.connected = True\n\n        if self.copilot.shell_menu:\n            await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n        await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n\n    async def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.connected = False\n        await self.copilot.delete_shared_memory()\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_command(self, data):\n        \"\"\"\n        Callback on tool command message.\n        \"\"\"\n        cmd, _, _ = data.partition(\" \")\n        pid_id = PB_Pid_Id()\n        match cmd:\n            case \"angular_speed_pid_config\":\n                # Request angular speed pid state\n                pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_speed_pid_config\":\n                # Request linear_speed pid state\n                pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"angular_position_pid_config\":\n                # Request angular position pid state\n                pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_position_pid_config\":\n                # Request linear position pid state\n                pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_pose_start(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose start (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Pose start: {data}\")\n        start_pose = models.PathPose.model_validate(data)\n        pb_start_pose = PB_PathPose()\n        start_pose.copy_pb(pb_start_pose)\n        await self.copilot.pbcom.send_can_message(copilot.pose_start_uuid, pb_start_pose)\n\n    async def on_pose_order(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose order (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Pose order: {data}\")\n        pose_order = models.PathPose.model_validate(data)\n        if self.copilot.id &gt; 1:\n            pose_order.motion_direction = models.MotionDirection.FORWARD_ONLY\n        pb_pose_order = PB_PathPose()\n        pose_order.copy_pb(pb_pose_order)\n        await self.copilot.pbcom.send_can_message(copilot.pose_order_uuid, pb_pose_order)\n\n    async def on_actuators_start(self):\n        \"\"\"\n        Callback on actuators_start (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.actuators_thread_start_uuid, None)\n\n    async def on_actuators_stop(self):\n        \"\"\"\n        Callback on actuators_stop (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.actuators_thread_stop_uuid, None)\n\n    async def on_actuator_command(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_command (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Actuator command: {data}\")\n        command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n        pb_command = PB_ActuatorCommand()\n        if isinstance(command, PositionalActuatorCommand):\n            command.pb_copy(pb_command.positional_actuator)\n        await self.copilot.pbcom.send_can_message(copilot.actuator_command_uuid, pb_command)\n\n    async def on_actuator_init(self):\n        \"\"\"\n        Callback on actuator_init (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        logger.info(\"[SIO] Actuator init\")\n        await self.copilot.pbcom.send_can_message(copilot.actuator_init_uuid, None)\n\n    async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on config_updated from dashboard.\n        Update pid PB message and send it back to firmware.\n        \"\"\"\n        pid_id, _, name = config[\"name\"].partition(\"-\")\n        if pid_id and name:\n            setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n            await self.copilot.pbcom.send_can_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n\n    async def on_set_controller(self, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to firmware.\n        \"\"\"\n        pb_controller = PB_Controller()\n        pb_controller.id = controller\n        await self.copilot.pbcom.send_can_message(copilot.controller_uuid, pb_controller)\n\n    async def on_game_start(self):\n        \"\"\"\n        Callback on game_start message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Game start\")\n        await self.copilot.pbcom.send_can_message(copilot.game_start_uuid, None)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game_end message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Game end\")\n        await self.copilot.pbcom.send_can_message(copilot.game_end_uuid, None)\n\n    async def on_game_reset(self):\n        \"\"\"\n        Callback on game_reset message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Game reset\")\n        await self.copilot.pbcom.send_can_message(copilot.game_reset_uuid, None)\n\n    async def on_brake(self):\n        \"\"\"\n        Callback on brake message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Brake\")\n        await self.copilot.pbcom.send_can_message(copilot.brake_uuid, None)\n\n    async def on_get_parameter_value(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on get_parameter_value.\n        Forward to firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Get parameter: {data}\")\n\n        parameter = FirmwareParameter.model_validate(data)\n        pb_get_request = PB_ParameterGetRequest()\n        parameter.pb_copy(pb_get_request)\n\n        await self.copilot.pbcom.send_can_message(copilot.parameter_get_uuid, pb_get_request)\n\n    async def on_set_parameter_value(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on set_parameter_value.\n        Forward to firmware.\n        \"\"\"\n        logger.info(f\"[SIO] Set parameter: {data}\")\n\n        parameter = FirmwareParameter.model_validate(data)\n        pb_set_request = PB_ParameterSetRequest()\n        parameter.pb_copy(pb_set_request)\n\n        await self.copilot.pbcom.send_can_message(copilot.parameter_set_uuid, pb_set_request)\n\n    async def on_telemetry_enable(self, data: dict[str, Any] | None = None):\n        \"\"\"\n        Callback on telemetry enable message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Telemetry enable\")\n        await self.copilot.pbcom.send_can_message(copilot.telemetry_enable_uuid, None)\n\n    async def on_telemetry_disable(self, data: dict[str, Any] | None = None):\n        \"\"\"\n        Callback on telemetry disable message.\n        Forward to firmware.\n        \"\"\"\n        logger.info(\"[SIO] Telemetry disable\")\n        await self.copilot.pbcom.send_can_message(copilot.telemetry_disable_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuator_command","title":"<code>on_actuator_command(data)</code>  <code>async</code>","text":"<p>Callback on actuator_command (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuator_command(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_command (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Actuator command: {data}\")\n    command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n    pb_command = PB_ActuatorCommand()\n    if isinstance(command, PositionalActuatorCommand):\n        command.pb_copy(pb_command.positional_actuator)\n    await self.copilot.pbcom.send_can_message(copilot.actuator_command_uuid, pb_command)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuator_init","title":"<code>on_actuator_init()</code>  <code>async</code>","text":"<p>Callback on actuator_init (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuator_init(self):\n    \"\"\"\n    Callback on actuator_init (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(\"[SIO] Actuator init\")\n    await self.copilot.pbcom.send_can_message(copilot.actuator_init_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuators_start","title":"<code>on_actuators_start()</code>  <code>async</code>","text":"<p>Callback on actuators_start (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuators_start(self):\n    \"\"\"\n    Callback on actuators_start (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.actuators_thread_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuators_stop","title":"<code>on_actuators_stop()</code>  <code>async</code>","text":"<p>Callback on actuators_stop (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuators_stop(self):\n    \"\"\"\n    Callback on actuators_stop (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.actuators_thread_stop_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_brake","title":"<code>on_brake()</code>  <code>async</code>","text":"<p>Callback on brake message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_brake(self):\n    \"\"\"\n    Callback on brake message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Brake\")\n    await self.copilot.pbcom.send_can_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_command","title":"<code>on_command(data)</code>  <code>async</code>","text":"<p>Callback on tool command message.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_command(self, data):\n    \"\"\"\n    Callback on tool command message.\n    \"\"\"\n    cmd, _, _ = data.partition(\" \")\n    pid_id = PB_Pid_Id()\n    match cmd:\n        case \"angular_speed_pid_config\":\n            # Request angular speed pid state\n            pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_speed_pid_config\":\n            # Request linear_speed pid state\n            pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"angular_position_pid_config\":\n            # Request angular position pid state\n            pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_position_pid_config\":\n            # Request linear position pid state\n            pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case _:\n            logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config_updated from dashboard. Update pid PB message and send it back to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on config_updated from dashboard.\n    Update pid PB message and send it back to firmware.\n    \"\"\"\n    pid_id, _, name = config[\"name\"].partition(\"-\")\n    if pid_id and name:\n        setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n        await self.copilot.pbcom.send_can_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=1,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n\n    self.copilot.create_shared_memory()\n    self.connected = True\n\n    if self.copilot.shell_menu:\n        await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n    await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.connected = False\n    await self.copilot.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game_end message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game_end message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Game end\")\n    await self.copilot.pbcom.send_can_message(copilot.game_end_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_reset","title":"<code>on_game_reset()</code>  <code>async</code>","text":"<p>Callback on game_reset message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_reset(self):\n    \"\"\"\n    Callback on game_reset message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Game reset\")\n    await self.copilot.pbcom.send_can_message(copilot.game_reset_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_start","title":"<code>on_game_start()</code>  <code>async</code>","text":"<p>Callback on game_start message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_start(self):\n    \"\"\"\n    Callback on game_start message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Game start\")\n    await self.copilot.pbcom.send_can_message(copilot.game_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_get_parameter_value","title":"<code>on_get_parameter_value(data)</code>  <code>async</code>","text":"<p>Callback on get_parameter_value. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_get_parameter_value(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on get_parameter_value.\n    Forward to firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Get parameter: {data}\")\n\n    parameter = FirmwareParameter.model_validate(data)\n    pb_get_request = PB_ParameterGetRequest()\n    parameter.pb_copy(pb_get_request)\n\n    await self.copilot.pbcom.send_can_message(copilot.parameter_get_uuid, pb_get_request)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_pose_order","title":"<code>on_pose_order(data)</code>  <code>async</code>","text":"<p>Callback on pose order (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_pose_order(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose order (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Pose order: {data}\")\n    pose_order = models.PathPose.model_validate(data)\n    if self.copilot.id &gt; 1:\n        pose_order.motion_direction = models.MotionDirection.FORWARD_ONLY\n    pb_pose_order = PB_PathPose()\n    pose_order.copy_pb(pb_pose_order)\n    await self.copilot.pbcom.send_can_message(copilot.pose_order_uuid, pb_pose_order)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_pose_start","title":"<code>on_pose_start(data)</code>  <code>async</code>","text":"<p>Callback on pose start (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_pose_start(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose start (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Pose start: {data}\")\n    start_pose = models.PathPose.model_validate(data)\n    pb_start_pose = PB_PathPose()\n    start_pose.copy_pb(pb_start_pose)\n    await self.copilot.pbcom.send_can_message(copilot.pose_start_uuid, pb_start_pose)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_set_controller","title":"<code>on_set_controller(controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_set_controller(self, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to firmware.\n    \"\"\"\n    pb_controller = PB_Controller()\n    pb_controller.id = controller\n    await self.copilot.pbcom.send_can_message(copilot.controller_uuid, pb_controller)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_set_parameter_value","title":"<code>on_set_parameter_value(data)</code>  <code>async</code>","text":"<p>Callback on set_parameter_value. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_set_parameter_value(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on set_parameter_value.\n    Forward to firmware.\n    \"\"\"\n    logger.info(f\"[SIO] Set parameter: {data}\")\n\n    parameter = FirmwareParameter.model_validate(data)\n    pb_set_request = PB_ParameterSetRequest()\n    parameter.pb_copy(pb_set_request)\n\n    await self.copilot.pbcom.send_can_message(copilot.parameter_set_uuid, pb_set_request)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_telemetry_disable","title":"<code>on_telemetry_disable(data=None)</code>  <code>async</code>","text":"<p>Callback on telemetry disable message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_telemetry_disable(self, data: dict[str, Any] | None = None):\n    \"\"\"\n    Callback on telemetry disable message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Telemetry disable\")\n    await self.copilot.pbcom.send_can_message(copilot.telemetry_disable_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_telemetry_enable","title":"<code>on_telemetry_enable(data=None)</code>  <code>async</code>","text":"<p>Callback on telemetry enable message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_telemetry_enable(self, data: dict[str, Any] | None = None):\n    \"\"\"\n    Callback on telemetry enable message.\n    Forward to firmware.\n    \"\"\"\n    logger.info(\"[SIO] Telemetry enable\")\n    await self.copilot.pbcom.send_can_message(copilot.telemetry_enable_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/cpp_cython_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_cython_example/__main__/#cogip.tools.cpp_cython_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a function from a C++ class built in C++ extension with a Cython binding.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-cython-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_cython_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a function from a C++ class built in C++ extension with a Cython binding.\n\n    During installation of cogip-tools, a script called `cogip-cpp-cython-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    example = PyCythonExample()\n    print(example.get_message())\n</code></pre>"},{"location":"reference/cogip/tools/cpp_logger_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_logger_example/__main__/#cogip.tools.cpp_logger_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a C++ function that emits logs to a Python logger.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-logger-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_logger_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a C++ function that emits logs to a Python logger.\n\n    During installation of cogip-tools, a script called `cogip-cpp-logger-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/cpp_nanobind_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_nanobind_example/__main__/#cogip.tools.cpp_nanobind_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a function from a C++ class built in C++ extension with a Nanobind binding.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-nanobind-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_nanobind_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a function from a C++ class built in C++ extension with a Nanobind binding.\n\n    During installation of cogip-tools, a script called `cogip-cpp-nanobind-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    example = NanobindExample()\n    print(example.get_message())\n    data: NDArray = example.get_data()\n    print(f\"data type: {data.__class__}\")\n    print(f\"data shape: {data.shape}\")\n    print(f\"data = \\n{data}\")\n</code></pre>"},{"location":"reference/cogip/tools/cpp_shm_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_shm_example/__main__/#cogip.tools.cpp_shm_example.__main__.main","title":"<code>main()</code>","text":"<p>Usage example for shared memory usage C++ extension.</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-shm-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_shm_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Usage example for shared memory usage C++ extension.\n\n    During installation of cogip-tools, a script called `cogip-cpp-shm-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    name = \"/example\"\n\n    # In this example, it is not necessary to create multiple SharedMemory objects.\n    # It is done to illustrate SharedMemory object from different processes.\n    # In the following example, there is no difference between writer and reader objects, only lock usage is important.\n\n    # ==&gt; OWNER process\n    # The owner object will be created in only one process,\n    # typically cogip-server be cause all other processes are depend on it.\n    print(\"Create owner object.\")\n    owner = SharedMemory(name, True)\n\n    # ==&gt; WRITER process\n    # A writer object will be instantiated by processes that need to write into the shared memory.\n    # Each process will get a lock corresponding to the part of the shared memory they want to modify.\n    # Typically, `cogip-copilot` will update the `pose_current` part so it get the lock named `PoseCurrent`.\n    print(\"Create writer object.\")\n    writer = SharedMemory(name)\n    writer_lock = writer.get_lock(LockName.PoseCurrent)\n    writer_data = writer.get_data()\n    writer_pose_current_buffer = writer.get_pose_current_buffer()\n\n    writer_lock.start_reading()\n    print(\" =&gt; writer data = \", writer_data)\n    writer_lock.finish_reading()\n\n    # ==&gt; READER process\n    # A reader object will be instantiated by processes that need to write into the shared memory.\n    # Each process will get a lock corresponding to the part of the shared memory they want to read.\n    # Typically, `cogip-planner` will read the `pose_current` part so it get the lock named `PoseCurrent`.\n    print(\"Create reader object.\")\n    reader = SharedMemory(name)\n    reader_lock = writer.get_lock(LockName.PoseCurrent)\n    reader_data = reader.get_data()\n    reader_pose_current_buffer = reader.get_pose_current_buffer()\n    reader_lock.start_reading()\n    print(\" =&gt; reader data = \", reader_data)\n    reader_lock.finish_reading()\n\n    # ==&gt; WRITER process\n    print(\"Set pose_order\")\n    writer_lock.start_writing()\n    writer_data.pose_order.x = 3.0\n    writer_data.pose_order.y = 4.0\n    writer_data.pose_order.angle = 180.0\n    writer_lock.finish_writing()\n    writer_lock.start_reading()\n    print(\" =&gt; writer data = \", writer_data)\n    writer_lock.finish_reading()\n\n    # ==&gt; READER process\n    reader_lock.start_reading()\n    print(\" =&gt; reader data = \", reader_data)\n    reader_lock.finish_reading()\n\n    # Test for detector_obstacles\n    print(\"\\nTest for detector_obstacles\")\n    reader_detector_obstacles = reader.get_detector_obstacles()\n    writer_detector_obstacles = reader.get_detector_obstacles()\n    print(\" =&gt; reader detector_obstacles size = \", reader_detector_obstacles.size())\n    writer_detector_obstacles.append(1.0, 2.0)\n    writer_detector_obstacles.append(3.0, 4.0)\n    print(\" =&gt; reader detector_obstacles size = \", reader_detector_obstacles.size())\n    print(\" =&gt; reader detector_obstacles[0] = \", reader_detector_obstacles.get(0))\n    print(\" =&gt; reader detector_obstacles[1] = \", reader_detector_obstacles.get(1))\n    writer_detector_obstacles.set(0, 5.0, 6.0)\n    writer_detector_obstacles.set(1, 7.0, 8.0)\n    print(\" =&gt; reader detector_obstacles[0] = \", reader_detector_obstacles.get(0))\n    print(\" =&gt; reader detector_obstacles[1] = \", reader_detector_obstacles.get(1))\n    coords1 = writer_detector_obstacles.get(0)\n    coords2 = writer_detector_obstacles[1]\n    coords1.x = 9.0\n    coords1.y = 10.0\n    coords2.x = 11.0\n    coords2.y = 12.0\n    print(\" =&gt; reader detector_obstacles[0] = \", reader_detector_obstacles.get(0))\n    print(\" =&gt; reader detector_obstacles[1] = \", reader_detector_obstacles.get(1))\n\n    for i, coords in enumerate(writer_detector_obstacles):\n        print(f\" =&gt; writer iterator on detector_obstacles: coords[{i}] = {coords}\")\n\n    for i, coords in enumerate(reader_detector_obstacles):\n        print(f\" =&gt; reader iterator on detector_obstacles: coords[{i}] = {coords}\")\n\n    # Test for circle_obstacles\n    print(\"\\nTest for circle_obstacles\")\n    reader_circle_obstacles = reader.get_circle_obstacles()\n    writer_circle_obstacles = reader.get_circle_obstacles()\n    print(\" =&gt; reader circle_obstacles size = \", reader_circle_obstacles.size())\n    writer_circle_obstacles.append(10, 20, 90, 200, 0.2, 4)\n    writer_circle_obstacles.append(\n        x=40, y=50, angle=180, radius=300, bounding_box_margin=0.2, bounding_box_points_number=5\n    )\n    print(\" =&gt; writer circle_obstacles size = \", len(writer_circle_obstacles))\n    for i, obstacle in enumerate(reader_circle_obstacles):\n        print(f\" =&gt; reader iterator on writer_circle_obstacles: obstacle[{i}] = {obstacle}\")\n\n    # Test for rectangle_obstacles\n    print(\"\\nTest for rectangle_obstacles\")\n    reader_rectangle_obstacles = reader.get_rectangle_obstacles()\n    writer_rectangle_obstacles = reader.get_rectangle_obstacles()\n    print(\" =&gt; reader rectangle_obstacles size = \", reader_rectangle_obstacles.size())\n    writer_rectangle_obstacles.append(10, 20, 90, 200, 300, 0.2)\n    writer_rectangle_obstacles.append(x=40, y=50, angle=180, length_x=250, length_y=350, bounding_box_margin=0.2)\n    print(\" =&gt; writer rectangle_obstacles size = \", len(writer_rectangle_obstacles))\n    for i, obstacle in enumerate(reader_rectangle_obstacles):\n        print(f\" =&gt; reader iterator on writer_rectangle_obstacles: obstacle[{i}] = {obstacle}\")\n\n    # Deep copy test\n    copy_list: list[ObstacleCircle] = []\n    for obstacle in writer_circle_obstacles:\n        copy_list.append(ObstacleCircle(obstacle, deep_copy=True))\n    copy_list[0].center.x = 11\n    copy_list[0].center.y = 22\n\n    print(\" =&gt; writer circle_obstacles[0] = \", writer_circle_obstacles[0])\n    print(\" =&gt; copy_list[0] = \", copy_list[0])\n\n    print(\"\\nTest for pose_current_buffer\")\n    writer_pose_current_buffer.push(1, 2, 90)\n    print(reader_pose_current_buffer.last)\n    writer_pose_current_buffer.push(1, 3, 90)\n    print(reader_pose_current_buffer.last)\n    print(reader_pose_current_buffer.get(1))\n    try:\n        print(reader_pose_current_buffer.get(2))\n    except Exception as exc:\n        print(exc)\n    for i in range(300):\n        writer_pose_current_buffer.push(1, i, 90)\n    print(reader_pose_current_buffer.last)\n\n    # Control order of shared memory object destruction\n    writer_rectangle_obstacles = None\n    writer_circle_obstacles = None\n    writer_detector_obstacles = None\n    writer_lock = None\n    writer_pose_current_buffer = None\n    writer_data = None\n    del writer_lock\n    del writer\n\n    reader_rectangle_obstacles = None\n    reader_circle_obstacles = None\n    reader_detector_obstacles = None\n    reader_lock = None\n    reader_pose_current_buffer = None\n    reader_data = None\n    del reader\n\n    del owner\n    print(\"End.\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/dashboard/__main__/#cogip.tools.dashboard.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Dashboard.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-dashboard</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/dashboard/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Dashboard.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-dashboard` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/app/","title":"app","text":""},{"location":"reference/cogip/tools/dashboard/app/#cogip.tools.dashboard.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/dashboard/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    dashboard = Dashboard()\n    return dashboard.app\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard","title":"<code>Dashboard</code>","text":"Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>class Dashboard:\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application.\n        \"\"\"\n        self.app = FastAPI(title=\"COGIP Web Monitor\", lifespan=lifespan, debug=False)\n\n        # Mount static files\n        current_dir = Path(__file__).parent\n        self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n        # Create HTML templates\n        self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n        # Register routes\n        self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application.</p> Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application.\n    \"\"\"\n    self.app = FastAPI(title=\"COGIP Web Monitor\", lifespan=lifespan, debug=False)\n\n    # Mount static files\n    current_dir = Path(__file__).parent\n    self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n    # Create HTML templates\n    self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n    # Register routes\n    self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.lifespan","title":"<code>lifespan(app)</code>  <code>async</code>","text":"<p>Handle application startup and shutdown events.</p> Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"\n    Handle application startup and shutdown events.\n    \"\"\"\n    logger.info(\"Dashboard starting up...\")\n    try:\n        systemd.daemon.notify(\"READY=1\")\n        logger.info(\"Systemd notified: READY=1\")\n    except Exception as e:\n        logger.error(f\"Failed to notify systemd: {e}\")\n\n    yield\n\n    logger.info(\"Dashboard shutting down...\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/routes/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/dashboard/routes/beacon/#cogip.tools.dashboard.routes.beacon.BeaconRouter","title":"<code>BeaconRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> Source code in <code>cogip/tools/dashboard/routes/beacon.py</code> <pre><code>class BeaconRouter(APIRouter):\n    def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        @self.get(\"/\", response_class=HTMLResponse)\n        async def index(request: Request):\n            \"\"\"\n            Homepage of the dashboard web server.\n            \"\"\"\n            robot_id = int(os.getenv(\"ROBOT_ID\", 0))\n            return templates.TemplateResponse(\"dashboard.html\", {\"request\": request, \"robot_id\": robot_id})\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/routes/beacon/#cogip.tools.dashboard.routes.beacon.BeaconRouter.__init__","title":"<code>__init__(templates, *args, **kwargs)</code>","text":"Source code in <code>cogip/tools/dashboard/routes/beacon.py</code> <pre><code>def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    @self.get(\"/\", response_class=HTMLResponse)\n    async def index(request: Request):\n        \"\"\"\n        Homepage of the dashboard web server.\n        \"\"\"\n        robot_id = int(os.getenv(\"ROBOT_ID\", 0))\n        return templates.TemplateResponse(\"dashboard.html\", {\"request\": request, \"robot_id\": robot_id})\n</code></pre>"},{"location":"reference/cogip/tools/detector/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/detector/__main__/#cogip.tools.detector.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Obstacle Detector.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-detector</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/detector/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Obstacle Detector.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-detector` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/detector/check_lidar_status/","title":"check_lidar_status","text":""},{"location":"reference/cogip/tools/detector/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector","title":"<code>Detector</code>","text":"<p>Main detector class.</p> <p>Read Lidar data from the Lidar in monitoring mode or fake data provided by <code>Monitor</code> in emulation Mode.</p> <p>Build obstacles and send the list to the server.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>class Detector:\n    \"\"\"\n    Main detector class.\n\n    Read Lidar data from the Lidar in monitoring mode\n    or fake data provided by `Monitor` in emulation Mode.\n\n    Build obstacles and send the list to the server.\n    \"\"\"\n\n    TABLE_LIMITS_MARGIN: int = 50\n    YDLIDAR_READY_TIMEOUT_MS: int = 10000\n\n    def __init__(\n        self,\n        robot_id: int,\n        server_url: str,\n        lidar_port: Path | None,\n        min_distance: int,\n        max_distance: int,\n        min_intensity: int,\n        refresh_interval: float,\n        sensor_delay: int,\n        cluster_min_samples: int,\n        cluster_eps: float,\n        gui: bool,\n        web: bool,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            robot_id: Robot ID\n            server_url: server URL\n            lidar_port: Serial port connected to the Lidar\n            min_distance: Minimum distance to detect an obstacle\n            max_distance: Maximum distance to detect an obstacle\n            min_intensity: Minimum intensity to detect an obstacle\n            refresh_interval: Interval between each update of the obstacle list (in seconds)\n            sensor_delay: Delay to compensate the delay between sensor data fetch and obstacle positions computation,\"\n                          unit is the index of pose current to get in the past\n            cluster_min_samples: Minimum number of samples to form a cluster\n            cluster_eps: Maximum distance between two samples to form a cluster (mm)\n            gui: Enable GUI\n            web: Enable data display on a web server\n        \"\"\"\n        if lidar_port:\n            try:\n                ser = serial.Serial(str(lidar_port), timeout=0.1)\n                ser.close()\n                logger.info(f\"Lidar check SUCCESS on {lidar_port}.\")\n            except serial.SerialException as exc:\n                # Failed to open port. Device not connected or permission error.\n                logger.error(f\"Lidar check FAILED on {lidar_port}: {exc}\")\n                os._exit(1)\n            except Exception as exc:\n                logger.error(f\"Lidar check FAILED on {lidar_port} with unexpected error: {exc}\")\n                os._exit(1)\n\n        self.robot_id = robot_id\n        self.server_url = server_url\n        self.lidar_port = lidar_port\n        self.gui = gui\n        self.web = web\n        self.properties = Properties(\n            min_distance=min_distance,\n            max_distance=max_distance,\n            min_intensity=min_intensity,\n            refresh_interval=refresh_interval,\n            sensor_delay=sensor_delay,\n            cluster_min_samples=cluster_min_samples,\n            cluster_eps=cluster_eps,\n        )\n\n        if robot_id == 1:\n            self.LIDAR_OFFSET_X = 0.0\n        else:\n            self.LIDAR_OFFSET_X = 75.5\n        self.LIDAR_OFFSET_Y = 0.0\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_pose_current_lock: WritePriorityLock | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_lidar_data: NDArray | None = None\n        self.shared_lidar_coords: NDArray | None = None\n        self.shared_lidar_data_lock: WritePriorityLock | None = None\n        self.shared_lidar_coords_lock: WritePriorityLock | None = None\n        self.shared_detector_obstacles: SharedCircleList | None = None\n        self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n\n        self.lidar_data_converter: LidarDataConverter | None = None\n\n        self.lidar: LDLidarDriver | YDLidar | None = None\n        self.clusters: list[NDArray] = []\n\n        self.obstacles_updater_loop = ThreadLoop(\n            \"Obstacles updater loop\",\n            refresh_interval,\n            self.process_lidar_coords,\n            logger=True,\n        )\n\n        if gui:\n            self.gui_handler = DetectorGUI(self)\n\n        if web:\n            self.web_thread = threading.Thread(\n                target=start_web,\n                args=(self, 8110 + robot_id),\n                name=\"Web thread\",\n            )\n\n        self.sio = socketio.Client(logger=False)\n        self.sio.register_namespace(SioEvents(self))\n\n    def create_shared_memory(self):\n        self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n        self.shared_pose_current_lock = self.shared_memory.get_lock(LockName.PoseCurrent)\n        self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n        self.shared_lidar_data = self.shared_memory.get_lidar_data()\n        self.shared_lidar_coords = self.shared_memory.get_lidar_coords()\n        self.shared_lidar_data_lock = self.shared_memory.get_lock(LockName.LidarData)\n        self.shared_lidar_coords_lock = self.shared_memory.get_lock(LockName.LidarCoords)\n        self.shared_detector_obstacles = self.shared_memory.get_detector_obstacles()\n        self.shared_detector_obstacles_lock = self.shared_memory.get_lock(LockName.DetectorObstacles)\n\n        self.shared_lidar_data_lock.reset()\n        self.shared_lidar_coords_lock.reset()\n        # self.shared_lidar_coords_lock.register_consumer()\n\n        # Lidar data is initialized to -1 to indicate that no data is available\n        self.shared_lidar_data[0][0] = -1\n        self.shared_lidar_data[0][1] = -1\n        self.shared_lidar_data[0][2] = -1\n        self.shared_lidar_coords[0][0] = -1\n        self.shared_lidar_coords[0][1] = -1\n\n        self.lidar_data_converter = LidarDataConverter(f\"cogip_{self.robot_id}\")\n        self.lidar_data_converter.set_pose_current_index(self.properties.sensor_delay)\n        self.lidar_data_converter.set_lidar_offset_x(self.LIDAR_OFFSET_X)\n        self.lidar_data_converter.set_lidar_offset_y(self.LIDAR_OFFSET_Y)\n        self.lidar_data_converter.set_table_limits_margin(self.TABLE_LIMITS_MARGIN)\n\n    def delete_shared_memory(self):\n        self.shared_detector_obstacles_lock = None\n        self.shared_detector_obstacles = None\n        self.shared_lidar_data_lock = None\n        self.shared_lidar_coords_lock = None\n        self.shared_lidar_coords = None\n        self.shared_lidar_data = None\n        self.shared_pose_current_buffer = None\n        self.shared_pose_current_lock = None\n        self.shared_memory = None\n\n        self.lidar_data_converter = None\n\n    def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        threading.Thread(target=self.try_connect).start()\n\n        if self.web:\n            self.web_thread.start()\n\n        if self.gui:\n            self.gui_handler.start_animation()\n            try:\n                plt.show()\n            except KeyboardInterrupt:\n                pass\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start updating obstacles list.\n        \"\"\"\n        self.create_shared_memory()\n        self.lidar_data_converter.start()\n        self.start_lidar()\n        self.obstacles_updater_loop.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop updating obstacles list.\n        \"\"\"\n        self.obstacles_updater_loop.stop()\n        self.stop_lidar()\n        self.lidar_data_converter.stop()\n        self.delete_shared_memory()\n\n    def try_connect(self):\n        \"\"\"\n        Poll to wait for the first cogip-server connection.\n        Disconnections/re-connections are handle directly by the client.\n        \"\"\"\n        while True:\n            try:\n                self.sio.connect(\n                    self.server_url,\n                    namespaces=[\"/detector\"],\n                )\n                self.sio.wait()\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    def cluster_obstacles(self, lidar_coords: NDArray) -&gt; list[NDArray]:\n        \"\"\"\n        Groups points into obstacle clusters using DBSCAN\n\n        Returns:\n            List of clusters, each cluster being a set of points belonging to the same obstacle\n        \"\"\"\n        if len(lidar_coords) == 0:\n            return []\n\n        db = DBSCAN(\n            eps=self.properties.cluster_eps,\n            min_samples=self.properties.cluster_min_samples,\n        ).fit(lidar_coords)\n        labels = db.labels_\n\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n        clusters = []\n        for i in range(n_clusters):\n            cluster_points = lidar_coords[labels == i]\n            clusters.append(cluster_points)\n\n        return clusters\n\n    def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Estimates position and size of obstacles from clusters\n\n        Args:\n            clusters: List of clusters, each cluster being a set of points\n\n        Returns:\n            List of tuples (center_x, center_y, radius) for each obstacle\n        \"\"\"\n        obstacle_properties = []\n\n        for cluster in clusters:\n            center_x = np.mean(cluster[:, 0])\n            center_y = np.mean(cluster[:, 1])\n\n            # Calculate the maximum distance from center in x and y directions\n            # This will be used as the radius of the circle\n            radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n            radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n            radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n            obstacle_properties.append((center_x, center_y, radius))\n\n        return obstacle_properties\n\n    def process_lidar_coords(self):\n        \"\"\"\n        Function executed in a thread loop to update and send dynamic obstacles.\n        \"\"\"\n        # self.shared_lidar_coords_lock.wait_update()\n        self.shared_lidar_coords_lock.start_reading()\n        lidar_coords = self.shared_lidar_coords[: np.argmax(self.shared_lidar_coords[:, 0] == -1)].copy()\n        self.shared_lidar_coords_lock.finish_reading()\n\n        self.clusters = self.cluster_obstacles(lidar_coords)\n        obstacles = self.estimate_obstacle_properties(self.clusters)\n        self.shared_detector_obstacles_lock.start_writing()\n        self.shared_detector_obstacles.clear()\n        for x, y, radius in obstacles:\n            self.shared_detector_obstacles.append(x=x, y=y, radius=radius)\n        self.shared_detector_obstacles_lock.finish_writing()\n        self.shared_detector_obstacles_lock.post_update()\n\n        logger.debug(f\"Generated obstacles: {obstacles}\")\n\n    def start_lidar(self):\n        \"\"\"\n        Start the Lidar.\n        \"\"\"\n        if self.lidar_port:\n            if self.robot_id == 1:\n                self.lidar = YDLidar(self.shared_lidar_data)\n                self.lidar.set_scan_frequency(10)\n                # No excluded angle range\n                self.lidar.set_invalid_angle_range(360, 0)\n            else:\n                self.lidar = LDLidarDriver(self.shared_lidar_data)\n                # Skip rear-facing Lidar data because Lidar is mounted in PAMI\n                self.lidar.set_invalid_angle_range(30, 330)\n            self.lidar.set_data_write_lock(self.shared_lidar_data_lock)\n            self.lidar.set_min_distance(self.properties.min_distance)\n            self.lidar.set_max_distance(self.properties.max_distance)\n            self.lidar.set_min_intensity(self.properties.min_intensity)\n\n            res = self.lidar.connect(str(self.lidar_port))\n            if not res:\n                logger.error(\"Error: Lidar connection failed.\")\n                os._exit(1)\n            logger.info(\"Lidar connected.\")\n\n            if self.robot_id &gt; 1:\n                res = self.lidar.wait_lidar_comm(self.YDLIDAR_READY_TIMEOUT_MS)\n                if not res:\n                    logger.error(\"Error: Lidar not ready.\")\n                    os._exit(1)\n                logger.info(\"Lidar is ready.\")\n\n            res = self.lidar.start()\n            if not res:\n                logger.error(\"Error: Lidar not started.\")\n                os._exit(1)\n\n            try:\n                systemd.daemon.notify(\"READY=1\")\n                logger.info(\"Systemd notified: READY=1\")\n            except Exception as e:\n                logger.error(f\"Failed to notify systemd: {e}\")\n\n            logger.info(\"Lidar started.\")\n\n    def stop_lidar(self):\n        \"\"\"\n        Stop the Lidar.\n        \"\"\"\n        if self.lidar:\n            self.lidar.stop()\n            self.lidar.disconnect()\n            self.lidar = None\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.__init__","title":"<code>__init__(robot_id, server_url, lidar_port, min_distance, max_distance, min_intensity, refresh_interval, sensor_delay, cluster_min_samples, cluster_eps, gui, web)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>Robot ID</p> required <code>server_url</code> <code>str</code> <p>server URL</p> required <code>lidar_port</code> <code>Path | None</code> <p>Serial port connected to the Lidar</p> required <code>min_distance</code> <code>int</code> <p>Minimum distance to detect an obstacle</p> required <code>max_distance</code> <code>int</code> <p>Maximum distance to detect an obstacle</p> required <code>min_intensity</code> <code>int</code> <p>Minimum intensity to detect an obstacle</p> required <code>refresh_interval</code> <code>float</code> <p>Interval between each update of the obstacle list (in seconds)</p> required <code>sensor_delay</code> <code>int</code> <p>Delay to compensate the delay between sensor data fetch and obstacle positions computation,\"           unit is the index of pose current to get in the past</p> required <code>cluster_min_samples</code> <code>int</code> <p>Minimum number of samples to form a cluster</p> required <code>cluster_eps</code> <code>float</code> <p>Maximum distance between two samples to form a cluster (mm)</p> required <code>gui</code> <code>bool</code> <p>Enable GUI</p> required <code>web</code> <code>bool</code> <p>Enable data display on a web server</p> required Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def __init__(\n    self,\n    robot_id: int,\n    server_url: str,\n    lidar_port: Path | None,\n    min_distance: int,\n    max_distance: int,\n    min_intensity: int,\n    refresh_interval: float,\n    sensor_delay: int,\n    cluster_min_samples: int,\n    cluster_eps: float,\n    gui: bool,\n    web: bool,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        robot_id: Robot ID\n        server_url: server URL\n        lidar_port: Serial port connected to the Lidar\n        min_distance: Minimum distance to detect an obstacle\n        max_distance: Maximum distance to detect an obstacle\n        min_intensity: Minimum intensity to detect an obstacle\n        refresh_interval: Interval between each update of the obstacle list (in seconds)\n        sensor_delay: Delay to compensate the delay between sensor data fetch and obstacle positions computation,\"\n                      unit is the index of pose current to get in the past\n        cluster_min_samples: Minimum number of samples to form a cluster\n        cluster_eps: Maximum distance between two samples to form a cluster (mm)\n        gui: Enable GUI\n        web: Enable data display on a web server\n    \"\"\"\n    if lidar_port:\n        try:\n            ser = serial.Serial(str(lidar_port), timeout=0.1)\n            ser.close()\n            logger.info(f\"Lidar check SUCCESS on {lidar_port}.\")\n        except serial.SerialException as exc:\n            # Failed to open port. Device not connected or permission error.\n            logger.error(f\"Lidar check FAILED on {lidar_port}: {exc}\")\n            os._exit(1)\n        except Exception as exc:\n            logger.error(f\"Lidar check FAILED on {lidar_port} with unexpected error: {exc}\")\n            os._exit(1)\n\n    self.robot_id = robot_id\n    self.server_url = server_url\n    self.lidar_port = lidar_port\n    self.gui = gui\n    self.web = web\n    self.properties = Properties(\n        min_distance=min_distance,\n        max_distance=max_distance,\n        min_intensity=min_intensity,\n        refresh_interval=refresh_interval,\n        sensor_delay=sensor_delay,\n        cluster_min_samples=cluster_min_samples,\n        cluster_eps=cluster_eps,\n    )\n\n    if robot_id == 1:\n        self.LIDAR_OFFSET_X = 0.0\n    else:\n        self.LIDAR_OFFSET_X = 75.5\n    self.LIDAR_OFFSET_Y = 0.0\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_pose_current_lock: WritePriorityLock | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_lidar_data: NDArray | None = None\n    self.shared_lidar_coords: NDArray | None = None\n    self.shared_lidar_data_lock: WritePriorityLock | None = None\n    self.shared_lidar_coords_lock: WritePriorityLock | None = None\n    self.shared_detector_obstacles: SharedCircleList | None = None\n    self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n\n    self.lidar_data_converter: LidarDataConverter | None = None\n\n    self.lidar: LDLidarDriver | YDLidar | None = None\n    self.clusters: list[NDArray] = []\n\n    self.obstacles_updater_loop = ThreadLoop(\n        \"Obstacles updater loop\",\n        refresh_interval,\n        self.process_lidar_coords,\n        logger=True,\n    )\n\n    if gui:\n        self.gui_handler = DetectorGUI(self)\n\n    if web:\n        self.web_thread = threading.Thread(\n            target=start_web,\n            args=(self, 8110 + robot_id),\n            name=\"Web thread\",\n        )\n\n    self.sio = socketio.Client(logger=False)\n    self.sio.register_namespace(SioEvents(self))\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.cluster_obstacles","title":"<code>cluster_obstacles(lidar_coords)</code>","text":"<p>Groups points into obstacle clusters using DBSCAN</p> <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points belonging to the same obstacle</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def cluster_obstacles(self, lidar_coords: NDArray) -&gt; list[NDArray]:\n    \"\"\"\n    Groups points into obstacle clusters using DBSCAN\n\n    Returns:\n        List of clusters, each cluster being a set of points belonging to the same obstacle\n    \"\"\"\n    if len(lidar_coords) == 0:\n        return []\n\n    db = DBSCAN(\n        eps=self.properties.cluster_eps,\n        min_samples=self.properties.cluster_min_samples,\n    ).fit(lidar_coords)\n    labels = db.labels_\n\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    clusters = []\n    for i in range(n_clusters):\n        cluster_points = lidar_coords[labels == i]\n        clusters.append(cluster_points)\n\n    return clusters\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.connect","title":"<code>connect()</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    threading.Thread(target=self.try_connect).start()\n\n    if self.web:\n        self.web_thread.start()\n\n    if self.gui:\n        self.gui_handler.start_animation()\n        try:\n            plt.show()\n        except KeyboardInterrupt:\n            pass\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.estimate_obstacle_properties","title":"<code>estimate_obstacle_properties(clusters)</code>","text":"<p>Estimates position and size of obstacles from clusters</p> <p>Parameters:</p> Name Type Description Default <code>clusters</code> <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points</p> required <p>Returns:</p> Type Description <code>list[tuple[float, float, float]]</code> <p>List of tuples (center_x, center_y, radius) for each obstacle</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n    \"\"\"\n    Estimates position and size of obstacles from clusters\n\n    Args:\n        clusters: List of clusters, each cluster being a set of points\n\n    Returns:\n        List of tuples (center_x, center_y, radius) for each obstacle\n    \"\"\"\n    obstacle_properties = []\n\n    for cluster in clusters:\n        center_x = np.mean(cluster[:, 0])\n        center_y = np.mean(cluster[:, 1])\n\n        # Calculate the maximum distance from center in x and y directions\n        # This will be used as the radius of the circle\n        radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n        radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n        radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n        obstacle_properties.append((center_x, center_y, radius))\n\n    return obstacle_properties\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.process_lidar_coords","title":"<code>process_lidar_coords()</code>","text":"<p>Function executed in a thread loop to update and send dynamic obstacles.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def process_lidar_coords(self):\n    \"\"\"\n    Function executed in a thread loop to update and send dynamic obstacles.\n    \"\"\"\n    # self.shared_lidar_coords_lock.wait_update()\n    self.shared_lidar_coords_lock.start_reading()\n    lidar_coords = self.shared_lidar_coords[: np.argmax(self.shared_lidar_coords[:, 0] == -1)].copy()\n    self.shared_lidar_coords_lock.finish_reading()\n\n    self.clusters = self.cluster_obstacles(lidar_coords)\n    obstacles = self.estimate_obstacle_properties(self.clusters)\n    self.shared_detector_obstacles_lock.start_writing()\n    self.shared_detector_obstacles.clear()\n    for x, y, radius in obstacles:\n        self.shared_detector_obstacles.append(x=x, y=y, radius=radius)\n    self.shared_detector_obstacles_lock.finish_writing()\n    self.shared_detector_obstacles_lock.post_update()\n\n    logger.debug(f\"Generated obstacles: {obstacles}\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.start","title":"<code>start()</code>","text":"<p>Start updating obstacles list.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start updating obstacles list.\n    \"\"\"\n    self.create_shared_memory()\n    self.lidar_data_converter.start()\n    self.start_lidar()\n    self.obstacles_updater_loop.start()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.start_lidar","title":"<code>start_lidar()</code>","text":"<p>Start the Lidar.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def start_lidar(self):\n    \"\"\"\n    Start the Lidar.\n    \"\"\"\n    if self.lidar_port:\n        if self.robot_id == 1:\n            self.lidar = YDLidar(self.shared_lidar_data)\n            self.lidar.set_scan_frequency(10)\n            # No excluded angle range\n            self.lidar.set_invalid_angle_range(360, 0)\n        else:\n            self.lidar = LDLidarDriver(self.shared_lidar_data)\n            # Skip rear-facing Lidar data because Lidar is mounted in PAMI\n            self.lidar.set_invalid_angle_range(30, 330)\n        self.lidar.set_data_write_lock(self.shared_lidar_data_lock)\n        self.lidar.set_min_distance(self.properties.min_distance)\n        self.lidar.set_max_distance(self.properties.max_distance)\n        self.lidar.set_min_intensity(self.properties.min_intensity)\n\n        res = self.lidar.connect(str(self.lidar_port))\n        if not res:\n            logger.error(\"Error: Lidar connection failed.\")\n            os._exit(1)\n        logger.info(\"Lidar connected.\")\n\n        if self.robot_id &gt; 1:\n            res = self.lidar.wait_lidar_comm(self.YDLIDAR_READY_TIMEOUT_MS)\n            if not res:\n                logger.error(\"Error: Lidar not ready.\")\n                os._exit(1)\n            logger.info(\"Lidar is ready.\")\n\n        res = self.lidar.start()\n        if not res:\n            logger.error(\"Error: Lidar not started.\")\n            os._exit(1)\n\n        try:\n            systemd.daemon.notify(\"READY=1\")\n            logger.info(\"Systemd notified: READY=1\")\n        except Exception as e:\n            logger.error(f\"Failed to notify systemd: {e}\")\n\n        logger.info(\"Lidar started.\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.stop","title":"<code>stop()</code>","text":"<p>Stop updating obstacles list.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop updating obstacles list.\n    \"\"\"\n    self.obstacles_updater_loop.stop()\n    self.stop_lidar()\n    self.lidar_data_converter.stop()\n    self.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.stop_lidar","title":"<code>stop_lidar()</code>","text":"<p>Stop the Lidar.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def stop_lidar(self):\n    \"\"\"\n    Stop the Lidar.\n    \"\"\"\n    if self.lidar:\n        self.lidar.stop()\n        self.lidar.disconnect()\n        self.lidar = None\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.try_connect","title":"<code>try_connect()</code>","text":"<p>Poll to wait for the first cogip-server connection. Disconnections/re-connections are handle directly by the client.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def try_connect(self):\n    \"\"\"\n    Poll to wait for the first cogip-server connection.\n    Disconnections/re-connections are handle directly by the client.\n    \"\"\"\n    while True:\n        try:\n            self.sio.connect(\n                self.server_url,\n                namespaces=[\"/detector\"],\n            )\n            self.sio.wait()\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/","title":"gui","text":""},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI","title":"<code>DetectorGUI</code>","text":"Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>class DetectorGUI:\n    def __init__(self, detector: \"Detector\"):\n        \"\"\"\n        Initialize the GUI for the detector.\n\n        Args:\n            detector: Reference to the Detector instance for accessing shared data.\n        \"\"\"\n        self.detector = detector\n\n        # Initialize plot and data containers\n        self.fig, self.ax = plt.subplots(figsize=(10, 10))\n\n        # Set figure and axes background color\n        self.fig.patch.set_facecolor(\"#2E2E2E\")\n        self.ax.set_facecolor(\"#1E1E1E\")\n\n        # Set labels and title with light colors\n        self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n        self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n        self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n        # Customize grid\n        self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n        # Customize axis appearance\n        self.ax.spines[\"bottom\"].set_color(\"#555555\")\n        self.ax.spines[\"top\"].set_color(\"#555555\")\n        self.ax.spines[\"left\"].set_color(\"#555555\")\n        self.ax.spines[\"right\"].set_color(\"#555555\")\n\n        # Customize tick parameters\n        self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n        # Invert x-axis and set equal aspect ratio\n        self.ax.invert_xaxis()\n        self.ax.axis(\"equal\")\n\n        # Configure legend with dark theme colors\n        self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n        # Set initial view range\n        view_radius = self.detector.properties.max_distance * 1.2\n        self.ax.set_xlim((view_radius, -view_radius))\n        self.ax.set_ylim((-view_radius, view_radius))\n\n        # Connect the scroll event to the handler\n        self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n        # Visualization elements\n        self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n        self.cluster_scatters: list[PathCollection] = []\n        self.obstacle_circles: list[Ellipse] = []\n\n        # Robot and Lidar markers\n        self.robot_marker = self.ax.scatter(\n            0,\n            0,\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Robot\",\n        )\n\n        # Calculate Lidar position\n        self.lidar_marker = self.ax.scatter(\n            self.detector.LIDAR_OFFSET_Y,\n            self.detector.LIDAR_OFFSET_X,\n            c=\"blue\",\n            s=80,\n            marker=\"o\",\n            label=\"Lidar\",\n        )\n\n        # Animation setup\n        self.animation: FuncAnimation | None = None\n\n    def start_animation(self):\n        \"\"\"Starts the real-time visualization.\"\"\"\n        plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n        self.animation = FuncAnimation(\n            self.fig,\n            self.update_plot,\n            interval=200,\n            blit=False,\n            cache_frame_data=False,\n        )\n\n    def update_robot_pose(self):\n        \"\"\"Update robot pose on the GUI.\"\"\"\n        if not self.detector.shared_pose_current_buffer:\n            return\n\n        pose_current = self.detector.shared_pose_current_buffer.last\n        x = pose_current.x\n        y = pose_current.y\n        angle = pose_current.angle\n\n        self.robot_marker.set_offsets([y, x])\n\n        angle_rad = np.radians(-angle)\n        lidar_offset_rotated = np.array(\n            [\n                self.detector.LIDAR_OFFSET_Y * np.cos(angle_rad) - self.detector.LIDAR_OFFSET_X * np.sin(angle_rad),\n                self.detector.LIDAR_OFFSET_Y * np.sin(angle_rad) + self.detector.LIDAR_OFFSET_X * np.cos(angle_rad),\n            ]\n        )\n        lidar_x = x + lidar_offset_rotated[1]\n        lidar_y = y + lidar_offset_rotated[0]\n        self.lidar_marker.set_offsets([lidar_y, lidar_x])\n\n    def update_plot(self, frame):\n        \"\"\"Updates the visualization with current data.\"\"\"\n        self.update_robot_pose()\n\n        if self.detector.shared_lidar_coords is None:\n            return\n\n        lidar_coords = self.detector.shared_lidar_coords[\n            : np.argmax(self.detector.shared_lidar_coords[:, 0] == -1)\n        ].copy()\n        self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n        for scatter in self.cluster_scatters:\n            scatter.remove()\n        self.cluster_scatters = []\n\n        for circle in self.obstacle_circles:\n            circle.remove()\n        self.obstacle_circles = []\n\n        colors = plt.cm.plasma(np.linspace(0, 1, len(self.detector.clusters) + 1))\n\n        for i, cluster in enumerate(self.detector.clusters):\n            scatter = self.ax.scatter(\n                cluster[:, 1],\n                cluster[:, 0],\n                c=[colors[i]],\n                s=20,\n            )\n            self.cluster_scatters.append(scatter)\n\n        for i, obstacle in enumerate(self.detector.shared_detector_obstacles):\n            center_x = obstacle.x\n            center_y = obstacle.y\n            radius = obstacle.radius\n            circle = Ellipse(\n                (center_y, center_x),\n                width=radius * 2,\n                height=radius * 2,\n                fill=False,\n                edgecolor=colors[i],\n                linewidth=2,\n                alpha=0.8,\n            )\n            self.ax.add_patch(circle)\n            self.obstacle_circles.append(circle)\n\n        self.fig.canvas.draw_idle()\n        self.fig.canvas.flush_events()\n\n    def on_scroll(self, event: MouseEvent):\n        \"\"\"Handle scroll events for zooming.\"\"\"\n        if event.inaxes != self.ax:\n            return\n\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        x_data, y_data = event.xdata, event.ydata\n        zoom_factor = 1.1 if event.button == \"down\" else 0.9\n\n        x_left = x_data - zoom_factor * (x_data - xlim[0])\n        x_right = x_data + zoom_factor * (xlim[1] - x_data)\n        y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n        y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n        view_radius = self.detector.properties.max_distance * 1.2\n        x_left = max(-view_radius, x_left)\n        x_right = min(view_radius, x_right)\n        y_bottom = max(-view_radius, y_bottom)\n        y_top = min(view_radius, y_top)\n\n        self.ax.set_xlim(x_left, x_right)\n        self.ax.set_ylim(y_bottom, y_top)\n\n        plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.__init__","title":"<code>__init__(detector)</code>","text":"<p>Initialize the GUI for the detector.</p> <p>Parameters:</p> Name Type Description Default <code>detector</code> <code>Detector</code> <p>Reference to the Detector instance for accessing shared data.</p> required Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def __init__(self, detector: \"Detector\"):\n    \"\"\"\n    Initialize the GUI for the detector.\n\n    Args:\n        detector: Reference to the Detector instance for accessing shared data.\n    \"\"\"\n    self.detector = detector\n\n    # Initialize plot and data containers\n    self.fig, self.ax = plt.subplots(figsize=(10, 10))\n\n    # Set figure and axes background color\n    self.fig.patch.set_facecolor(\"#2E2E2E\")\n    self.ax.set_facecolor(\"#1E1E1E\")\n\n    # Set labels and title with light colors\n    self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n    self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n    self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n    # Customize grid\n    self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Customize axis appearance\n    self.ax.spines[\"bottom\"].set_color(\"#555555\")\n    self.ax.spines[\"top\"].set_color(\"#555555\")\n    self.ax.spines[\"left\"].set_color(\"#555555\")\n    self.ax.spines[\"right\"].set_color(\"#555555\")\n\n    # Customize tick parameters\n    self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n    # Invert x-axis and set equal aspect ratio\n    self.ax.invert_xaxis()\n    self.ax.axis(\"equal\")\n\n    # Configure legend with dark theme colors\n    self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n    # Set initial view range\n    view_radius = self.detector.properties.max_distance * 1.2\n    self.ax.set_xlim((view_radius, -view_radius))\n    self.ax.set_ylim((-view_radius, view_radius))\n\n    # Connect the scroll event to the handler\n    self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n    # Visualization elements\n    self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n    self.cluster_scatters: list[PathCollection] = []\n    self.obstacle_circles: list[Ellipse] = []\n\n    # Robot and Lidar markers\n    self.robot_marker = self.ax.scatter(\n        0,\n        0,\n        c=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"Robot\",\n    )\n\n    # Calculate Lidar position\n    self.lidar_marker = self.ax.scatter(\n        self.detector.LIDAR_OFFSET_Y,\n        self.detector.LIDAR_OFFSET_X,\n        c=\"blue\",\n        s=80,\n        marker=\"o\",\n        label=\"Lidar\",\n    )\n\n    # Animation setup\n    self.animation: FuncAnimation | None = None\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.on_scroll","title":"<code>on_scroll(event)</code>","text":"<p>Handle scroll events for zooming.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def on_scroll(self, event: MouseEvent):\n    \"\"\"Handle scroll events for zooming.\"\"\"\n    if event.inaxes != self.ax:\n        return\n\n    xlim = self.ax.get_xlim()\n    ylim = self.ax.get_ylim()\n\n    x_data, y_data = event.xdata, event.ydata\n    zoom_factor = 1.1 if event.button == \"down\" else 0.9\n\n    x_left = x_data - zoom_factor * (x_data - xlim[0])\n    x_right = x_data + zoom_factor * (xlim[1] - x_data)\n    y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n    y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n    view_radius = self.detector.properties.max_distance * 1.2\n    x_left = max(-view_radius, x_left)\n    x_right = min(view_radius, x_right)\n    y_bottom = max(-view_radius, y_bottom)\n    y_top = min(view_radius, y_top)\n\n    self.ax.set_xlim(x_left, x_right)\n    self.ax.set_ylim(y_bottom, y_top)\n\n    plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.start_animation","title":"<code>start_animation()</code>","text":"<p>Starts the real-time visualization.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def start_animation(self):\n    \"\"\"Starts the real-time visualization.\"\"\"\n    plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n    self.animation = FuncAnimation(\n        self.fig,\n        self.update_plot,\n        interval=200,\n        blit=False,\n        cache_frame_data=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.update_plot","title":"<code>update_plot(frame)</code>","text":"<p>Updates the visualization with current data.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def update_plot(self, frame):\n    \"\"\"Updates the visualization with current data.\"\"\"\n    self.update_robot_pose()\n\n    if self.detector.shared_lidar_coords is None:\n        return\n\n    lidar_coords = self.detector.shared_lidar_coords[\n        : np.argmax(self.detector.shared_lidar_coords[:, 0] == -1)\n    ].copy()\n    self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n    for scatter in self.cluster_scatters:\n        scatter.remove()\n    self.cluster_scatters = []\n\n    for circle in self.obstacle_circles:\n        circle.remove()\n    self.obstacle_circles = []\n\n    colors = plt.cm.plasma(np.linspace(0, 1, len(self.detector.clusters) + 1))\n\n    for i, cluster in enumerate(self.detector.clusters):\n        scatter = self.ax.scatter(\n            cluster[:, 1],\n            cluster[:, 0],\n            c=[colors[i]],\n            s=20,\n        )\n        self.cluster_scatters.append(scatter)\n\n    for i, obstacle in enumerate(self.detector.shared_detector_obstacles):\n        center_x = obstacle.x\n        center_y = obstacle.y\n        radius = obstacle.radius\n        circle = Ellipse(\n            (center_y, center_x),\n            width=radius * 2,\n            height=radius * 2,\n            fill=False,\n            edgecolor=colors[i],\n            linewidth=2,\n            alpha=0.8,\n        )\n        self.ax.add_patch(circle)\n        self.obstacle_circles.append(circle)\n\n    self.fig.canvas.draw_idle()\n    self.fig.canvas.flush_events()\n</code></pre>"},{"location":"reference/cogip/tools/detector/gui/#cogip.tools.detector.gui.DetectorGUI.update_robot_pose","title":"<code>update_robot_pose()</code>","text":"<p>Update robot pose on the GUI.</p> Source code in <code>cogip/tools/detector/gui.py</code> <pre><code>def update_robot_pose(self):\n    \"\"\"Update robot pose on the GUI.\"\"\"\n    if not self.detector.shared_pose_current_buffer:\n        return\n\n    pose_current = self.detector.shared_pose_current_buffer.last\n    x = pose_current.x\n    y = pose_current.y\n    angle = pose_current.angle\n\n    self.robot_marker.set_offsets([y, x])\n\n    angle_rad = np.radians(-angle)\n    lidar_offset_rotated = np.array(\n        [\n            self.detector.LIDAR_OFFSET_Y * np.cos(angle_rad) - self.detector.LIDAR_OFFSET_X * np.sin(angle_rad),\n            self.detector.LIDAR_OFFSET_Y * np.sin(angle_rad) + self.detector.LIDAR_OFFSET_X * np.cos(angle_rad),\n        ]\n    )\n    lidar_x = x + lidar_offset_rotated[1]\n    lidar_y = y + lidar_offset_rotated[0]\n    self.lidar_marker.set_offsets([lidar_y, lidar_x])\n</code></pre>"},{"location":"reference/cogip/tools/detector/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/detector/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/detector/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>ClientNamespace</code></p> <p>Handle all SocketIO events received by Detector.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>class SioEvents(socketio.ClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Detector.\n    \"\"\"\n\n    def __init__(self, detector: \"detector.Detector\"):\n        super().__init__(\"/detector\")\n        self.detector = detector\n\n    def on_connect(self):\n        \"\"\"\n        On connection to cogip-server, start detector threads.\n        \"\"\"\n        polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Connected to cogip-server\")\n        self.emit(\"connected\", self.detector.lidar_port is None)\n        self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n        self.detector.start()\n\n    def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server, stop detector threads.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.detector.stop()\n        self.detector.delete_shared_memory()\n\n    def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Detector is already connected and exit,\n        or retry connection.\n        \"\"\"\n        logger.error(f\"Connect to cogip-server error: {data = }\")\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A detector is already connected\"\n        ):\n            logger.error(message)\n            self.detector.retry_connection = False\n            return\n\n    def on_command(self, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema = self.detector.properties.model_json_schema()\n            # Add namespace in JSON Schema\n            schema[\"namespace\"] = \"/detector\"\n            schema[\"sio_event\"] = \"config_updated\"\n            # Add current values in JSON Schema\n            for prop, value in self.detector.properties.model_dump().items():\n                schema[\"properties\"][prop][\"value\"] = value\n            # Send config\n            self.emit(\"config\", schema)\n        else:\n            logger.warning(f\"Unknown command: {cmd}\")\n\n    def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        value = config[\"value\"]\n        self.detector.properties.__setattr__(name := config[\"name\"], value)\n        match name:\n            case \"refresh_interval\":\n                self.detector.obstacles_updater_loop.interval = value\n            case \"min_distance\":\n                if self.detector.lidar:\n                    self.detector.lidar.set_min_distance(value)\n            case \"max_distance\":\n                if self.detector.lidar:\n                    self.detector.lidar.set_max_distance(value)\n            case \"min_intensity\":\n                if self.detector.lidar:\n                    self.detector.lidar.set_min_intensity(value)\n            case \"sensor_delay\":\n                self.detector.lidar_data_converter.set_pose_current_index(value)\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_command","title":"<code>on_command(cmd)</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_command(self, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema = self.detector.properties.model_json_schema()\n        # Add namespace in JSON Schema\n        schema[\"namespace\"] = \"/detector\"\n        schema[\"sio_event\"] = \"config_updated\"\n        # Add current values in JSON Schema\n        for prop, value in self.detector.properties.model_dump().items():\n            schema[\"properties\"][prop][\"value\"] = value\n        # Send config\n        self.emit(\"config\", schema)\n    else:\n        logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>","text":"<p>On connection to cogip-server, start detector threads.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_connect(self):\n    \"\"\"\n    On connection to cogip-server, start detector threads.\n    \"\"\"\n    polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n    logger.info(\"Connected to cogip-server\")\n    self.emit(\"connected\", self.detector.lidar_port is None)\n    self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n    self.detector.start()\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>","text":"<p>On connection error, check if a Detector is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Detector is already connected and exit,\n    or retry connection.\n    \"\"\"\n    logger.error(f\"Connect to cogip-server error: {data = }\")\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A detector is already connected\"\n    ):\n        logger.error(message)\n        self.detector.retry_connection = False\n        return\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>","text":"<p>On disconnection from cogip-server, stop detector threads.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server, stop detector threads.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.detector.stop()\n    self.detector.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/detector/web/","title":"web","text":""},{"location":"reference/cogip/tools/firmware_odometry_calibration/__main__/","title":"__main__","text":"<p>CLI entry point for the Odometry Calibration tool.</p> <p>Provides a command-line interface to calibrate robot odometry parameters by communicating with the firmware via SocketIO through cogip-server.</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/__main__/#cogip.tools.firmware_odometry_calibration.__main__.main","title":"<code>main()</code>","text":"<p>Run odometry calibration tool.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-odometry-calibration</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Run odometry calibration tool.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-odometry-calibration` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/","title":"calculator","text":"<p>Odometry Calibration Calculator.</p> <p>Pure mathematical functions for computing calibration parameters.</p> <p>Calibrates three parameters for differential drive odometry: wheel distance, left wheel radius, and right wheel radius.</p> Calibration process <p>Phase 1 (Turn in Place): Spin N rotations to compute wheel distance from encoder arcs Phase 2 (Square Path): Drive squares to isolate linear motion and find wheel radius ratio (beta) Phase 3 (Straight Line): Drive known distance to solve for actual wheel radius using beta</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/#cogip.tools.firmware_odometry_calibration.calculator.compute_alpha_coefficients","title":"<code>compute_alpha_coefficients(turns, lticks_delta, rticks_delta, encoder_ticks)</code>","text":"<p>Compute alpha coefficients from turn-in-place data.</p> <p>Alpha represents wheel rotations per robot rotation.</p> <p>Parameters:</p> Name Type Description Default <code>turns</code> <code>int</code> <p>Number of full rotations performed</p> required <code>lticks_delta</code> <code>int</code> <p>Change in left encoder ticks</p> required <code>rticks_delta</code> <code>int</code> <p>Change in right encoder ticks</p> required <code>encoder_ticks</code> <code>float</code> <p>Encoder ticks per wheel revolution</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple of (alpha_l, alpha_r)</p> Source code in <code>cogip/tools/firmware_odometry_calibration/calculator.py</code> <pre><code>def compute_alpha_coefficients(\n    turns: int,\n    lticks_delta: int,\n    rticks_delta: int,\n    encoder_ticks: float,\n) -&gt; tuple[float, float]:\n    \"\"\"\n    Compute alpha coefficients from turn-in-place data.\n\n    Alpha represents wheel rotations per robot rotation.\n\n    Args:\n        turns: Number of full rotations performed\n        lticks_delta: Change in left encoder ticks\n        rticks_delta: Change in right encoder ticks\n        encoder_ticks: Encoder ticks per wheel revolution\n\n    Returns:\n        Tuple of (alpha_l, alpha_r)\n    \"\"\"\n    alpha_l = lticks_delta / (encoder_ticks * turns)\n    alpha_r = rticks_delta / (encoder_ticks * turns)\n    return alpha_l, alpha_r\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/#cogip.tools.firmware_odometry_calibration.calculator.compute_beta_coefficient","title":"<code>compute_beta_coefficient(lticks_linear, rticks_linear)</code>","text":"<p>Compute beta coefficient (radius ratio) from linear encoder components.</p> <p>For straight-line motion, both wheels travel the same distance D:     D = 2\u03c0 * radius_l * (lticks / encoder_ticks)     D = 2\u03c0 * radius_r * (rticks / encoder_ticks)</p> <p>Therefore: radius_r / radius_l = lticks / rticks</p> <p>Beta = radius_r / radius_l = lticks_linear / rticks_linear</p> <p>Parameters:</p> Name Type Description Default <code>lticks_linear</code> <code>float</code> <p>Linear component of left encoder ticks</p> required <code>rticks_linear</code> <code>float</code> <p>Linear component of right encoder ticks</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>Beta coefficient (radius_r / radius_l), or None if rticks_linear is too small</p> Source code in <code>cogip/tools/firmware_odometry_calibration/calculator.py</code> <pre><code>def compute_beta_coefficient(\n    lticks_linear: float,\n    rticks_linear: float,\n) -&gt; float | None:\n    \"\"\"\n    Compute beta coefficient (radius ratio) from linear encoder components.\n\n    For straight-line motion, both wheels travel the same distance D:\n        D = 2\u03c0 * radius_l * (lticks / encoder_ticks)\n        D = 2\u03c0 * radius_r * (rticks / encoder_ticks)\n\n    Therefore: radius_r / radius_l = lticks / rticks\n\n    Beta = radius_r / radius_l = lticks_linear / rticks_linear\n\n    Args:\n        lticks_linear: Linear component of left encoder ticks\n        rticks_linear: Linear component of right encoder ticks\n\n    Returns:\n        Beta coefficient (radius_r / radius_l), or None if rticks_linear is too small\n    \"\"\"\n    if abs(rticks_linear) &lt; 1:\n        return None\n    return lticks_linear / rticks_linear\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/#cogip.tools.firmware_odometry_calibration.calculator.compute_left_wheel_radius_result","title":"<code>compute_left_wheel_radius_result(distance_mm, lticks_delta, rticks_delta, state, encoder_ticks, left_polarity=1.0, right_polarity=1.0)</code>","text":"<p>Phase 3: Compute left wheel radius from straight line data.</p> For straight-line motion of distance D <p>D = 2\u03c0 * radius_l * (lticks / encoder_ticks) D = 2\u03c0 * radius_r * (rticks / encoder_ticks)</p> <p>With radius_r = beta * radius_l, summing both equations:     2D = 2\u03c0 * radius_l * (lticks + beta * rticks) / encoder_ticks</p> <p>Formula: radius_l = D * encoder_ticks / (\u03c0 * (lticks + beta * rticks))</p> <p>Parameters:</p> Name Type Description Default <code>distance_mm</code> <code>int</code> <p>Distance traveled in mm</p> required <code>lticks_delta</code> <code>int</code> <p>Change in left encoder ticks (raw)</p> required <code>rticks_delta</code> <code>int</code> <p>Change in right encoder ticks (raw)</p> required <code>state</code> <code>CalibrationState</code> <p>Current calibration state with alpha and beta coefficients</p> required <code>encoder_ticks</code> <code>float</code> <p>Encoder ticks per wheel revolution</p> required <code>left_polarity</code> <code>float</code> <p>Left encoder polarity correction (+1 or -1)</p> <code>1.0</code> <code>right_polarity</code> <code>float</code> <p>Right encoder polarity correction (+1 or -1)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>tuple[CalibrationResult, CalibrationState] | None</code> <p>Tuple of (CalibrationResult, CalibrationState), or None if computation fails</p> Source code in <code>cogip/tools/firmware_odometry_calibration/calculator.py</code> <pre><code>def compute_left_wheel_radius_result(\n    distance_mm: int,\n    lticks_delta: int,\n    rticks_delta: int,\n    state: CalibrationState,\n    encoder_ticks: float,\n    left_polarity: float = 1.0,\n    right_polarity: float = 1.0,\n) -&gt; tuple[CalibrationResult, CalibrationState] | None:\n    \"\"\"\n    Phase 3: Compute left wheel radius from straight line data.\n\n    For straight-line motion of distance D:\n        D = 2\u03c0 * radius_l * (lticks / encoder_ticks)\n        D = 2\u03c0 * radius_r * (rticks / encoder_ticks)\n\n    With radius_r = beta * radius_l, summing both equations:\n        2D = 2\u03c0 * radius_l * (lticks + beta * rticks) / encoder_ticks\n\n    Formula: radius_l = D * encoder_ticks / (\u03c0 * (lticks + beta * rticks))\n\n    Args:\n        distance_mm: Distance traveled in mm\n        lticks_delta: Change in left encoder ticks (raw)\n        rticks_delta: Change in right encoder ticks (raw)\n        state: Current calibration state with alpha and beta coefficients\n        encoder_ticks: Encoder ticks per wheel revolution\n        left_polarity: Left encoder polarity correction (+1 or -1)\n        right_polarity: Right encoder polarity correction (+1 or -1)\n\n    Returns:\n        Tuple of (CalibrationResult, CalibrationState), or None if computation fails\n    \"\"\"\n    # Apply polarity correction\n    lticks_delta = int(lticks_delta * left_polarity)\n    rticks_delta = int(rticks_delta * right_polarity)\n\n    denominator = math.pi * (lticks_delta + state.beta * rticks_delta)\n\n    if abs(denominator) &lt; 1:\n        return None\n\n    new_left_wheel_radius = (distance_mm * encoder_ticks) / denominator\n    new_right_wheel_radius = state.beta * new_left_wheel_radius\n    new_wheels_distance = compute_wheel_distance(\n        state.alpha_l, state.alpha_r, new_left_wheel_radius, new_right_wheel_radius\n    )\n\n    result = CalibrationResult(\n        wheels_distance=new_wheels_distance,\n        right_wheel_radius=new_right_wheel_radius,\n        left_wheel_radius=new_left_wheel_radius,\n    )\n\n    # State unchanged in phase 3\n    return result, state\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/#cogip.tools.firmware_odometry_calibration.calculator.compute_right_wheel_radius_result","title":"<code>compute_right_wheel_radius_result(squares, lticks_delta, rticks_delta, state, encoder_ticks, left_wheel_radius, left_polarity=1.0, right_polarity=1.0)</code>","text":"<p>Phase 2: Compute right wheel radius from square trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>squares</code> <code>int</code> <p>Number of square paths performed</p> required <code>lticks_delta</code> <code>int</code> <p>Change in left encoder ticks (raw)</p> required <code>rticks_delta</code> <code>int</code> <p>Change in right encoder ticks (raw)</p> required <code>state</code> <code>CalibrationState</code> <p>Current calibration state with alpha coefficients</p> required <code>encoder_ticks</code> <code>float</code> <p>Encoder ticks per wheel revolution</p> required <code>left_wheel_radius</code> <code>float</code> <p>Current left wheel radius</p> required <code>left_polarity</code> <code>float</code> <p>Left encoder polarity correction (+1 or -1)</p> <code>1.0</code> <code>right_polarity</code> <code>float</code> <p>Right encoder polarity correction (+1 or -1)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>tuple[CalibrationResult, CalibrationState] | None</code> <p>Tuple of (CalibrationResult, updated CalibrationState), or None if computation fails</p> Source code in <code>cogip/tools/firmware_odometry_calibration/calculator.py</code> <pre><code>def compute_right_wheel_radius_result(\n    squares: int,\n    lticks_delta: int,\n    rticks_delta: int,\n    state: CalibrationState,\n    encoder_ticks: float,\n    left_wheel_radius: float,\n    left_polarity: float = 1.0,\n    right_polarity: float = 1.0,\n) -&gt; tuple[CalibrationResult, CalibrationState] | None:\n    \"\"\"\n    Phase 2: Compute right wheel radius from square trajectory data.\n\n    Args:\n        squares: Number of square paths performed\n        lticks_delta: Change in left encoder ticks (raw)\n        rticks_delta: Change in right encoder ticks (raw)\n        state: Current calibration state with alpha coefficients\n        encoder_ticks: Encoder ticks per wheel revolution\n        left_wheel_radius: Current left wheel radius\n        left_polarity: Left encoder polarity correction (+1 or -1)\n        right_polarity: Right encoder polarity correction (+1 or -1)\n\n    Returns:\n        Tuple of (CalibrationResult, updated CalibrationState), or None if computation fails\n    \"\"\"\n    # Apply polarity correction\n    lticks_delta = int(lticks_delta * left_polarity)\n    rticks_delta = int(rticks_delta * right_polarity)\n\n    # Subtract rotation component to get linear component\n    lticks_linear = lticks_delta - (state.alpha_l * encoder_ticks * squares)\n    rticks_linear = rticks_delta - (state.alpha_r * encoder_ticks * squares)\n\n    beta = compute_beta_coefficient(lticks_linear, rticks_linear)\n    if beta is None:\n        return None\n\n    new_right_wheel_radius = beta * left_wheel_radius\n    new_wheels_distance = compute_wheel_distance(\n        state.alpha_l, state.alpha_r, left_wheel_radius, new_right_wheel_radius\n    )\n\n    result = CalibrationResult(\n        wheels_distance=new_wheels_distance,\n        right_wheel_radius=new_right_wheel_radius,\n        left_wheel_radius=left_wheel_radius,\n    )\n\n    updated_state = CalibrationState(\n        alpha_l=state.alpha_l,\n        alpha_r=state.alpha_r,\n        beta=beta,\n    )\n\n    return result, updated_state\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/#cogip.tools.firmware_odometry_calibration.calculator.compute_wheel_distance","title":"<code>compute_wheel_distance(alpha_l, alpha_r, left_wheel_radius, right_wheel_radius)</code>","text":"<p>Compute wheel distance from alpha coefficients and wheel radii.</p> <p>Formula: axletrack = |alpha_l| * radius_l + |alpha_r| * radius_r</p> <p>During rotation in place, wheels turn in opposite directions, so alpha coefficients have opposite signs. We use absolute values to sum their contributions.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_l</code> <code>float</code> <p>Left wheel rotations per robot rotation (may be negative)</p> required <code>alpha_r</code> <code>float</code> <p>Right wheel rotations per robot rotation (may be negative)</p> required <code>left_wheel_radius</code> <code>float</code> <p>Current left wheel radius estimate</p> required <code>right_wheel_radius</code> <code>float</code> <p>Current right wheel radius estimate</p> required <p>Returns:</p> Type Description <code>float</code> <p>Computed wheel distance in mm</p> Source code in <code>cogip/tools/firmware_odometry_calibration/calculator.py</code> <pre><code>def compute_wheel_distance(\n    alpha_l: float,\n    alpha_r: float,\n    left_wheel_radius: float,\n    right_wheel_radius: float,\n) -&gt; float:\n    \"\"\"\n    Compute wheel distance from alpha coefficients and wheel radii.\n\n    Formula: axletrack = |alpha_l| * radius_l + |alpha_r| * radius_r\n\n    During rotation in place, wheels turn in opposite directions, so alpha\n    coefficients have opposite signs. We use absolute values to sum their\n    contributions.\n\n    Args:\n        alpha_l: Left wheel rotations per robot rotation (may be negative)\n        alpha_r: Right wheel rotations per robot rotation (may be negative)\n        left_wheel_radius: Current left wheel radius estimate\n        right_wheel_radius: Current right wheel radius estimate\n\n    Returns:\n        Computed wheel distance in mm\n    \"\"\"\n    return abs(alpha_l) * left_wheel_radius + abs(alpha_r) * right_wheel_radius\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/calculator/#cogip.tools.firmware_odometry_calibration.calculator.compute_wheel_distance_result","title":"<code>compute_wheel_distance_result(turns, lticks_delta, rticks_delta, encoder_ticks, left_wheel_radius, right_wheel_radius, left_polarity=1.0, right_polarity=1.0)</code>","text":"<p>Phase 1: Compute wheel distance from turn-in-place data.</p> <p>Parameters:</p> Name Type Description Default <code>turns</code> <code>int</code> <p>Number of full rotations performed</p> required <code>lticks_delta</code> <code>int</code> <p>Change in left encoder ticks (raw)</p> required <code>rticks_delta</code> <code>int</code> <p>Change in right encoder ticks (raw)</p> required <code>encoder_ticks</code> <code>float</code> <p>Encoder ticks per wheel revolution</p> required <code>left_wheel_radius</code> <code>float</code> <p>Current left wheel radius</p> required <code>right_wheel_radius</code> <code>float</code> <p>Current right wheel radius</p> required <code>left_polarity</code> <code>float</code> <p>Left encoder polarity correction (+1 or -1)</p> <code>1.0</code> <code>right_polarity</code> <code>float</code> <p>Right encoder polarity correction (+1 or -1)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>tuple[CalibrationResult, CalibrationState]</code> <p>Tuple of (CalibrationResult, updated CalibrationState)</p> Source code in <code>cogip/tools/firmware_odometry_calibration/calculator.py</code> <pre><code>def compute_wheel_distance_result(\n    turns: int,\n    lticks_delta: int,\n    rticks_delta: int,\n    encoder_ticks: float,\n    left_wheel_radius: float,\n    right_wheel_radius: float,\n    left_polarity: float = 1.0,\n    right_polarity: float = 1.0,\n) -&gt; tuple[CalibrationResult, CalibrationState]:\n    \"\"\"\n    Phase 1: Compute wheel distance from turn-in-place data.\n\n    Args:\n        turns: Number of full rotations performed\n        lticks_delta: Change in left encoder ticks (raw)\n        rticks_delta: Change in right encoder ticks (raw)\n        encoder_ticks: Encoder ticks per wheel revolution\n        left_wheel_radius: Current left wheel radius\n        right_wheel_radius: Current right wheel radius\n        left_polarity: Left encoder polarity correction (+1 or -1)\n        right_polarity: Right encoder polarity correction (+1 or -1)\n\n    Returns:\n        Tuple of (CalibrationResult, updated CalibrationState)\n    \"\"\"\n    # Apply polarity correction\n    lticks_delta = int(lticks_delta * left_polarity)\n    rticks_delta = int(rticks_delta * right_polarity)\n\n    alpha_l, alpha_r = compute_alpha_coefficients(turns, lticks_delta, rticks_delta, encoder_ticks)\n    new_wheels_distance = compute_wheel_distance(alpha_l, alpha_r, left_wheel_radius, right_wheel_radius)\n\n    result = CalibrationResult(\n        wheels_distance=new_wheels_distance,\n        right_wheel_radius=right_wheel_radius,\n        left_wheel_radius=left_wheel_radius,\n    )\n\n    state = CalibrationState(\n        alpha_l=alpha_l,\n        alpha_r=alpha_r,\n        beta=0.0,\n    )\n\n    return result, state\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/","title":"firmware_adapter","text":"<p>Firmware Adapter for Odometry Calibration</p> <p>Unified facade for all firmware interactions via SocketIO: - Parameter load/save operations - Encoder telemetry - Motion control via pose_order/pose_reached - Calibration-specific movement sequences</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter","title":"<code>FirmwareAdapter</code>","text":"<p>Unified adapter for firmware operations via SocketIO.</p> <p>Handles odometry parameter load/save, encoder telemetry, motion control via pose_order/pose_reached events, and calibration movement sequences.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>class FirmwareAdapter:\n    \"\"\"Unified adapter for firmware operations via SocketIO.\n\n    Handles odometry parameter load/save, encoder telemetry, motion control\n    via pose_order/pose_reached events, and calibration movement sequences.\n    \"\"\"\n\n    # Parameter name constants\n    PARAM_WHEELS_DISTANCE = \"encoder_wheels_distance_mm\"\n    PARAM_RIGHT_WHEEL_DIAMETER = \"right_wheel_diameter_mm\"\n    PARAM_LEFT_WHEEL_DIAMETER = \"left_wheel_diameter_mm\"\n    PARAM_LEFT_POLARITY = \"qdec_left_polarity\"\n    PARAM_RIGHT_POLARITY = \"qdec_right_polarity\"\n    PARAM_ENCODER_RESOLUTION = \"encoder_wheels_resolution_pulses\"\n\n    # Telemetry keys for encoder values\n    TELEMETRY_LEFT_ENCODER = \"encoder_left\"\n    TELEMETRY_RIGHT_ENCODER = \"encoder_right\"\n\n    def __init__(\n        self,\n        sio: socketio.AsyncClient,\n        param_manager: FirmwareParameterManager,\n        telemetry_manager: FirmwareTelemetryManager,\n        pose_reached_event: asyncio.Event,\n        console: ConsoleUI | None = None,\n    ):\n        \"\"\"\n        Initialize the firmware adapter.\n\n        Args:\n            sio: SocketIO client for communication\n            param_manager: Firmware parameter manager for read/write operations\n            telemetry_manager: Firmware telemetry manager for encoder tick counts\n            pose_reached_event: Event signaled when robot reaches target position\n            console: Optional ConsoleUI for progress display\n        \"\"\"\n        self.sio = sio\n        self._param_manager = param_manager\n        self._telemetry = telemetry_manager\n        self.pose_reached_event = pose_reached_event\n        self._console = console or ConsoleUI()\n\n    # === Parameters ===\n\n    async def load_parameters(self) -&gt; OdometryParameters:\n        \"\"\"\n        Load current odometry parameters from firmware.\n\n        Returns:\n            OdometryParameters populated with values from firmware\n\n        Raises:\n            TimeoutError: If firmware communication times out\n        \"\"\"\n        logger.info(\"Loading parameters from firmware...\")\n        (\n            wheels_distance,\n            right_diameter,\n            left_diameter,\n            left_polarity,\n            right_polarity,\n            encoder_ticks,\n        ) = await asyncio.gather(\n            self._param_manager.get_parameter_value(self.PARAM_WHEELS_DISTANCE),\n            self._param_manager.get_parameter_value(self.PARAM_RIGHT_WHEEL_DIAMETER),\n            self._param_manager.get_parameter_value(self.PARAM_LEFT_WHEEL_DIAMETER),\n            self._param_manager.get_parameter_value(self.PARAM_LEFT_POLARITY),\n            self._param_manager.get_parameter_value(self.PARAM_RIGHT_POLARITY),\n            self._param_manager.get_parameter_value(self.PARAM_ENCODER_RESOLUTION),\n        )\n\n        params = OdometryParameters(\n            wheels_distance=wheels_distance,\n            right_wheel_radius=right_diameter / 2.0,\n            left_wheel_radius=left_diameter / 2.0,\n            left_polarity=left_polarity,\n            right_polarity=right_polarity,\n            encoder_ticks=encoder_ticks,\n        )\n\n        logger.info(f\"Loaded parameters: {params}\")\n\n        return params\n\n    async def save_parameters(self, params: OdometryParameters) -&gt; None:\n        \"\"\"\n        Save odometry parameters to firmware.\n\n        Only saves the calibrated values (wheels_distance, wheel radii).\n        Polarity and encoder ticks are not modified.\n\n        Args:\n            params: OdometryParameters with values to save\n\n        Raises:\n            TimeoutError: If firmware communication times out\n        \"\"\"\n        logger.info(f\"Saving parameters to firmware: {params}\")\n\n        await asyncio.gather(\n            self._param_manager.set_parameter_value(self.PARAM_WHEELS_DISTANCE, params.wheels_distance),\n            self._param_manager.set_parameter_value(self.PARAM_RIGHT_WHEEL_DIAMETER, params.right_wheel_radius * 2.0),\n            self._param_manager.set_parameter_value(self.PARAM_LEFT_WHEEL_DIAMETER, params.left_wheel_radius * 2.0),\n        )\n\n        logger.info(\"Parameters saved successfully\")\n\n    # === Telemetry ===\n\n    async def get_encoder_ticks(self) -&gt; tuple[int, int]:\n        \"\"\"\n        Get current encoder tick counts from firmware telemetry.\n\n        Waits briefly for telemetry to stabilize before reading values.\n\n        Returns:\n            Tuple of (left_ticks, right_ticks)\n        \"\"\"\n        await asyncio.sleep(0.1)\n\n        left = self._telemetry.get_value(self.TELEMETRY_LEFT_ENCODER)\n        right = self._telemetry.get_value(self.TELEMETRY_RIGHT_ENCODER)\n\n        return int(left), int(right)\n\n    # === Motion Control ===\n\n    async def set_start_position(self, x: float, y: float, orientation: float) -&gt; None:\n        \"\"\"\n        Set the robot's starting reference position.\n\n        Args:\n            x: X coordinate in mm\n            y: Y coordinate in mm\n            orientation: Orientation in degrees\n        \"\"\"\n        pose = Pose(x=x, y=y, O=orientation)\n\n        logger.debug(f\"Setting start position: {pose}\")\n\n        await self.sio.emit(\"pose_start\", pose.model_dump(), namespace=\"/calibration\")\n\n    async def _send_pose_order(self, x: float, y: float, orientation: float) -&gt; None:\n        \"\"\"\n        Send a pose order to the robot.\n\n        Args:\n            x: Target X coordinate in mm\n            y: Target Y coordinate in mm\n            orientation: Target orientation in degrees\n        \"\"\"\n        pose = Pose(x=x, y=y, O=orientation)\n        self.pose_reached_event.clear()\n\n        logger.debug(f\"Sending pose order: {pose}\")\n\n        await self.sio.emit(\"pose_order\", pose.model_dump(), namespace=\"/calibration\")\n\n    async def _wait_pose_reached(self, timeout: float = 60.0) -&gt; bool:\n        \"\"\"\n        Wait for the robot to reach its target position.\n\n        Args:\n            timeout: Maximum time to wait in seconds\n\n        Returns:\n            True if pose was reached, False if timeout\n        \"\"\"\n        try:\n            await asyncio.wait_for(self.pose_reached_event.wait(), timeout=timeout)\n            return True\n        except TimeoutError:\n            logger.warning(f\"Timeout waiting for pose reached (&gt;{timeout}s)\")\n            return False\n\n    async def goto(self, x: float, y: float, orientation: float, timeout: float = 60.0) -&gt; bool:\n        \"\"\"\n        Move robot to target position and wait for completion.\n\n        Args:\n            x: Target X coordinate in mm\n            y: Target Y coordinate in mm\n            orientation: Target orientation in degrees\n            timeout: Maximum time to wait in seconds\n\n        Returns:\n            True if movement completed, False if timeout\n        \"\"\"\n        await self._send_pose_order(x, y, orientation)\n        return await self._wait_pose_reached(timeout)\n\n    # === Calibration Movement Sequences ===\n\n    async def execute_rotations(self, num_rotations: int) -&gt; bool:\n        \"\"\"\n        Execute N full rotations in place (Phase 1: WHEEL_DISTANCE).\n\n        Args:\n            num_rotations: Number of full 360-degree rotations\n\n        Returns:\n            True if successful, False otherwise.\n        \"\"\"\n        target_orientation = num_rotations * 360.0\n        logger.info(f\"Executing {num_rotations} rotations ({target_orientation}\u00b0)...\")\n\n        # Reset position to origin\n        await self.set_start_position(0, 0, 0)\n        await asyncio.sleep(0.2)\n\n        quarter_turns = [90, 180, -90, 0]\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[cyan]Rotation {task.fields[rotation]}/{task.fields[total_count]}[/]\"),\n            TimeElapsedColumn(),\n            console=self._console,\n        ) as progress:\n            task = progress.add_task(\"\", rotation=1, total_count=num_rotations)\n\n            for rotation_num in range(num_rotations):\n                progress.update(task, rotation=rotation_num + 1)\n                logger.debug(f\"Rotation {rotation_num + 1}/{num_rotations}\")\n                for target_angle in quarter_turns:\n                    success = await self.goto(0, 0, target_angle, timeout=30.0)\n                    if not success:\n                        self._console.show_error(\n                            f\"Rotation {rotation_num + 1}/{num_rotations} failed at {target_angle}\u00b0 (timeout)\"\n                        )\n                        return False\n\n            progress.update(task, rotation=num_rotations)\n\n        logger.info(\"Rotations completed\")\n        return True\n\n    async def execute_squares(self, num_squares: int) -&gt; bool:\n        \"\"\"\n        Execute N square paths clockwise (Phase 2: RIGHT_WHEEL_RADIUS).\n\n        Uses the predefined 500mm square path from __init__.py.\n\n        Args:\n            num_squares: Number of complete squares to execute\n\n        Returns:\n            True if successful, False otherwise.\n        \"\"\"\n        logger.info(f\"Executing {num_squares} squares...\")\n\n        # Reset position to origin\n        await self.set_start_position(0, 0, 0)\n        await asyncio.sleep(0.2)\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[cyan]Square {task.fields[square]}/{task.fields[total_count]}[/]\"),\n            TimeElapsedColumn(),\n            console=self._console,\n        ) as progress:\n            task = progress.add_task(\"\", square=1, total_count=num_squares)\n\n            for square_num in range(num_squares):\n                progress.update(task, square=square_num + 1)\n                for waypoint_idx, waypoint in enumerate(SQUARE_PATH_CCW):\n                    orientation_degrees = math.degrees(waypoint.O)\n                    logger.debug(\n                        f\"Square {square_num + 1}/{num_squares}, waypoint {waypoint_idx + 1}/4: \"\n                        f\"({waypoint.x}, {waypoint.y}, {orientation_degrees}\u00b0)\"\n                    )\n\n                    success = await self.goto(waypoint.x, waypoint.y, orientation_degrees, timeout=30.0)\n                    if not success:\n                        self._console.show_error(\n                            f\"Square path failed at waypoint {waypoint_idx + 1}/4 of square {square_num + 1}\"\n                        )\n                        return False\n\n            progress.update(task, square=num_squares)\n\n        logger.info(\"Squares completed\")\n        return True\n\n    async def execute_straight_line(self, distance_mm: int) -&gt; bool:\n        \"\"\"\n        Execute a straight line movement (Phase 3: LEFT_WHEEL_RADIUS).\n\n        Moves forward from origin by the specified distance.\n\n        Args:\n            distance_mm: Distance to travel in mm\n\n        Returns:\n            True if successful, False otherwise.\n        \"\"\"\n        logger.info(f\"Executing straight line movement ({distance_mm}mm)...\")\n\n        # Reset position to origin facing forward (0\u00b0)\n        await self.set_start_position(0, 0, 0)\n        await asyncio.sleep(0.2)\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[cyan]Straight line ({task.fields[distance]} mm)[/]\"),\n            TimeElapsedColumn(),\n            console=self._console,\n        ) as progress:\n            progress.add_task(\"\", distance=distance_mm)\n\n            success = await self.goto(distance_mm, 0, 0, timeout=30.0)\n            if not success:\n                self._console.show_error(\"Straight line movement failed (timeout)\")\n                return False\n\n        logger.info(\"Straight line completed\")\n        return True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.__init__","title":"<code>__init__(sio, param_manager, telemetry_manager, pose_reached_event, console=None)</code>","text":"<p>Initialize the firmware adapter.</p> <p>Parameters:</p> Name Type Description Default <code>sio</code> <code>AsyncClient</code> <p>SocketIO client for communication</p> required <code>param_manager</code> <code>FirmwareParameterManager</code> <p>Firmware parameter manager for read/write operations</p> required <code>telemetry_manager</code> <code>FirmwareTelemetryManager</code> <p>Firmware telemetry manager for encoder tick counts</p> required <code>pose_reached_event</code> <code>Event</code> <p>Event signaled when robot reaches target position</p> required <code>console</code> <code>ConsoleUI | None</code> <p>Optional ConsoleUI for progress display</p> <code>None</code> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>def __init__(\n    self,\n    sio: socketio.AsyncClient,\n    param_manager: FirmwareParameterManager,\n    telemetry_manager: FirmwareTelemetryManager,\n    pose_reached_event: asyncio.Event,\n    console: ConsoleUI | None = None,\n):\n    \"\"\"\n    Initialize the firmware adapter.\n\n    Args:\n        sio: SocketIO client for communication\n        param_manager: Firmware parameter manager for read/write operations\n        telemetry_manager: Firmware telemetry manager for encoder tick counts\n        pose_reached_event: Event signaled when robot reaches target position\n        console: Optional ConsoleUI for progress display\n    \"\"\"\n    self.sio = sio\n    self._param_manager = param_manager\n    self._telemetry = telemetry_manager\n    self.pose_reached_event = pose_reached_event\n    self._console = console or ConsoleUI()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.execute_rotations","title":"<code>execute_rotations(num_rotations)</code>  <code>async</code>","text":"<p>Execute N full rotations in place (Phase 1: WHEEL_DISTANCE).</p> <p>Parameters:</p> Name Type Description Default <code>num_rotations</code> <code>int</code> <p>Number of full 360-degree rotations</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def execute_rotations(self, num_rotations: int) -&gt; bool:\n    \"\"\"\n    Execute N full rotations in place (Phase 1: WHEEL_DISTANCE).\n\n    Args:\n        num_rotations: Number of full 360-degree rotations\n\n    Returns:\n        True if successful, False otherwise.\n    \"\"\"\n    target_orientation = num_rotations * 360.0\n    logger.info(f\"Executing {num_rotations} rotations ({target_orientation}\u00b0)...\")\n\n    # Reset position to origin\n    await self.set_start_position(0, 0, 0)\n    await asyncio.sleep(0.2)\n\n    quarter_turns = [90, 180, -90, 0]\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[cyan]Rotation {task.fields[rotation]}/{task.fields[total_count]}[/]\"),\n        TimeElapsedColumn(),\n        console=self._console,\n    ) as progress:\n        task = progress.add_task(\"\", rotation=1, total_count=num_rotations)\n\n        for rotation_num in range(num_rotations):\n            progress.update(task, rotation=rotation_num + 1)\n            logger.debug(f\"Rotation {rotation_num + 1}/{num_rotations}\")\n            for target_angle in quarter_turns:\n                success = await self.goto(0, 0, target_angle, timeout=30.0)\n                if not success:\n                    self._console.show_error(\n                        f\"Rotation {rotation_num + 1}/{num_rotations} failed at {target_angle}\u00b0 (timeout)\"\n                    )\n                    return False\n\n        progress.update(task, rotation=num_rotations)\n\n    logger.info(\"Rotations completed\")\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.execute_squares","title":"<code>execute_squares(num_squares)</code>  <code>async</code>","text":"<p>Execute N square paths clockwise (Phase 2: RIGHT_WHEEL_RADIUS).</p> <p>Uses the predefined 500mm square path from init.py.</p> <p>Parameters:</p> Name Type Description Default <code>num_squares</code> <code>int</code> <p>Number of complete squares to execute</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def execute_squares(self, num_squares: int) -&gt; bool:\n    \"\"\"\n    Execute N square paths clockwise (Phase 2: RIGHT_WHEEL_RADIUS).\n\n    Uses the predefined 500mm square path from __init__.py.\n\n    Args:\n        num_squares: Number of complete squares to execute\n\n    Returns:\n        True if successful, False otherwise.\n    \"\"\"\n    logger.info(f\"Executing {num_squares} squares...\")\n\n    # Reset position to origin\n    await self.set_start_position(0, 0, 0)\n    await asyncio.sleep(0.2)\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[cyan]Square {task.fields[square]}/{task.fields[total_count]}[/]\"),\n        TimeElapsedColumn(),\n        console=self._console,\n    ) as progress:\n        task = progress.add_task(\"\", square=1, total_count=num_squares)\n\n        for square_num in range(num_squares):\n            progress.update(task, square=square_num + 1)\n            for waypoint_idx, waypoint in enumerate(SQUARE_PATH_CCW):\n                orientation_degrees = math.degrees(waypoint.O)\n                logger.debug(\n                    f\"Square {square_num + 1}/{num_squares}, waypoint {waypoint_idx + 1}/4: \"\n                    f\"({waypoint.x}, {waypoint.y}, {orientation_degrees}\u00b0)\"\n                )\n\n                success = await self.goto(waypoint.x, waypoint.y, orientation_degrees, timeout=30.0)\n                if not success:\n                    self._console.show_error(\n                        f\"Square path failed at waypoint {waypoint_idx + 1}/4 of square {square_num + 1}\"\n                    )\n                    return False\n\n        progress.update(task, square=num_squares)\n\n    logger.info(\"Squares completed\")\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.execute_straight_line","title":"<code>execute_straight_line(distance_mm)</code>  <code>async</code>","text":"<p>Execute a straight line movement (Phase 3: LEFT_WHEEL_RADIUS).</p> <p>Moves forward from origin by the specified distance.</p> <p>Parameters:</p> Name Type Description Default <code>distance_mm</code> <code>int</code> <p>Distance to travel in mm</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def execute_straight_line(self, distance_mm: int) -&gt; bool:\n    \"\"\"\n    Execute a straight line movement (Phase 3: LEFT_WHEEL_RADIUS).\n\n    Moves forward from origin by the specified distance.\n\n    Args:\n        distance_mm: Distance to travel in mm\n\n    Returns:\n        True if successful, False otherwise.\n    \"\"\"\n    logger.info(f\"Executing straight line movement ({distance_mm}mm)...\")\n\n    # Reset position to origin facing forward (0\u00b0)\n    await self.set_start_position(0, 0, 0)\n    await asyncio.sleep(0.2)\n\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[cyan]Straight line ({task.fields[distance]} mm)[/]\"),\n        TimeElapsedColumn(),\n        console=self._console,\n    ) as progress:\n        progress.add_task(\"\", distance=distance_mm)\n\n        success = await self.goto(distance_mm, 0, 0, timeout=30.0)\n        if not success:\n            self._console.show_error(\"Straight line movement failed (timeout)\")\n            return False\n\n    logger.info(\"Straight line completed\")\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.get_encoder_ticks","title":"<code>get_encoder_ticks()</code>  <code>async</code>","text":"<p>Get current encoder tick counts from firmware telemetry.</p> <p>Waits briefly for telemetry to stabilize before reading values.</p> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>Tuple of (left_ticks, right_ticks)</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def get_encoder_ticks(self) -&gt; tuple[int, int]:\n    \"\"\"\n    Get current encoder tick counts from firmware telemetry.\n\n    Waits briefly for telemetry to stabilize before reading values.\n\n    Returns:\n        Tuple of (left_ticks, right_ticks)\n    \"\"\"\n    await asyncio.sleep(0.1)\n\n    left = self._telemetry.get_value(self.TELEMETRY_LEFT_ENCODER)\n    right = self._telemetry.get_value(self.TELEMETRY_RIGHT_ENCODER)\n\n    return int(left), int(right)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.goto","title":"<code>goto(x, y, orientation, timeout=60.0)</code>  <code>async</code>","text":"<p>Move robot to target position and wait for completion.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Target X coordinate in mm</p> required <code>y</code> <code>float</code> <p>Target Y coordinate in mm</p> required <code>orientation</code> <code>float</code> <p>Target orientation in degrees</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds</p> <code>60.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if movement completed, False if timeout</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def goto(self, x: float, y: float, orientation: float, timeout: float = 60.0) -&gt; bool:\n    \"\"\"\n    Move robot to target position and wait for completion.\n\n    Args:\n        x: Target X coordinate in mm\n        y: Target Y coordinate in mm\n        orientation: Target orientation in degrees\n        timeout: Maximum time to wait in seconds\n\n    Returns:\n        True if movement completed, False if timeout\n    \"\"\"\n    await self._send_pose_order(x, y, orientation)\n    return await self._wait_pose_reached(timeout)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.load_parameters","title":"<code>load_parameters()</code>  <code>async</code>","text":"<p>Load current odometry parameters from firmware.</p> <p>Returns:</p> Type Description <code>OdometryParameters</code> <p>OdometryParameters populated with values from firmware</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If firmware communication times out</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def load_parameters(self) -&gt; OdometryParameters:\n    \"\"\"\n    Load current odometry parameters from firmware.\n\n    Returns:\n        OdometryParameters populated with values from firmware\n\n    Raises:\n        TimeoutError: If firmware communication times out\n    \"\"\"\n    logger.info(\"Loading parameters from firmware...\")\n    (\n        wheels_distance,\n        right_diameter,\n        left_diameter,\n        left_polarity,\n        right_polarity,\n        encoder_ticks,\n    ) = await asyncio.gather(\n        self._param_manager.get_parameter_value(self.PARAM_WHEELS_DISTANCE),\n        self._param_manager.get_parameter_value(self.PARAM_RIGHT_WHEEL_DIAMETER),\n        self._param_manager.get_parameter_value(self.PARAM_LEFT_WHEEL_DIAMETER),\n        self._param_manager.get_parameter_value(self.PARAM_LEFT_POLARITY),\n        self._param_manager.get_parameter_value(self.PARAM_RIGHT_POLARITY),\n        self._param_manager.get_parameter_value(self.PARAM_ENCODER_RESOLUTION),\n    )\n\n    params = OdometryParameters(\n        wheels_distance=wheels_distance,\n        right_wheel_radius=right_diameter / 2.0,\n        left_wheel_radius=left_diameter / 2.0,\n        left_polarity=left_polarity,\n        right_polarity=right_polarity,\n        encoder_ticks=encoder_ticks,\n    )\n\n    logger.info(f\"Loaded parameters: {params}\")\n\n    return params\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.save_parameters","title":"<code>save_parameters(params)</code>  <code>async</code>","text":"<p>Save odometry parameters to firmware.</p> <p>Only saves the calibrated values (wheels_distance, wheel radii). Polarity and encoder ticks are not modified.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>OdometryParameters</code> <p>OdometryParameters with values to save</p> required <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If firmware communication times out</p> Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def save_parameters(self, params: OdometryParameters) -&gt; None:\n    \"\"\"\n    Save odometry parameters to firmware.\n\n    Only saves the calibrated values (wheels_distance, wheel radii).\n    Polarity and encoder ticks are not modified.\n\n    Args:\n        params: OdometryParameters with values to save\n\n    Raises:\n        TimeoutError: If firmware communication times out\n    \"\"\"\n    logger.info(f\"Saving parameters to firmware: {params}\")\n\n    await asyncio.gather(\n        self._param_manager.set_parameter_value(self.PARAM_WHEELS_DISTANCE, params.wheels_distance),\n        self._param_manager.set_parameter_value(self.PARAM_RIGHT_WHEEL_DIAMETER, params.right_wheel_radius * 2.0),\n        self._param_manager.set_parameter_value(self.PARAM_LEFT_WHEEL_DIAMETER, params.left_wheel_radius * 2.0),\n    )\n\n    logger.info(\"Parameters saved successfully\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/firmware_adapter/#cogip.tools.firmware_odometry_calibration.firmware_adapter.FirmwareAdapter.set_start_position","title":"<code>set_start_position(x, y, orientation)</code>  <code>async</code>","text":"<p>Set the robot's starting reference position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate in mm</p> required <code>y</code> <code>float</code> <p>Y coordinate in mm</p> required <code>orientation</code> <code>float</code> <p>Orientation in degrees</p> required Source code in <code>cogip/tools/firmware_odometry_calibration/firmware_adapter.py</code> <pre><code>async def set_start_position(self, x: float, y: float, orientation: float) -&gt; None:\n    \"\"\"\n    Set the robot's starting reference position.\n\n    Args:\n        x: X coordinate in mm\n        y: Y coordinate in mm\n        orientation: Orientation in degrees\n    \"\"\"\n    pose = Pose(x=x, y=y, O=orientation)\n\n    logger.debug(f\"Setting start position: {pose}\")\n\n    await self.sio.emit(\"pose_start\", pose.model_dump(), namespace=\"/calibration\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/odometry_calibration/","title":"odometry_calibration","text":"<p>Odometry Calibration Tool for differential drive robots.</p> <p>Calibrates three parameters: wheel distance, left/right wheel radius.</p> Phases <ol> <li>Wheel Distance - Turn in place N rotations</li> <li>Right Wheel Radius - Execute square trajectories to find radius ratio</li> <li>Left Wheel Radius - Travel straight line to compute absolute radius</li> </ol> Usage <ul> <li>Start with approximate parameter values in firmware</li> <li>Execute phases in order (each depends on previous results)</li> <li>Manually reposition robot to theoretical position after each motion</li> </ul>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/odometry_calibration/#cogip.tools.firmware_odometry_calibration.odometry_calibration.OdometryCalibration","title":"<code>OdometryCalibration</code>","text":"<p>Odometry Calibration controller.</p> <p>Orchestrates the calibration process by coordinating: - SocketIO connection to cogip-server - FirmwareAdapter for all firmware operations - User interaction via ConsoleUI</p> Source code in <code>cogip/tools/firmware_odometry_calibration/odometry_calibration.py</code> <pre><code>class OdometryCalibration:\n    \"\"\"\n    Odometry Calibration controller.\n\n    Orchestrates the calibration process by coordinating:\n    - SocketIO connection to cogip-server\n    - FirmwareAdapter for all firmware operations\n    - User interaction via ConsoleUI\n    \"\"\"\n\n    def __init__(self, server_url: str, parameters_group: FirmwareParametersGroup):\n        \"\"\"\n        Initialize the calibration controller.\n\n        Args:\n            server_url: URL of the cogip-server\n            parameters_group: Firmware parameters configuration\n        \"\"\"\n        self.server_url = server_url\n        self.console = ConsoleUI()\n\n        # Event to signal pose reached\n        self.pose_reached_event = asyncio.Event()\n\n        # SocketIO client and namespaces\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_ns = SioEvents(self)\n        self.sio.register_namespace(self.sio_ns)\n\n        # Managers (they register their own namespaces)\n        self.param_manager = FirmwareParameterManager(self.sio, parameters_group)\n        self.telemetry_manager = FirmwareTelemetryManager(self.sio)\n\n        # Firmware adapter for motion control\n        self.firmware = FirmwareAdapter(\n            self.sio, self.param_manager, self.telemetry_manager, self.pose_reached_event, self.console\n        )\n\n        # Calibration state\n        self.params: OdometryParameters | None = None\n        self.initial_params: OdometryParameters | None = None\n        self.state = CalibrationState()\n\n    async def _connect(self) -&gt; None:\n        \"\"\"Connect to cogip-server.\"\"\"\n        self.console.show_info(f\"Connecting to {self.server_url}...\")\n        await self.sio.connect(\n            self.server_url,\n            namespaces=[\n                self.sio_ns.namespace,\n                self.param_manager.namespace,\n                self.telemetry_manager.namespace,\n            ],\n        )\n\n        # Wait for all namespaces to be connected\n        self.console.show_info(\"Waiting for connections...\")\n        while not (self.sio_ns.connected and self.param_manager.is_connected and self.telemetry_manager.is_connected):\n            await asyncio.sleep(0.1)\n\n        self.console.show_success(\"Connected to cogip-server\")\n\n        # Enable telemetry\n        await self.telemetry_manager.enable()\n        await asyncio.sleep(0.2)\n\n    async def _disconnect(self) -&gt; None:\n        \"\"\"Disconnect from server.\"\"\"\n        if self.sio and self.sio.connected:\n            await self.sio.disconnect()\n\n    def _display_intro(self) -&gt; None:\n        \"\"\"Display introduction panel.\"\"\"\n        self.console.show_panel(\n            \"This tool calibrates the robot's odometry parameters through 3 phases:\\n\"\n            \"1. [header]Wheel Distance[/] - Robot will rotates in place\\n\"\n            \"2. [header]Right Wheel Radius[/] - Robot will performs square paths\\n\"\n            \"3. [header]Left Wheel Radius[/] - Robot will travels along a straight line\",\n            title=\"Odometry Calibration Tool\",\n        )\n\n    def _display_parameters(self, params: OdometryParameters, title: str) -&gt; None:\n        \"\"\"Display parameters in a table.\"\"\"\n        self.console.show_key_value_table(\n            [\n                (\"Wheels Distance\", f\"{params.wheels_distance:.3f} mm\"),\n                (\"Left Wheel Radius\", f\"{params.left_wheel_radius:.3f} mm\"),\n                (\"Right Wheel Radius\", f\"{params.right_wheel_radius:.3f} mm\"),\n                (\"Left Polarity\", f\"{params.left_polarity:.0f}\"),\n                (\"Right Polarity\", f\"{params.right_polarity:.0f}\"),\n                (\"Encoder Ticks\", f\"{params.encoder_ticks:.0f} ticks/rev\"),\n            ],\n            title=title,\n        )\n\n    def _display_result(self, result: CalibrationResult, current: OdometryParameters) -&gt; None:\n        \"\"\"Display calibration result comparison.\"\"\"\n        change_wd = result.wheels_distance - current.wheels_distance\n        change_lr = result.left_wheel_radius - current.left_wheel_radius\n        change_rr = result.right_wheel_radius - current.right_wheel_radius\n\n        table = self.console.create_table(\n            title=\"Calibration Result\",\n            columns=[\n                (\"Parameter\", {\"style\": \"label\"}),\n                (\"Before\", {\"style\": \"muted\", \"justify\": \"right\"}),\n                (\"After\", {\"style\": \"value\", \"justify\": \"right\"}),\n                (\"Change\", {\"style\": \"warning\", \"justify\": \"right\"}),\n            ],\n        )\n        table.add_row(\n            \"Wheels Distance (mm)\",\n            f\"{current.wheels_distance:.3f}\",\n            f\"{result.wheels_distance:.3f}\",\n            f\"{change_wd:+.3f}\",\n        )\n        table.add_row(\n            \"Left Wheel Radius (mm)\",\n            f\"{current.left_wheel_radius:.3f}\",\n            f\"{result.left_wheel_radius:.3f}\",\n            f\"{change_lr:+.3f}\",\n        )\n        table.add_row(\n            \"Right Wheel Radius (mm)\",\n            f\"{current.right_wheel_radius:.3f}\",\n            f\"{result.right_wheel_radius:.3f}\",\n            f\"{change_rr:+.3f}\",\n        )\n        self.console.print(table)\n\n    async def _apply_result(self, result: CalibrationResult) -&gt; None:\n        \"\"\"Apply calibration result to current parameters and save to firmware.\"\"\"\n        self.params.wheels_distance = result.wheels_distance\n        self.params.right_wheel_radius = result.right_wheel_radius\n        self.params.left_wheel_radius = result.left_wheel_radius\n\n        self.console.show_info(\"Saving parameters to firmware...\")\n        await self.firmware.save_parameters(self.params)\n        self.console.show_success(\"Parameters saved to firmware\")\n\n    async def _execute_motion_sequence(\n        self,\n        motion_fn: Callable[[int], Awaitable[bool]],\n        motion_arg: int,\n    ) -&gt; EncoderDeltas | None:\n        \"\"\"\n        Execute motion and collect encoder tick deltas.\n\n        Args:\n            motion_fn: Async function to execute the motion (e.g., execute_rotations).\n            motion_arg: Argument to pass to the motion function (e.g., number of rotations).\n\n        Returns:\n            EncoderDeltas or None if motion failed.\n        \"\"\"\n        await self.console.wait_for_enter(\"Position the robot at the starting position\")\n        left_before, right_before = await self.firmware.get_encoder_ticks()\n        logger.info(f\"Encoder ticks before: L={left_before}, R={right_before}\")\n\n        if not await motion_fn(motion_arg):\n            return None\n\n        await self.console.wait_for_enter(\"Reposition the robot to its theoretical position\")\n        left_after, right_after = await self.firmware.get_encoder_ticks()\n        logger.info(f\"Encoder ticks after: L={left_after}, R={right_after}\")\n\n        deltas = EncoderDeltas(left=left_after - left_before, right=right_after - right_before)\n        logger.info(f\"Encoder deltas: L={deltas.left}, R={deltas.right}\")\n\n        return deltas\n\n    async def _handle_phase_result(\n        self,\n        result_tuple: tuple[CalibrationResult, CalibrationState] | None,\n        phase: CalibrationPhaseType,\n    ) -&gt; bool:\n        \"\"\"\n        Handle calibration result: display, confirm, and apply.\n\n        Args:\n            result_tuple: The computation result or None if computation failed.\n            phase: The calibration phase type for error messages.\n\n        Returns:\n            True if result was accepted and applied, False otherwise.\n        \"\"\"\n        if result_tuple is None:\n            self.console.show_error(phase.error_message)\n            return False\n\n        result, new_state = result_tuple\n        self._display_result(result, self.params)\n\n        accepted = await self.console.confirm(\"Accept this result?\")\n        self.console.show_info(f\"Accepted: {accepted}\")\n\n        if accepted:\n            await self._apply_result(result)\n            self.state = new_state\n            return True\n\n        return False\n\n    async def _run_phase_1(self) -&gt; bool:\n        \"\"\"Phase 1: Wheel Distance Calibration (Turn in Place).\"\"\"\n        phase = CalibrationPhaseType.WHEEL_DISTANCE\n\n        self.console.show_rule(phase.title)\n        self.console.show_info(phase.description)\n\n        num_rotations = await self.console.get_integer(phase.input_prompt, default=phase.default_value)\n\n        deltas = await self._execute_motion_sequence(self.firmware.execute_rotations, num_rotations)\n        if deltas is None:\n            return False\n\n        result_tuple = compute_wheel_distance_result(\n            turns=num_rotations,\n            lticks_delta=deltas.left,\n            rticks_delta=deltas.right,\n            encoder_ticks=self.params.encoder_ticks,\n            left_wheel_radius=self.params.left_wheel_radius,\n            right_wheel_radius=self.params.right_wheel_radius,\n            left_polarity=self.params.left_polarity,\n            right_polarity=self.params.right_polarity,\n        )\n\n        return await self._handle_phase_result(result_tuple, phase)\n\n    async def _run_phase_2(self) -&gt; bool:\n        \"\"\"Phase 2: Right Wheel Radius Calibration (Square Trajectories).\"\"\"\n        phase = CalibrationPhaseType.RIGHT_WHEEL_RADIUS\n\n        self.console.show_rule(phase.title)\n        self.console.show_info(phase.description)\n\n        num_squares = await self.console.get_integer(phase.input_prompt, default=phase.default_value)\n\n        deltas = await self._execute_motion_sequence(self.firmware.execute_squares, num_squares)\n        if deltas is None:\n            return False\n\n        result_tuple = compute_right_wheel_radius_result(\n            squares=num_squares,\n            lticks_delta=deltas.left,\n            rticks_delta=deltas.right,\n            state=self.state,\n            encoder_ticks=self.params.encoder_ticks,\n            left_wheel_radius=self.params.left_wheel_radius,\n            left_polarity=self.params.left_polarity,\n            right_polarity=self.params.right_polarity,\n        )\n\n        return await self._handle_phase_result(result_tuple, phase)\n\n    async def _run_phase_3(self) -&gt; bool:\n        \"\"\"Phase 3: Left Wheel Radius Calibration (Straight Line).\"\"\"\n        phase = CalibrationPhaseType.LEFT_WHEEL_RADIUS\n\n        self.console.show_rule(phase.title)\n        self.console.show_info(phase.description)\n\n        distance_mm = await self.console.get_integer(phase.input_prompt, default=phase.default_value)\n\n        deltas = await self._execute_motion_sequence(self.firmware.execute_straight_line, distance_mm)\n        if deltas is None:\n            return False\n\n        result_tuple = compute_left_wheel_radius_result(\n            distance_mm=distance_mm,\n            lticks_delta=deltas.left,\n            rticks_delta=deltas.right,\n            state=self.state,\n            encoder_ticks=self.params.encoder_ticks,\n            left_polarity=self.params.left_polarity,\n            right_polarity=self.params.right_polarity,\n        )\n\n        return await self._handle_phase_result(result_tuple, phase)\n\n    async def _run_calibration(self) -&gt; None:\n        \"\"\"Run the calibration phases.\"\"\"\n        self._display_intro()\n\n        # Load parameters from firmware\n        self.console.show_info(\"Loading odometry parameters from firmware...\")\n        self.params = await self.firmware.load_parameters()\n        self.initial_params = self.params.model_copy()\n        self.console.show_success(\"Parameters loaded successfully\")\n        self._display_parameters(self.params, \"Initial Parameters\")\n\n        # Phase 1: Wheel distance\n        while not await self._run_phase_1():\n            self.console.show_warning(\"Retrying Phase 1...\")\n\n        # Phase 2: Right wheel radius\n        while not await self._run_phase_2():\n            self.console.show_warning(\"Retrying Phase 2...\")\n\n        # Phase 3: Left wheel radius\n        while not await self._run_phase_3():\n            self.console.show_warning(\"Retrying Phase 3...\")\n\n        # Final summary\n        self.console.print()\n        self._display_parameters(self.params, \"Final Calibrated Parameters\")\n\n        # Save or restore\n        save_params = await self.console.confirm(\"Save calibrated parameters to firmware?\")\n        self.console.show_info(f\"Save: {save_params}\")\n        if save_params:\n            self.console.show_info(\"Saving parameters to firmware...\")\n            await self.firmware.save_parameters(self.params)\n            self.console.show_success(\"Parameters saved successfully!\")\n        else:\n            self.console.show_warning(\"Restoring initial parameters...\")\n            await self.firmware.save_parameters(self.initial_params)\n            self.console.show_warning(\"Initial parameters restored.\")\n\n    async def run(self) -&gt; None:\n        \"\"\"Main entry point: connect, run calibration, disconnect.\"\"\"\n        try:\n            await self._connect()\n            await self._run_calibration()\n        except KeyboardInterrupt:\n            self.console.show_warning(\"\\nCalibration interrupted by user\")\n            if self.initial_params and self.firmware:\n                self.console.show_warning(\"Restoring initial parameters...\")\n                await self.firmware.save_parameters(self.initial_params)\n            sys.exit(0)\n        except Exception as e:\n            self.console.show_error(str(e))\n            logger.error(\"Unexpected error during calibration\")\n            if self.initial_params and self.firmware:\n                try:\n                    await self.firmware.save_parameters(self.initial_params)\n                except Exception:\n                    pass\n            sys.exit(1)\n        finally:\n            await self._disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/odometry_calibration/#cogip.tools.firmware_odometry_calibration.odometry_calibration.OdometryCalibration.__init__","title":"<code>__init__(server_url, parameters_group)</code>","text":"<p>Initialize the calibration controller.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>URL of the cogip-server</p> required <code>parameters_group</code> <code>FirmwareParametersGroup</code> <p>Firmware parameters configuration</p> required Source code in <code>cogip/tools/firmware_odometry_calibration/odometry_calibration.py</code> <pre><code>def __init__(self, server_url: str, parameters_group: FirmwareParametersGroup):\n    \"\"\"\n    Initialize the calibration controller.\n\n    Args:\n        server_url: URL of the cogip-server\n        parameters_group: Firmware parameters configuration\n    \"\"\"\n    self.server_url = server_url\n    self.console = ConsoleUI()\n\n    # Event to signal pose reached\n    self.pose_reached_event = asyncio.Event()\n\n    # SocketIO client and namespaces\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_ns = SioEvents(self)\n    self.sio.register_namespace(self.sio_ns)\n\n    # Managers (they register their own namespaces)\n    self.param_manager = FirmwareParameterManager(self.sio, parameters_group)\n    self.telemetry_manager = FirmwareTelemetryManager(self.sio)\n\n    # Firmware adapter for motion control\n    self.firmware = FirmwareAdapter(\n        self.sio, self.param_manager, self.telemetry_manager, self.pose_reached_event, self.console\n    )\n\n    # Calibration state\n    self.params: OdometryParameters | None = None\n    self.initial_params: OdometryParameters | None = None\n    self.state = CalibrationState()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/odometry_calibration/#cogip.tools.firmware_odometry_calibration.odometry_calibration.OdometryCalibration.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Main entry point: connect, run calibration, disconnect.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/odometry_calibration.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"Main entry point: connect, run calibration, disconnect.\"\"\"\n    try:\n        await self._connect()\n        await self._run_calibration()\n    except KeyboardInterrupt:\n        self.console.show_warning(\"\\nCalibration interrupted by user\")\n        if self.initial_params and self.firmware:\n            self.console.show_warning(\"Restoring initial parameters...\")\n            await self.firmware.save_parameters(self.initial_params)\n        sys.exit(0)\n    except Exception as e:\n        self.console.show_error(str(e))\n        logger.error(\"Unexpected error during calibration\")\n        if self.initial_params and self.firmware:\n            try:\n                await self.firmware.save_parameters(self.initial_params)\n            except Exception:\n                pass\n        sys.exit(1)\n    finally:\n        await self._disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/firmware_odometry_calibration/sio_events/#cogip.tools.firmware_odometry_calibration.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by the odometry calibration tool.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by the odometry calibration tool.\n    \"\"\"\n\n    def __init__(self, calibration: \"OdometryCalibration\"):\n        super().__init__(\"/calibration\")\n        self.calibration = calibration\n        self.connected = False\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=0.2,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server on /calibration\")\n        await self.emit(\"connected\")\n        self.connected = True\n\n    async def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.connected = False\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle pose_reached event from copilot (via server).\n        Signal that the robot has reached its target position.\n        \"\"\"\n        logger.debug(\"Pose reached\")\n        self.calibration.pose_reached_event.set()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/sio_events/#cogip.tools.firmware_odometry_calibration.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=0.2,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server on /calibration\")\n    await self.emit(\"connected\")\n    self.connected = True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/sio_events/#cogip.tools.firmware_odometry_calibration.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/sio_events/#cogip.tools.firmware_odometry_calibration.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/sio_events.py</code> <pre><code>async def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.connected = False\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/sio_events/#cogip.tools.firmware_odometry_calibration.sio_events.SioEvents.on_pose_reached","title":"<code>on_pose_reached()</code>  <code>async</code>","text":"<p>Handle pose_reached event from copilot (via server). Signal that the robot has reached its target position.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/sio_events.py</code> <pre><code>async def on_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle pose_reached event from copilot (via server).\n    Signal that the robot has reached its target position.\n    \"\"\"\n    logger.debug(\"Pose reached\")\n    self.calibration.pose_reached_event.set()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/","title":"types","text":"<p>Odometry Calibration Types</p> <p>Enums and constants for the calibration tool.</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/#cogip.tools.firmware_odometry_calibration.types.CalibrationPhaseType","title":"<code>CalibrationPhaseType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Calibration phase types.</p> Source code in <code>cogip/tools/firmware_odometry_calibration/types.py</code> <pre><code>class CalibrationPhaseType(IntEnum):\n    \"\"\"Calibration phase types.\"\"\"\n\n    WHEEL_DISTANCE = auto()\n    RIGHT_WHEEL_RADIUS = auto()\n    LEFT_WHEEL_RADIUS = auto()\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Phase title for display.\"\"\"\n        titles = {\n            CalibrationPhaseType.WHEEL_DISTANCE: \"WHEEL DISTANCE CALIBRATION\",\n            CalibrationPhaseType.RIGHT_WHEEL_RADIUS: \"RIGHT WHEEL RADIUS CALIBRATION\",\n            CalibrationPhaseType.LEFT_WHEEL_RADIUS: \"LEFT WHEEL RADIUS CALIBRATION\",\n        }\n        return titles[self]\n\n    @property\n    def description(self) -&gt; str:\n        \"\"\"Phase description for display.\"\"\"\n        descriptions = {\n            CalibrationPhaseType.WHEEL_DISTANCE: \"The robot will rotate in place to calibrate the wheel distance\",\n            CalibrationPhaseType.RIGHT_WHEEL_RADIUS: (\n                \"The robot will perform square trajectories to calibrate the right wheel radius\"\n            ),\n            CalibrationPhaseType.LEFT_WHEEL_RADIUS: (\n                \"The robot will travel a straight line to calibrate the left wheel radius\"\n            ),\n        }\n        return descriptions[self]\n\n    @property\n    def input_prompt(self) -&gt; str:\n        \"\"\"Input prompt for this phase.\"\"\"\n        prompts = {\n            CalibrationPhaseType.WHEEL_DISTANCE: \"How many full rotations?\",\n            CalibrationPhaseType.RIGHT_WHEEL_RADIUS: \"How many squares?\",\n            CalibrationPhaseType.LEFT_WHEEL_RADIUS: \"What distance in mm?\",\n        }\n        return prompts[self]\n\n    @property\n    def default_value(self) -&gt; int:\n        \"\"\"Default value for this phase input.\"\"\"\n        defaults = {\n            CalibrationPhaseType.WHEEL_DISTANCE: 10,\n            CalibrationPhaseType.RIGHT_WHEEL_RADIUS: 5,\n            CalibrationPhaseType.LEFT_WHEEL_RADIUS: 2000,\n        }\n        return defaults[self]\n\n    @property\n    def error_message(self) -&gt; str | None:\n        \"\"\"Error message specific to this phase computation.\"\"\"\n        errors = {\n            CalibrationPhaseType.WHEEL_DISTANCE: None,\n            CalibrationPhaseType.RIGHT_WHEEL_RADIUS: (\n                \"Right encoder linear component too small. Check encoder connection.\"\n            ),\n            CalibrationPhaseType.LEFT_WHEEL_RADIUS: \"Denominator too small. Check encoder counts.\",\n        }\n        return errors[self]\n</code></pre>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/#cogip.tools.firmware_odometry_calibration.types.CalibrationPhaseType.default_value","title":"<code>default_value</code>  <code>property</code>","text":"<p>Default value for this phase input.</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/#cogip.tools.firmware_odometry_calibration.types.CalibrationPhaseType.description","title":"<code>description</code>  <code>property</code>","text":"<p>Phase description for display.</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/#cogip.tools.firmware_odometry_calibration.types.CalibrationPhaseType.error_message","title":"<code>error_message</code>  <code>property</code>","text":"<p>Error message specific to this phase computation.</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/#cogip.tools.firmware_odometry_calibration.types.CalibrationPhaseType.input_prompt","title":"<code>input_prompt</code>  <code>property</code>","text":"<p>Input prompt for this phase.</p>"},{"location":"reference/cogip/tools/firmware_odometry_calibration/types/#cogip.tools.firmware_odometry_calibration.types.CalibrationPhaseType.title","title":"<code>title</code>  <code>property</code>","text":"<p>Phase title for display.</p>"},{"location":"reference/cogip/tools/firmware_parameter_manager/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/firmware_parameter_manager/__main__/#cogip.tools.firmware_parameter_manager.__main__.main","title":"<code>main()</code>","text":"<p>Run firmware parameter manager utility.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-firmware-parameter-manager</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/firmware_parameter_manager/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Run firmware parameter manager utility.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-firmware-parameter-manager` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/__main__/#cogip.tools.firmware_parameter_manager.__main__.main_async","title":"<code>main_async(server_url, parameters_group)</code>  <code>async</code>","text":"<p>CLI utility to test firmware parameter communication. Creates its own Socket.IO client to host the FirmwareParameterManager.</p> Source code in <code>cogip/tools/firmware_parameter_manager/__main__.py</code> <pre><code>async def main_async(server_url: str, parameters_group: FirmwareParametersGroup):\n    \"\"\"\n    CLI utility to test firmware parameter communication.\n    Creates its own Socket.IO client to host the FirmwareParameterManager.\n    \"\"\"\n    sio = socketio.AsyncClient(logger=False)\n    manager = FirmwareParameterManager(sio=sio, parameter_group=parameters_group)\n\n    await sio.connect(server_url, namespaces=[manager.namespace])\n\n    print(\"Firmware parameter values before reading from firmware:\")\n    for param in manager.parameter_group:\n        print(f\"  {param.name:.&lt;40} {param.value}\")\n    print()\n\n    for param in manager.parameter_group:\n        try:\n            await manager.get_parameter_value(param.name)\n        except TimeoutError:\n            print(f\"  {param.name:.&lt;40} TIMEOUT\")\n\n    print(\"Firmware parameter values after reading from firmware:\")\n    for param in manager.parameter_group:\n        print(f\"  {param.name:.&lt;40} {param.value}\")\n    print()\n\n    manager.cleanup()\n    await sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/","title":"firmware_parameter_manager","text":""},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager","title":"<code>FirmwareParameterManager</code>","text":"<p>Manager to handle firmware parameter requests/responses via SocketIO through copilot. Uses asyncio.Future to correlate requests with their responses.</p> <p>This class is designed to be embedded into another Socket.IO client (e.g., Planner, Monitor, or any tool that needs firmware parameter access). It registers its own namespace (/parameters) on the provided client, allowing the host tool to manage the connection lifecycle while benefiting from firmware parameter functionality.</p> <p>Note on concurrent usage: The correlation mechanism uses parameter hashes (FNV-1a) to match responses to requests. This makes the system naturally resilient to multiple clients making concurrent requests - each client maintains its own pending requests dictionary and only resolves its own Futures. However, this usage pattern is not recommended as it may lead to unpredictable firmware behavior and debugging complexity. Prefer having a single client handle firmware parameters at a time.</p> Source code in <code>cogip/tools/firmware_parameter_manager/firmware_parameter_manager.py</code> <pre><code>class FirmwareParameterManager:\n    \"\"\"\n    Manager to handle firmware parameter requests/responses via SocketIO through copilot.\n    Uses asyncio.Future to correlate requests with their responses.\n\n    This class is designed to be embedded into another Socket.IO client (e.g., Planner,\n    Monitor, or any tool that needs firmware parameter access). It registers its own\n    namespace (/parameters) on the provided client, allowing the host tool to manage\n    the connection lifecycle while benefiting from firmware parameter functionality.\n\n    Note on concurrent usage: The correlation mechanism uses parameter hashes (FNV-1a)\n    to match responses to requests. This makes the system naturally resilient to multiple\n    clients making concurrent requests - each client maintains its own pending requests\n    dictionary and only resolves its own Futures. However, this usage pattern is not\n    recommended as it may lead to unpredictable firmware behavior and debugging complexity.\n    Prefer having a single client handle firmware parameters at a time.\n    \"\"\"\n\n    def __init__(\n        self,\n        sio: socketio.AsyncClient,\n        parameter_group: FirmwareParametersGroup,\n    ):\n        \"\"\"\n        Initialize the FirmwareParameterManager.\n\n        Args:\n            sio: External Socket.IO client on which to register the /parameters namespace.\n                 The host client is responsible for connection management.\n            parameter_group: The firmware parameters to manage\n        \"\"\"\n        self.sio = sio\n        self.parameter_group = parameter_group\n\n        self.sio_events = SioEvents(self)\n        self.sio.register_namespace(self.sio_events)\n\n        # Dictionary to store Futures waiting for responses\n        # Key: firmware parameter hash (int), Value: asyncio.Future\n        self.pending_get_requests: dict[int, asyncio.Future] = {}\n        self.pending_set_requests: dict[int, asyncio.Future] = {}\n\n    @property\n    def namespace(self) -&gt; str:\n        \"\"\"Return the namespace path to include when connecting the host client.\"\"\"\n        return self.sio_events.namespace\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if the namespace is connected and ready.\"\"\"\n        return self.sio_events.connected\n\n    async def get_parameter_value(\n        self,\n        parameter_name: str,\n        timeout: float = 1,\n    ) -&gt; float | int | bool:\n        \"\"\"\n        Sends a get_firmware_parameter request and waits for the response.\n\n        Args:\n            parameter_name: Name of the firmware parameter to retrieve\n            timeout: Timeout in seconds (default: 1)\n\n        Returns:\n            The firmware parameter value (float, int, or bool) after pydantic validation\n\n        Raises:\n            KeyError: If the firmware parameter name is not found in the firmware parameter group\n            TimeoutError: If no response is received within the timeout\n        \"\"\"\n        # Validate that firmware parameter exists in the group\n        parameter = self.parameter_group.get(parameter_name)\n\n        # Create a Future for this request\n        future = asyncio.Future()\n\n        # Store pending request for response correalation\n        parameter_hash = hash(parameter)\n        self.pending_get_requests[parameter_hash] = future\n\n        try:\n            logger.info(f\"[firmware_parameter =&gt; server] get: {parameter}\")\n            await self.sio.emit(\"get_parameter_value\", parameter.model_dump(by_alias=True), namespace=\"/parameters\")\n\n            logger.info(f\"Sent get_parameter request for hash: 0x{parameter_hash:08x}\")\n\n            # Wait for the response with timeout\n            response = await asyncio.wait_for(future, timeout=timeout)\n\n            # Update parameter with response data (pydantic validation happens here)\n            parameter.pb_read(response)\n\n            # Return the validated value\n            return parameter.value\n\n        except TimeoutError:\n            # Clean up on timeout\n            if not future.done():\n                future.cancel()\n\n            self.pending_get_requests.pop(parameter_hash, None)\n            logger.error(f\"Timeout waiting for get_firmware_parameter response (hash: 0x{parameter_hash:08x})\")\n            raise TimeoutError(f\"No response received for firmware parameter hash 0x{parameter_hash:08x}\")\n\n        except Exception as exc:\n            # Clean up on error\n            if not future.done():\n                future.cancel()\n\n            self.pending_get_requests.pop(parameter_hash, None)\n            logger.error(f\"Error in get_parameter: {exc}\")\n            raise\n\n    async def set_parameter_value(\n        self,\n        parameter_name: str,\n        value: int | float | bool,\n        timeout: float = 1,\n    ) -&gt; None:\n        \"\"\"\n        Sends a set_firmware_parameter request and waits for the response.\n\n        Args:\n            parameter_name: Name of the firmware parameter to modify\n            value: Value to set (int, float, or bool)\n            timeout: Timeout in seconds (default: 1)\n\n        Returns:\n            True if the firmware parameter was successfully written\n\n        Raises:\n            KeyError: If the firmware parameter name is not found in the firmware parameter group\n            ValidationError: If the value type doesn't match the firmware parameter type or is invalid\n            TimeoutError: If no response is received within the timeout\n        \"\"\"\n        # Validate that firmware parameter exists in the group\n        parameter = self.parameter_group.get(parameter_name)\n\n        # Set the new value (pydantic validation happens here)\n        parameter.value = value\n\n        # Create a Future for this request\n        future = asyncio.Future()\n\n        # Store pending request for response correalation\n        parameter_hash = hash(parameter)\n        self.pending_set_requests[parameter_hash] = future\n\n        try:\n            logger.info(f\"[firmware_parameter =&gt; server] set: {parameter}\")\n            await self.sio.emit(\"set_parameter_value\", parameter.model_dump(by_alias=True), namespace=\"/parameters\")\n\n            logger.info(f\"Sent set_parameter request for hash: 0x{parameter_hash:08x}\")\n\n            # Wait for the response with timeout\n            response = await asyncio.wait_for(future, timeout=timeout)\n\n            # Update parameter with response data (pydantic validation happens here)\n            parameter.pb_read(response)\n\n        except TimeoutError:\n            # Clean up on timeout\n            if not future.done():\n                future.cancel()\n\n            self.pending_set_requests.pop(parameter_hash, None)\n            logger.error(f\"Timeout waiting for set_firmware_parameter response (hash: 0x{parameter_hash:08x})\")\n            raise TimeoutError(f\"No response received for firmware parameter hash 0x{parameter_hash:08x}\")\n\n        except Exception as exc:\n            # Clean up on error\n            if not future.done():\n                future.cancel()\n\n            self.pending_set_requests.pop(parameter_hash, None)\n            logger.error(f\"Error in set_parameter: {exc}\")\n            raise\n\n    def cleanup(self):\n        \"\"\"\n        Cleans up all pending Futures.\n        \"\"\"\n        for future in self.pending_get_requests.values():\n            if not future.done():\n                future.cancel()\n        for future in self.pending_set_requests.values():\n            if not future.done():\n                future.cancel()\n\n        self.pending_get_requests.clear()\n        self.pending_set_requests.clear()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if the namespace is connected and ready.</p>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager.namespace","title":"<code>namespace</code>  <code>property</code>","text":"<p>Return the namespace path to include when connecting the host client.</p>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager.__init__","title":"<code>__init__(sio, parameter_group)</code>","text":"<p>Initialize the FirmwareParameterManager.</p> <p>Parameters:</p> Name Type Description Default <code>sio</code> <code>AsyncClient</code> <p>External Socket.IO client on which to register the /parameters namespace.  The host client is responsible for connection management.</p> required <code>parameter_group</code> <code>FirmwareParametersGroup</code> <p>The firmware parameters to manage</p> required Source code in <code>cogip/tools/firmware_parameter_manager/firmware_parameter_manager.py</code> <pre><code>def __init__(\n    self,\n    sio: socketio.AsyncClient,\n    parameter_group: FirmwareParametersGroup,\n):\n    \"\"\"\n    Initialize the FirmwareParameterManager.\n\n    Args:\n        sio: External Socket.IO client on which to register the /parameters namespace.\n             The host client is responsible for connection management.\n        parameter_group: The firmware parameters to manage\n    \"\"\"\n    self.sio = sio\n    self.parameter_group = parameter_group\n\n    self.sio_events = SioEvents(self)\n    self.sio.register_namespace(self.sio_events)\n\n    # Dictionary to store Futures waiting for responses\n    # Key: firmware parameter hash (int), Value: asyncio.Future\n    self.pending_get_requests: dict[int, asyncio.Future] = {}\n    self.pending_set_requests: dict[int, asyncio.Future] = {}\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleans up all pending Futures.</p> Source code in <code>cogip/tools/firmware_parameter_manager/firmware_parameter_manager.py</code> <pre><code>def cleanup(self):\n    \"\"\"\n    Cleans up all pending Futures.\n    \"\"\"\n    for future in self.pending_get_requests.values():\n        if not future.done():\n            future.cancel()\n    for future in self.pending_set_requests.values():\n        if not future.done():\n            future.cancel()\n\n    self.pending_get_requests.clear()\n    self.pending_set_requests.clear()\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager.get_parameter_value","title":"<code>get_parameter_value(parameter_name, timeout=1)</code>  <code>async</code>","text":"<p>Sends a get_firmware_parameter request and waits for the response.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>Name of the firmware parameter to retrieve</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds (default: 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>float | int | bool</code> <p>The firmware parameter value (float, int, or bool) after pydantic validation</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the firmware parameter name is not found in the firmware parameter group</p> <code>TimeoutError</code> <p>If no response is received within the timeout</p> Source code in <code>cogip/tools/firmware_parameter_manager/firmware_parameter_manager.py</code> <pre><code>async def get_parameter_value(\n    self,\n    parameter_name: str,\n    timeout: float = 1,\n) -&gt; float | int | bool:\n    \"\"\"\n    Sends a get_firmware_parameter request and waits for the response.\n\n    Args:\n        parameter_name: Name of the firmware parameter to retrieve\n        timeout: Timeout in seconds (default: 1)\n\n    Returns:\n        The firmware parameter value (float, int, or bool) after pydantic validation\n\n    Raises:\n        KeyError: If the firmware parameter name is not found in the firmware parameter group\n        TimeoutError: If no response is received within the timeout\n    \"\"\"\n    # Validate that firmware parameter exists in the group\n    parameter = self.parameter_group.get(parameter_name)\n\n    # Create a Future for this request\n    future = asyncio.Future()\n\n    # Store pending request for response correalation\n    parameter_hash = hash(parameter)\n    self.pending_get_requests[parameter_hash] = future\n\n    try:\n        logger.info(f\"[firmware_parameter =&gt; server] get: {parameter}\")\n        await self.sio.emit(\"get_parameter_value\", parameter.model_dump(by_alias=True), namespace=\"/parameters\")\n\n        logger.info(f\"Sent get_parameter request for hash: 0x{parameter_hash:08x}\")\n\n        # Wait for the response with timeout\n        response = await asyncio.wait_for(future, timeout=timeout)\n\n        # Update parameter with response data (pydantic validation happens here)\n        parameter.pb_read(response)\n\n        # Return the validated value\n        return parameter.value\n\n    except TimeoutError:\n        # Clean up on timeout\n        if not future.done():\n            future.cancel()\n\n        self.pending_get_requests.pop(parameter_hash, None)\n        logger.error(f\"Timeout waiting for get_firmware_parameter response (hash: 0x{parameter_hash:08x})\")\n        raise TimeoutError(f\"No response received for firmware parameter hash 0x{parameter_hash:08x}\")\n\n    except Exception as exc:\n        # Clean up on error\n        if not future.done():\n            future.cancel()\n\n        self.pending_get_requests.pop(parameter_hash, None)\n        logger.error(f\"Error in get_parameter: {exc}\")\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/firmware_parameter_manager/#cogip.tools.firmware_parameter_manager.firmware_parameter_manager.FirmwareParameterManager.set_parameter_value","title":"<code>set_parameter_value(parameter_name, value, timeout=1)</code>  <code>async</code>","text":"<p>Sends a set_firmware_parameter request and waits for the response.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>Name of the firmware parameter to modify</p> required <code>value</code> <code>int | float | bool</code> <p>Value to set (int, float, or bool)</p> required <code>timeout</code> <code>float</code> <p>Timeout in seconds (default: 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>True if the firmware parameter was successfully written</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the firmware parameter name is not found in the firmware parameter group</p> <code>ValidationError</code> <p>If the value type doesn't match the firmware parameter type or is invalid</p> <code>TimeoutError</code> <p>If no response is received within the timeout</p> Source code in <code>cogip/tools/firmware_parameter_manager/firmware_parameter_manager.py</code> <pre><code>async def set_parameter_value(\n    self,\n    parameter_name: str,\n    value: int | float | bool,\n    timeout: float = 1,\n) -&gt; None:\n    \"\"\"\n    Sends a set_firmware_parameter request and waits for the response.\n\n    Args:\n        parameter_name: Name of the firmware parameter to modify\n        value: Value to set (int, float, or bool)\n        timeout: Timeout in seconds (default: 1)\n\n    Returns:\n        True if the firmware parameter was successfully written\n\n    Raises:\n        KeyError: If the firmware parameter name is not found in the firmware parameter group\n        ValidationError: If the value type doesn't match the firmware parameter type or is invalid\n        TimeoutError: If no response is received within the timeout\n    \"\"\"\n    # Validate that firmware parameter exists in the group\n    parameter = self.parameter_group.get(parameter_name)\n\n    # Set the new value (pydantic validation happens here)\n    parameter.value = value\n\n    # Create a Future for this request\n    future = asyncio.Future()\n\n    # Store pending request for response correalation\n    parameter_hash = hash(parameter)\n    self.pending_set_requests[parameter_hash] = future\n\n    try:\n        logger.info(f\"[firmware_parameter =&gt; server] set: {parameter}\")\n        await self.sio.emit(\"set_parameter_value\", parameter.model_dump(by_alias=True), namespace=\"/parameters\")\n\n        logger.info(f\"Sent set_parameter request for hash: 0x{parameter_hash:08x}\")\n\n        # Wait for the response with timeout\n        response = await asyncio.wait_for(future, timeout=timeout)\n\n        # Update parameter with response data (pydantic validation happens here)\n        parameter.pb_read(response)\n\n    except TimeoutError:\n        # Clean up on timeout\n        if not future.done():\n            future.cancel()\n\n        self.pending_set_requests.pop(parameter_hash, None)\n        logger.error(f\"Timeout waiting for set_firmware_parameter response (hash: 0x{parameter_hash:08x})\")\n        raise TimeoutError(f\"No response received for firmware parameter hash 0x{parameter_hash:08x}\")\n\n    except Exception as exc:\n        # Clean up on error\n        if not future.done():\n            future.cancel()\n\n        self.pending_set_requests.pop(parameter_hash, None)\n        logger.error(f\"Error in set_parameter: {exc}\")\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/#cogip.tools.firmware_parameter_manager.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by FirmwareParameterManager.</p> Source code in <code>cogip/tools/firmware_parameter_manager/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by FirmwareParameterManager.\n    \"\"\"\n\n    def __init__(self, manager: \"FirmwareParameterManager\"):\n        super().__init__(\"/parameters\")\n        self.manager = manager\n        self.connected = False\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=1,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n\n        self.connected = True\n\n    async def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.connected = False\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a firmware parameter manager is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_get_parameter_response(self, data: dict[str, Any]):\n        \"\"\"\n        Handle get_parameter_response from copilot.\n        Resolve the pending Future with the response.\n        \"\"\"\n        response = ParseDict(data, PB_ParameterGetResponse())\n\n        logger.info(f\"[SIO] Received get_response for firmware parameter hash: 0x{response.key_hash:08x}\")\n\n        # Retrieve the Future corresponding to this request\n        if response.key_hash in self.manager.pending_get_requests:\n            future = self.manager.pending_get_requests.pop(response.key_hash)\n            if not future.done():\n                future.set_result(response)\n        else:\n            logger.warning(f\"No pending request found for firmware parameter hash: 0x{response.key_hash:08x}\")\n\n    async def on_set_parameter_response(self, data: dict[str, Any]):\n        \"\"\"\n        Handle set_parameter_response from copilot.\n        Resolve the pending Future with the response.\n        \"\"\"\n        response = ParseDict(data, PB_ParameterSetResponse())\n\n        logger.info(f\"[SIO] Received set_response for firmware parameter hash: 0x{response.key_hash:08x}\")\n\n        # Retrieve the Future corresponding to this request\n        if response.key_hash in self.manager.pending_set_requests:\n            future = self.manager.pending_set_requests.pop(response.key_hash)\n            if not future.done():\n                future.set_result(response)\n        else:\n            logger.warning(f\"No pending request found for firmware parameter hash: 0x{response.key_hash:08x}\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/#cogip.tools.firmware_parameter_manager.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/firmware_parameter_manager/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=1,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n\n    self.connected = True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/#cogip.tools.firmware_parameter_manager.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a firmware parameter manager is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/firmware_parameter_manager/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a firmware parameter manager is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/#cogip.tools.firmware_parameter_manager.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/firmware_parameter_manager/sio_events.py</code> <pre><code>async def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.connected = False\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/#cogip.tools.firmware_parameter_manager.sio_events.SioEvents.on_get_parameter_response","title":"<code>on_get_parameter_response(data)</code>  <code>async</code>","text":"<p>Handle get_parameter_response from copilot. Resolve the pending Future with the response.</p> Source code in <code>cogip/tools/firmware_parameter_manager/sio_events.py</code> <pre><code>async def on_get_parameter_response(self, data: dict[str, Any]):\n    \"\"\"\n    Handle get_parameter_response from copilot.\n    Resolve the pending Future with the response.\n    \"\"\"\n    response = ParseDict(data, PB_ParameterGetResponse())\n\n    logger.info(f\"[SIO] Received get_response for firmware parameter hash: 0x{response.key_hash:08x}\")\n\n    # Retrieve the Future corresponding to this request\n    if response.key_hash in self.manager.pending_get_requests:\n        future = self.manager.pending_get_requests.pop(response.key_hash)\n        if not future.done():\n            future.set_result(response)\n    else:\n        logger.warning(f\"No pending request found for firmware parameter hash: 0x{response.key_hash:08x}\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_parameter_manager/sio_events/#cogip.tools.firmware_parameter_manager.sio_events.SioEvents.on_set_parameter_response","title":"<code>on_set_parameter_response(data)</code>  <code>async</code>","text":"<p>Handle set_parameter_response from copilot. Resolve the pending Future with the response.</p> Source code in <code>cogip/tools/firmware_parameter_manager/sio_events.py</code> <pre><code>async def on_set_parameter_response(self, data: dict[str, Any]):\n    \"\"\"\n    Handle set_parameter_response from copilot.\n    Resolve the pending Future with the response.\n    \"\"\"\n    response = ParseDict(data, PB_ParameterSetResponse())\n\n    logger.info(f\"[SIO] Received set_response for firmware parameter hash: 0x{response.key_hash:08x}\")\n\n    # Retrieve the Future corresponding to this request\n    if response.key_hash in self.manager.pending_set_requests:\n        future = self.manager.pending_set_requests.pop(response.key_hash)\n        if not future.done():\n            future.set_result(response)\n    else:\n        logger.warning(f\"No pending request found for firmware parameter hash: 0x{response.key_hash:08x}\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/firmware_telemetry/__main__/#cogip.tools.firmware_telemetry.__main__.main","title":"<code>main()</code>","text":"<p>Run firmware telemetry utility.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-firmware-telemetry</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/firmware_telemetry/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Run firmware telemetry utility.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-firmware-telemetry` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/__main__/#cogip.tools.firmware_telemetry.__main__.main_async","title":"<code>main_async(server_url, duration)</code>  <code>async</code>","text":"<p>CLI utility to test firmware telemetry reception. Creates its own Socket.IO client to host the FirmwareTelemetryManager.</p> Source code in <code>cogip/tools/firmware_telemetry/__main__.py</code> <pre><code>async def main_async(server_url: str, duration: float):\n    \"\"\"\n    CLI utility to test firmware telemetry reception.\n    Creates its own Socket.IO client to host the FirmwareTelemetryManager.\n    \"\"\"\n    sio = socketio.AsyncClient(logger=False)\n    telemetry = FirmwareTelemetryManager(sio=sio)\n\n    print(f\"Connecting to {server_url}...\")\n    await sio.connect(server_url, namespaces=[telemetry.namespace])\n\n    print(\"Enabling telemetry...\")\n    await telemetry.enable()\n\n    print(f\"Receiving telemetry data for {duration} seconds...\")\n    print(\"-\" * 60)\n\n    start_time = time.monotonic()\n    last_print_time = 0.0\n\n    try:\n        while (time.monotonic() - start_time) &lt; duration:\n            await asyncio.sleep(0.1)\n\n            # Print telemetry values every second\n            current_time = time.monotonic() - start_time\n            if current_time - last_print_time &gt;= 1.0:\n                last_print_time = current_time\n                print(f\"\\n[{current_time:.1f}s] Telemetry store ({len(telemetry.store)} entries):\")\n                for key_hash, data in telemetry.store.items():\n                    print(f\"  hash=0x{key_hash:08x} ts={data.timestamp_ms}ms value={data.value}\")\n\n    except KeyboardInterrupt:\n        print(\"\\nInterrupted by user.\")\n\n    print(\"-\" * 60)\n    print(\"Disabling telemetry...\")\n    await telemetry.disable()\n\n    await sio.disconnect()\n    print(\"Disconnected.\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/","title":"firmware_telemetry_manager","text":""},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager","title":"<code>FirmwareTelemetryManager</code>","text":"<p>Manager to receive firmware telemetry data via SocketIO through copilot.</p> <p>This class is designed to be embedded into another Socket.IO client (e.g., Planner, Monitor, Calibration tool, or any tool that needs firmware telemetry access). It registers its own namespace (/telemetry) on the provided client, allowing the host tool to manage the connection lifecycle while benefiting from telemetry data reception.</p> <p>Telemetry data is stored in a TelemetryDict and can be accessed by key name or hash.</p> <p>Note on concurrent usage: Multiple clients can receive telemetry data simultaneously as the server broadcasts to all connected clients. However, having multiple consumers may lead to debugging complexity. Prefer having a single client handle telemetry at a time.</p> Source code in <code>cogip/tools/firmware_telemetry/firmware_telemetry_manager.py</code> <pre><code>class FirmwareTelemetryManager:\n    \"\"\"\n    Manager to receive firmware telemetry data via SocketIO through copilot.\n\n    This class is designed to be embedded into another Socket.IO client (e.g., Planner,\n    Monitor, Calibration tool, or any tool that needs firmware telemetry access). It registers\n    its own namespace (/telemetry) on the provided client, allowing the host tool to manage\n    the connection lifecycle while benefiting from telemetry data reception.\n\n    Telemetry data is stored in a TelemetryDict and can be accessed by key name or hash.\n\n    Note on concurrent usage: Multiple clients can receive telemetry data simultaneously\n    as the server broadcasts to all connected clients. However, having multiple consumers\n    may lead to debugging complexity. Prefer having a single client handle telemetry at a time.\n    \"\"\"\n\n    def __init__(\n        self,\n        sio: socketio.AsyncClient,\n    ):\n        \"\"\"\n        Initialize the FirmwareTelemetryManager.\n\n        Args:\n            sio: External Socket.IO client on which to register the /telemetry namespace.\n                 The host client is responsible for connection management.\n        \"\"\"\n        self.sio = sio\n        self.data = TelemetryDict()\n\n        self.sio_events = SioEvents(self)\n        self.sio.register_namespace(self.sio_events)\n\n    @property\n    def namespace(self) -&gt; str:\n        \"\"\"Return the namespace path to include when connecting the host client.\"\"\"\n        return self.sio_events.namespace\n\n    @property\n    def is_connected(self) -&gt; bool:\n        \"\"\"Check if the namespace is connected and ready.\"\"\"\n        return self.sio_events.connected\n\n    async def enable(self) -&gt; None:\n        \"\"\"\n        Enable telemetry on the firmware.\n        Sends telemetry_enable event to copilot via the server.\n        \"\"\"\n        await self.sio.emit(\"telemetry_enable\", namespace=\"/telemetry\")\n\n    async def disable(self) -&gt; None:\n        \"\"\"\n        Disable telemetry on the firmware.\n        Sends telemetry_disable event to copilot via the server.\n        \"\"\"\n        await self.sio.emit(\"telemetry_disable\", namespace=\"/telemetry\")\n\n    def get_value(self, key: str, default: float | int = 0) -&gt; float | int:\n        \"\"\"\n        Get the latest telemetry value for a key.\n\n        Args:\n            key: The telemetry key name.\n            default: Default value if key not found.\n\n        Returns:\n            The telemetry value, or default if not found.\n        \"\"\"\n        if key in self.data:\n            return self.data[key]\n        return default\n\n    def get_model(self, key: str) -&gt; TelemetryData:\n        \"\"\"\n        Get the full telemetry data model for a key.\n\n        Args:\n            key: The telemetry key name.\n\n        Returns:\n            TelemetryData containing key_hash, timestamp_ms, and value.\n\n        Raises:\n            KeyError: If the key is not found in the store.\n        \"\"\"\n        return self.data.get_model(key)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if the namespace is connected and ready.</p>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.namespace","title":"<code>namespace</code>  <code>property</code>","text":"<p>Return the namespace path to include when connecting the host client.</p>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.__init__","title":"<code>__init__(sio)</code>","text":"<p>Initialize the FirmwareTelemetryManager.</p> <p>Parameters:</p> Name Type Description Default <code>sio</code> <code>AsyncClient</code> <p>External Socket.IO client on which to register the /telemetry namespace.  The host client is responsible for connection management.</p> required Source code in <code>cogip/tools/firmware_telemetry/firmware_telemetry_manager.py</code> <pre><code>def __init__(\n    self,\n    sio: socketio.AsyncClient,\n):\n    \"\"\"\n    Initialize the FirmwareTelemetryManager.\n\n    Args:\n        sio: External Socket.IO client on which to register the /telemetry namespace.\n             The host client is responsible for connection management.\n    \"\"\"\n    self.sio = sio\n    self.data = TelemetryDict()\n\n    self.sio_events = SioEvents(self)\n    self.sio.register_namespace(self.sio_events)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.disable","title":"<code>disable()</code>  <code>async</code>","text":"<p>Disable telemetry on the firmware. Sends telemetry_disable event to copilot via the server.</p> Source code in <code>cogip/tools/firmware_telemetry/firmware_telemetry_manager.py</code> <pre><code>async def disable(self) -&gt; None:\n    \"\"\"\n    Disable telemetry on the firmware.\n    Sends telemetry_disable event to copilot via the server.\n    \"\"\"\n    await self.sio.emit(\"telemetry_disable\", namespace=\"/telemetry\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.enable","title":"<code>enable()</code>  <code>async</code>","text":"<p>Enable telemetry on the firmware. Sends telemetry_enable event to copilot via the server.</p> Source code in <code>cogip/tools/firmware_telemetry/firmware_telemetry_manager.py</code> <pre><code>async def enable(self) -&gt; None:\n    \"\"\"\n    Enable telemetry on the firmware.\n    Sends telemetry_enable event to copilot via the server.\n    \"\"\"\n    await self.sio.emit(\"telemetry_enable\", namespace=\"/telemetry\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.get_model","title":"<code>get_model(key)</code>","text":"<p>Get the full telemetry data model for a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The telemetry key name.</p> required <p>Returns:</p> Type Description <code>TelemetryData</code> <p>TelemetryData containing key_hash, timestamp_ms, and value.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the store.</p> Source code in <code>cogip/tools/firmware_telemetry/firmware_telemetry_manager.py</code> <pre><code>def get_model(self, key: str) -&gt; TelemetryData:\n    \"\"\"\n    Get the full telemetry data model for a key.\n\n    Args:\n        key: The telemetry key name.\n\n    Returns:\n        TelemetryData containing key_hash, timestamp_ms, and value.\n\n    Raises:\n        KeyError: If the key is not found in the store.\n    \"\"\"\n    return self.data.get_model(key)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/firmware_telemetry_manager/#cogip.tools.firmware_telemetry.firmware_telemetry_manager.FirmwareTelemetryManager.get_value","title":"<code>get_value(key, default=0)</code>","text":"<p>Get the latest telemetry value for a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The telemetry key name.</p> required <code>default</code> <code>float | int</code> <p>Default value if key not found.</p> <code>0</code> <p>Returns:</p> Type Description <code>float | int</code> <p>The telemetry value, or default if not found.</p> Source code in <code>cogip/tools/firmware_telemetry/firmware_telemetry_manager.py</code> <pre><code>def get_value(self, key: str, default: float | int = 0) -&gt; float | int:\n    \"\"\"\n    Get the latest telemetry value for a key.\n\n    Args:\n        key: The telemetry key name.\n        default: Default value if key not found.\n\n    Returns:\n        The telemetry value, or default if not found.\n    \"\"\"\n    if key in self.data:\n        return self.data[key]\n    return default\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/firmware_telemetry/sio_events/#cogip.tools.firmware_telemetry.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by FirmwareTelemetryManager.</p> Source code in <code>cogip/tools/firmware_telemetry/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by FirmwareTelemetryManager.\n    \"\"\"\n\n    def __init__(self, manager: \"FirmwareTelemetryManager\"):\n        super().__init__(\"/telemetry\")\n        self.manager = manager\n        self.connected = False\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=1,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n\n        self.connected = True\n\n    async def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self.connected = False\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_telemetry_data(self, data: dict[str, Any]):\n        \"\"\"\n        Handle telemetry_data from copilot.\n        Store the telemetry data point.\n        \"\"\"\n        telemetry = ParseDict(data, PB_TelemetryData())\n        telemetry_data = TelemetryData.from_protobuf(telemetry)\n        self.manager.store.update(telemetry_data)\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/sio_events/#cogip.tools.firmware_telemetry.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/firmware_telemetry/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=1,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n\n    self.connected = True\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/sio_events/#cogip.tools.firmware_telemetry.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error.</p> Source code in <code>cogip/tools/firmware_telemetry/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/sio_events/#cogip.tools.firmware_telemetry.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/firmware_telemetry/sio_events.py</code> <pre><code>async def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self.connected = False\n</code></pre>"},{"location":"reference/cogip/tools/firmware_telemetry/sio_events/#cogip.tools.firmware_telemetry.sio_events.SioEvents.on_telemetry_data","title":"<code>on_telemetry_data(data)</code>  <code>async</code>","text":"<p>Handle telemetry_data from copilot. Store the telemetry data point.</p> Source code in <code>cogip/tools/firmware_telemetry/sio_events.py</code> <pre><code>async def on_telemetry_data(self, data: dict[str, Any]):\n    \"\"\"\n    Handle telemetry_data from copilot.\n    Store the telemetry data point.\n    \"\"\"\n    telemetry = ParseDict(data, PB_TelemetryData())\n    telemetry_data = TelemetryData.from_protobuf(telemetry)\n    self.manager.store.update(telemetry_data)\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/lidar_ld19/__main__/#cogip.tools.lidar_ld19.__main__.main","title":"<code>main()</code>","text":"<p>Tool demonstrating usage of lidar_ld19 C++ driver.</p> <p>During installation of cogip-tools, a script called <code>cogip-lidar-ld19</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/lidar_ld19/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Tool demonstrating usage of lidar_ld19 C++ driver.\n\n    During installation of cogip-tools, a script called `cogip-lidar-ld19`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/","title":"gui","text":""},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker","title":"<code>LidarObstacleTracker</code>","text":"Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>class LidarObstacleTracker:\n    def __init__(\n        self,\n        lidar_coords: NDArray,\n        lidar_offset: tuple[float, float],\n        eps: float = 30.0,\n        min_samples: int = 6,\n        update_interval: int = 100,\n    ):\n        \"\"\"\n        Initialize the real-time Lidar obstacle tracker\n\n        Args:\n            lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n            lidar_offset: Lidar offset from robot center\n            eps: DBSCAN clustering parameter\n            min_samples: Minimum points for cluster formation\n            update_interval: Visualization update interval\n        \"\"\"\n        # Use default pose if not provided\n        self.lidar_coords = lidar_coords\n        self.lidar_offset = lidar_offset\n        self.eps = eps\n        self.min_samples = min_samples\n        self.update_interval = update_interval\n        self.view_radius = 2500\n        self.clusters: list[NDArray] = []\n        self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n        # Initialize plot and data containers\n        self.fig, self.ax = plt.subplots(figsize=(10, 10))\n        self.setup_plot()\n\n        # Connect the scroll event to the handler\n        self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n        # Visualization elements\n        self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n        self.cluster_scatters: list[PathCollection] = []\n        self.obstacle_circles: list[Ellipse] = []\n\n        # Robot and Lidar markers\n        self.robot_marker = self.ax.scatter(\n            0,\n            0,\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Robot\",\n        )\n\n        # Calculate Lidar position\n        self.lidar_marker = self.ax.scatter(\n            self.lidar_offset[1],\n            self.lidar_offset[0],\n            c=\"blue\",\n            s=80,\n            marker=\"o\",\n            label=\"Lidar\",\n        )\n\n        # Animation setup\n        self.animation: FuncAnimation | None = None\n\n    def setup_plot(self):\n        \"\"\"Configure the plot appearance with dark theme\"\"\"\n        # Set figure and axes background color\n        self.fig.patch.set_facecolor(\"#2E2E2E\")\n        self.ax.set_facecolor(\"#1E1E1E\")\n\n        # Set labels and title with light colors\n        self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n        self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n        self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n        # Customize grid\n        self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n        # Customize axis appearance\n        self.ax.spines[\"bottom\"].set_color(\"#555555\")\n        self.ax.spines[\"top\"].set_color(\"#555555\")\n        self.ax.spines[\"left\"].set_color(\"#555555\")\n        self.ax.spines[\"right\"].set_color(\"#555555\")\n\n        # Customize tick parameters\n        self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n        # Invert x-axis and set equal aspect ratio\n        self.ax.invert_xaxis()\n        self.ax.axis(\"equal\")\n\n        # Configure legend with dark theme colors\n        self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n        # Set initial view range\n        self.ax.set_xlim((self.view_radius, -self.view_radius))\n        self.ax.set_ylim((-self.view_radius, self.view_radius))\n\n    def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n        \"\"\"\n        Groups points into obstacle clusters using DBSCAN\n\n        Args:\n            points: NDArray of (x, y) points representing detected obstacles\n\n        Returns:\n            List of clusters, each cluster being a set of points belonging to the same obstacle\n        \"\"\"\n        if len(points) == 0:\n            return []\n\n        db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n        labels = db.labels_\n\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n        clusters = []\n        for i in range(n_clusters):\n            cluster_points = points[labels == i]\n            clusters.append(cluster_points)\n\n        return clusters\n\n    def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Estimates position and size of obstacles from clusters\n\n        Args:\n            clusters: List of clusters, each cluster being a set of points\n\n        Returns:\n            List of tuples (center_x, center_y, radius) for each obstacle\n        \"\"\"\n        obstacle_properties = []\n\n        for cluster in clusters:\n            center_x = np.mean(cluster[:, 0])\n            center_y = np.mean(cluster[:, 1])\n\n            # Calculate the maximum distance from center in x and y directions\n            # This will be used as the radius of the circle\n            radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n            radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n            radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n            obstacle_properties.append((center_x, center_y, radius))\n\n        return obstacle_properties\n\n    def update_plot(self, frame):\n        \"\"\"Updates the visualization with current data\"\"\"\n        lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n        self.clusters = self.cluster_obstacles(lidar_coords)\n        self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n        # Update points scatter\n        self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n        # Clear previous cluster scatters and obstacle visualizations\n        for scatter in self.cluster_scatters:\n            scatter.remove()\n        self.cluster_scatters = []\n\n        for circle in self.obstacle_circles:\n            circle.remove()\n        self.obstacle_circles = []\n\n        # Create color map for clusters that works well with dark theme\n        colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n        # Draw new clusters\n        for i, cluster in enumerate(self.clusters):\n            scatter = self.ax.scatter(\n                cluster[:, 1],\n                cluster[:, 0],\n                c=[colors[i]],\n                s=20,\n                label=f\"Cluster {i}\" if i == 0 else \"\",\n            )\n            self.cluster_scatters.append(scatter)\n\n        # Draw obstacle circles and labels\n        for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n            # Create ellipse for the obstacle\n            circle = Ellipse(\n                (center_y, center_x),\n                width=radius * 2,\n                height=radius * 2,\n                fill=False,\n                edgecolor=colors[i],\n                linewidth=2,\n                alpha=0.8,\n            )\n            self.ax.add_patch(circle)\n            self.obstacle_circles.append(circle)\n\n        # Redraw the figure\n        self.fig.canvas.draw_idle()\n\n    def start_animation(self):\n        \"\"\"Starts the real-time visualization\"\"\"\n        # Set dark theme for the color map (for clusters)\n        plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n        # Continue with original animation code\n        self.animation = FuncAnimation(\n            self.fig,\n            self.update_plot,\n            interval=self.update_interval,\n            blit=False,\n            cache_frame_data=False,\n        )\n\n    def on_scroll(self, event: MouseEvent):\n        # Ignore if the mouse is not over the axes\n        if event.inaxes != self.ax:\n            return\n\n        # Get the current limits\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        # Get mouse position in data coordinates\n        x_data, y_data = event.xdata, event.ydata\n\n        # Calculate zoom factor\n        zoom_factor = 1.1 if event.button == \"down\" else 0.9  # Zoom in/out\n\n        # Calculate new limits maintaining the mouse position as center\n        x_left = x_data - zoom_factor * (x_data - xlim[0])\n        x_right = x_data + zoom_factor * (xlim[1] - x_data)\n        y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n        y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n        # Limit the zoom range\n        x_left = max(-self.view_radius, x_left)\n        x_right = min(self.view_radius, x_right)\n        y_bottom = max(-self.view_radius, y_bottom)\n        y_top = min(self.view_radius, y_top)\n\n        # Apply the new limits\n        self.ax.set_xlim(x_left, x_right)\n        self.ax.set_ylim(y_bottom, y_top)\n\n        # Redraw the plot\n        plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.__init__","title":"<code>__init__(lidar_coords, lidar_offset, eps=30.0, min_samples=6, update_interval=100)</code>","text":"<p>Initialize the real-time Lidar obstacle tracker</p> <p>Parameters:</p> Name Type Description Default <code>lidar_coords</code> <code>NDArray</code> <p>2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates</p> required <code>lidar_offset</code> <code>tuple[float, float]</code> <p>Lidar offset from robot center</p> required <code>eps</code> <code>float</code> <p>DBSCAN clustering parameter</p> <code>30.0</code> <code>min_samples</code> <code>int</code> <p>Minimum points for cluster formation</p> <code>6</code> <code>update_interval</code> <code>int</code> <p>Visualization update interval</p> <code>100</code> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def __init__(\n    self,\n    lidar_coords: NDArray,\n    lidar_offset: tuple[float, float],\n    eps: float = 30.0,\n    min_samples: int = 6,\n    update_interval: int = 100,\n):\n    \"\"\"\n    Initialize the real-time Lidar obstacle tracker\n\n    Args:\n        lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n        lidar_offset: Lidar offset from robot center\n        eps: DBSCAN clustering parameter\n        min_samples: Minimum points for cluster formation\n        update_interval: Visualization update interval\n    \"\"\"\n    # Use default pose if not provided\n    self.lidar_coords = lidar_coords\n    self.lidar_offset = lidar_offset\n    self.eps = eps\n    self.min_samples = min_samples\n    self.update_interval = update_interval\n    self.view_radius = 2500\n    self.clusters: list[NDArray] = []\n    self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n    # Initialize plot and data containers\n    self.fig, self.ax = plt.subplots(figsize=(10, 10))\n    self.setup_plot()\n\n    # Connect the scroll event to the handler\n    self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n    # Visualization elements\n    self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n    self.cluster_scatters: list[PathCollection] = []\n    self.obstacle_circles: list[Ellipse] = []\n\n    # Robot and Lidar markers\n    self.robot_marker = self.ax.scatter(\n        0,\n        0,\n        c=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"Robot\",\n    )\n\n    # Calculate Lidar position\n    self.lidar_marker = self.ax.scatter(\n        self.lidar_offset[1],\n        self.lidar_offset[0],\n        c=\"blue\",\n        s=80,\n        marker=\"o\",\n        label=\"Lidar\",\n    )\n\n    # Animation setup\n    self.animation: FuncAnimation | None = None\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.cluster_obstacles","title":"<code>cluster_obstacles(points)</code>","text":"<p>Groups points into obstacle clusters using DBSCAN</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray</code> <p>NDArray of (x, y) points representing detected obstacles</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points belonging to the same obstacle</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n    \"\"\"\n    Groups points into obstacle clusters using DBSCAN\n\n    Args:\n        points: NDArray of (x, y) points representing detected obstacles\n\n    Returns:\n        List of clusters, each cluster being a set of points belonging to the same obstacle\n    \"\"\"\n    if len(points) == 0:\n        return []\n\n    db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n    labels = db.labels_\n\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    clusters = []\n    for i in range(n_clusters):\n        cluster_points = points[labels == i]\n        clusters.append(cluster_points)\n\n    return clusters\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.estimate_obstacle_properties","title":"<code>estimate_obstacle_properties(clusters)</code>","text":"<p>Estimates position and size of obstacles from clusters</p> <p>Parameters:</p> Name Type Description Default <code>clusters</code> <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points</p> required <p>Returns:</p> Type Description <code>list[tuple[float, float, float]]</code> <p>List of tuples (center_x, center_y, radius) for each obstacle</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n    \"\"\"\n    Estimates position and size of obstacles from clusters\n\n    Args:\n        clusters: List of clusters, each cluster being a set of points\n\n    Returns:\n        List of tuples (center_x, center_y, radius) for each obstacle\n    \"\"\"\n    obstacle_properties = []\n\n    for cluster in clusters:\n        center_x = np.mean(cluster[:, 0])\n        center_y = np.mean(cluster[:, 1])\n\n        # Calculate the maximum distance from center in x and y directions\n        # This will be used as the radius of the circle\n        radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n        radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n        radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n        obstacle_properties.append((center_x, center_y, radius))\n\n    return obstacle_properties\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.setup_plot","title":"<code>setup_plot()</code>","text":"<p>Configure the plot appearance with dark theme</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def setup_plot(self):\n    \"\"\"Configure the plot appearance with dark theme\"\"\"\n    # Set figure and axes background color\n    self.fig.patch.set_facecolor(\"#2E2E2E\")\n    self.ax.set_facecolor(\"#1E1E1E\")\n\n    # Set labels and title with light colors\n    self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n    self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n    self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n    # Customize grid\n    self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Customize axis appearance\n    self.ax.spines[\"bottom\"].set_color(\"#555555\")\n    self.ax.spines[\"top\"].set_color(\"#555555\")\n    self.ax.spines[\"left\"].set_color(\"#555555\")\n    self.ax.spines[\"right\"].set_color(\"#555555\")\n\n    # Customize tick parameters\n    self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n    # Invert x-axis and set equal aspect ratio\n    self.ax.invert_xaxis()\n    self.ax.axis(\"equal\")\n\n    # Configure legend with dark theme colors\n    self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n    # Set initial view range\n    self.ax.set_xlim((self.view_radius, -self.view_radius))\n    self.ax.set_ylim((-self.view_radius, self.view_radius))\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.start_animation","title":"<code>start_animation()</code>","text":"<p>Starts the real-time visualization</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def start_animation(self):\n    \"\"\"Starts the real-time visualization\"\"\"\n    # Set dark theme for the color map (for clusters)\n    plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n    # Continue with original animation code\n    self.animation = FuncAnimation(\n        self.fig,\n        self.update_plot,\n        interval=self.update_interval,\n        blit=False,\n        cache_frame_data=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/gui/#cogip.tools.lidar_ld19.gui.LidarObstacleTracker.update_plot","title":"<code>update_plot(frame)</code>","text":"<p>Updates the visualization with current data</p> Source code in <code>cogip/tools/lidar_ld19/gui.py</code> <pre><code>def update_plot(self, frame):\n    \"\"\"Updates the visualization with current data\"\"\"\n    lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n    self.clusters = self.cluster_obstacles(lidar_coords)\n    self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n    # Update points scatter\n    self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n    # Clear previous cluster scatters and obstacle visualizations\n    for scatter in self.cluster_scatters:\n        scatter.remove()\n    self.cluster_scatters = []\n\n    for circle in self.obstacle_circles:\n        circle.remove()\n    self.obstacle_circles = []\n\n    # Create color map for clusters that works well with dark theme\n    colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n    # Draw new clusters\n    for i, cluster in enumerate(self.clusters):\n        scatter = self.ax.scatter(\n            cluster[:, 1],\n            cluster[:, 0],\n            c=[colors[i]],\n            s=20,\n            label=f\"Cluster {i}\" if i == 0 else \"\",\n        )\n        self.cluster_scatters.append(scatter)\n\n    # Draw obstacle circles and labels\n    for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n        # Create ellipse for the obstacle\n        circle = Ellipse(\n            (center_y, center_x),\n            width=radius * 2,\n            height=radius * 2,\n            fill=False,\n            edgecolor=colors[i],\n            linewidth=2,\n            alpha=0.8,\n        )\n        self.ax.add_patch(circle)\n        self.obstacle_circles.append(circle)\n\n    # Redraw the figure\n    self.fig.canvas.draw_idle()\n</code></pre>"},{"location":"reference/cogip/tools/lidar_ld19/web/","title":"web","text":""},{"location":"reference/cogip/tools/mcu_logger/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/mcu_logger/__main__/#cogip.tools.mcu_logger.__main__.main","title":"<code>main()</code>","text":"<p>This tools outputs from a serial port, like mcu-firmware outputs, and forward them to the logger.</p> <p>During installation of cogip-tools, a script called <code>cogip-mcu-logger</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/mcu_logger/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    This tools outputs from a serial port, like mcu-firmware outputs, and forward them to the logger.\n\n    During installation of cogip-tools, a script called `cogip-mcu-logger`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/monitor/main/","title":"main","text":""},{"location":"reference/cogip/tools/monitor/main/#cogip.tools.monitor.main.main","title":"<code>main()</code>","text":"<p>Starts the copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-monitor</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/monitor/main.py</code> <pre><code>def main():\n    \"\"\"\n    Starts the copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-monitor` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/main/#cogip.tools.monitor.main.main_opt","title":"<code>main_opt(url=typer.Argument('http://localhost:8091', envvar='COGIP_SOCKETIO_SERVER_URL', help='Socket.IO Server URL'))</code>","text":"<p>Launch COGIP Monitor.</p> Source code in <code>cogip/tools/monitor/main.py</code> <pre><code>def main_opt(\n    url: str = typer.Argument(\n        \"http://localhost:8091\",\n        envvar=\"COGIP_SOCKETIO_SERVER_URL\",\n        help=\"Socket.IO Server URL\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Launch COGIP Monitor.\n    \"\"\"\n    if os.getenv(\"QT_QPA_PLATFORM\") is None:\n        os.environ[\"QT_QPA_PLATFORM\"] = \"xcb\"\n\n    QCoreApplication.setOrganizationName(\"cogip\")\n    QCoreApplication.setOrganizationDomain(\"cogip.tools\")\n    QCoreApplication.setApplicationName(\"COGIP Monitor\")\n\n    sio_client = SocketioClient(url)\n\n    app = QGuiApplication(sys.argv)\n    app.setFont(QFont(\"Ubuntu\", 11))\n\n    QQuickStyle.setStyle(\"Fusion\")\n\n    palette = app.palette()\n    palette.setColor(QPalette.ColorRole.Window, \"#2a2a2a\")\n    palette.setColor(QPalette.ColorRole.WindowText, \"#ffffff\")\n    palette.setColor(QPalette.ColorRole.Base, \"#2a2a2a\")\n    palette.setColor(QPalette.ColorRole.AlternateBase, \"#272727\")\n    palette.setColor(QPalette.ColorRole.ToolTipBase, \"#ffffdc\")\n    palette.setColor(QPalette.ColorRole.ToolTipText, \"#000000\")\n    palette.setColor(QPalette.ColorRole.Text, \"#ffffff\")\n    palette.setColor(QPalette.ColorRole.Button, \"#2a2a2a\")\n    palette.setColor(QPalette.ColorRole.ButtonText, \"#ffffff\")\n    palette.setColor(QPalette.ColorRole.BrightText, \"#ffffff\")\n    palette.setColor(QPalette.ColorRole.Highlight, \"#e95420\")\n    palette.setColor(QPalette.ColorRole.HighlightedText, \"#ffffff\")\n    palette.setColor(QPalette.ColorRole.Light, \"#343434\")\n    palette.setColor(QPalette.ColorRole.Midlight, \"#2f2f2f\")\n    palette.setColor(QPalette.ColorRole.Dark, \"#252525\")\n    palette.setColor(QPalette.ColorRole.Mid, \"#2f2f2f\")\n    palette.setColor(QPalette.ColorRole.Shadow, \"#020202\")\n    palette.setColor(QPalette.ColorRole.Link, \"#308cc6\")\n    palette.setColor(QPalette.ColorRole.LinkVisited, \"#ff00ff\")\n    palette.setColor(QPalette.ColorRole.NoRole, \"#000000\")\n    palette.setColor(QPalette.ColorRole.PlaceholderText, \"#9b9b9b\")\n    palette.setColor(QPalette.ColorRole.Accent, \"#308cc6\")\n    app.setPalette(palette)\n\n    qmlRegisterType(View3DBackend, \"View3DBackend\", 1, 0, \"View3DBackend\")\n\n    engine = QQmlApplicationEngine()\n\n    # Add PySide6's QML import path\n    engine.addImportPath(PySide6.__path__[0])\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(QUrl.fromLocalFile(str(qml_file)))\n\n    if not engine.rootObjects():\n        logger.error(\"No root objects loaded, exiting.\")\n        sys.exit(-1)\n\n    root: QWindow = engine.rootObjects()[0]\n    scene_qml = root.findChild(QObject, \"Scene\")\n    view3d_backend = View3DBackend(scene_qml)\n    view3d_qml = scene_qml.findChild(QObject, \"view\")\n    view3d_qml.setProperty(\"view3DBackend\", view3d_backend)\n    root.setProperty(\"isConnected\", False)\n    root.setProperty(\"starterChecked\", False)\n    root.setProperty(\"socketClient\", sio_client)\n    root.setProperty(\"toolMenu\", {\"name\": \"\", \"entries\": []})\n    obstacle_storage = ObstacleStorage()\n    root.setProperty(\"obstacleStorage\", obstacle_storage)\n\n    table = Table(view3d_qml.findChild(QObject, \"table\"))\n    root.setProperty(\"table\", table)\n\n    def request_quit() -&gt; None:\n        QtCore.QTimer.singleShot(0, app.quit)\n\n    def handle_connected(connected: bool) -&gt; None:\n        def update_state() -&gt; None:\n            root.setProperty(\"isConnected\", connected)\n            if not connected:\n                root.setProperty(\"toolMenu\", {\"name\": \"\", \"entries\": []})\n                root.setProperty(\"starterChecked\", False)\n                QtCore.QMetaObject.invokeMethod(\n                    root,\n                    \"closeAllConfigWindows\",\n                    QtCore.Qt.ConnectionType.QueuedConnection,\n                )\n                QtCore.QMetaObject.invokeMethod(\n                    root,\n                    \"closeWizardWindow\",\n                    QtCore.Qt.ConnectionType.QueuedConnection,\n                )\n\n        QtCore.QTimer.singleShot(0, update_state)\n\n    def handle_tool_menu(menu: models.ShellMenu) -&gt; None:\n        filtered_entries: list[dict[str, str]] = []\n        for entry in menu.entries:\n            if entry.cmd.startswith(\"_\"):\n                continue\n            entry_dict = {\"cmd\": entry.cmd, \"desc\": entry.desc}\n            if entry.cmd == \"exit\":\n                filtered_entries.insert(0, entry_dict)\n            else:\n                filtered_entries.append(entry_dict)\n        payload = {\n            \"name\": menu.name,\n            \"entries\": filtered_entries,\n        }\n\n        QtCore.QTimer.singleShot(0, lambda: root.setProperty(\"toolMenu\", payload))\n\n    def handle_wizard_request(data: dict[str, Any]) -&gt; None:\n        QtCore.QMetaObject.invokeMethod(\n            root,\n            \"openWizardWindow\",\n            QtCore.Qt.ConnectionType.QueuedConnection,\n            QtCore.Q_ARG(\"QVariant\", data),\n        )\n\n    def handle_close_wizard() -&gt; None:\n        QtCore.QMetaObject.invokeMethod(\n            root,\n            \"closeWizardWindow\",\n            QtCore.Qt.ConnectionType.QueuedConnection,\n        )\n\n    def handle_starter_changed(pushed: bool) -&gt; None:\n        QtCore.QTimer.singleShot(0, lambda: root.setProperty(\"starterChecked\", pushed))\n\n    sio_client.signal_connected.connect(handle_connected)\n    sio_client.signal_exit.connect(request_quit)\n    sio_client.signal_add_robot.connect(view3d_backend.handle_add_robot)\n    sio_client.signal_del_robot.connect(view3d_backend.handle_del_robot)\n    sio_client.signal_pose_current.connect(view3d_backend.handle_pose_current)\n    sio_client.signal_robot_path.connect(view3d_backend.handle_robot_path)\n    sio_client.signal_tool_menu.connect(handle_tool_menu)\n    sio_client.signal_wizard_request.connect(handle_wizard_request)\n    sio_client.signal_close_wizard.connect(handle_close_wizard)\n    sio_client.signal_starter_changed.connect(handle_starter_changed)\n\n    sio_client.start()\n\n    ret = app.exec()\n\n    sio_client.stop()\n\n    sys.exit(ret)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/obstacle/","title":"obstacle","text":""},{"location":"reference/cogip/tools/monitor/shared_memory/","title":"shared_memory","text":""},{"location":"reference/cogip/tools/monitor/shared_memory/#cogip.tools.monitor.shared_memory.SharedMemoryManager","title":"<code>SharedMemoryManager</code>","text":"<p>Shared memory management.</p> Source code in <code>cogip/tools/monitor/shared_memory.py</code> <pre><code>class SharedMemoryManager(metaclass=Singleton):\n    \"\"\"\n    Shared memory management.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        self.robot_id: int | None = None\n        self.shared_memory: SharedMemory | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_lidar_data: NDArray | None = None\n        self.shared_lidar_data_lock: WritePriorityLock | None = None\n        self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n        self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n        self.shared_obstacles_lock: WritePriorityLock | None = None\n        self.shared_monitor_obstacles: SharedCircleList | None = None\n        self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n        self.shared_sim_camera_data: NDArray | None = None\n        self.shared_sim_camera_data_lock: WritePriorityLock | None = None\n        self.update_obstacles_timer: QTimer | None = None\n        self.view_item: QObject | None = None\n        self.scene_root: QObject | None = None\n\n    def set_scene(self, scene_root: QObject | None, view_item: QObject | None) -&gt; None:\n        self.scene_root = scene_root\n        self.view_item = view_item\n        if view_item is None and scene_root is None:\n            return\n        # Ensure QML side starts with empty obstacles so stale data is cleared\n        self.apply_obstacle_data([], [])\n\n    def connect(self, robot_id: int, virtual_planner: bool = False, virtual_detector: bool = False) -&gt; None:\n        logger.info(f\"Connecting to shared memory for robot {robot_id}\")\n        self.robot_id = robot_id\n        if virtual_planner or virtual_detector:\n            self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n        if virtual_planner:\n            self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n            self.shared_circle_obstacles = self.shared_memory.get_circle_obstacles()\n            self.shared_rectangle_obstacles = self.shared_memory.get_rectangle_obstacles()\n            self.shared_obstacles_lock = self.shared_memory.get_lock(LockName.Obstacles)\n            self.shared_obstacles_lock.register_consumer()\n            self.shared_sim_camera_data = self.shared_memory.get_sim_camera_data()\n            self.shared_sim_camera_data_lock = self.shared_memory.get_lock(LockName.SimCameraData)\n            if self.update_obstacles_timer is None:\n                self.update_obstacles_timer = QTimer()\n                self.update_obstacles_timer.setInterval(100)\n                self.update_obstacles_timer.timeout.connect(self.update_obstacles)\n            else:\n                self.update_obstacles_timer.stop()\n                self.update_obstacles_timer.setInterval(100)\n            self.update_obstacles_timer.start()\n            self.update_obstacles()\n        else:\n            if self.update_obstacles_timer is not None:\n                self.update_obstacles_timer.stop()\n            self.apply_obstacle_data([], [])\n\n        if virtual_detector:\n            self.shared_lidar_data = self.shared_memory.get_lidar_data()\n            self.shared_lidar_data_lock = self.shared_memory.get_lock(LockName.LidarData)\n            self.shared_monitor_obstacles = self.shared_memory.get_monitor_obstacles()\n            self.shared_monitor_obstacles_lock = self.shared_memory.get_lock(LockName.MonitorObstacles)\n\n    def disconnect(self) -&gt; None:\n        logger.info(f\"Disconnecting from shared memory for robot {self.robot_id}\")\n        self.shared_sim_camera_data_lock = None\n        self.shared_sim_camera_data = None\n        self.shared_monitor_obstacles_lock = None\n        self.shared_monitor_obstacles = None\n        self.shared_obstacles_lock = None\n        self.shared_rectangle_obstacles = None\n        self.shared_circle_obstacles = None\n        self.shared_lidar_data_lock = None\n        self.shared_lidar_data = None\n        self.shared_pose_current_buffer = None\n        self.shared_memory = None\n        self.robot_id = None\n        if self.update_obstacles_timer is not None:\n            self.update_obstacles_timer.stop()\n            self.update_obstacles_timer.deleteLater()\n            self.update_obstacles_timer = None\n        self.apply_obstacle_data([], [])\n\n    def update_obstacles(self) -&gt; None:\n        if self.shared_obstacles_lock is None:\n            return\n\n        rectangles: list[dict[str, float]] = []\n        circles: list[dict[str, float]] = []\n\n        self.shared_obstacles_lock.start_reading()\n        try:\n            if self.shared_rectangle_obstacles is not None:\n                for rectangle_obstacle in self.shared_rectangle_obstacles:\n                    center = rectangle_obstacle.center\n                    rect_data: dict[str, float] = {\n                        \"x\": center.x,\n                        \"y\": center.y,\n                        \"angle\": center.angle,\n                        \"length_x\": rectangle_obstacle.length_x,\n                        \"length_y\": rectangle_obstacle.length_y,\n                    }\n                    rect_data[\"bounding_box\"] = [\n                        {\"x\": vertex.x, \"y\": vertex.y} for vertex in rectangle_obstacle.bounding_box\n                    ]\n                    rectangles.append(rect_data)\n\n            if self.shared_circle_obstacles is not None:\n                for circle_obstacle in self.shared_circle_obstacles:\n                    center = circle_obstacle.center\n                    circle_data: dict[str, float] = {\n                        \"x\": center.x,\n                        \"y\": center.y,\n                        \"angle\": center.angle,\n                        \"radius\": circle_obstacle.radius,\n                    }\n                    circle_data[\"bounding_box\"] = [\n                        {\"x\": vertex.x, \"y\": vertex.y} for vertex in circle_obstacle.bounding_box\n                    ]\n                    circles.append(circle_data)\n        finally:\n            self.shared_obstacles_lock.finish_reading()\n\n        self.apply_obstacle_data(rectangles, circles)\n\n    def apply_obstacle_data(self, rectangles: list[dict[str, Any]], circles: list[dict[str, Any]]) -&gt; None:\n        targets = [self.view_item, self.scene_root]\n        for target in targets:\n            if target is None:\n                continue\n            if not Shiboken.isValid(target):\n                continue\n            target.setProperty(\"rectangleObstacles\", rectangles)\n            target.setProperty(\"circleObstacles\", circles)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/shared_memory/#cogip.tools.monitor.shared_memory.SharedMemoryManager.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/tools/monitor/shared_memory.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    self.robot_id: int | None = None\n    self.shared_memory: SharedMemory | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_lidar_data: NDArray | None = None\n    self.shared_lidar_data_lock: WritePriorityLock | None = None\n    self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n    self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n    self.shared_obstacles_lock: WritePriorityLock | None = None\n    self.shared_monitor_obstacles: SharedCircleList | None = None\n    self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n    self.shared_sim_camera_data: NDArray | None = None\n    self.shared_sim_camera_data_lock: WritePriorityLock | None = None\n    self.update_obstacles_timer: QTimer | None = None\n    self.view_item: QObject | None = None\n    self.scene_root: QObject | None = None\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/","title":"sio_client","text":""},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient","title":"<code>SocketioClient</code>","text":"<p>               Bases: <code>QObject</code></p> <p>This class controls the socket.io port used to communicate with the server. Its main purpose is to get the shell and tool menus to update the interface, get the robot position to update its position, and send the commands to the robot and to the tools.</p> <p>Attributes:</p> Name Type Description <code>signal_connected</code> <code>Signal</code> <p>Qt signal emitted on server connection state changes</p> <code>signal_exit</code> <code>Signal</code> <p>Qt signal emitted to exit Monitor</p> <code>signal_add_robot</code> <code>Signal</code> <p>Qt signal emitted to add a new robot</p> <code>signal_del_robot</code> <code>Signal</code> <p>Qt signal emitted to remove a robot</p> <code>signal_pose_current</code> <code>Signal</code> <p>Qt signal emitted on pose current update</p> <code>signal_robot_path</code> <code>Signal</code> <p>Qt signal emitted on robot path update</p> <code>signal_tool_menu</code> <code>Signal</code> <p>Qt signal emitted to load a new tool menu</p> <code>signal_config_request</code> <code>Signal</code> <p>Qt signal emitted on configuration requests</p> <code>signal_wizard_request</code> <code>Signal</code> <p>Qt signal emitted to forward wizard requests</p> <code>signal_starter_changed</code> <code>Signal</code> <p>Qt signal emitted the starter state has changed</p> Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>class SocketioClient(QtCore.QObject):\n    \"\"\"\n    This class controls the socket.io port used to communicate with the server.\n    Its main purpose is to get the shell and tool menus to update the interface,\n    get the robot position to update its position, and send the commands\n    to the robot and to the tools.\n\n    Attributes:\n        signal_connected:\n            Qt signal emitted on server connection state changes\n        signal_exit:\n            Qt signal emitted to exit Monitor\n        signal_add_robot:\n            Qt signal emitted to add a new robot\n        signal_del_robot:\n            Qt signal emitted to remove a robot\n        signal_pose_current:\n            Qt signal emitted on pose current update\n        signal_robot_path:\n            Qt signal emitted on robot path update\n        signal_tool_menu:\n            Qt signal emitted to load a new tool menu\n        signal_config_request:\n            Qt signal emitted on configuration requests\n        signal_wizard_request:\n            Qt signal emitted to forward wizard requests\n        signal_starter_changed:\n            Qt signal emitted the starter state has changed\n    \"\"\"\n\n    signal_connected: QtSignal = QtSignal(bool)\n    signal_exit: QtSignal = QtSignal()\n    signal_add_robot: QtSignal = QtSignal(int, bool, bool)\n    signal_del_robot: QtSignal = QtSignal(int)\n    signal_pose_current: QtSignal = QtSignal(models.Pose)\n    signal_robot_path: QtSignal = QtSignal(list)\n    signal_tool_menu: QtSignal = QtSignal(models.ShellMenu)\n    signal_config_request: QtSignal = QtSignal(dict)\n    signal_wizard_request: QtSignal = QtSignal(dict)\n    signal_close_wizard: QtSignal = QtSignal()\n    signal_starter_changed: QtSignal = QtSignal(bool)\n\n    def __init__(self, url: str):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            url: URL to socket.io server\n        \"\"\"\n        super().__init__()\n\n        self._url = url\n        self.sio = socketio.Client()\n        self.register_events()\n\n    @QtCore.Property(str, constant=True)\n    def url(self) -&gt; str:\n        return self._url\n\n    def start(self):\n        \"\"\"\n        Connect to socket.io server.\n        \"\"\"\n        # Poll in background to wait for the first connection.\n        # Disconnections/re-connections are handled directly by the client.\n        self.retry_connection = True\n        Thread(target=self.try_connect).start()\n\n    def try_connect(self):\n        while self.retry_connection:\n            try:\n                self.sio.connect(self._url, namespaces=[\"/monitor\", \"/dashboard\"])\n            except ConnectionError as ex:\n                logger.error(str(ex))\n                time.sleep(2)\n                continue\n            break\n\n    def stop(self):\n        \"\"\"\n        Disconnect from socket.io server.\n        \"\"\"\n        self.retry_connection = False\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    @QtSlot(str)\n    def tool_command(self, command: str):\n        \"\"\"\n        Send a command to the robot.\n\n        Arguments:\n            command: Command to send\n        \"\"\"\n        self.sio.emit(\"tool_cmd\", command, namespace=\"/dashboard\")\n\n    @QtSlot(str, str, str, \"QVariant\", bool)\n    def send_config_update(self, namespace: str, sio_event: str, name: str, value: object, is_integer: bool = False):\n        \"\"\"\n        Forward a configuration update to the server.\n\n        Arguments:\n            namespace: Socket.IO namespace to target\n            sio_event: Event name to emit (defaults to 'config_updated' when empty)\n            name: Property name\n            value: New property value\n            is_integer: Whether the value should be converted to an integer\n                (integers and floats are sent as floats from QML)\n        \"\"\"\n        value = int(value) if is_integer else value\n        payload = {\n            \"namespace\": namespace,\n            \"sio_event\": sio_event or \"config_updated\",\n            \"name\": name,\n            \"value\": value,\n        }\n        self.sio.emit(\"config_updated\", payload, namespace=\"/dashboard\")\n\n    @QtSlot(dict)\n    def wizard_response(self, response: dict[str, Any]):\n        if not response.get(\"namespace\"):\n            return\n        match response[\"type\"]:\n            case \"choice_integer\":\n                response[\"value\"] = int(response[\"value\"])\n            case \"choice_str_group\":\n                response[\"type\"] = \"choice_str\"\n        self.sio.emit(\"wizard\", response, namespace=\"/dashboard\")\n\n    @QtSlot(bool)\n    def starter_changed(self, pushed: bool):\n        self.sio.emit(\"starter_changed\", pushed, namespace=\"/dashboard\")\n\n    def register_events(self):\n        \"\"\"\n        Define socket.io message handlers.\n        \"\"\"\n\n        @self.sio.on(\"connect\", namespace=\"/dashboard\")\n        def dashboard_connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Dashboard connected to cogip-server\")\n            self.sio.emit(\"connected\", namespace=\"/dashboard\")\n\n        @self.sio.on(\"connect\", namespace=\"/monitor\")\n        def monitor_connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Monitor connected to cogip-server\")\n            self.sio.emit(\"connected\", namespace=\"/monitor\")\n            self.signal_connected.emit(True)\n\n        @self.sio.event(namespace=\"/monitor\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            if (\n                data\n                and isinstance(data, dict)\n                and (message := data.get(\"message\"))\n                and message == \"A monitor is already connected\"\n            ):\n                logger.error(f\"Error: {message}.\")\n                self.retry_connection = False\n                self.signal_exit.emit()\n                return\n            logger.error(f\"Monitor connection error: {data}\")\n            self.signal_connected.emit(False)\n\n        @self.sio.event(namespace=\"/dashboard\")\n        def dashboard_disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Dashboard disconnected from cogip-server\")\n\n        @self.sio.event(namespace=\"/monitor\")\n        def monitor_disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            self.signal_connected.emit(False)\n            logger.info(\"Monitor disconnected from cogip-server\")\n\n        @self.sio.on(\"add_robot\", namespace=\"/monitor\")\n        def on_add_robot(robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n            \"\"\"\n            Add a new robot.\n            \"\"\"\n            self.signal_add_robot.emit(int(robot_id), virtual_planner, virtual_detector)\n\n        @self.sio.on(\"del_robot\", namespace=\"/monitor\")\n        def on_del_robot(robot_id: int) -&gt; None:\n            \"\"\"\n            Remove a robot.\n            \"\"\"\n            self.signal_del_robot.emit(robot_id)\n\n        @self.sio.on(\"pose_current\", namespace=\"/dashboard\")\n        def on_pose_current(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n            \"\"\"\n            Callback on pose current message.\n            \"\"\"\n            try:\n                pose_current = models.Pose(**data)\n                self.signal_pose_current.emit(pose_current)\n            except ValidationError as exc:\n                logger.warning(\"Failed to decode pose current: %s\", exc)\n\n        @self.sio.on(\"path\", namespace=\"/dashboard\")\n        def on_path(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n            \"\"\"\n            Callback on robot path message.\n            \"\"\"\n            try:\n                path = TypeAdapter(list[models.Pose]).validate_python(data)\n                self.signal_robot_path.emit(path)\n            except ValidationError as exc:\n                logger.warning(\"Failed to decode robot path: %s\", exc)\n\n        @self.sio.on(\"tool_menu\", namespace=\"/dashboard\")\n        def on_tool_menu(data):\n            \"\"\"\n            Callback on tool menu message.\n            \"\"\"\n            try:\n                menu = models.ShellMenu.model_validate(data)\n            except ValidationError as exc:\n                logger.warning(\"Failed to decode tool menu: %s\", exc)\n                return\n\n            logger.info(\"Tool menu '%s' received with %d entries\", menu.name, len(menu.entries))\n            self.signal_tool_menu.emit(menu)\n\n        @self.sio.on(\"config\", namespace=\"/dashboard\")\n        def on_config(config):\n            \"\"\"\n            Callback on config request.\n            \"\"\"\n            logger.debug(\"Config received: %s\", config)\n            self.signal_config_request.emit(config)\n\n        @self.sio.on(\"wizard\", namespace=\"/dashboard\")\n        def on_wizard_request(data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Wizard request.\n            \"\"\"\n            if (\n                (choices := data.get(\"choices\"))\n                and isinstance(choices, list)\n                and choices\n                and isinstance(choices[0], list)\n            ):\n                data[\"type\"] = \"choice_str_group\"\n            self.signal_wizard_request.emit(data)\n\n        @self.sio.on(\"close_wizard\", namespace=\"/dashboard\")\n        def on_close_wizard() -&gt; None:\n            \"\"\"\n            Close wizard.\n            \"\"\"\n            self.signal_close_wizard.emit()\n\n        @self.sio.on(\"score\", namespace=\"/dashboard\")\n        def on_score(data: int) -&gt; None:\n            \"\"\"\n            Score.\n            \"\"\"\n            self.signal_wizard_request.emit(\n                {\n                    \"name\": \"Score\",\n                    \"type\": \"message\",\n                    \"value\": str(data),\n                    \"namespace\": \"\",\n                }\n            )\n\n        @self.sio.on(\"starter_changed\", namespace=\"/dashboard\")\n        def on_starter_changed(pushed: bool) -&gt; None:\n            \"\"\"\n            Change the state of a starter.\n            \"\"\"\n            self.signal_starter_changed.emit(pushed)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient.__init__","title":"<code>__init__(url)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to socket.io server</p> required Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>def __init__(self, url: str):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        url: URL to socket.io server\n    \"\"\"\n    super().__init__()\n\n    self._url = url\n    self.sio = socketio.Client()\n    self.register_events()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient.register_events","title":"<code>register_events()</code>","text":"<p>Define socket.io message handlers.</p> Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>def register_events(self):\n    \"\"\"\n    Define socket.io message handlers.\n    \"\"\"\n\n    @self.sio.on(\"connect\", namespace=\"/dashboard\")\n    def dashboard_connect():\n        \"\"\"\n        Callback on server connection.\n        \"\"\"\n        polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Dashboard connected to cogip-server\")\n        self.sio.emit(\"connected\", namespace=\"/dashboard\")\n\n    @self.sio.on(\"connect\", namespace=\"/monitor\")\n    def monitor_connect():\n        \"\"\"\n        Callback on server connection.\n        \"\"\"\n        polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Monitor connected to cogip-server\")\n        self.sio.emit(\"connected\", namespace=\"/monitor\")\n        self.signal_connected.emit(True)\n\n    @self.sio.event(namespace=\"/monitor\")\n    def connect_error(data):\n        \"\"\"\n        Callback on server connection error.\n        \"\"\"\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A monitor is already connected\"\n        ):\n            logger.error(f\"Error: {message}.\")\n            self.retry_connection = False\n            self.signal_exit.emit()\n            return\n        logger.error(f\"Monitor connection error: {data}\")\n        self.signal_connected.emit(False)\n\n    @self.sio.event(namespace=\"/dashboard\")\n    def dashboard_disconnect():\n        \"\"\"\n        Callback on server disconnection.\n        \"\"\"\n        logger.info(\"Dashboard disconnected from cogip-server\")\n\n    @self.sio.event(namespace=\"/monitor\")\n    def monitor_disconnect():\n        \"\"\"\n        Callback on server disconnection.\n        \"\"\"\n        self.signal_connected.emit(False)\n        logger.info(\"Monitor disconnected from cogip-server\")\n\n    @self.sio.on(\"add_robot\", namespace=\"/monitor\")\n    def on_add_robot(robot_id: int, virtual_planner: bool, virtual_detector: bool) -&gt; None:\n        \"\"\"\n        Add a new robot.\n        \"\"\"\n        self.signal_add_robot.emit(int(robot_id), virtual_planner, virtual_detector)\n\n    @self.sio.on(\"del_robot\", namespace=\"/monitor\")\n    def on_del_robot(robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n        \"\"\"\n        self.signal_del_robot.emit(robot_id)\n\n    @self.sio.on(\"pose_current\", namespace=\"/dashboard\")\n    def on_pose_current(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n        \"\"\"\n        Callback on pose current message.\n        \"\"\"\n        try:\n            pose_current = models.Pose(**data)\n            self.signal_pose_current.emit(pose_current)\n        except ValidationError as exc:\n            logger.warning(\"Failed to decode pose current: %s\", exc)\n\n    @self.sio.on(\"path\", namespace=\"/dashboard\")\n    def on_path(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n        \"\"\"\n        Callback on robot path message.\n        \"\"\"\n        try:\n            path = TypeAdapter(list[models.Pose]).validate_python(data)\n            self.signal_robot_path.emit(path)\n        except ValidationError as exc:\n            logger.warning(\"Failed to decode robot path: %s\", exc)\n\n    @self.sio.on(\"tool_menu\", namespace=\"/dashboard\")\n    def on_tool_menu(data):\n        \"\"\"\n        Callback on tool menu message.\n        \"\"\"\n        try:\n            menu = models.ShellMenu.model_validate(data)\n        except ValidationError as exc:\n            logger.warning(\"Failed to decode tool menu: %s\", exc)\n            return\n\n        logger.info(\"Tool menu '%s' received with %d entries\", menu.name, len(menu.entries))\n        self.signal_tool_menu.emit(menu)\n\n    @self.sio.on(\"config\", namespace=\"/dashboard\")\n    def on_config(config):\n        \"\"\"\n        Callback on config request.\n        \"\"\"\n        logger.debug(\"Config received: %s\", config)\n        self.signal_config_request.emit(config)\n\n    @self.sio.on(\"wizard\", namespace=\"/dashboard\")\n    def on_wizard_request(data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Wizard request.\n        \"\"\"\n        if (\n            (choices := data.get(\"choices\"))\n            and isinstance(choices, list)\n            and choices\n            and isinstance(choices[0], list)\n        ):\n            data[\"type\"] = \"choice_str_group\"\n        self.signal_wizard_request.emit(data)\n\n    @self.sio.on(\"close_wizard\", namespace=\"/dashboard\")\n    def on_close_wizard() -&gt; None:\n        \"\"\"\n        Close wizard.\n        \"\"\"\n        self.signal_close_wizard.emit()\n\n    @self.sio.on(\"score\", namespace=\"/dashboard\")\n    def on_score(data: int) -&gt; None:\n        \"\"\"\n        Score.\n        \"\"\"\n        self.signal_wizard_request.emit(\n            {\n                \"name\": \"Score\",\n                \"type\": \"message\",\n                \"value\": str(data),\n                \"namespace\": \"\",\n            }\n        )\n\n    @self.sio.on(\"starter_changed\", namespace=\"/dashboard\")\n    def on_starter_changed(pushed: bool) -&gt; None:\n        \"\"\"\n        Change the state of a starter.\n        \"\"\"\n        self.signal_starter_changed.emit(pushed)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient.send_config_update","title":"<code>send_config_update(namespace, sio_event, name, value, is_integer=False)</code>","text":"<p>Forward a configuration update to the server.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Socket.IO namespace to target</p> required <code>sio_event</code> <code>str</code> <p>Event name to emit (defaults to 'config_updated' when empty)</p> required <code>name</code> <code>str</code> <p>Property name</p> required <code>value</code> <code>object</code> <p>New property value</p> required <code>is_integer</code> <code>bool</code> <p>Whether the value should be converted to an integer (integers and floats are sent as floats from QML)</p> <code>False</code> Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>@QtSlot(str, str, str, \"QVariant\", bool)\ndef send_config_update(self, namespace: str, sio_event: str, name: str, value: object, is_integer: bool = False):\n    \"\"\"\n    Forward a configuration update to the server.\n\n    Arguments:\n        namespace: Socket.IO namespace to target\n        sio_event: Event name to emit (defaults to 'config_updated' when empty)\n        name: Property name\n        value: New property value\n        is_integer: Whether the value should be converted to an integer\n            (integers and floats are sent as floats from QML)\n    \"\"\"\n    value = int(value) if is_integer else value\n    payload = {\n        \"namespace\": namespace,\n        \"sio_event\": sio_event or \"config_updated\",\n        \"name\": name,\n        \"value\": value,\n    }\n    self.sio.emit(\"config_updated\", payload, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient.start","title":"<code>start()</code>","text":"<p>Connect to socket.io server.</p> Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>def start(self):\n    \"\"\"\n    Connect to socket.io server.\n    \"\"\"\n    # Poll in background to wait for the first connection.\n    # Disconnections/re-connections are handled directly by the client.\n    self.retry_connection = True\n    Thread(target=self.try_connect).start()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient.stop","title":"<code>stop()</code>","text":"<p>Disconnect from socket.io server.</p> Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Disconnect from socket.io server.\n    \"\"\"\n    self.retry_connection = False\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/sio_client/#cogip.tools.monitor.sio_client.SocketioClient.tool_command","title":"<code>tool_command(command)</code>","text":"<p>Send a command to the robot.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to send</p> required Source code in <code>cogip/tools/monitor/sio_client.py</code> <pre><code>@QtSlot(str)\ndef tool_command(self, command: str):\n    \"\"\"\n    Send a command to the robot.\n\n    Arguments:\n        command: Command to send\n    \"\"\"\n    self.sio.emit(\"tool_cmd\", command, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/table/","title":"table","text":""},{"location":"reference/cogip/tools/monitor/view3D/","title":"view3D","text":""},{"location":"reference/cogip/tools/monitor/artifacts/artifacts/","title":"artifacts","text":""},{"location":"reference/cogip/tools/monitor/robots/ninja_manual/","title":"ninja_manual","text":""},{"location":"reference/cogip/tools/monitor/robots/pami_manual/","title":"pami_manual","text":""},{"location":"reference/cogip/tools/monitor/robots/robot/","title":"robot","text":""},{"location":"reference/cogip/tools/monitor/robots/robot/#cogip.tools.monitor.robots.robot.Robot","title":"<code>Robot</code>","text":"Source code in <code>cogip/tools/monitor/robots/robot.py</code> <pre><code>class Robot:\n    update_pose_current_interval: int = 100\n\n    def __init__(\n        self,\n        root: QObject,\n        view: QObject | None,\n        robot_id: int,\n        virtual_planner: bool,\n        virtual_detector: bool,\n    ):\n        self.root = root\n        self.scene = self.root.parent() if self.root else None\n        self.view = view if view is not None else (self.scene.parent() if self.scene else None)\n        self.robot_id = robot_id\n        self.virtual_planner = virtual_planner\n        self.virtual_detector = virtual_detector\n        self.shm = SharedMemoryManager()\n        self.lidar_ray_nodes: dict[int, QObject] = {}\n        self.lidar_distances_changed: bool = False\n\n        self.node = self.root.findChild(QObject, \"Scene\")\n        self.models = [m for m in self.node.children() if m.metaObject().className() == \"QQuick3DModel\"]\n        for model in self.models:\n            model.setObjectName(f\"robot_{model.objectName()}\")\n\n        self.update_pose_current_timer = QTimer(self.root)\n        self.update_pose_current_timer.setInterval(Robot.update_pose_current_interval)\n        self.update_pose_current_timer.timeout.connect(self.update_pose_current_from_shm)\n\n        if self.virtual_planner:\n            self.update_pose_current_timer.start()\n\n        if self.virtual_detector:\n            for i in range(360):\n                self.shm.shared_lidar_data[i][0] = i\n                self.shm.shared_lidar_data[i][2] = 255\n            if self.robot_id &gt; 1:\n                for i in range(90, 270):\n                    self.shm.shared_lidar_data[i][1] = 65535\n            self.shm.shared_lidar_data[360][0] = -1\n\n            # Find Lidar ray nodes\n            if self.view is None:\n                logger.warning(\"Unable to locate View3D instance for lidar ray binding\")\n            else:\n                lidar_ray_nodes_prop: QJSValue = self.view.property(\"lidarRayNodes\")\n                it = QJSValueIterator(lidar_ray_nodes_prop)\n                while it.hasNext():\n                    it.next()\n                    try:\n                        index = int(it.name())\n                    except ValueError:\n                        continue\n                    q_object = it.value().toQObject()\n                    if not q_object:\n                        continue\n                    self.lidar_ray_nodes[index] = q_object\n\n                    try:\n                        signal_distance_changed: QtSignalInstance = q_object.distanceChanged\n                        if isinstance(signal_distance_changed, QtSignalInstance):\n                            signal_distance_changed.connect(partial(self.handle_distance_changed, index))\n                    except AttributeError:\n                        continue\n\n                try:\n                    signal_post_lidar_update: QtSignalInstance = self.view.postLidarUpdate\n                    if isinstance(signal_post_lidar_update, QtSignalInstance):\n                        signal_post_lidar_update.connect(self.post_lidar_update)\n                except AttributeError:\n                    logger.error(\"No postLidarUpdate signal found on view\")\n\n    def update_pose_current_from_shm(self) -&gt; None:\n        \"\"\"\n        Update pose current from shared memory.\n        \"\"\"\n        if self.shm.shared_pose_current_buffer is None:\n            return\n\n        pose_current = self.shm.shared_pose_current_buffer.last\n        if pose_current is None or self.root is None:\n            return\n\n        self.root.setProperty(\"x\", pose_current.x)\n        self.root.setProperty(\"y\", pose_current.y)\n        self.root.setProperty(\"eulerRotation\", QVector3D(0, 0, pose_current.angle))\n\n    def update_pose_current_from_model(self, pose_current: models.Pose) -&gt; None:\n        \"\"\"\n        Update pose current from model.\n        \"\"\"\n        self.root.setProperty(\"x\", pose_current.x)\n        self.root.setProperty(\"y\", pose_current.y)\n        self.root.setProperty(\"eulerRotation\", QVector3D(0, 0, pose_current.O))\n\n    def handle_distance_changed(self, index: int) -&gt; None:\n        q_object = self.lidar_ray_nodes.get(index)\n        if not q_object:\n            return\n        distance = q_object.property(\"distance\")\n        if abs(distance - self.shm.shared_lidar_data[index][1]) &lt; 1.0:\n            return\n        self.lidar_distances_changed = True\n        self.shm.shared_lidar_data[index][1] = distance\n\n    def post_lidar_update(self) -&gt; None:\n        \"\"\"\n        Post lidar update to shared memory if distances have changed.\n        \"\"\"\n        if self.lidar_distances_changed:\n            self.lidar_distances_changed = False\n            self.shm.shared_lidar_data_lock.post_update()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/robot/#cogip.tools.monitor.robots.robot.Robot.post_lidar_update","title":"<code>post_lidar_update()</code>","text":"<p>Post lidar update to shared memory if distances have changed.</p> Source code in <code>cogip/tools/monitor/robots/robot.py</code> <pre><code>def post_lidar_update(self) -&gt; None:\n    \"\"\"\n    Post lidar update to shared memory if distances have changed.\n    \"\"\"\n    if self.lidar_distances_changed:\n        self.lidar_distances_changed = False\n        self.shm.shared_lidar_data_lock.post_update()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/robot/#cogip.tools.monitor.robots.robot.Robot.update_pose_current_from_model","title":"<code>update_pose_current_from_model(pose_current)</code>","text":"<p>Update pose current from model.</p> Source code in <code>cogip/tools/monitor/robots/robot.py</code> <pre><code>def update_pose_current_from_model(self, pose_current: models.Pose) -&gt; None:\n    \"\"\"\n    Update pose current from model.\n    \"\"\"\n    self.root.setProperty(\"x\", pose_current.x)\n    self.root.setProperty(\"y\", pose_current.y)\n    self.root.setProperty(\"eulerRotation\", QVector3D(0, 0, pose_current.O))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/robot/#cogip.tools.monitor.robots.robot.Robot.update_pose_current_from_shm","title":"<code>update_pose_current_from_shm()</code>","text":"<p>Update pose current from shared memory.</p> Source code in <code>cogip/tools/monitor/robots/robot.py</code> <pre><code>def update_pose_current_from_shm(self) -&gt; None:\n    \"\"\"\n    Update pose current from shared memory.\n    \"\"\"\n    if self.shm.shared_pose_current_buffer is None:\n        return\n\n    pose_current = self.shm.shared_pose_current_buffer.last\n    if pose_current is None or self.root is None:\n        return\n\n    self.root.setProperty(\"x\", pose_current.x)\n    self.root.setProperty(\"y\", pose_current.y)\n    self.root.setProperty(\"eulerRotation\", QVector3D(0, 0, pose_current.angle))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/robot_manual/","title":"robot_manual","text":""},{"location":"reference/cogip/tools/monitor/robots/robot_order/","title":"robot_order","text":""},{"location":"reference/cogip/tools/monitor/robots/robot_order/#cogip.tools.monitor.robots.robot_order.RobotOrder","title":"<code>RobotOrder</code>","text":"Source code in <code>cogip/tools/monitor/robots/robot_order.py</code> <pre><code>class RobotOrder:\n    def __init__(self, root: QObject, robot_id: int):\n        self.root = root\n        self.robot_id = robot_id\n\n        principled_materials = [\n            m for m in self.root.children() if m.metaObject().className() == \"QQuick3DPrincipledMaterial\"\n        ]\n        for mat in principled_materials:\n            mat.setProperty(\"baseColor\", QColor(144, 238, 144, 150))  # RGBA: light green\n\n        self.node = self.root.findChild(QObject, \"Scene\")\n        self.models = [m for m in self.node.children() if m.metaObject().className() == \"QQuick3DModel\"]\n        for model in self.models:\n            model.setObjectName(f\"robot_order_{model.objectName()}\")\n\n    def set_pose_order(self, order: models.Pose) -&gt; None:\n        \"\"\"\n        Update pose order.\n        \"\"\"\n        self.root.setProperty(\"x\", order.x)\n        self.root.setProperty(\"y\", order.y)\n        self.root.setProperty(\"eulerRotation\", QVector3D(0, 0, order.O))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/robot_order/#cogip.tools.monitor.robots.robot_order.RobotOrder.set_pose_order","title":"<code>set_pose_order(order)</code>","text":"<p>Update pose order.</p> Source code in <code>cogip/tools/monitor/robots/robot_order.py</code> <pre><code>def set_pose_order(self, order: models.Pose) -&gt; None:\n    \"\"\"\n    Update pose order.\n    \"\"\"\n    self.root.setProperty(\"x\", order.x)\n    self.root.setProperty(\"y\", order.y)\n    self.root.setProperty(\"eulerRotation\", QVector3D(0, 0, order.O))\n</code></pre>"},{"location":"reference/cogip/tools/planner/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/planner/__main__/#cogip.tools.planner.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Game Planner.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-planner</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/planner/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Game Planner.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-planner` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actuators/","title":"actuators","text":""},{"location":"reference/cogip/tools/planner/actuators/#cogip.tools.planner.actuators.actuators_init","title":"<code>actuators_init(planner)</code>  <code>async</code>","text":"<p>Send actuators initialization command to the firmware.</p> Source code in <code>cogip/tools/planner/actuators.py</code> <pre><code>async def actuators_init(planner: \"Planner\"):\n    \"\"\"\n    Send actuators initialization command to the firmware.\n    \"\"\"\n    await planner.sio_ns.emit(\"actuator_init\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/cameras/","title":"cameras","text":""},{"location":"reference/cogip/tools/planner/camp/","title":"camp","text":""},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp","title":"<code>Camp</code>","text":"<p>Class representing the camp selected before the game starts.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>class Camp(metaclass=Singleton):\n    \"\"\"\n    Class representing the camp selected before the game starts.\n    \"\"\"\n\n    class Colors(IntEnum):\n        blue = 0\n        yellow = 1\n\n    def __init__(self, color: Colors = Colors.blue):\n        self.color = color\n\n    def adapt_y(self, dist: float) -&gt; float:\n        \"\"\"\n        Adapt Y distance depending on the selected camp.\n        Given the current table orientation and axes,\n        only Y has to be adapted when the camp changes.\n        \"\"\"\n        return dist if self.color == Camp.Colors.blue else -dist\n\n    def adapt_angle(self, angle: float | None) -&gt; float | None:\n        \"\"\"\n        Adapt an angle depending on the actual camp.\n        \"\"\"\n        if angle is None:\n            return None\n        return angle if self.color == Camp.Colors.blue else -angle\n</code></pre>"},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp.adapt_angle","title":"<code>adapt_angle(angle)</code>","text":"<p>Adapt an angle depending on the actual camp.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>def adapt_angle(self, angle: float | None) -&gt; float | None:\n    \"\"\"\n    Adapt an angle depending on the actual camp.\n    \"\"\"\n    if angle is None:\n        return None\n    return angle if self.color == Camp.Colors.blue else -angle\n</code></pre>"},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp.adapt_y","title":"<code>adapt_y(dist)</code>","text":"<p>Adapt Y distance depending on the selected camp. Given the current table orientation and axes, only Y has to be adapted when the camp changes.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>def adapt_y(self, dist: float) -&gt; float:\n    \"\"\"\n    Adapt Y distance depending on the selected camp.\n    Given the current table orientation and axes,\n    only Y has to be adapted when the camp changes.\n    \"\"\"\n    return dist if self.color == Camp.Colors.blue else -dist\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/","title":"context","text":""},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext","title":"<code>GameContext</code>","text":"<p>A class recording the current game context.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>class GameContext:\n    \"\"\"\n    A class recording the current game context.\n    \"\"\"\n\n    def __init__(self, shared_properties: SharedProperties, initialize: bool = True):\n        self.shared_properties = shared_properties\n        if initialize:\n            self.minimum_score: int = 0\n            self.game_duration: int = 100\n            self.score = self.minimum_score\n            self.tribunes_in_robot = 0\n            self.construction_areas: dict[ConstructionAreaID, ConstructionArea] = {}\n            self.opponent_construction_areas: dict[ConstructionAreaID, ConstructionArea] = {}\n            self.tribunes: dict[TribuneID, Tribune] = {}\n            self.fixed_obstacles: dict[FixedObstacleID, FixedObstacle] = {}\n            self.positional_actuator_states: dict[PositionalActuatorEnum, PositionalActuator] = {}\n            self.bool_sensor_states: dict[BoolSensorEnum, BoolSensor] = {}\n            self.emulated_actuator_states: set[PositionalActuatorEnum] = {}\n            self.reset()\n\n    def reset(self):\n        \"\"\"\n        Reset the context.\n        \"\"\"\n        self.score = self.minimum_score\n        self.countdown = self.game_duration\n        self.last_countdown = self.game_duration\n        self.tribunes_in_robot = 0\n        self.create_artifacts()\n        self.create_fixed_obstacles()\n        self.create_actuators_states()\n\n    def deepcopy(self):\n        \"\"\"\n        Return a deep copy of the GameContext instance.\n        \"\"\"\n        new_ctx = GameContext(self.shared_properties, initialize=False)\n        new_ctx.game_duration = self.game_duration\n        new_ctx.minimum_score = self.minimum_score\n        new_ctx.score = self.score\n        new_ctx.countdown = self.countdown\n        new_ctx.last_countdown = self.last_countdown\n        new_ctx.tribunes_in_robot = self.tribunes_in_robot\n        new_ctx.construction_areas = {k: v.model_copy() for k, v in self.construction_areas.items()}\n        new_ctx.tribunes = {k: v.model_copy() for k, v in self.tribunes.items()}\n        new_ctx.fixed_obstacles = {k: v.model_copy() for k, v in self.fixed_obstacles.items()}\n        # Do not copy artifacts that are not used in actions but keep the code in comments to no forget\n        # that this copy function is only a partial copy.\n        # new_ctx.opponent_construction_areas = {\n        #     k: v.model_copy(deep=True) for k, v in self.opponent_construction_areas.items()\n        # }\n        # new_ctx.positional_actuator_states = {\n        #     k: v.model_copy(deep=True) for k, v in self.positional_actuator_states.items()\n        # }\n        return new_ctx\n\n    def create_artifacts(self):\n        # Positions are related to the default camp blue.\n        self.construction_areas: dict[ConstructionAreaID, ConstructionArea] = {}\n        self.opponent_construction_areas: dict[ConstructionAreaID, ConstructionArea] = {}\n        self.tribunes: dict[TribuneID, Tribune] = {}\n\n        # Construction areas\n        for id, area in construction_area_positions.items():\n            adapted_pose = AdaptedPose(**area.model_dump())\n            self.construction_areas[id] = ConstructionAreaSmall(**adapted_pose.model_dump(), id=id, enabled=False)\n            self.opponent_construction_areas[id] = ConstructionAreaSmall(\n                x=adapted_pose.x,\n                y=-adapted_pose.y,\n                O=-adapted_pose.O,\n                id=id,\n            )\n\n        self.opponent_construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled = False\n        self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled = False\n        if self.shared_properties.table == TableEnum.Training:\n            self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge1].enabled = False\n            self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled = False\n            self.opponent_construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled = False\n\n        # Tribunes\n        for id, tribune in tribune_positions.items():\n            adapted_pose = AdaptedPose(**tribune.model_dump())\n            self.tribunes[id] = Tribune(**adapted_pose.model_dump(), id=id)\n\n        if self.shared_properties.table == TableEnum.Training:\n            self.tribunes[TribuneID.LocalTop] = self.tribunes[TribuneID.LocalTopTraining].model_copy(\n                update={\"id\": TribuneID.LocalTop}\n            )\n            self.tribunes[TribuneID.LocalTop].x -= 73.0 / 2\n            self.tribunes[TribuneID.LocalCenter].x -= 73.0 / 2\n        del self.tribunes[TribuneID.LocalTopTraining]\n\n    def create_fixed_obstacles(self):\n        # Positions are related to the default camp blue.\n        self.fixed_obstacles: dict[FixedObstacleID, FixedObstacle] = {}\n\n        # Ramp\n        self.fixed_obstacles[FixedObstacleID.Ramp] = FixedObstacle(\n            **AdaptedPose(x=900, y=-650).model_dump(),\n            length=400,\n            width=200,\n            id=FixedObstacleID.Ramp,\n        )\n\n        # Scene\n        self.fixed_obstacles[FixedObstacleID.Scene] = FixedObstacle(\n            **AdaptedPose(x=825, y=-225).model_dump(),\n            length=450,\n            width=450,\n            id=FixedObstacleID.Scene,\n        )\n\n        # Pami 5 path\n        self.fixed_obstacles[FixedObstacleID.Pami5Path] = FixedObstacle(\n            **AdaptedPose(x=930, y=-1175).model_dump(),\n            length=650,\n            width=50,\n            id=FixedObstacleID.Pami5Path,\n        )\n\n        # Opponent ramp\n        self.fixed_obstacles[FixedObstacleID.OpponentRamp] = FixedObstacle(\n            **AdaptedPose(x=900, y=650).model_dump(),\n            length=400,\n            width=200,\n            id=FixedObstacleID.OpponentRamp,\n        )\n\n        # Opponent scene\n        self.fixed_obstacles[FixedObstacleID.OpponentScene] = FixedObstacle(\n            **AdaptedPose(x=825, y=225).model_dump(),\n            length=450,\n            width=450,\n            id=FixedObstacleID.OpponentScene,\n        )\n\n        # Backstage\n        self.fixed_obstacles[FixedObstacleID.Backstage] = FixedObstacle(\n            **AdaptedPose(x=1000 - 450 / 2, y=-1500 + 150 + 450 / 2).model_dump(),\n            length=450,\n            width=450,\n            enabled=False,\n            id=FixedObstacleID.Backstage,\n        )\n\n        # PAMIs starting area for robot ID 1, the main robot.\n        if self.shared_properties.robot_id == 1:\n            self.fixed_obstacles[FixedObstacleID.PamiStartArea] = FixedObstacle(\n                **AdaptedPose(x=825, y=-1425).model_dump(),\n                length=150,\n                width=450,\n                id=FixedObstacleID.PamiStartArea,\n            )\n\n            self.fixed_obstacles[FixedObstacleID.PitArea] = FixedObstacle(\n                **AdaptedPose(x=375, y=-350).model_dump(),\n                length=700,\n                width=350,\n                enabled=False,\n                id=FixedObstacleID.PitArea,\n            )\n\n            self.fixed_obstacles[FixedObstacleID.OpponentPitArea] = FixedObstacle(\n                **AdaptedPose(x=375, y=350).model_dump(),\n                length=700,\n                width=350,\n                enabled=False,\n                id=FixedObstacleID.OpponentPitArea,\n            )\n\n        if (\n            self.shared_properties.robot_id == 1\n            and self.shared_properties.table == TableEnum.Training\n            or self.shared_properties.robot_id == 5\n        ):\n            self.fixed_obstacles[FixedObstacleID.Ramp].enabled = False\n            self.fixed_obstacles[FixedObstacleID.Scene].enabled = False\n            self.fixed_obstacles[FixedObstacleID.Pami5Path].enabled = False\n\n        if self.shared_properties.table == TableEnum.Training:\n            for obstacle in self.fixed_obstacles.values():\n                obstacle.x -= 1000\n\n    def create_actuators_states(self):\n        self.positional_actuator_states: dict[PositionalActuatorEnum, PositionalActuator] = {}\n        self.bool_sensor_states: dict[BoolSensorEnum, BoolSensor] = {id: BoolSensor(id=id) for id in BoolSensorEnum}\n        self.emulated_actuator_states: set[PositionalActuatorEnum] = {}\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.deepcopy","title":"<code>deepcopy()</code>","text":"<p>Return a deep copy of the GameContext instance.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>def deepcopy(self):\n    \"\"\"\n    Return a deep copy of the GameContext instance.\n    \"\"\"\n    new_ctx = GameContext(self.shared_properties, initialize=False)\n    new_ctx.game_duration = self.game_duration\n    new_ctx.minimum_score = self.minimum_score\n    new_ctx.score = self.score\n    new_ctx.countdown = self.countdown\n    new_ctx.last_countdown = self.last_countdown\n    new_ctx.tribunes_in_robot = self.tribunes_in_robot\n    new_ctx.construction_areas = {k: v.model_copy() for k, v in self.construction_areas.items()}\n    new_ctx.tribunes = {k: v.model_copy() for k, v in self.tribunes.items()}\n    new_ctx.fixed_obstacles = {k: v.model_copy() for k, v in self.fixed_obstacles.items()}\n    # Do not copy artifacts that are not used in actions but keep the code in comments to no forget\n    # that this copy function is only a partial copy.\n    # new_ctx.opponent_construction_areas = {\n    #     k: v.model_copy(deep=True) for k, v in self.opponent_construction_areas.items()\n    # }\n    # new_ctx.positional_actuator_states = {\n    #     k: v.model_copy(deep=True) for k, v in self.positional_actuator_states.items()\n    # }\n    return new_ctx\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.reset","title":"<code>reset()</code>","text":"<p>Reset the context.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the context.\n    \"\"\"\n    self.score = self.minimum_score\n    self.countdown = self.game_duration\n    self.last_countdown = self.game_duration\n    self.tribunes_in_robot = 0\n    self.create_artifacts()\n    self.create_fixed_obstacles()\n    self.create_actuators_states()\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/","title":"event_manager","text":""},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager","title":"<code>EventManager</code>","text":"<p>Manages asynchronous events and tasks for the Planner.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>class EventManager:\n    \"\"\"\n    Manages asynchronous events and tasks for the Planner.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        self.planner = planner\n        self.blocked_event_task: asyncio.Task | None = None\n        self.new_path_event_task: asyncio.Task | None = None\n        self.countdown_task: asyncio.Task | None = None\n\n    async def start_loops(self):\n        \"\"\"Start all async event loops.\"\"\"\n        self.blocked_event_task = asyncio.create_task(\n            self.blocked_event_loop(),\n            name=\"Planner: Task Blocked Event Watcher Loop\",\n        )\n        self.new_path_event_task = asyncio.create_task(\n            self.new_path_event_loop(),\n            name=\"Planner: Task New Path Event Watcher Loop\",\n        )\n        await self.countdown_start()\n\n    async def stop_loops(self):\n        \"\"\"Stop all async event loops.\"\"\"\n        await self.countdown_stop()\n\n        if self.blocked_event_task:\n            self.blocked_event_task.cancel()\n            try:\n                await self.blocked_event_task\n            except asyncio.CancelledError:\n                logger.info(\"Planner: Task Blocked Event Watcher Loop stopped\")\n            except Exception as exc:\n                logger.warning(f\"Planner: Unexpected exception {exc}\")\n            self.blocked_event_task = None\n\n        if self.new_path_event_task:\n            self.new_path_event_task.cancel()\n            try:\n                await self.new_path_event_task\n            except asyncio.CancelledError:\n                logger.info(\"Planner: Task New Path Event Watcher Loop stopped\")\n            except Exception as exc:\n                logger.warning(f\"Planner: Unexpected exception {exc}\")\n                traceback.print_exc()\n            self.new_path_event_task = None\n\n    async def blocked_event_loop(self):\n        \"\"\"Watches for robot blocked events.\"\"\"\n        logger.info(\"Planner: Task Blocked Event Watcher Loop started\")\n        try:\n            while True:\n                updated = await asyncio.to_thread(self.planner.shared_avoidance_blocked_lock.wait_update, 1.0)\n                if not updated:\n                    continue\n                if self.planner.sio.connected:\n                    await self.planner.sio_ns.emit(\"brake\")\n                self.planner.blocked_counter += 1\n                if self.planner.blocked_counter &gt; 10:\n                    self.planner.blocked_counter = 0\n                    await self.planner.blocked()\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Blocked Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Task Blocked Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def new_path_event_loop(self):\n        \"\"\"Watches for new path events.\"\"\"\n        logger.info(\"Planner: Task New Path Event Watcher Loop started\")\n        try:\n            while True:\n                updated = await asyncio.to_thread(self.planner.shared_avoidance_path_lock.wait_update, 1.0)\n                if not updated:\n                    continue\n                self.planner.blocked_counter = 0\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task New Path Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def countdown_loop(self):\n        \"\"\"Manages the game countdown.\"\"\"\n        logger.info(\"Planner: Task Countdown started\")\n        try:\n            self.planner.game_context.last_countdown = self.planner.game_context.countdown\n            while True:\n                await asyncio.sleep(0.2)\n\n                if not self.planner.playing:\n                    continue\n\n                now = datetime.now(UTC)\n                self.planner.game_context.countdown = (\n                    self.planner.game_context.game_duration\n                    - (now - self.planner.countdown_start_timestamp).total_seconds()\n                )\n\n                logger.info(f\"Planner: countdown = {self.planner.game_context.countdown: 3.2f}\")\n                if (\n                    self.planner.robot_id &gt; 1\n                    and self.planner.game_context.countdown &lt; 15\n                    and self.planner.game_context.last_countdown &gt; 15\n                ):\n                    logger.info(\"Planner: countdown==15: start PAMI\")\n                    self.planner.pami_event.set()\n                if (\n                    self.planner.robot_id == 1\n                    and self.planner.game_context.countdown &lt; 7\n                    and self.planner.game_context.last_countdown &gt; 7\n                ):\n                    logger.info(\"Planner: countdown==7: disable GOAP, force blocked\")\n                    self.planner.strategy.goap_allowed = False\n                    asyncio.create_task(self.planner.blocked())\n                if self.planner.game_context.countdown &lt; 0 and self.planner.game_context.last_countdown &gt; 0:\n                    logger.info(\"Planner: countdown==0: final action\")\n                    await self.planner.final_action()\n                if self.planner.game_context.countdown &lt; -5 and self.planner.game_context.last_countdown &gt; -5:\n                    await self.planner.sio_ns.emit(\"stop_video_record\")\n                self.planner.game_context.last_countdown = self.planner.game_context.countdown\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Countdown cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Unknown exception {exc}\")\n            raise\n\n    async def countdown_start(self):\n        \"\"\"Starts the countdown task.\"\"\"\n        await self.countdown_stop()\n        self.countdown_task = asyncio.create_task(self.countdown_loop())\n\n    async def countdown_stop(self):\n        \"\"\"Stops the countdown task.\"\"\"\n        if self.countdown_task is None:\n            return\n\n        self.countdown_task.cancel()\n        try:\n            await self.countdown_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Countdown stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n\n        self.countdown_task = None\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.blocked_event_loop","title":"<code>blocked_event_loop()</code>  <code>async</code>","text":"<p>Watches for robot blocked events.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def blocked_event_loop(self):\n    \"\"\"Watches for robot blocked events.\"\"\"\n    logger.info(\"Planner: Task Blocked Event Watcher Loop started\")\n    try:\n        while True:\n            updated = await asyncio.to_thread(self.planner.shared_avoidance_blocked_lock.wait_update, 1.0)\n            if not updated:\n                continue\n            if self.planner.sio.connected:\n                await self.planner.sio_ns.emit(\"brake\")\n            self.planner.blocked_counter += 1\n            if self.planner.blocked_counter &gt; 10:\n                self.planner.blocked_counter = 0\n                await self.planner.blocked()\n    except asyncio.CancelledError:\n        logger.info(\"Planner: Task Blocked Event Watcher Loop cancelled\")\n        raise\n    except Exception as exc:  # noqa\n        logger.warning(f\"Planner: Task Blocked Event Watcher Loop: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.countdown_loop","title":"<code>countdown_loop()</code>  <code>async</code>","text":"<p>Manages the game countdown.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def countdown_loop(self):\n    \"\"\"Manages the game countdown.\"\"\"\n    logger.info(\"Planner: Task Countdown started\")\n    try:\n        self.planner.game_context.last_countdown = self.planner.game_context.countdown\n        while True:\n            await asyncio.sleep(0.2)\n\n            if not self.planner.playing:\n                continue\n\n            now = datetime.now(UTC)\n            self.planner.game_context.countdown = (\n                self.planner.game_context.game_duration\n                - (now - self.planner.countdown_start_timestamp).total_seconds()\n            )\n\n            logger.info(f\"Planner: countdown = {self.planner.game_context.countdown: 3.2f}\")\n            if (\n                self.planner.robot_id &gt; 1\n                and self.planner.game_context.countdown &lt; 15\n                and self.planner.game_context.last_countdown &gt; 15\n            ):\n                logger.info(\"Planner: countdown==15: start PAMI\")\n                self.planner.pami_event.set()\n            if (\n                self.planner.robot_id == 1\n                and self.planner.game_context.countdown &lt; 7\n                and self.planner.game_context.last_countdown &gt; 7\n            ):\n                logger.info(\"Planner: countdown==7: disable GOAP, force blocked\")\n                self.planner.strategy.goap_allowed = False\n                asyncio.create_task(self.planner.blocked())\n            if self.planner.game_context.countdown &lt; 0 and self.planner.game_context.last_countdown &gt; 0:\n                logger.info(\"Planner: countdown==0: final action\")\n                await self.planner.final_action()\n            if self.planner.game_context.countdown &lt; -5 and self.planner.game_context.last_countdown &gt; -5:\n                await self.planner.sio_ns.emit(\"stop_video_record\")\n            self.planner.game_context.last_countdown = self.planner.game_context.countdown\n    except asyncio.CancelledError:\n        logger.info(\"Planner: Task Countdown cancelled\")\n        raise\n    except Exception as exc:  # noqa\n        logger.warning(f\"Planner: Unknown exception {exc}\")\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.countdown_start","title":"<code>countdown_start()</code>  <code>async</code>","text":"<p>Starts the countdown task.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def countdown_start(self):\n    \"\"\"Starts the countdown task.\"\"\"\n    await self.countdown_stop()\n    self.countdown_task = asyncio.create_task(self.countdown_loop())\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.countdown_stop","title":"<code>countdown_stop()</code>  <code>async</code>","text":"<p>Stops the countdown task.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def countdown_stop(self):\n    \"\"\"Stops the countdown task.\"\"\"\n    if self.countdown_task is None:\n        return\n\n    self.countdown_task.cancel()\n    try:\n        await self.countdown_task\n    except asyncio.CancelledError:\n        logger.info(\"Planner: Task Countdown stopped\")\n    except Exception as exc:\n        logger.warning(f\"Planner: Unexpected exception {exc}\")\n\n    self.countdown_task = None\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.new_path_event_loop","title":"<code>new_path_event_loop()</code>  <code>async</code>","text":"<p>Watches for new path events.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def new_path_event_loop(self):\n    \"\"\"Watches for new path events.\"\"\"\n    logger.info(\"Planner: Task New Path Event Watcher Loop started\")\n    try:\n        while True:\n            updated = await asyncio.to_thread(self.planner.shared_avoidance_path_lock.wait_update, 1.0)\n            if not updated:\n                continue\n            self.planner.blocked_counter = 0\n    except asyncio.CancelledError:\n        logger.info(\"Planner: Task New Path Event Watcher Loop cancelled\")\n        raise\n    except Exception as exc:  # noqa\n        logger.warning(f\"Planner: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.start_loops","title":"<code>start_loops()</code>  <code>async</code>","text":"<p>Start all async event loops.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def start_loops(self):\n    \"\"\"Start all async event loops.\"\"\"\n    self.blocked_event_task = asyncio.create_task(\n        self.blocked_event_loop(),\n        name=\"Planner: Task Blocked Event Watcher Loop\",\n    )\n    self.new_path_event_task = asyncio.create_task(\n        self.new_path_event_loop(),\n        name=\"Planner: Task New Path Event Watcher Loop\",\n    )\n    await self.countdown_start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/event_manager/#cogip.tools.planner.event_manager.EventManager.stop_loops","title":"<code>stop_loops()</code>  <code>async</code>","text":"<p>Stop all async event loops.</p> Source code in <code>cogip/tools/planner/event_manager.py</code> <pre><code>async def stop_loops(self):\n    \"\"\"Stop all async event loops.\"\"\"\n    await self.countdown_stop()\n\n    if self.blocked_event_task:\n        self.blocked_event_task.cancel()\n        try:\n            await self.blocked_event_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Blocked Event Watcher Loop stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n        self.blocked_event_task = None\n\n    if self.new_path_event_task:\n        self.new_path_event_task.cancel()\n        try:\n            await self.new_path_event_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task New Path Event Watcher Loop stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n            traceback.print_exc()\n        self.new_path_event_task = None\n</code></pre>"},{"location":"reference/cogip/tools/planner/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/planner/planner/","title":"planner","text":""},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner","title":"<code>Planner</code>","text":"<p>Main planner class.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>class Planner:\n    \"\"\"\n    Main planner class.\n    \"\"\"\n\n    def __init__(\n        self,\n        robot_id: int,\n        server_url: str,\n        robot_width: int,\n        robot_length: int,\n        obstacle_radius: int,\n        obstacle_bb_margin: float,\n        obstacle_bb_vertices: int,\n        obstacle_updater_interval: float,\n        path_refresh_interval: float,\n        starter_pin: int | None,\n        led_red_pin: int | None,\n        led_green_pin: int | None,\n        led_blue_pin: int | None,\n        flag_motor_pin: int | None,\n        oled_bus: int | None,\n        oled_address: int | None,\n        bypass_detector: bool,\n        scservos_port: Path | None,\n        scservos_baud_rate: int,\n        disable_fixed_obstacles: bool,\n        table: TableEnum,\n        strategy_enum: StrategyEnum,\n        start_position: StartPositionEnum,\n        avoidance_strategy: AvoidanceStrategy,\n        goap_depth: int,\n        debug: bool,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            robot_id: Robot ID\n            server_url: Socket.IO Server URL\n            robot_width: Width of the robot (in mm)\n            robot_length: Length of the robot (in mm)\n            obstacle_radius: Radius of a dynamic obstacle (in mm)\n            obstacle_bb_margin: Obstacle bounding box margin in percent of the radius\n            obstacle_bb_vertices: Number of obstacle bounding box vertices\n            obstacle_updater_interval: Interval between each send of obstacles to dashboards (in seconds)\n            path_refresh_interval: Interval between each update of robot paths (in seconds)\n            starter_pin: GPIO pin connected to the starter\n            led_red_pin: GPIO pin connected to the red LED\n            led_green_pin: GPIO pin connected to the green LED\n            led_blue_pin: GPIO pin connected to the blue LED\n            flag_motor_pin: GPIO pin connected to the flag motor\n            oled_bus: PAMI OLED display i2c bus\n            oled_address: PAMI OLED display i2c address\n            bypass_detector: Use perfect obstacles from monitor instead of detected obstacles by Lidar\n            scservos_port: SC Servos serial port\n            scservos_baud_rate: SC Servos baud rate (usually 921600 or 1000000)\n            disable_fixed_obstacles: Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance\n            table: Default table on startup\n            strategy_enum: Default strategy on startup\n            start_position: Default start position on startup\n            avoidance_strategy: Default avoidance strategy on startup\n            goap_depth: Depth of the GOAP search tree\n            debug: enable debug messages\n        \"\"\"\n        self.robot_id = robot_id\n        self.server_url = server_url\n        self.oled_bus = oled_bus\n        self.oled_address = oled_address\n        self.scservos_port = scservos_port\n        self.scservos_baud_rate = scservos_baud_rate\n        self.debug = debug\n\n        self.shared_memory: SharedMemory | None = None\n        self.shared_properties: SharedProperties | None = None\n        self.shared_pose_current_lock: WritePriorityLock | None = None\n        self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n        self.shared_table_limits: NDArray | None = None\n        self.shared_detector_obstacles: SharedCircleList | None = None\n        self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n        self.shared_monitor_obstacles: SharedCircleList | None = None\n        self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n        self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n        self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n        self.shared_obstacles_lock: WritePriorityLock | None = None\n        self.shared_avoidance_pose_order: SharedPoseOrder | None = None\n        self.shared_avoidance_blocked_lock: WritePriorityLock | None = None\n        self.shared_avoidance_path: SharedPoseOrderList | None = None\n        self.shared_avoidance_path_lock: WritePriorityLock | None = None\n        self.create_shared_memory()\n\n        # Fix type checker after shared memory creation\n        self.shared_properties: SharedProperties\n\n        # Update shared memory properties\n        self.shared_properties.robot_id = robot_id\n        self.shared_properties.robot_width = robot_width\n        self.shared_properties.robot_length = robot_length\n        self.shared_properties.obstacle_radius = obstacle_radius\n        self.shared_properties.obstacle_bb_margin = obstacle_bb_margin\n        self.shared_properties.obstacle_bb_vertices = obstacle_bb_vertices\n        self.shared_properties.obstacle_updater_interval = obstacle_updater_interval\n        self.shared_properties.path_refresh_interval = path_refresh_interval\n        self.shared_properties.bypass_detector = bypass_detector\n        self.shared_properties.disable_fixed_obstacles = disable_fixed_obstacles\n        self.shared_properties.table = table.val\n        self.shared_properties.strategy = strategy_enum.val\n        self.shared_properties.start_position = start_position.val\n        self.shared_properties.avoidance_strategy = avoidance_strategy.val\n        self.shared_properties.goap_depth = goap_depth\n\n        self.virtual = platform.machine() != \"aarch64\"\n        self.retry_connection = True\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_ns = sio_events.SioEvents(self)\n        self.sio.register_namespace(self.sio_ns)\n        self.game_context = GameContext(self.shared_properties)\n        self.camp = Camp()\n        self.start_positions = StartPositions(self.shared_properties)\n        self.process_manager = Manager()\n        self.action: action.Action | None = None\n        self.strategy = strategy_classes.get(self.shared_properties.strategy, strategy.Strategy)(self)\n        self.obstacles_updater_loop = AsyncLoop(\n            \"Obstacles updater loop\",\n            obstacle_updater_interval,\n            self.update_obstacles,\n            logger=self.debug,\n        )\n        self.playing: bool = False\n        self._pose_order: pose.Pose | None = None\n        self.pose_reached: bool = True\n        self.blocked_counter: int = 0\n        self.controller = self.default_controller\n        self.game_wizard = GameWizard(self)\n        self.event_manager = EventManager(self)\n        self.scservos = SCServos(self.scservos_port, scservos_baud_rate)\n        self.pami_event = asyncio.Event()\n        self.last_starter_event_timestamp: datetime | None = None\n        self.countdown_start_timestamp: datetime = datetime.now(UTC)\n\n        if not self.start_positions.is_valid(start_position):\n            logger.error(f\"Start position {start_position.name} invalid in current table and camp\")\n            sys.exit(1)\n\n        self.avoidance_process: Process | None = None\n\n        if starter_pin:\n            self.starter = Button(\n                starter_pin,\n                pull_up=False,\n                bounce_time=None,\n            )\n        else:\n            self.starter = Button(\n                17,\n                pull_up=True,\n                pin_factory=MockFactory(),\n            )\n        self.starter.when_activated = partial(self.starter_changed_callback, True)\n        self.starter.when_deactivated = partial(self.starter_changed_callback, False)\n\n        if led_red_pin and led_green_pin and led_blue_pin:\n            self.led = RGBLED(\n                led_red_pin,\n                led_green_pin,\n                led_blue_pin,\n                initial_value=(1, 0, 0),\n            )\n        else:\n            self.led = Mock()\n\n        if flag_motor_pin:\n            self.flag_motor = OutputDevice(flag_motor_pin)\n        else:\n            self.flag_motor = Mock()\n\n        if self.oled_bus and self.oled_address:\n            self.oled_serial = i2c(port=self.oled_bus, address=self.oled_address)\n            self.oled_device = sh1106(self.oled_serial)\n            self.oled_font = ImageFont.truetype(\"DejaVuSansMono.ttf\", 9)\n            self.oled_image = canvas(self.oled_device)\n            self.oled_update_loop = AsyncLoop(\n                \"OLED display update loop\",\n                0.5,\n                self.update_oled_display,\n                logger=self.debug,\n            )\n\n    def create_shared_memory(self):\n        if self.shared_memory is None:\n            self.shared_memory = SharedMemory(f\"cogip_{self.robot_id}\")\n            self.shared_properties = self.shared_memory.get_properties()\n            self.shared_pose_current_lock = self.shared_memory.get_lock(LockName.PoseCurrent)\n            self.shared_pose_current_buffer = self.shared_memory.get_pose_current_buffer()\n            self.shared_table_limits = self.shared_memory.get_table_limits()\n            self.shared_detector_obstacles = self.shared_memory.get_detector_obstacles()\n            self.shared_detector_obstacles_lock = self.shared_memory.get_lock(LockName.DetectorObstacles)\n            self.shared_monitor_obstacles = self.shared_memory.get_monitor_obstacles()\n            self.shared_monitor_obstacles_lock = self.shared_memory.get_lock(LockName.MonitorObstacles)\n            self.shared_circle_obstacles = self.shared_memory.get_circle_obstacles()\n            self.shared_rectangle_obstacles = self.shared_memory.get_rectangle_obstacles()\n            self.shared_obstacles_lock = self.shared_memory.get_lock(LockName.Obstacles)\n            self.shared_avoidance_pose_order = self.shared_memory.get_avoidance_pose_order()\n            self.shared_avoidance_blocked_lock = self.shared_memory.get_lock(LockName.AvoidanceBlocked)\n            self.shared_avoidance_blocked_lock.reset()\n            self.shared_avoidance_blocked_lock.register_consumer()\n            self.shared_avoidance_path = self.shared_memory.get_avoidance_path()\n            self.shared_avoidance_path_lock = self.shared_memory.get_lock(LockName.AvoidancePath)\n            self.shared_avoidance_path_lock.register_consumer()\n\n    def delete_shared_memory(self):\n        if self.shared_memory is not None:\n            self.shared_avoidance_path_lock = None\n            self.shared_avoidance_path = None\n            self.shared_avoidance_blocked_lock = None\n            self.shared_avoidance_pose_order = None\n            self.shared_obstacles_lock = None\n            self.shared_rectangle_obstacles = None\n            self.shared_circle_obstacles = None\n            self.shared_monitor_obstacles_lock = None\n            self.shared_monitor_obstacles = None\n            self.shared_detector_obstacles_lock = None\n            self.shared_detector_obstacles = None\n            self.shared_table_limits = None\n            self.shared_pose_current_buffer = None\n            self.shared_pose_current_lock = None\n            self.shared_properties = None\n            self.shared_memory = None\n\n    async def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        self.retry_connection = True\n        try:\n            await self.try_connect()\n            await self.sio.wait()\n        except asyncio.CancelledError:\n            self.process_manager.shutdown()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/planner\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    @property\n    def pose_current(self) -&gt; models.Pose:\n        \"\"\"\n        Get the current pose of the robot.\n        \"\"\"\n        pose = self.shared_pose_current_buffer.last\n        return models.Pose(x=pose.x, y=pose.y, O=pose.angle)\n\n    async def start(self):\n        \"\"\"\n        Start sending obstacles list.\n        \"\"\"\n        logger.info(\"Planner: start\")\n        self.create_shared_memory()\n        self.shared_memory.avoidance_exiting = False\n        await self.soft_reset()\n        await self.event_manager.start_loops()\n        await self.sio_ns.emit(\"starter_changed\", self.starter.is_pressed)\n        await self.sio_ns.emit(\"game_reset\")\n        self.obstacles_updater_loop.start()\n        if self.oled_bus and self.oled_address:\n            self.oled_update_loop.start()\n\n        self.avoidance_process = Process(target=avoidance_process, args=(self.robot_id,))\n        self.avoidance_process.start()\n\n        await actuators.actuators_init(self)\n\n    async def stop(self):\n        \"\"\"\n        Stop running tasks.\n        \"\"\"\n        logger.info(\"Planner: stop\")\n\n        self.shared_memory.avoidance_exiting = True\n        await self.sio_ns.emit(\"stop_video_record\")\n        await self.event_manager.stop_loops()\n        await self.obstacles_updater_loop.stop()\n        if self.oled_bus and self.oled_address:\n            await self.oled_update_loop.stop()\n\n        if self.avoidance_process and self.avoidance_process.is_alive():\n            self.avoidance_process.join()\n            self.avoidance_process = None\n\n        self.delete_shared_memory()\n\n    async def reset(self):\n        \"\"\"\n        Reset planner, context, robots and strategy.\n        \"\"\"\n        await self.stop()\n        await self.start()\n\n    async def soft_reset(self):\n        \"\"\"\n        Only reset context and strategy.\n        \"\"\"\n        self.game_context.reset()\n        self.playing = False\n        await self.set_controller(self.default_controller, True)\n        table = get_table(self.shared_properties.table)\n        self.shared_table_limits[0] = table.x_min\n        self.shared_table_limits[1] = table.x_max\n        self.shared_table_limits[2] = table.y_min\n        self.shared_table_limits[3] = table.y_max\n        self.shared_memory.avoidance_has_pose_order = False\n        self.shared_memory.avoidance_has_new_pose_order = False\n        self.flag_motor.off()\n        self.strategy = strategy_classes.get(StrategyEnum(self.shared_properties.strategy), strategy.Strategy)(self)\n        await self.set_pose_start(self.start_positions.get())\n        self.pami_event.clear()\n\n    async def final_action(self):\n        if not self.playing:\n            return\n        self.playing = False\n        await self.sio_ns.emit(\"game_end\")\n        if self.robot_id == 1:\n            if self.robot_in_parking():\n                self.game_context.score += 10\n\n            # Display score\n            await self.sio_ns.emit(\"score\", self.game_context.score)\n\n        self.flag_motor.on()\n        self.pose_order = None\n\n    def starter_changed_callback(self, pushed: bool):\n        asyncio.create_task(self.starter_changed(pushed))\n\n    async def starter_changed(self, pushed: bool):\n        self.last_starter_event_timestamp = datetime.now(UTC)\n        if not self.virtual:\n            await self.sio_ns.emit(\"starter_changed\", pushed)\n\n    @property\n    def default_controller(self) -&gt; ControllerEnum:\n        match self.shared_properties.strategy:\n            case StrategyEnum.PidAngularSpeedTest:\n                return ControllerEnum.ANGULAR_SPEED_TEST\n            case StrategyEnum.PidLinearSpeedTest:\n                return ControllerEnum.LINEAR_SPEED_TEST\n            case _:\n                return ControllerEnum.QUADPID\n\n    async def set_controller(self, new_controller: ControllerEnum, force: bool = False):\n        if self.controller == new_controller and not force:\n            return\n        self.controller = new_controller\n        await self.sio_ns.emit(\"set_controller\", self.controller.value)\n\n    async def set_pose_start(self, pose_start: models.Pose):\n        \"\"\"\n        Set the start position of the robot for the next game.\n        \"\"\"\n        self.action = None\n        self.pose_order = None\n        self.pose_reached = True\n\n        # When the firmware receives a pose start, it does not send its updated pose current,\n        # so do it here.\n        self.shared_pose_current_buffer.push(pose_start.x, pose_start.y, pose_start.O)\n        await self.sio_ns.emit(\"pose_start\", pose_start.model_dump())\n\n    @property\n    def pose_order(self) -&gt; pose.Pose | None:\n        return self._pose_order\n\n    @pose_order.setter\n    def pose_order(self, new_pose: pose.Pose | None):\n        logger.info(f\"Planner: pose_order={new_pose.path_pose if new_pose else None}\")\n        self._pose_order = new_pose\n        self.shared_memory.avoidance_has_pose_order = False\n        if new_pose is None:\n            self.shared_memory.avoidance_has_new_pose_order = False\n        else:\n            self.shared_memory.avoidance_has_new_pose_order = True\n            new_pose.to_shared(self.shared_avoidance_pose_order)\n\n    async def set_pose_reached(self):\n        \"\"\"\n        Set pose reached for a robot.\n        \"\"\"\n        logger.info(\"Planner: set_pose_reached()\")\n\n        # Set pose reached\n        if not self.pose_reached and (pose_order := self.pose_order):\n            self.pose_order = None\n            await pose_order.act_after_pose()\n        else:\n            self.pose_order = None\n\n        self.pose_reached = True\n        if (action := self.action) and len(self.action.poses) == 0:\n            self.action = None\n            await action.act_after_action()\n\n        if not self.playing:\n            return\n\n        await self.next_pose()\n\n    async def set_intermediate_pose_reached(self):\n        \"\"\"\n        Set pose reached for a robot.\n        \"\"\"\n        logger.info(\"Planner: set_intermediate_pose_reached()\")\n\n        # The pose reached is intermediate, just force path recompute.\n        if self.pose_order:\n            await self.pose_order.act_intermediate_pose()\n            self.pose_order.path_pose.to_shared(self.shared_avoidance_pose_order)\n            self.shared_memory.avoidance_has_new_pose_order = True\n\n    async def next_pose_in_action(self):\n        if self.action and len(self.action.poses) &gt; 0:\n            pose_order = self.action.poses.pop(0)\n            self.pose_order = None\n            await pose_order.act_before_pose()\n            self.blocked_counter = 0\n            self.pose_order = pose_order\n\n            if self.shared_properties.strategy in [StrategyEnum.PidLinearSpeedTest, StrategyEnum.PidAngularSpeedTest]:\n                await self.sio_ns.emit(\"pose_order\", self.pose_order.path_pose.model_dump())\n\n    async def next_pose(self):\n        \"\"\"\n        Select the next pose for a robot.\n        \"\"\"\n        logger.info(\"Planner: next_pose()\")\n        try:\n            # Get and set new pose\n            self.pose_reached = False\n            await self.next_pose_in_action()\n\n            # If no pose left in current action, get and set new action\n            if not self.pose_order and (new_action := await self.strategy.get_next_action()):\n                await self.set_action(new_action)\n                if not self.pose_order:\n                    asyncio.create_task(self.set_pose_reached())\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def set_action(self, action: \"action.Action\"):\n        \"\"\"\n        Set current action.\n        \"\"\"\n        logger.info(f\"Planner: set action '{action.name}'\")\n        self.pose_order = None\n        self.action = action\n        await self.action.act_before_action()\n        await self.next_pose_in_action()\n\n    async def blocked(self):\n        \"\"\"\n        Function called when a robot cannot find a path to go to the current pose of the current action\n        \"\"\"\n        if (current_action := self.action) and current_action.interruptable:\n            logger.info(\"Planner: blocked\")\n            if new_action := await self.strategy.get_next_action():\n                await self.set_action(new_action)\n            await current_action.recycle()\n            self.strategy.append(current_action)\n            if not self.pose_order:\n                asyncio.create_task(self.set_pose_reached())\n\n    async def update_obstacles(self):\n        table = get_table(self.shared_properties.table)\n        try:\n            margin = self.shared_properties.obstacle_bb_margin * self.shared_properties.robot_length / 2\n            if self.shared_properties.bypass_detector:\n                shared_obstacles = self.shared_monitor_obstacles\n                shared_lock = self.shared_monitor_obstacles_lock\n            else:\n                shared_obstacles = self.shared_detector_obstacles\n                shared_lock = self.shared_detector_obstacles_lock\n            shared_lock.start_reading()\n            self.shared_obstacles_lock.start_writing()\n            self.shared_circle_obstacles.clear()\n            self.shared_rectangle_obstacles.clear()\n\n            # Add dynamic obstacles\n            for detector_obstacle in shared_obstacles:\n                if not table.contains(detector_obstacle, margin):\n                    continue\n                if self.robot_id == 1:\n                    radius = self.shared_properties.obstacle_radius\n                else:\n                    radius = detector_obstacle.radius\n                radius += self.shared_properties.robot_length / 2\n                self.shared_circle_obstacles.append(\n                    x=detector_obstacle.x,\n                    y=detector_obstacle.y,\n                    angle=0,\n                    radius=radius,\n                    bounding_box_margin=margin,\n                    bounding_box_points_number=self.shared_properties.obstacle_bb_vertices,\n                )\n            shared_lock.finish_reading()\n\n            if not self.shared_properties.disable_fixed_obstacles:\n                if self.robot_id == 1:\n                    # Add artifact obstacles\n                    construction_areas: list[ConstructionArea] = list(\n                        self.game_context.construction_areas.values()\n                    ) + list(self.game_context.opponent_construction_areas.values())\n                    for construction_area in construction_areas:\n                        if not construction_area.enabled:\n                            continue\n                        if not table.contains(construction_area, margin):\n                            continue\n                        self.shared_rectangle_obstacles.append(\n                            x=construction_area.x,\n                            y=construction_area.y,\n                            angle=construction_area.O,\n                            length_x=construction_area.length + self.shared_properties.robot_width,\n                            length_y=construction_area.width + self.shared_properties.robot_width,\n                            bounding_box_margin=margin,\n                            id=construction_area.id.value,\n                        )\n                    for tribune in self.game_context.tribunes.values():\n                        if not tribune.enabled:\n                            continue\n                        if not table.contains(tribune, margin):\n                            continue\n                        self.shared_rectangle_obstacles.append(\n                            x=tribune.x,\n                            y=tribune.y,\n                            angle=tribune.O,\n                            length_x=tribune.width + self.shared_properties.robot_width,\n                            length_y=tribune.length + self.shared_properties.robot_width,\n                            bounding_box_margin=margin,\n                            id=tribune.id.value,\n                        )\n\n                # Add fixed obstacles\n                for fixed_obstacle in self.game_context.fixed_obstacles.values():\n                    if not fixed_obstacle.enabled:\n                        continue\n                    if not table.contains(fixed_obstacle, margin):\n                        continue\n                    self.shared_rectangle_obstacles.append(\n                        x=fixed_obstacle.x,\n                        y=fixed_obstacle.y,\n                        angle=0,\n                        length_x=fixed_obstacle.width + self.shared_properties.robot_width,\n                        length_y=fixed_obstacle.length + self.shared_properties.robot_width,\n                        bounding_box_margin=margin,\n                        id=fixed_obstacle.id.value,\n                    )\n\n            self.shared_obstacles_lock.finish_writing()\n            self.shared_obstacles_lock.post_update()\n        except Exception as exc:\n            logger.warning(f\"Planner: update_obstacles: Unknown exception {exc}\")\n            traceback.print_exc()\n\n    async def update_oled_display(self):\n        try:\n            pose_current = self.pose_current\n            text = (\n                f\"{'Connected' if self.sio.connected else 'Not connected': &lt;20}\"\n                f\"{'\u25b6' if self.playing else '\u25fc'}\\n\"\n                f\"Camp: {self.camp.color.name}\\n\"\n                f\"Strategy: {StrategyEnum(self.shared_properties.strategy).name}\\n\"\n                f\"Pose: {pose_current.x},{pose_current.y},{pose_current.O}\\n\"\n                f\"Countdown: {self.game_context.countdown:.2f}\"\n            )\n            with self.oled_image as draw:\n                draw.rectangle([(0, 0), (128, 64)], fill=\"black\", outline=\"black\")\n                draw.multiline_text(\n                    (1, 0),\n                    text,\n                    fill=\"white\",\n                    font=self.oled_font,\n                )\n        except Exception as exc:\n            logger.warning(f\"Planner: OLED display update loop: Unknown exception {exc}\")\n            traceback.print_exc()\n\n    async def command(self, cmd: str, *args):\n        \"\"\"\n        Execute a command from the menu.\n        \"\"\"\n        if cmd.startswith(\"wizard_\"):\n            await self.cmd_wizard_test(cmd)\n            return\n\n        if cmd.startswith(\"act_\"):\n            await self.cmd_act(cmd)\n            return\n\n        if cmd.startswith(\"cam_\"):\n            await self.cmd_cam(cmd)\n            return\n\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema_with_values = properties_schema.copy()\n            # Add current values in JSON Schema\n            for prop in schema_with_values[\"properties\"]:\n                schema_with_values[\"properties\"][prop][\"value\"] = getattr(self.shared_properties, prop)\n            # Send config\n            await self.sio_ns.emit(\"config\", schema_with_values)\n            return\n\n        if cmd == \"scservos\":\n            # Get JSON Schema\n            schema = self.scservos.get_schema()\n            await self.sio_ns.emit(\"config\", schema)\n            return\n\n        if cmd == \"game_wizard\":\n            await self.game_wizard.start()\n            return\n\n        if not (cmd_func := getattr(self, f\"cmd_{cmd}\", None)):\n            logger.warning(f\"Unknown command: {cmd}\")\n            return\n\n        await cmd_func(*args)\n\n    def update_config(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update a Planner property with the value sent by the dashboard.\n        \"\"\"\n        name = config[\"name\"]\n        current_value = getattr(self.shared_properties, name)\n        current_value_type = type(current_value)\n        setattr(self.shared_properties, name, current_value_type(config[\"value\"]))\n        match name:\n            case \"obstacle_updater_interval\":\n                self.obstacles_updater_loop.interval = self.shared_properties.obstacle_updater_interval\n\n    async def update_scservo(self, servo: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update a SC Servo with the value sent by the dashboard.\n        \"\"\"\n        self.scservos.set(SCServoEnum[servo[\"name\"]], servo[\"value\"])\n\n    async def cmd_play(self, timestamp: str | None = None):\n        \"\"\"\n        Play command from the menu.\n        \"\"\"\n        if timestamp:\n            self.countdown_start_timestamp = datetime.fromisoformat(timestamp)\n        else:\n            self.countdown_start_timestamp = datetime.now(UTC)\n\n        logger.info(f\"Planner: cmd_play({self.countdown_start_timestamp})\")\n        if self.playing:\n            return\n\n        self.game_context.countdown = self.game_context.game_duration\n        self.playing = True\n        self.led.color = Color(\"blue\")\n\n        await self.sio_ns.emit(\n            \"start_countdown\",\n            (self.robot_id, self.game_context.game_duration, self.countdown_start_timestamp.isoformat(), \"deepskyblue\"),\n        )\n\n        await self.sio_ns.emit(\"start_video_record\")\n        asyncio.create_task(self.set_pose_reached())\n\n    async def cmd_stop(self):\n        \"\"\"\n        Stop command from the menu.\n        \"\"\"\n        logger.info(\"Planner: cmd_stop()\")\n        self.playing = False\n        await self.sio_ns.emit(\"stop_video_record\")\n\n    async def cmd_next(self):\n        \"\"\"\n        Next command from the menu.\n        Ignored if current pose is not reached for all robots.\n        \"\"\"\n        logger.info(\"Planner: cmd_next()\")\n        if self.playing:\n            return\n\n        # Check that pose_reached is set\n        if not self.pose_reached:\n            return\n\n        asyncio.create_task(self.next_pose())\n\n    async def cmd_reset(self):\n        \"\"\"\n        Reset command from the menu.\n        \"\"\"\n        logger.info(\"Planner: cmd_reset()\")\n        await self.reset()\n        await self.sio_ns.emit(\"cmd_reset\")\n\n    async def cmd_choose_camp(self):\n        \"\"\"\n        Choose camp command from the menu.\n        Send camp wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Camp\",\n                \"type\": \"camp\",\n                \"value\": self.camp.color.name,\n            },\n        )\n\n    async def cmd_choose_strategy(self):\n        \"\"\"\n        Choose strategy command from the menu.\n        Send strategy wizard message.\n        \"\"\"\n        choices: list[tuple[str, str, str]] = []  # list of (category, value, name). Name can be used for display.\n        for strategy_enum in StrategyEnum:\n            split = re.findall(r\"[A-Z][a-z]*|[a-z]+|[0-9]+\", strategy_enum.name)\n            choices.append((strategy_enum.name, split[0], \" \".join(split)))\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Strategy\",\n                \"type\": \"choice_str\",\n                \"choices\": choices,\n                \"value\": StrategyEnum(self.shared_properties.strategy).name,\n            },\n        )\n\n    async def cmd_choose_avoidance(self):\n        \"\"\"\n        Choose avoidance strategy command from the menu.\n        Send avoidance strategy wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Avoidance\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in AvoidanceStrategy],\n                \"value\": AvoidanceStrategy(self.shared_properties.avoidance_strategy).name,\n            },\n        )\n\n    async def cmd_choose_start_position(self):\n        \"\"\"\n        Choose start position command from the menu.\n        Send start position wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Start Position\",\n                \"type\": \"choice_str\",\n                \"choices\": [p.name for p in StartPositionEnum if self.start_positions.is_valid(p)],\n                \"value\": StartPositionEnum(self.shared_properties.start_position).name,\n            },\n        )\n\n    async def cmd_choose_table(self):\n        \"\"\"\n        Choose table command from the menu.\n        Send table wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Table\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in TableEnum],\n                \"value\": TableEnum(self.shared_properties.table).name,\n            },\n        )\n\n    async def wizard_response(self, message: dict[str, Any]):\n        \"\"\"\n        Handle wizard response sent from the dashboard.\n        \"\"\"\n        if (value := message[\"value\"]) is None:\n            return\n\n        match name := message.get(\"name\"):\n            case \"Choose Camp\":\n                new_camp = Camp.Colors[value]\n                if self.camp.color == new_camp:\n                    return\n                previous_camp = self.camp.color\n                if self.shared_properties.table == TableEnum.Training and new_camp == Camp.Colors.yellow:\n                    error_message = \"Yellow camp not compatible with training table\"\n                    self.camp.color = previous_camp\n                    logger.warning(f\"Wizard: {error_message}\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": message,\n                        },\n                    )\n                    return\n                self.camp.color = new_camp\n                await self.soft_reset()\n                logger.info(f\"Wizard: New camp: {self.camp.color.name}\")\n            case \"Choose Strategy\":\n                new_strategy = StrategyEnum[value]\n                if self.shared_properties.strategy == new_strategy:\n                    return\n                self.shared_properties.strategy = new_strategy.val\n                await self.soft_reset()\n                logger.info(f\"Wizard: New strategy: {value}\")\n            case \"Choose Avoidance\":\n                new_avoidance = AvoidanceStrategy[value]\n                if self.shared_properties.avoidance_strategy == new_avoidance:\n                    return\n                self.shared_properties.avoidance_strategy = new_avoidance.val\n                logger.info(f\"Wizard: New avoidance strategy: {value}\")\n            case \"Choose Start Position\":\n                new_start_position = StartPositionEnum[value]\n                if self.shared_properties.start_position == new_start_position:\n                    return\n                if not self.start_positions.is_valid(new_start_position):\n                    message = f\"Start position {new_start_position.name} invalid in current table and camp\"\n                    logger.warning(f\"Wizard: {message}\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": message,\n                        },\n                    )\n                    return\n                self.shared_properties.start_position = new_start_position.val\n                await self.soft_reset()\n            case \"Choose Table\":\n                new_table = TableEnum[value]\n                if self.shared_properties.table == new_table:\n                    return\n                error_message = \"\"\n                previous_table = self.shared_properties.table\n                self.shared_properties.table = new_table.val\n                if not self.start_positions.is_valid(StartPositionEnum(self.shared_properties.start_position)):\n                    error_message = (\n                        f\"Table {new_table.name} not compatible \"\n                        f\"with start position {StartPositionEnum(self.shared_properties.start_position).name}\"\n                    )\n                if new_table == TableEnum.Training and self.camp.color == Camp.Colors.yellow:\n                    error_message = f\"Table {new_table.name} not compatible yellow camp\"\n                if error_message:\n                    self.shared_properties.table = previous_table\n                    logger.warning(f\"Wizard: {error_message}\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": error_message,\n                        },\n                    )\n                    return\n                await self.soft_reset()\n                logger.info(f\"Wizard: New table: {value}\")\n            case game_wizard_response if game_wizard_response.startswith(\"Game Wizard\"):\n                await self.game_wizard.response(message)\n            case wizard_test_response if wizard_test_response.startswith(\"Wizard Test\"):\n                logger.info(f\"Wizard test response: {name} = {value}\")\n            case _:\n                logger.warning(f\"Wizard: Unknown type: {name}\")\n\n    async def cmd_wizard_test(self, cmd: str):\n        match cmd:\n            case \"wizard_boolean\":\n                message = {\n                    \"name\": \"Wizard Test Boolean\",\n                    \"type\": \"boolean\",\n                    \"value\": True,\n                }\n            case \"wizard_integer\":\n                message = {\n                    \"name\": \"Wizard Test Integer\",\n                    \"type\": \"integer\",\n                    \"value\": 42,\n                }\n            case \"wizard_floating\":\n                message = {\n                    \"name\": \"Wizard Test Float\",\n                    \"type\": \"floating\",\n                    \"value\": 66.6,\n                }\n            case \"wizard_str\":\n                message = {\n                    \"name\": \"Wizard Test String\",\n                    \"type\": \"str\",\n                    \"value\": \"cogip\",\n                }\n            case \"wizard_message\":\n                message = {\n                    \"name\": \"Wizard Test Message\",\n                    \"type\": \"message\",\n                    \"value\": \"Hello Robot!\",\n                }\n            case \"wizard_choice_integer\":\n                message = {\n                    \"name\": \"Wizard Test Choice Integer\",\n                    \"type\": \"choice_integer\",\n                    \"choices\": list(range(1, 21)),\n                    \"value\": 2,\n                }\n            case \"wizard_choice_floating\":\n                message = {\n                    \"name\": \"Wizard Test Choice Float\",\n                    \"type\": \"choice_floating\",\n                    \"choices\": list([x * 1.1 for x in range(1, 21)]),\n                    \"value\": 2.2,\n                }\n            case \"wizard_choice_str\":\n                message = {\n                    \"name\": \"Wizard Test Choice String\",\n                    \"type\": \"choice_str\",\n                    \"choices\": list([f\"item{i}\" for i in range(1, 21)]),\n                    \"value\": \"item2\",\n                }\n            case \"wizard_choice_str_group\":\n                message = {\n                    \"name\": \"Wizard Test Choice String\",\n                    \"type\": \"choice_str\",\n                    \"choices\": [\n                        (\"one\", \"Group A\", \"One\"),\n                        (\"two\", \"Group A\", \"Two\"),\n                        (\"three\", \"Group B\", \"Three\"),\n                    ],\n                    \"value\": \"two\",\n                }\n            case \"wizard_select_integer\":\n                message = {\n                    \"name\": \"Wizard Test Select Integer\",\n                    \"type\": \"select_integer\",\n                    \"choices\": list(range(1, 21)),\n                    \"value\": [1, 3],\n                }\n            case \"wizard_select_floating\":\n                message = {\n                    \"name\": \"Wizard Test Select Float\",\n                    \"type\": \"select_floating\",\n                    \"choices\": [1.1, 2.2, 3.3],\n                    \"value\": [1.1, 3.3],\n                }\n            case \"wizard_select_str\":\n                message = {\n                    \"name\": \"Wizard Test Select String\",\n                    \"type\": \"select_str\",\n                    \"choices\": [\"one\", \"two\", \"tree\"],\n                    \"value\": [\"one\", \"tree\"],\n                }\n            case \"wizard_camp\":\n                message = {\n                    \"name\": \"Wizard Test Camp\",\n                    \"type\": \"camp\",\n                    \"value\": \"blue\",\n                }\n            case \"wizard_camera\":\n                message = {\n                    \"name\": \"Wizard Test Camera\",\n                    \"type\": \"camera\",\n                }\n            case \"wizard_score\":\n                await self.sio_ns.emit(\"score\", 100)\n                return\n            case _:\n                logger.warning(f\"Wizard test unsupported: {cmd}\")\n                return\n\n        await self.sio_ns.emit(\"wizard\", message)\n\n    async def cmd_act(self, cmd: str):\n        _, _, command = cmd.partition(\"_\")\n        func = getattr(actuators, command)\n        await func(self)\n\n    async def cmd_cam(self, cmd: str):\n        _, _, command = cmd.partition(\"_\")\n        match command:\n            case \"snapshot\":\n                await cameras.snapshot()\n            case \"camera_position\":\n                await self.get_camera_position()\n\n    async def get_camera_position(self):\n        if camera_position := await cameras.calibrate_camera(self):\n            logger.info(\n                f\"Planner: Camera position in robot:\"\n                f\" X={camera_position.x:.0f} Y={camera_position.y:.0f} Z={camera_position.z:.0f}\"\n            )\n        else:\n            logger.info(\"Planner: No table marker found\")\n\n    async def update_actuator_state(self, actuator_state: ActuatorState):\n        # actuators_states = getattr(self.game_context, f\"{actuator_state.kind.name}_states\")\n        # actuators_states[actuator_state.id] = actuator_state\n        # if not self.virtual and actuator_state.id in self.game_context.emulated_actuator_states:\n        #     self.game_context.emulated_actuator_states.remove(actuator_state.id)\n        pass\n\n    def robot_in_parking(self) -&gt; bool:\n        pose_current = self.pose_current.model_copy()\n        robot_half = self.shared_properties.robot_width / 2.0\n        robot_square = Polygon(\n            [\n                (-robot_half, -robot_half),\n                (robot_half, -robot_half),\n                (robot_half, robot_half),\n                (-robot_half, robot_half),\n            ]\n        )\n        robot_square = rotate(robot_square, pose_current.O, origin=(0, 0), use_radians=False)\n        robot_square = translate(robot_square, xoff=pose_current.x, yoff=pose_current.y)\n\n        parking = self.game_context.fixed_obstacles[FixedObstacleID.Backstage]\n        parking_half = parking.width / 2.0\n        parking_square = Polygon(\n            [\n                (-parking_half, -parking_half),\n                (parking_half, -parking_half),\n                (parking_half, parking_half),\n                (-parking_half, parking_half),\n            ]\n        )\n        parking_square = translate(parking_square, xoff=parking.x, yoff=parking.y)\n\n        result = robot_square.intersects(parking_square)\n        logger.info(f\"Planner: Robot in parking={result}\")\n        return result\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.pose_current","title":"<code>pose_current</code>  <code>property</code>","text":"<p>Get the current pose of the robot.</p>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.__init__","title":"<code>__init__(robot_id, server_url, robot_width, robot_length, obstacle_radius, obstacle_bb_margin, obstacle_bb_vertices, obstacle_updater_interval, path_refresh_interval, starter_pin, led_red_pin, led_green_pin, led_blue_pin, flag_motor_pin, oled_bus, oled_address, bypass_detector, scservos_port, scservos_baud_rate, disable_fixed_obstacles, table, strategy_enum, start_position, avoidance_strategy, goap_depth, debug)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>Robot ID</p> required <code>server_url</code> <code>str</code> <p>Socket.IO Server URL</p> required <code>robot_width</code> <code>int</code> <p>Width of the robot (in mm)</p> required <code>robot_length</code> <code>int</code> <p>Length of the robot (in mm)</p> required <code>obstacle_radius</code> <code>int</code> <p>Radius of a dynamic obstacle (in mm)</p> required <code>obstacle_bb_margin</code> <code>float</code> <p>Obstacle bounding box margin in percent of the radius</p> required <code>obstacle_bb_vertices</code> <code>int</code> <p>Number of obstacle bounding box vertices</p> required <code>obstacle_updater_interval</code> <code>float</code> <p>Interval between each send of obstacles to dashboards (in seconds)</p> required <code>path_refresh_interval</code> <code>float</code> <p>Interval between each update of robot paths (in seconds)</p> required <code>starter_pin</code> <code>int | None</code> <p>GPIO pin connected to the starter</p> required <code>led_red_pin</code> <code>int | None</code> <p>GPIO pin connected to the red LED</p> required <code>led_green_pin</code> <code>int | None</code> <p>GPIO pin connected to the green LED</p> required <code>led_blue_pin</code> <code>int | None</code> <p>GPIO pin connected to the blue LED</p> required <code>flag_motor_pin</code> <code>int | None</code> <p>GPIO pin connected to the flag motor</p> required <code>oled_bus</code> <code>int | None</code> <p>PAMI OLED display i2c bus</p> required <code>oled_address</code> <code>int | None</code> <p>PAMI OLED display i2c address</p> required <code>bypass_detector</code> <code>bool</code> <p>Use perfect obstacles from monitor instead of detected obstacles by Lidar</p> required <code>scservos_port</code> <code>Path | None</code> <p>SC Servos serial port</p> required <code>scservos_baud_rate</code> <code>int</code> <p>SC Servos baud rate (usually 921600 or 1000000)</p> required <code>disable_fixed_obstacles</code> <code>bool</code> <p>Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance</p> required <code>table</code> <code>TableEnum</code> <p>Default table on startup</p> required <code>strategy_enum</code> <code>StrategyEnum</code> <p>Default strategy on startup</p> required <code>start_position</code> <code>StartPositionEnum</code> <p>Default start position on startup</p> required <code>avoidance_strategy</code> <code>AvoidanceStrategy</code> <p>Default avoidance strategy on startup</p> required <code>goap_depth</code> <code>int</code> <p>Depth of the GOAP search tree</p> required <code>debug</code> <code>bool</code> <p>enable debug messages</p> required Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def __init__(\n    self,\n    robot_id: int,\n    server_url: str,\n    robot_width: int,\n    robot_length: int,\n    obstacle_radius: int,\n    obstacle_bb_margin: float,\n    obstacle_bb_vertices: int,\n    obstacle_updater_interval: float,\n    path_refresh_interval: float,\n    starter_pin: int | None,\n    led_red_pin: int | None,\n    led_green_pin: int | None,\n    led_blue_pin: int | None,\n    flag_motor_pin: int | None,\n    oled_bus: int | None,\n    oled_address: int | None,\n    bypass_detector: bool,\n    scservos_port: Path | None,\n    scservos_baud_rate: int,\n    disable_fixed_obstacles: bool,\n    table: TableEnum,\n    strategy_enum: StrategyEnum,\n    start_position: StartPositionEnum,\n    avoidance_strategy: AvoidanceStrategy,\n    goap_depth: int,\n    debug: bool,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        robot_id: Robot ID\n        server_url: Socket.IO Server URL\n        robot_width: Width of the robot (in mm)\n        robot_length: Length of the robot (in mm)\n        obstacle_radius: Radius of a dynamic obstacle (in mm)\n        obstacle_bb_margin: Obstacle bounding box margin in percent of the radius\n        obstacle_bb_vertices: Number of obstacle bounding box vertices\n        obstacle_updater_interval: Interval between each send of obstacles to dashboards (in seconds)\n        path_refresh_interval: Interval between each update of robot paths (in seconds)\n        starter_pin: GPIO pin connected to the starter\n        led_red_pin: GPIO pin connected to the red LED\n        led_green_pin: GPIO pin connected to the green LED\n        led_blue_pin: GPIO pin connected to the blue LED\n        flag_motor_pin: GPIO pin connected to the flag motor\n        oled_bus: PAMI OLED display i2c bus\n        oled_address: PAMI OLED display i2c address\n        bypass_detector: Use perfect obstacles from monitor instead of detected obstacles by Lidar\n        scservos_port: SC Servos serial port\n        scservos_baud_rate: SC Servos baud rate (usually 921600 or 1000000)\n        disable_fixed_obstacles: Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance\n        table: Default table on startup\n        strategy_enum: Default strategy on startup\n        start_position: Default start position on startup\n        avoidance_strategy: Default avoidance strategy on startup\n        goap_depth: Depth of the GOAP search tree\n        debug: enable debug messages\n    \"\"\"\n    self.robot_id = robot_id\n    self.server_url = server_url\n    self.oled_bus = oled_bus\n    self.oled_address = oled_address\n    self.scservos_port = scservos_port\n    self.scservos_baud_rate = scservos_baud_rate\n    self.debug = debug\n\n    self.shared_memory: SharedMemory | None = None\n    self.shared_properties: SharedProperties | None = None\n    self.shared_pose_current_lock: WritePriorityLock | None = None\n    self.shared_pose_current_buffer: SharedPoseBuffer | None = None\n    self.shared_table_limits: NDArray | None = None\n    self.shared_detector_obstacles: SharedCircleList | None = None\n    self.shared_detector_obstacles_lock: WritePriorityLock | None = None\n    self.shared_monitor_obstacles: SharedCircleList | None = None\n    self.shared_monitor_obstacles_lock: WritePriorityLock | None = None\n    self.shared_circle_obstacles: SharedObstacleCircleList | None = None\n    self.shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n    self.shared_obstacles_lock: WritePriorityLock | None = None\n    self.shared_avoidance_pose_order: SharedPoseOrder | None = None\n    self.shared_avoidance_blocked_lock: WritePriorityLock | None = None\n    self.shared_avoidance_path: SharedPoseOrderList | None = None\n    self.shared_avoidance_path_lock: WritePriorityLock | None = None\n    self.create_shared_memory()\n\n    # Fix type checker after shared memory creation\n    self.shared_properties: SharedProperties\n\n    # Update shared memory properties\n    self.shared_properties.robot_id = robot_id\n    self.shared_properties.robot_width = robot_width\n    self.shared_properties.robot_length = robot_length\n    self.shared_properties.obstacle_radius = obstacle_radius\n    self.shared_properties.obstacle_bb_margin = obstacle_bb_margin\n    self.shared_properties.obstacle_bb_vertices = obstacle_bb_vertices\n    self.shared_properties.obstacle_updater_interval = obstacle_updater_interval\n    self.shared_properties.path_refresh_interval = path_refresh_interval\n    self.shared_properties.bypass_detector = bypass_detector\n    self.shared_properties.disable_fixed_obstacles = disable_fixed_obstacles\n    self.shared_properties.table = table.val\n    self.shared_properties.strategy = strategy_enum.val\n    self.shared_properties.start_position = start_position.val\n    self.shared_properties.avoidance_strategy = avoidance_strategy.val\n    self.shared_properties.goap_depth = goap_depth\n\n    self.virtual = platform.machine() != \"aarch64\"\n    self.retry_connection = True\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_ns = sio_events.SioEvents(self)\n    self.sio.register_namespace(self.sio_ns)\n    self.game_context = GameContext(self.shared_properties)\n    self.camp = Camp()\n    self.start_positions = StartPositions(self.shared_properties)\n    self.process_manager = Manager()\n    self.action: action.Action | None = None\n    self.strategy = strategy_classes.get(self.shared_properties.strategy, strategy.Strategy)(self)\n    self.obstacles_updater_loop = AsyncLoop(\n        \"Obstacles updater loop\",\n        obstacle_updater_interval,\n        self.update_obstacles,\n        logger=self.debug,\n    )\n    self.playing: bool = False\n    self._pose_order: pose.Pose | None = None\n    self.pose_reached: bool = True\n    self.blocked_counter: int = 0\n    self.controller = self.default_controller\n    self.game_wizard = GameWizard(self)\n    self.event_manager = EventManager(self)\n    self.scservos = SCServos(self.scservos_port, scservos_baud_rate)\n    self.pami_event = asyncio.Event()\n    self.last_starter_event_timestamp: datetime | None = None\n    self.countdown_start_timestamp: datetime = datetime.now(UTC)\n\n    if not self.start_positions.is_valid(start_position):\n        logger.error(f\"Start position {start_position.name} invalid in current table and camp\")\n        sys.exit(1)\n\n    self.avoidance_process: Process | None = None\n\n    if starter_pin:\n        self.starter = Button(\n            starter_pin,\n            pull_up=False,\n            bounce_time=None,\n        )\n    else:\n        self.starter = Button(\n            17,\n            pull_up=True,\n            pin_factory=MockFactory(),\n        )\n    self.starter.when_activated = partial(self.starter_changed_callback, True)\n    self.starter.when_deactivated = partial(self.starter_changed_callback, False)\n\n    if led_red_pin and led_green_pin and led_blue_pin:\n        self.led = RGBLED(\n            led_red_pin,\n            led_green_pin,\n            led_blue_pin,\n            initial_value=(1, 0, 0),\n        )\n    else:\n        self.led = Mock()\n\n    if flag_motor_pin:\n        self.flag_motor = OutputDevice(flag_motor_pin)\n    else:\n        self.flag_motor = Mock()\n\n    if self.oled_bus and self.oled_address:\n        self.oled_serial = i2c(port=self.oled_bus, address=self.oled_address)\n        self.oled_device = sh1106(self.oled_serial)\n        self.oled_font = ImageFont.truetype(\"DejaVuSansMono.ttf\", 9)\n        self.oled_image = canvas(self.oled_device)\n        self.oled_update_loop = AsyncLoop(\n            \"OLED display update loop\",\n            0.5,\n            self.update_oled_display,\n            logger=self.debug,\n        )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.blocked","title":"<code>blocked()</code>  <code>async</code>","text":"<p>Function called when a robot cannot find a path to go to the current pose of the current action</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def blocked(self):\n    \"\"\"\n    Function called when a robot cannot find a path to go to the current pose of the current action\n    \"\"\"\n    if (current_action := self.action) and current_action.interruptable:\n        logger.info(\"Planner: blocked\")\n        if new_action := await self.strategy.get_next_action():\n            await self.set_action(new_action)\n        await current_action.recycle()\n        self.strategy.append(current_action)\n        if not self.pose_order:\n            asyncio.create_task(self.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_avoidance","title":"<code>cmd_choose_avoidance()</code>  <code>async</code>","text":"<p>Choose avoidance strategy command from the menu. Send avoidance strategy wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_avoidance(self):\n    \"\"\"\n    Choose avoidance strategy command from the menu.\n    Send avoidance strategy wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Avoidance\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in AvoidanceStrategy],\n            \"value\": AvoidanceStrategy(self.shared_properties.avoidance_strategy).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_camp","title":"<code>cmd_choose_camp()</code>  <code>async</code>","text":"<p>Choose camp command from the menu. Send camp wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_camp(self):\n    \"\"\"\n    Choose camp command from the menu.\n    Send camp wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Camp\",\n            \"type\": \"camp\",\n            \"value\": self.camp.color.name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_start_position","title":"<code>cmd_choose_start_position()</code>  <code>async</code>","text":"<p>Choose start position command from the menu. Send start position wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_start_position(self):\n    \"\"\"\n    Choose start position command from the menu.\n    Send start position wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Start Position\",\n            \"type\": \"choice_str\",\n            \"choices\": [p.name for p in StartPositionEnum if self.start_positions.is_valid(p)],\n            \"value\": StartPositionEnum(self.shared_properties.start_position).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_strategy","title":"<code>cmd_choose_strategy()</code>  <code>async</code>","text":"<p>Choose strategy command from the menu. Send strategy wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_strategy(self):\n    \"\"\"\n    Choose strategy command from the menu.\n    Send strategy wizard message.\n    \"\"\"\n    choices: list[tuple[str, str, str]] = []  # list of (category, value, name). Name can be used for display.\n    for strategy_enum in StrategyEnum:\n        split = re.findall(r\"[A-Z][a-z]*|[a-z]+|[0-9]+\", strategy_enum.name)\n        choices.append((strategy_enum.name, split[0], \" \".join(split)))\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Strategy\",\n            \"type\": \"choice_str\",\n            \"choices\": choices,\n            \"value\": StrategyEnum(self.shared_properties.strategy).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_table","title":"<code>cmd_choose_table()</code>  <code>async</code>","text":"<p>Choose table command from the menu. Send table wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_table(self):\n    \"\"\"\n    Choose table command from the menu.\n    Send table wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Table\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in TableEnum],\n            \"value\": TableEnum(self.shared_properties.table).name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_next","title":"<code>cmd_next()</code>  <code>async</code>","text":"<p>Next command from the menu. Ignored if current pose is not reached for all robots.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_next(self):\n    \"\"\"\n    Next command from the menu.\n    Ignored if current pose is not reached for all robots.\n    \"\"\"\n    logger.info(\"Planner: cmd_next()\")\n    if self.playing:\n        return\n\n    # Check that pose_reached is set\n    if not self.pose_reached:\n        return\n\n    asyncio.create_task(self.next_pose())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_play","title":"<code>cmd_play(timestamp=None)</code>  <code>async</code>","text":"<p>Play command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_play(self, timestamp: str | None = None):\n    \"\"\"\n    Play command from the menu.\n    \"\"\"\n    if timestamp:\n        self.countdown_start_timestamp = datetime.fromisoformat(timestamp)\n    else:\n        self.countdown_start_timestamp = datetime.now(UTC)\n\n    logger.info(f\"Planner: cmd_play({self.countdown_start_timestamp})\")\n    if self.playing:\n        return\n\n    self.game_context.countdown = self.game_context.game_duration\n    self.playing = True\n    self.led.color = Color(\"blue\")\n\n    await self.sio_ns.emit(\n        \"start_countdown\",\n        (self.robot_id, self.game_context.game_duration, self.countdown_start_timestamp.isoformat(), \"deepskyblue\"),\n    )\n\n    await self.sio_ns.emit(\"start_video_record\")\n    asyncio.create_task(self.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_reset","title":"<code>cmd_reset()</code>  <code>async</code>","text":"<p>Reset command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_reset(self):\n    \"\"\"\n    Reset command from the menu.\n    \"\"\"\n    logger.info(\"Planner: cmd_reset()\")\n    await self.reset()\n    await self.sio_ns.emit(\"cmd_reset\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_stop","title":"<code>cmd_stop()</code>  <code>async</code>","text":"<p>Stop command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_stop(self):\n    \"\"\"\n    Stop command from the menu.\n    \"\"\"\n    logger.info(\"Planner: cmd_stop()\")\n    self.playing = False\n    await self.sio_ns.emit(\"stop_video_record\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.command","title":"<code>command(cmd, *args)</code>  <code>async</code>","text":"<p>Execute a command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def command(self, cmd: str, *args):\n    \"\"\"\n    Execute a command from the menu.\n    \"\"\"\n    if cmd.startswith(\"wizard_\"):\n        await self.cmd_wizard_test(cmd)\n        return\n\n    if cmd.startswith(\"act_\"):\n        await self.cmd_act(cmd)\n        return\n\n    if cmd.startswith(\"cam_\"):\n        await self.cmd_cam(cmd)\n        return\n\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema_with_values = properties_schema.copy()\n        # Add current values in JSON Schema\n        for prop in schema_with_values[\"properties\"]:\n            schema_with_values[\"properties\"][prop][\"value\"] = getattr(self.shared_properties, prop)\n        # Send config\n        await self.sio_ns.emit(\"config\", schema_with_values)\n        return\n\n    if cmd == \"scservos\":\n        # Get JSON Schema\n        schema = self.scservos.get_schema()\n        await self.sio_ns.emit(\"config\", schema)\n        return\n\n    if cmd == \"game_wizard\":\n        await self.game_wizard.start()\n        return\n\n    if not (cmd_func := getattr(self, f\"cmd_{cmd}\", None)):\n        logger.warning(f\"Unknown command: {cmd}\")\n        return\n\n    await cmd_func(*args)\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    self.retry_connection = True\n    try:\n        await self.try_connect()\n        await self.sio.wait()\n    except asyncio.CancelledError:\n        self.process_manager.shutdown()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.next_pose","title":"<code>next_pose()</code>  <code>async</code>","text":"<p>Select the next pose for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def next_pose(self):\n    \"\"\"\n    Select the next pose for a robot.\n    \"\"\"\n    logger.info(\"Planner: next_pose()\")\n    try:\n        # Get and set new pose\n        self.pose_reached = False\n        await self.next_pose_in_action()\n\n        # If no pose left in current action, get and set new action\n        if not self.pose_order and (new_action := await self.strategy.get_next_action()):\n            await self.set_action(new_action)\n            if not self.pose_order:\n                asyncio.create_task(self.set_pose_reached())\n    except Exception as exc:  # noqa\n        logger.warning(f\"Planner: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.reset","title":"<code>reset()</code>  <code>async</code>","text":"<p>Reset planner, context, robots and strategy.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def reset(self):\n    \"\"\"\n    Reset planner, context, robots and strategy.\n    \"\"\"\n    await self.stop()\n    await self.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_action","title":"<code>set_action(action)</code>  <code>async</code>","text":"<p>Set current action.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_action(self, action: \"action.Action\"):\n    \"\"\"\n    Set current action.\n    \"\"\"\n    logger.info(f\"Planner: set action '{action.name}'\")\n    self.pose_order = None\n    self.action = action\n    await self.action.act_before_action()\n    await self.next_pose_in_action()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_intermediate_pose_reached","title":"<code>set_intermediate_pose_reached()</code>  <code>async</code>","text":"<p>Set pose reached for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_intermediate_pose_reached(self):\n    \"\"\"\n    Set pose reached for a robot.\n    \"\"\"\n    logger.info(\"Planner: set_intermediate_pose_reached()\")\n\n    # The pose reached is intermediate, just force path recompute.\n    if self.pose_order:\n        await self.pose_order.act_intermediate_pose()\n        self.pose_order.path_pose.to_shared(self.shared_avoidance_pose_order)\n        self.shared_memory.avoidance_has_new_pose_order = True\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_reached","title":"<code>set_pose_reached()</code>  <code>async</code>","text":"<p>Set pose reached for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_pose_reached(self):\n    \"\"\"\n    Set pose reached for a robot.\n    \"\"\"\n    logger.info(\"Planner: set_pose_reached()\")\n\n    # Set pose reached\n    if not self.pose_reached and (pose_order := self.pose_order):\n        self.pose_order = None\n        await pose_order.act_after_pose()\n    else:\n        self.pose_order = None\n\n    self.pose_reached = True\n    if (action := self.action) and len(self.action.poses) == 0:\n        self.action = None\n        await action.act_after_action()\n\n    if not self.playing:\n        return\n\n    await self.next_pose()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_start","title":"<code>set_pose_start(pose_start)</code>  <code>async</code>","text":"<p>Set the start position of the robot for the next game.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_pose_start(self, pose_start: models.Pose):\n    \"\"\"\n    Set the start position of the robot for the next game.\n    \"\"\"\n    self.action = None\n    self.pose_order = None\n    self.pose_reached = True\n\n    # When the firmware receives a pose start, it does not send its updated pose current,\n    # so do it here.\n    self.shared_pose_current_buffer.push(pose_start.x, pose_start.y, pose_start.O)\n    await self.sio_ns.emit(\"pose_start\", pose_start.model_dump())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.soft_reset","title":"<code>soft_reset()</code>  <code>async</code>","text":"<p>Only reset context and strategy.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def soft_reset(self):\n    \"\"\"\n    Only reset context and strategy.\n    \"\"\"\n    self.game_context.reset()\n    self.playing = False\n    await self.set_controller(self.default_controller, True)\n    table = get_table(self.shared_properties.table)\n    self.shared_table_limits[0] = table.x_min\n    self.shared_table_limits[1] = table.x_max\n    self.shared_table_limits[2] = table.y_min\n    self.shared_table_limits[3] = table.y_max\n    self.shared_memory.avoidance_has_pose_order = False\n    self.shared_memory.avoidance_has_new_pose_order = False\n    self.flag_motor.off()\n    self.strategy = strategy_classes.get(StrategyEnum(self.shared_properties.strategy), strategy.Strategy)(self)\n    await self.set_pose_start(self.start_positions.get())\n    self.pami_event.clear()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start sending obstacles list.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start sending obstacles list.\n    \"\"\"\n    logger.info(\"Planner: start\")\n    self.create_shared_memory()\n    self.shared_memory.avoidance_exiting = False\n    await self.soft_reset()\n    await self.event_manager.start_loops()\n    await self.sio_ns.emit(\"starter_changed\", self.starter.is_pressed)\n    await self.sio_ns.emit(\"game_reset\")\n    self.obstacles_updater_loop.start()\n    if self.oled_bus and self.oled_address:\n        self.oled_update_loop.start()\n\n    self.avoidance_process = Process(target=avoidance_process, args=(self.robot_id,))\n    self.avoidance_process.start()\n\n    await actuators.actuators_init(self)\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop running tasks.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def stop(self):\n    \"\"\"\n    Stop running tasks.\n    \"\"\"\n    logger.info(\"Planner: stop\")\n\n    self.shared_memory.avoidance_exiting = True\n    await self.sio_ns.emit(\"stop_video_record\")\n    await self.event_manager.stop_loops()\n    await self.obstacles_updater_loop.stop()\n    if self.oled_bus and self.oled_address:\n        await self.oled_update_loop.stop()\n\n    if self.avoidance_process and self.avoidance_process.is_alive():\n        self.avoidance_process.join()\n        self.avoidance_process = None\n\n    self.delete_shared_memory()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/planner\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.update_config","title":"<code>update_config(config)</code>","text":"<p>Update a Planner property with the value sent by the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def update_config(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update a Planner property with the value sent by the dashboard.\n    \"\"\"\n    name = config[\"name\"]\n    current_value = getattr(self.shared_properties, name)\n    current_value_type = type(current_value)\n    setattr(self.shared_properties, name, current_value_type(config[\"value\"]))\n    match name:\n        case \"obstacle_updater_interval\":\n            self.obstacles_updater_loop.interval = self.shared_properties.obstacle_updater_interval\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.update_scservo","title":"<code>update_scservo(servo)</code>  <code>async</code>","text":"<p>Update a SC Servo with the value sent by the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def update_scservo(self, servo: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update a SC Servo with the value sent by the dashboard.\n    \"\"\"\n    self.scservos.set(SCServoEnum[servo[\"name\"]], servo[\"value\"])\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.wizard_response","title":"<code>wizard_response(message)</code>  <code>async</code>","text":"<p>Handle wizard response sent from the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def wizard_response(self, message: dict[str, Any]):\n    \"\"\"\n    Handle wizard response sent from the dashboard.\n    \"\"\"\n    if (value := message[\"value\"]) is None:\n        return\n\n    match name := message.get(\"name\"):\n        case \"Choose Camp\":\n            new_camp = Camp.Colors[value]\n            if self.camp.color == new_camp:\n                return\n            previous_camp = self.camp.color\n            if self.shared_properties.table == TableEnum.Training and new_camp == Camp.Colors.yellow:\n                error_message = \"Yellow camp not compatible with training table\"\n                self.camp.color = previous_camp\n                logger.warning(f\"Wizard: {error_message}\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": message,\n                    },\n                )\n                return\n            self.camp.color = new_camp\n            await self.soft_reset()\n            logger.info(f\"Wizard: New camp: {self.camp.color.name}\")\n        case \"Choose Strategy\":\n            new_strategy = StrategyEnum[value]\n            if self.shared_properties.strategy == new_strategy:\n                return\n            self.shared_properties.strategy = new_strategy.val\n            await self.soft_reset()\n            logger.info(f\"Wizard: New strategy: {value}\")\n        case \"Choose Avoidance\":\n            new_avoidance = AvoidanceStrategy[value]\n            if self.shared_properties.avoidance_strategy == new_avoidance:\n                return\n            self.shared_properties.avoidance_strategy = new_avoidance.val\n            logger.info(f\"Wizard: New avoidance strategy: {value}\")\n        case \"Choose Start Position\":\n            new_start_position = StartPositionEnum[value]\n            if self.shared_properties.start_position == new_start_position:\n                return\n            if not self.start_positions.is_valid(new_start_position):\n                message = f\"Start position {new_start_position.name} invalid in current table and camp\"\n                logger.warning(f\"Wizard: {message}\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": message,\n                    },\n                )\n                return\n            self.shared_properties.start_position = new_start_position.val\n            await self.soft_reset()\n        case \"Choose Table\":\n            new_table = TableEnum[value]\n            if self.shared_properties.table == new_table:\n                return\n            error_message = \"\"\n            previous_table = self.shared_properties.table\n            self.shared_properties.table = new_table.val\n            if not self.start_positions.is_valid(StartPositionEnum(self.shared_properties.start_position)):\n                error_message = (\n                    f\"Table {new_table.name} not compatible \"\n                    f\"with start position {StartPositionEnum(self.shared_properties.start_position).name}\"\n                )\n            if new_table == TableEnum.Training and self.camp.color == Camp.Colors.yellow:\n                error_message = f\"Table {new_table.name} not compatible yellow camp\"\n            if error_message:\n                self.shared_properties.table = previous_table\n                logger.warning(f\"Wizard: {error_message}\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": error_message,\n                    },\n                )\n                return\n            await self.soft_reset()\n            logger.info(f\"Wizard: New table: {value}\")\n        case game_wizard_response if game_wizard_response.startswith(\"Game Wizard\"):\n            await self.game_wizard.response(message)\n        case wizard_test_response if wizard_test_response.startswith(\"Wizard Test\"):\n            logger.info(f\"Wizard test response: {name} = {value}\")\n        case _:\n            logger.warning(f\"Wizard: Unknown type: {name}\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/","title":"pose","text":""},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose","title":"<code>AdaptedPose</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Like a Pose, but its values are automatically adapted to selected camp during initialization. So to define static positions in actions, we can use this class to set pose related to the default camp, and if the camp changes, the pose will be adapted on reset.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>class AdaptedPose(Pose):\n    \"\"\"\n    Like a Pose, but its values are automatically adapted to selected camp\n    during initialization.\n    So to define static positions in actions, we can use this class to set pose related\n    to the default camp, and if the camp changes, the pose will be adapted on reset.\n    \"\"\"\n\n    _camp: ClassVar[Camp] = Camp()\n\n    @field_validator(\"y\")\n    @classmethod\n    def adapt_y(cls, v, **kwargs):\n        \"\"\"\n        Validator to adapt Y depending on the camp at initialization.\n        \"\"\"\n        return cls._camp.adapt_y(v)\n\n    @field_validator(\"O\")\n    @classmethod\n    def adapt_O(cls, v, **kwargs):\n        \"\"\"\n        Validator to adapt the angle depending on the camp at initialization.\n        \"\"\"\n        return cls._camp.adapt_angle(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose.adapt_O","title":"<code>adapt_O(v, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validator to adapt the angle depending on the camp at initialization.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@field_validator(\"O\")\n@classmethod\ndef adapt_O(cls, v, **kwargs):\n    \"\"\"\n    Validator to adapt the angle depending on the camp at initialization.\n    \"\"\"\n    return cls._camp.adapt_angle(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose.adapt_y","title":"<code>adapt_y(v, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validator to adapt Y depending on the camp at initialization.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@field_validator(\"y\")\n@classmethod\ndef adapt_y(cls, v, **kwargs):\n    \"\"\"\n    Validator to adapt Y depending on the camp at initialization.\n    \"\"\"\n    return cls._camp.adapt_y(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>PathPose</code></p> <p>Pose class used in actions. A function can be executed before moving and an other once it is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>class Pose(PathPose):\n    \"\"\"\n    Pose class used in actions.\n    A function can be executed before moving and an other once it is reached.\n    \"\"\"\n\n    before_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n    intermediate_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n    after_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n\n    @final\n    async def act_before_pose(self):\n        \"\"\"\n        Function executed before the robot starts moving.\n        \"\"\"\n        if self.before_pose_func:\n            await self.before_pose_func()\n\n    @final\n    async def act_intermediate_pose(self):\n        \"\"\"\n        Function executed once an intermediate pose is reached.\n        \"\"\"\n        if self.intermediate_pose_func:\n            await self.intermediate_pose_func()\n\n    @final\n    async def act_after_pose(self):\n        \"\"\"\n        Function executed once the pose is reached.\n        \"\"\"\n        if self.after_pose_func:\n            await self.after_pose_func()\n\n    @property\n    def path_pose(self) -&gt; PathPose:\n        \"\"\"\n        Convert the pose into its parent class.\n        \"\"\"\n        return PathPose(**self.model_dump())\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.path_pose","title":"<code>path_pose</code>  <code>property</code>","text":"<p>Convert the pose into its parent class.</p>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_after_pose","title":"<code>act_after_pose()</code>  <code>async</code>","text":"<p>Function executed once the pose is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_after_pose(self):\n    \"\"\"\n    Function executed once the pose is reached.\n    \"\"\"\n    if self.after_pose_func:\n        await self.after_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_before_pose","title":"<code>act_before_pose()</code>  <code>async</code>","text":"<p>Function executed before the robot starts moving.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_before_pose(self):\n    \"\"\"\n    Function executed before the robot starts moving.\n    \"\"\"\n    if self.before_pose_func:\n        await self.before_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_intermediate_pose","title":"<code>act_intermediate_pose()</code>  <code>async</code>","text":"<p>Function executed once an intermediate pose is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_intermediate_pose(self):\n    \"\"\"\n    Function executed once an intermediate pose is reached.\n    \"\"\"\n    if self.intermediate_pose_func:\n        await self.intermediate_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/planner/scservos/","title":"scservos","text":""},{"location":"reference/cogip/tools/planner/scservos/#cogip.tools.planner.scservos.SCServoEnum","title":"<code>SCServoEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining SC Servo IDs</p> Source code in <code>cogip/tools/planner/scservos.py</code> <pre><code>class SCServoEnum(IntEnum):\n    \"\"\"Enum defining SC Servo IDs\"\"\"\n\n    UNUSED = 0\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__(\"/planner\")\n        self.planner = planner\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=0.2,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\", self.planner.virtual)\n        await self.emit(\"register_menu\", {\"name\": \"planner\", \"menu\": menu.model_dump()})\n        await self.emit(\"register_menu\", {\"name\": \"wizard\", \"menu\": wizard_test_menu.model_dump()})\n        if self.planner.robot_id == 1:\n            await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": robot_actuators_menu.model_dump()})\n            await self.emit(\n                \"register_menu\", {\"name\": \"actuators_multi\", \"menu\": robot_actuators_multi_menu.model_dump()}\n            )\n        else:\n            await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": pami_actuators_menu.model_dump()})\n        await self.emit(\"register_menu\", {\"name\": \"cameras\", \"menu\": cameras_menu.model_dump()})\n\n    async def on_disconnect(self):\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        await self.planner.stop()\n        logger.info(\"Disconnected from cogip-server\")\n\n    async def on_connect_error(self, data: dict[str, Any]):\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A planner is already connected\"\n        ):\n            logger.error(f\"Connection to cogip-server failed: {message}\")\n            self.planner.retry_connection = False\n            return\n        else:\n            logger.error(f\"Connection to cogip-server failed: {data = }\")\n\n    async def on_copilot_connected(self):\n        \"\"\"\n        Copilot connected, start planner.\n        \"\"\"\n        logger.info(\"[SIO] Copilot connected.\")\n        await self.planner.start()\n\n    async def on_copilot_disconnected(self):\n        \"\"\"\n        Copilot disconnected, stop planner.\n        \"\"\"\n        logger.info(\"[SIO] Copilot disconnected.\")\n        await self.planner.stop()\n\n    def on_starter_changed(self, pushed: bool):\n        \"\"\"\n        Signal received from the Monitor when the starter state changes in emulation mode.\n        \"\"\"\n        logger.info(f\"[SIO] Starter changed: {pushed}\")\n        if not self.planner.virtual:\n            return\n        if pushed:\n            self.planner.starter.pin.drive_low()\n        else:\n            self.planner.starter.pin.drive_high()\n\n    async def on_reset(self):\n        \"\"\"\n        Callback on reset message from copilot.\n        \"\"\"\n        logger.info(\"[SIO] Reset.\")\n        await self.planner.reset()\n\n    async def on_pose_reached(self):\n        \"\"\"\n        Callback on pose reached message.\n        \"\"\"\n        logger.info(\"[SIO] Pose reached.\")\n        asyncio.create_task(self.planner.set_pose_reached())\n\n    async def on_intermediate_pose_reached(self):\n        \"\"\"\n        Callback on intermediate pose reached message.\n        \"\"\"\n        logger.info(\"[SIO] Intermediate pose reached.\")\n        asyncio.create_task(self.planner.set_intermediate_pose_reached())\n\n    async def on_blocked(self):\n        \"\"\"\n        Callback on blocked message.\n        \"\"\"\n        logger.info(\"[SIO] Blocked.\")\n        asyncio.create_task(self.planner.blocked())\n\n    async def on_command(self, cmd: str, *args):\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        logger.info(f\"[SIO] Command: {cmd}\")\n        await self.planner.command(cmd, *args)\n\n    async def on_config_updated(self, config: dict[str, Any]):\n        \"\"\"\n        Callback on config update from dashboard.\n        \"\"\"\n        self.planner.update_config(config)\n\n    async def on_scservo_updated(self, scservo: dict[str, Any]):\n        \"\"\"\n        Callback on scservo update from dashboard.\n        \"\"\"\n        await self.planner.update_scservo(scservo)\n\n    async def on_wizard(self, message: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        await self.planner.wizard_response(message)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game end message.\n        \"\"\"\n        logger.info(\"[SIO] Game ended.\")\n        await self.planner.game_end()\n\n    async def on_actuator_state(self, actuator_state: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        try:\n            state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n        except ValidationError as exc:\n            logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n            return\n\n        await self.planner.update_actuator_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_actuator_state","title":"<code>on_actuator_state(actuator_state)</code>  <code>async</code>","text":"<p>Callback on actuator_state message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_actuator_state(self, actuator_state: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_state message.\n    \"\"\"\n    try:\n        state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n    except ValidationError as exc:\n        logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n        return\n\n    await self.planner.update_actuator_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_blocked","title":"<code>on_blocked()</code>  <code>async</code>","text":"<p>Callback on blocked message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_blocked(self):\n    \"\"\"\n    Callback on blocked message.\n    \"\"\"\n    logger.info(\"[SIO] Blocked.\")\n    asyncio.create_task(self.planner.blocked())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_command","title":"<code>on_command(cmd, *args)</code>  <code>async</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_command(self, cmd: str, *args):\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    logger.info(f\"[SIO] Command: {cmd}\")\n    await self.planner.command(cmd, *args)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config update from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]):\n    \"\"\"\n    Callback on config update from dashboard.\n    \"\"\"\n    self.planner.update_config(config)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=0.2,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\", self.planner.virtual)\n    await self.emit(\"register_menu\", {\"name\": \"planner\", \"menu\": menu.model_dump()})\n    await self.emit(\"register_menu\", {\"name\": \"wizard\", \"menu\": wizard_test_menu.model_dump()})\n    if self.planner.robot_id == 1:\n        await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": robot_actuators_menu.model_dump()})\n        await self.emit(\n            \"register_menu\", {\"name\": \"actuators_multi\", \"menu\": robot_actuators_multi_menu.model_dump()}\n        )\n    else:\n        await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": pami_actuators_menu.model_dump()})\n    await self.emit(\"register_menu\", {\"name\": \"cameras\", \"menu\": cameras_menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]):\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A planner is already connected\"\n    ):\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n        self.planner.retry_connection = False\n        return\n    else:\n        logger.error(f\"Connection to cogip-server failed: {data = }\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_copilot_connected","title":"<code>on_copilot_connected()</code>  <code>async</code>","text":"<p>Copilot connected, start planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_copilot_connected(self):\n    \"\"\"\n    Copilot connected, start planner.\n    \"\"\"\n    logger.info(\"[SIO] Copilot connected.\")\n    await self.planner.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_copilot_disconnected","title":"<code>on_copilot_disconnected()</code>  <code>async</code>","text":"<p>Copilot disconnected, stop planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_copilot_disconnected(self):\n    \"\"\"\n    Copilot disconnected, stop planner.\n    \"\"\"\n    logger.info(\"[SIO] Copilot disconnected.\")\n    await self.planner.stop()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_disconnect(self):\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    await self.planner.stop()\n    logger.info(\"Disconnected from cogip-server\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game end message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game end message.\n    \"\"\"\n    logger.info(\"[SIO] Game ended.\")\n    await self.planner.game_end()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_intermediate_pose_reached","title":"<code>on_intermediate_pose_reached()</code>  <code>async</code>","text":"<p>Callback on intermediate pose reached message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_intermediate_pose_reached(self):\n    \"\"\"\n    Callback on intermediate pose reached message.\n    \"\"\"\n    logger.info(\"[SIO] Intermediate pose reached.\")\n    asyncio.create_task(self.planner.set_intermediate_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_pose_reached","title":"<code>on_pose_reached()</code>  <code>async</code>","text":"<p>Callback on pose reached message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_pose_reached(self):\n    \"\"\"\n    Callback on pose reached message.\n    \"\"\"\n    logger.info(\"[SIO] Pose reached.\")\n    asyncio.create_task(self.planner.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_reset","title":"<code>on_reset()</code>  <code>async</code>","text":"<p>Callback on reset message from copilot.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_reset(self):\n    \"\"\"\n    Callback on reset message from copilot.\n    \"\"\"\n    logger.info(\"[SIO] Reset.\")\n    await self.planner.reset()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_scservo_updated","title":"<code>on_scservo_updated(scservo)</code>  <code>async</code>","text":"<p>Callback on scservo update from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_scservo_updated(self, scservo: dict[str, Any]):\n    \"\"\"\n    Callback on scservo update from dashboard.\n    \"\"\"\n    await self.planner.update_scservo(scservo)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_starter_changed","title":"<code>on_starter_changed(pushed)</code>","text":"<p>Signal received from the Monitor when the starter state changes in emulation mode.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>def on_starter_changed(self, pushed: bool):\n    \"\"\"\n    Signal received from the Monitor when the starter state changes in emulation mode.\n    \"\"\"\n    logger.info(f\"[SIO] Starter changed: {pushed}\")\n    if not self.planner.virtual:\n        return\n    if pushed:\n        self.planner.starter.pin.drive_low()\n    else:\n        self.planner.starter.pin.drive_high()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_wizard","title":"<code>on_wizard(message)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_wizard(self, message: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    await self.planner.wizard_response(message)\n</code></pre>"},{"location":"reference/cogip/tools/planner/start_positions/","title":"start_positions","text":""},{"location":"reference/cogip/tools/planner/start_positions/#cogip.tools.planner.start_positions.StartPositionEnum","title":"<code>StartPositionEnum</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Enum for available start positions.</p> Source code in <code>cogip/tools/planner/start_positions.py</code> <pre><code>class StartPositionEnum(ArgEnum):\n    \"\"\"\n    Enum for available start positions.\n    \"\"\"\n\n    Bottom = auto()\n    Top = auto()\n    Opposite = auto()\n    PAMI2 = auto()\n    PAMI3 = auto()\n    PAMI4 = auto()\n    PAMI5 = auto()\n    Center = auto()\n</code></pre>"},{"location":"reference/cogip/tools/planner/table/","title":"table","text":""},{"location":"reference/cogip/tools/planner/table/#cogip.tools.planner.table.TableEnum","title":"<code>TableEnum</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Enum for available tables.</p> Source code in <code>cogip/tools/planner/table.py</code> <pre><code>class TableEnum(ArgEnum):\n    \"\"\"\n    Enum for available tables.\n    \"\"\"\n\n    Training = 0\n    Game = 1\n</code></pre>"},{"location":"reference/cogip/tools/planner/wizard/","title":"wizard","text":""},{"location":"reference/cogip/tools/planner/actions/action/","title":"action","text":""},{"location":"reference/cogip/tools/planner/actions/action/#cogip.tools.planner.actions.action.Action","title":"<code>Action</code>","text":"<p>This class represents an action of the game. It contains a list of Pose to reach in order. A function can be executed before the action starts and after it ends.</p> Source code in <code>cogip/tools/planner/actions/action.py</code> <pre><code>class Action:\n    \"\"\"\n    This class represents an action of the game.\n    It contains a list of Pose to reach in order.\n    A function can be executed before the action starts and after it ends.\n    \"\"\"\n\n    logger = logger\n\n    def __init__(self, name: str, planner: \"Planner\", strategy: \"Strategy\", interruptable: bool = True):\n        self.name = name\n        self.planner = planner\n        self.strategy = strategy\n        self.interruptable = interruptable\n        self.poses: list[Pose] = []\n        self.before_action_func: Callable[[], Awaitable[None]] | None = None\n        self.after_action_func: Callable[[], Awaitable[None]] | None = None\n        self.recycled: bool = False\n\n    def weight(self) -&gt; float:\n        \"\"\"\n        Weight of the action.\n        It can be used to choose the next action to select.\n        This is the generic implementation.\n        \"\"\"\n        raise NotImplementedError\n\n    @final\n    async def act_before_action(self):\n        \"\"\"\n        Function executed before the action starts.\n        \"\"\"\n        if self.before_action_func:\n            await self.before_action_func()\n\n    @final\n    async def act_after_action(self):\n        \"\"\"\n        Function executed after the action ends.\n        \"\"\"\n        if self.after_action_func:\n            await self.after_action_func()\n\n        # Re-enable all actions after a successful action\n        for action in self.strategy:\n            action.recycled = False\n\n    async def recycle(self):\n        \"\"\"\n        Function called if the action is blocked and put back in the actions list\n        \"\"\"\n        self.recycled = True\n\n    @property\n    def pose_current(self) -&gt; models.Pose:\n        return self.planner.pose_current\n\n    async def evaluate(self):\n        # Average robot speed in mm/s.\n        # This is just an empirical value found by testing that gives a good enough\n        # estimation of the time needed to perform the action.\n        # This could be improved later by using target speed and acceleration.\n        average_speed = 100\n\n        await self.act_before_action()\n\n        # Update countdown\n        self.planner.game_context.countdown -= asyncio.sleep.total_sleep\n        asyncio.sleep.reset()\n\n        while len(self.poses) and self.planner.game_context.countdown &gt; 0:\n            pose = self.poses.pop(0)\n\n            await pose.act_before_pose()\n            await pose.act_after_pose()\n\n            # Update countdown\n            distance = math.dist(\n                (self.planner.pose_current.x, self.planner.pose_current.y),\n                (pose.x, pose.y),\n            )\n            self.planner.game_context.countdown -= asyncio.sleep.total_sleep + distance / average_speed\n            asyncio.sleep.reset()\n\n            # Update pose_current\n            self.planner.pose_current.x = pose.x\n            self.planner.pose_current.y = pose.y\n            self.planner.pose_current.O = pose.O\n\n        await self.act_after_action()\n\n        # Update countdown\n        self.planner.game_context.countdown -= asyncio.sleep.total_sleep\n        asyncio.sleep.reset()\n\n    def __str__(self) -&gt; str:\n        return f\"Action[0x{id(self):x}]({self.name})\"\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action/#cogip.tools.planner.actions.action.Action.act_after_action","title":"<code>act_after_action()</code>  <code>async</code>","text":"<p>Function executed after the action ends.</p> Source code in <code>cogip/tools/planner/actions/action.py</code> <pre><code>@final\nasync def act_after_action(self):\n    \"\"\"\n    Function executed after the action ends.\n    \"\"\"\n    if self.after_action_func:\n        await self.after_action_func()\n\n    # Re-enable all actions after a successful action\n    for action in self.strategy:\n        action.recycled = False\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action/#cogip.tools.planner.actions.action.Action.act_before_action","title":"<code>act_before_action()</code>  <code>async</code>","text":"<p>Function executed before the action starts.</p> Source code in <code>cogip/tools/planner/actions/action.py</code> <pre><code>@final\nasync def act_before_action(self):\n    \"\"\"\n    Function executed before the action starts.\n    \"\"\"\n    if self.before_action_func:\n        await self.before_action_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action/#cogip.tools.planner.actions.action.Action.recycle","title":"<code>recycle()</code>  <code>async</code>","text":"<p>Function called if the action is blocked and put back in the actions list</p> Source code in <code>cogip/tools/planner/actions/action.py</code> <pre><code>async def recycle(self):\n    \"\"\"\n    Function called if the action is blocked and put back in the actions list\n    \"\"\"\n    self.recycled = True\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action/#cogip.tools.planner.actions.action.Action.weight","title":"<code>weight()</code>","text":"<p>Weight of the action. It can be used to choose the next action to select. This is the generic implementation.</p> Source code in <code>cogip/tools/planner/actions/action.py</code> <pre><code>def weight(self) -&gt; float:\n    \"\"\"\n    Weight of the action.\n    It can be used to choose the next action to select.\n    This is the generic implementation.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_align/","title":"action_align","text":""},{"location":"reference/cogip/tools/planner/actions/action_align/#cogip.tools.planner.actions.action_align.AlignBottomAction","title":"<code>AlignBottomAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to align the back of the robot on the border before game start. Only on Bottom start position.</p> Source code in <code>cogip/tools/planner/actions/action_align.py</code> <pre><code>class AlignBottomAction(Action):\n    \"\"\"\n    Action used to align the back of the robot on the border before game start.\n    Only on Bottom start position.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        strategy: Strategy,\n        *,\n        final_pose: models.Pose = Pose(x=-750, y=-250, O=0),\n        reset_countdown=False,\n        weight: float = 2000000.0,\n    ):\n        self.final_pose = final_pose\n        self.reset_countdown = reset_countdown\n        self.custom_weight = weight\n        super().__init__(\"Align Bottom action\", planner, strategy)\n        self.before_action_func = self.init_poses\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def init_poses(self):\n        self.avoidance_backup = AvoidanceStrategy(self.planner.shared_properties.avoidance_strategy)\n\n        # On start, the robot is aligned on the right (blue camp) border of the Bottom start position\n        self.start_pose = AdaptedPose(\n            x=-750,\n            y=-500 + self.planner.shared_properties.robot_width / 2,\n            O=0,\n        )\n        await self.planner.sio_ns.emit(\"pose_start\", self.start_pose.model_dump())\n\n        # Align back\n        pose = Pose(\n            x=-1200,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=10,\n            max_speed_angular=10,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            bypass_anti_blocking=True,\n            timeout_ms=0,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_align_back,\n            after_pose_func=self.after_align_back,\n        )\n        self.poses.append(pose)\n\n        # Step forward\n        pose = Pose(\n            x=-950 + self.planner.shared_properties.robot_length / 2,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_step_forward,\n            after_pose_func=self.after_step_forward,\n        )\n        self.poses.append(pose)\n\n        # Final pose\n        pose = AdaptedPose(\n            x=self.final_pose.x,\n            y=self.final_pose.y,\n            O=self.final_pose.O,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            before_pose_func=self.before_final_pose,\n            after_pose_func=self.after_final_pose,\n        )\n        self.poses.append(pose)\n\n    async def before_align_back(self):\n        self.logger.info(f\"{self.name}: before_align_back\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_align_back(self):\n        self.logger.info(f\"{self.name}: after_align_back\")\n        current_pose = models.Pose(\n            x=-1000 + self.planner.shared_properties.robot_length / 2,\n            y=self.start_pose.y,\n            O=0,\n        )\n        await self.planner.sio_ns.emit(\"pose_start\", current_pose.model_dump())\n        await asyncio.sleep(1)\n\n    async def before_step_forward(self):\n        self.logger.info(f\"{self.name}: before_step_forward\")\n\n    async def after_step_forward(self):\n        self.logger.info(f\"{self.name}: after_step_forward\")\n\n    async def before_final_pose(self):\n        self.logger.info(f\"{self.name}: before_final_pose\")\n\n    async def after_final_pose(self):\n        self.logger.info(f\"{self.name}: after_final_pose\")\n        self.set_avoidance(self.avoidance_backup)\n        if self.reset_countdown:\n            now = datetime.now(UTC)\n            self.planner.countdown_start_timestamp = now\n            await self.planner.sio_ns.emit(\n                \"start_countdown\",\n                (self.planner.robot_id, self.planner.game_context.game_duration, now.isoformat(), \"deepskyblue\"),\n            )\n\n    def weight(self) -&gt; float:\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x1/","title":"action_build_tribune_x1","text":""},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x1/#cogip.tools.planner.actions.action_build_tribune_x1.BuildTribuneX1Action","title":"<code>BuildTribuneX1Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to build a tribune.</p> Source code in <code>cogip/tools/planner/actions/action_build_tribune_x1.py</code> <pre><code>class BuildTribuneX1Action(Action):\n    \"\"\"\n    Action used to build a tribune.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        strategy: Strategy,\n        construction_area_id: ConstructionAreaID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"BuildTribuneX1 {construction_area_id.name}\", planner, strategy)\n        self.before_action_func = self.before_action\n        self.construction_area_id = construction_area_id\n        self.shift_build = 180\n        self.shift_approach = self.shift_build + 150\n        self.shift_step_back = self.shift_approach\n\n    @property\n    def construction_area(self) -&gt; ConstructionArea:\n        return self.planner.game_context.construction_areas[self.construction_area_id]\n\n    async def recycle(self):\n        self.recycled = True\n\n    async def before_action(self):\n        self.logger.info(\n            f\"{self.name}: before_action - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n        self.start_pose = self.pose_current\n\n        # Approach\n        # Skip approach if the robot is already in front of the construction area\n        match self.construction_area.O:\n            case 0 | 180:\n                diff = abs(self.construction_area.y - self.start_pose.y)\n            case -90 | 90:\n                diff = abs(self.construction_area.x - self.start_pose.x)\n            case _:\n                diff = 1000\n\n        if diff &gt;= 5:\n            approach_pose = Pose(\n                **get_relative_pose(\n                    self.construction_area,\n                    front_offset=self.shift_approach,\n                    angular_offset=180,\n                ).model_dump(),\n                max_speed_linear=100,\n                max_speed_angular=100,\n                motion_direction=MotionDirection.BIDIRECTIONAL,\n                before_pose_func=self.before_approach,\n                after_pose_func=self.after_approach,\n            )\n            self.poses.append(approach_pose)\n        else:\n            self.logger.info(f\"{self.name}: skip approach (diff = {diff})\")\n            await self.before_approach()\n            await self.after_approach()\n\n        # Build\n        build_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=80,\n            max_speed_angular=80,\n            bypass_final_orientation=False,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            after_pose_func=self.after_build,\n        )\n        self.poses.append(build_pose)\n\n        # Step back\n        step_back_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_step_back,\n            after_pose_func=self.after_step_back,\n        )\n        self.poses.append(step_back_pose)\n\n    async def before_approach(self):\n        self.logger.info(f\"{self.name}: before_approach\")\n\n    async def after_approach(self):\n        self.logger.info(f\"{self.name}: after_approach\")\n\n    async def after_build(self):\n        self.logger.info(f\"{self.name}: after_build - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\")\n        self.planner.game_context.tribunes_in_robot -= 1\n        self.construction_area.tribune_level += 1\n\n    async def before_step_back(self):\n        self.logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        self.logger.info(\n            f\"{self.name}: after_step_back - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n        self.construction_area.enabled = True\n        self.planner.game_context.score += 4\n\n    def weight(self) -&gt; float:\n        if self.planner.game_context.tribunes_in_robot == 0 or self.construction_area.tribune_level != 0:\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge2\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x2/","title":"action_build_tribune_x2","text":""},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x2/#cogip.tools.planner.actions.action_build_tribune_x2.BuildTribuneX2Action","title":"<code>BuildTribuneX2Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to build a 2-story tribune.</p> Source code in <code>cogip/tools/planner/actions/action_build_tribune_x2.py</code> <pre><code>class BuildTribuneX2Action(Action):\n    \"\"\"\n    Action used to build a 2-story tribune.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        strategy: Strategy,\n        construction_area_id: ConstructionAreaID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"BuildTribuneX2 {construction_area_id.name}\", planner, strategy)\n        self.before_action_func = self.before_action\n        self.construction_area_id = construction_area_id\n        self.shift_build = 180\n        self.shift_approach = self.shift_build + 150\n        self.shift_step_back = self.shift_approach\n\n    @property\n    def construction_area(self) -&gt; ConstructionArea:\n        return self.planner.game_context.construction_areas[self.construction_area_id]\n\n    async def recycle(self):\n        self.recycled = True\n\n    async def before_action(self):\n        self.logger.info(\n            f\"{self.name}: before_action - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n        self.start_pose = self.pose_current\n\n        # Approach\n        # Skip approach if the robot is already in front of the construction area\n        match self.construction_area.O:\n            case 0 | 180:\n                diff = abs(self.construction_area.y - self.start_pose.y)\n            case -90 | 90:\n                diff = abs(self.construction_area.x - self.start_pose.x)\n            case _:\n                diff = 1000\n\n        if diff &gt;= 5:\n            approach_pose = Pose(\n                **get_relative_pose(\n                    self.construction_area,\n                    front_offset=self.shift_approach,\n                    angular_offset=180,\n                ).model_dump(),\n                max_speed_linear=100,\n                max_speed_angular=100,\n                motion_direction=MotionDirection.BIDIRECTIONAL,\n                before_pose_func=self.before_approach,\n                after_pose_func=self.after_approach,\n            )\n            self.poses.append(approach_pose)\n        else:\n            self.logger.info(f\"{self.name}: skip approach (diff = {diff})\")\n            await self.before_approach()\n            await self.after_approach()\n\n        # Build\n        build_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=80,\n            max_speed_angular=80,\n            bypass_final_orientation=False,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            before_pose_func=self.before_build,\n            after_pose_func=self.after_build,\n        )\n        self.poses.append(build_pose)\n\n        # Step back\n        step_back_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_step_back,\n            after_pose_func=self.after_step_back,\n        )\n        self.poses.append(step_back_pose)\n\n    async def before_approach(self):\n        self.logger.info(f\"{self.name}: before_approach\")\n\n    async def after_approach(self):\n        self.logger.info(f\"{self.name}: after_approach\")\n\n    async def before_build(self):\n        self.logger.info(f\"{self.name}: before_build\")\n\n    async def after_build(self):\n        self.logger.info(f\"{self.name}: after_build - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\")\n        self.planner.game_context.tribunes_in_robot -= 2\n        self.construction_area.tribune_level += 2\n\n    async def before_step_back(self):\n        self.logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        self.logger.info(\n            f\"{self.name}: after_step_back - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n        self.construction_area.enabled = True\n        self.planner.game_context.score += 12\n\n    def weight(self) -&gt; float:\n        if self.planner.game_context.tribunes_in_robot &lt; 2 or self.construction_area.tribune_level != 0:\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge2\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x3/","title":"action_build_tribune_x3","text":""},{"location":"reference/cogip/tools/planner/actions/action_build_tribune_x3/#cogip.tools.planner.actions.action_build_tribune_x3.BuildTribuneX3Action","title":"<code>BuildTribuneX3Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to build a 3-story tribune.</p> Source code in <code>cogip/tools/planner/actions/action_build_tribune_x3.py</code> <pre><code>class BuildTribuneX3Action(Action):\n    \"\"\"\n    Action used to build a 3-story tribune.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        strategy: Strategy,\n        construction_area_id: ConstructionAreaID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"BuildTribuneX3 {construction_area_id.name}\", planner, strategy)\n        self.before_action_func = self.before_action\n        self.construction_area_id = construction_area_id\n        self.shift_build_x3 = 160\n        self.shift_build_x2 = self.shift_build_x3 + 160\n        self.shift_approach_x2 = self.shift_build_x2 + 130\n        self.shift_step_back_x2 = self.shift_build_x2 + 20\n        self.shift_approach_x3 = self.shift_build_x2 - 20\n        self.shift_step_back_x3 = self.shift_approach_x3\n\n    @property\n    def construction_area(self) -&gt; ConstructionArea:\n        return self.planner.game_context.construction_areas[self.construction_area_id]\n\n    async def recycle(self):\n        self.recycled = True\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.logger.info(\n            f\"{self.name}: before_action - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n        self.avoidance_backup = AvoidanceStrategy(self.planner.shared_properties.avoidance_strategy)\n        self.start_pose = self.pose_current\n\n        # Approach x2\n        approach_x2_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_approach_x2,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            before_pose_func=self.before_approach_x2,\n            after_pose_func=self.after_approach_x2,\n        )\n        self.poses.append(approach_x2_pose)\n\n        # Build x2\n        build_x2_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build_x2,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=80,\n            max_speed_angular=80,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_build_x2,\n            after_pose_func=self.after_build_x2,\n        )\n        self.poses.append(build_x2_pose)\n\n        # Step back x2\n        step_back_x2_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back_x2,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            before_pose_func=self.before_step_back_x2,\n            after_pose_func=self.after_step_back_x2,\n        )\n        self.poses.append(step_back_x2_pose)\n\n        # Approach x3\n        approach_x3_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_approach_x3,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=20,\n            max_speed_angular=20,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_approach_x3,\n            after_pose_func=self.after_approach_x3,\n        )\n        self.poses.append(approach_x3_pose)\n\n        # Build x3\n        build_x3_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_build_x3,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=20,\n            max_speed_angular=20,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_build_x3,\n            after_pose_func=self.after_build_x3,\n        )\n        self.poses.append(build_x3_pose)\n\n        # Step back x3\n        step_back_x3_pose = Pose(\n            **get_relative_pose(\n                self.construction_area,\n                front_offset=self.shift_step_back_x3,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=50,\n            max_speed_angular=50,\n            bypass_final_orientation=False,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            before_pose_func=self.before_step_back_x3,\n            after_pose_func=self.after_step_back_x3,\n        )\n        self.poses.append(step_back_x3_pose)\n\n    async def before_approach_x2(self):\n        self.logger.info(f\"{self.name}: before_approach_x2\")\n\n    async def after_approach_x2(self):\n        self.logger.info(f\"{self.name}: after_approach_x2\")\n        self.construction_area.enabled = False\n\n    async def before_build_x2(self):\n        self.logger.info(f\"{self.name}: before_build_x2\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_build_x2(self):\n        self.logger.info(\n            f\"{self.name}: after_build_x2 - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n\n    async def before_step_back_x2(self):\n        self.logger.info(f\"{self.name}: before_step_back_x2\")\n\n    async def after_step_back_x2(self):\n        self.logger.info(f\"{self.name}: after_step_back_x2\")\n\n    async def before_approach_x3(self):\n        self.logger.info(f\"{self.name}: before_approach_x3\")\n\n    async def after_approach_x3(self):\n        self.logger.info(f\"{self.name}: after_approach_x3\")\n\n    async def before_build_x3(self):\n        self.logger.info(f\"{self.name}: before_build_x3\")\n\n    async def after_build_x3(self):\n        self.logger.info(f\"{self.name}: after_build_x3\")\n\n    async def before_step_back_x3(self):\n        self.logger.info(f\"{self.name}: before_step_back_x3\")\n\n    async def after_step_back_x3(self):\n        self.logger.info(\n            f\"{self.name}: after_step_back - tribunes_in_robot={self.planner.game_context.tribunes_in_robot}\"\n        )\n        self.construction_area.enabled = True\n        self.planner.game_context.tribunes_in_robot -= 2\n        self.construction_area.tribune_level += 2\n        self.planner.game_context.score += 24\n        self.set_avoidance(self.avoidance_backup)\n\n    def weight(self) -&gt; float:\n        if self.planner.game_context.tribunes_in_robot &lt; 2 or self.construction_area.tribune_level != 1:\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.LocalBottom].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeBottomSmall\n            and self.planner.game_context.tribunes[TribuneID.OppositeBottomSide].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge2\n            and self.planner.game_context.construction_areas[ConstructionAreaID.LocalBottomLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge2].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge1\n            and self.planner.game_context.construction_areas[ConstructionAreaID.OppositeSideLarge3].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.LocalBottomLarge3\n            and self.planner.game_context.tribunes[TribuneID.LocalCenter].enabled\n        ):\n            return 0\n\n        if (\n            self.construction_area.id == ConstructionAreaID.OppositeSideLarge3\n            and self.planner.game_context.tribunes[TribuneID.OppositeCenter].enabled\n        ):\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_capture_tribune/","title":"action_capture_tribune","text":""},{"location":"reference/cogip/tools/planner/actions/action_capture_tribune/#cogip.tools.planner.actions.action_capture_tribune.CaptureTribuneAction","title":"<code>CaptureTribuneAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to capture tribune using magnets.</p> Source code in <code>cogip/tools/planner/actions/action_capture_tribune.py</code> <pre><code>class CaptureTribuneAction(Action):\n    \"\"\"\n    Action used to capture tribune using magnets.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        strategy: Strategy,\n        tribune_id: artifacts.TribuneID,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(f\"CaptureTribune {tribune_id.name}\", planner, strategy)\n        self.before_action_func = self.before_action\n        self.tribune_id = tribune_id\n        self.shift_capture = 140\n        self.shift_approach = self.shift_capture + 150\n        self.shift_step_back = self.shift_capture + 80\n\n    @property\n    def tribune(self) -&gt; artifacts.Tribune:\n        return self.planner.game_context.tribunes[self.tribune_id]\n\n    async def recycle(self):\n        self.tribune.enabled = True\n        self.recycled = True\n\n    async def before_action(self):\n        self.start_pose = self.pose_current\n\n        # Approach\n        approach_pose = Pose(\n            **get_relative_pose(\n                self.tribune,\n                front_offset=self.shift_approach,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            before_pose_func=self.before_approach,\n            after_pose_func=self.after_approach,\n        )\n        self.poses.append(approach_pose)\n\n        # Capture\n        capture_pose = Pose(\n            **get_relative_pose(\n                self.tribune,\n                front_offset=self.shift_capture,\n                angular_offset=180,\n            ).model_dump(),\n            max_speed_linear=20,\n            max_speed_angular=20,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_capture,\n            after_pose_func=self.after_capture,\n        )\n        self.poses.append(capture_pose)\n\n        if (\n            (\n                self.tribune_id == artifacts.TribuneID.LocalCenter\n                and self.planner.shared_properties.table == TableEnum.Training\n            )\n            or self.tribune_id == artifacts.TribuneID.LocalTop\n            or self.tribune_id == artifacts.TribuneID.LocalTopSide\n            or self.tribune_id == artifacts.TribuneID.LocalBottomSide\n            or self.tribune_id == artifacts.TribuneID.OppositeTop\n            or self.tribune_id == artifacts.TribuneID.OppositeTopSide\n            or self.tribune_id == artifacts.TribuneID.OppositeBottomSide\n        ):\n            # Step back\n            pose = Pose(\n                **get_relative_pose(\n                    self.tribune,\n                    front_offset=self.shift_step_back,\n                    angular_offset=180,\n                ).model_dump(),\n                max_speed_linear=50,\n                max_speed_angular=50,\n                motion_direction=MotionDirection.BIDIRECTIONAL,\n                bypass_final_orientation=False,\n                before_pose_func=self.before_step_back,\n                after_pose_func=self.after_step_back,\n            )\n            self.poses.append(pose)\n\n    async def before_approach(self):\n        self.logger.info(f\"{self.name}: before_approach\")\n\n    async def after_approach(self):\n        self.logger.info(f\"{self.name}: after_approach\")\n\n    async def before_capture(self):\n        self.logger.info(f\"{self.name}: before_capture\")\n\n    async def after_capture(self):\n        self.logger.info(f\"{self.name}: after_capture\")\n        self.planner.game_context.tribunes_in_robot = 2\n\n    async def before_step_back(self):\n        self.logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        self.logger.info(f\"{self.name}: after_step_back\")\n\n    def weight(self) -&gt; float:\n        if not self.tribune.enabled or self.planner.game_context.tribunes_in_robot != 0:\n            return 0\n\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_drop_banner/","title":"action_drop_banner","text":""},{"location":"reference/cogip/tools/planner/actions/action_drop_banner/#cogip.tools.planner.actions.action_drop_banner.DropBannerAction","title":"<code>DropBannerAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to drop the banner on the table border.</p> Source code in <code>cogip/tools/planner/actions/action_drop_banner.py</code> <pre><code>class DropBannerAction(Action):\n    \"\"\"\n    Action used to drop the banner on the table border.\n    \"\"\"\n\n    def __init__(\n        self,\n        planner: \"Planner\",\n        strategy: Strategy,\n        weight: float = 2000000.0,\n    ):\n        self.custom_weight = weight\n        super().__init__(\"Drop banner action\", planner, strategy)\n        self.before_action_func = self.before_action\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.logger.info(f\"{self.name}: before_action\")\n        self.avoidance_backup = AvoidanceStrategy(self.planner.shared_properties.avoidance_strategy)\n\n        # On start, the robot is facing the back of the table\n        self.start_pose = self.pose_current\n\n        # Go in contact of the border\n        drop_pose = Pose(\n            x=-1000 + 132,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=10,\n            max_speed_angular=10,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_anti_blocking=False,\n            timeout_ms=0,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_drop,\n            after_pose_func=self.after_drop,\n        )\n        self.poses.append(drop_pose)\n\n        # Step back\n        step_back_pose = Pose(\n            x=-950 + self.planner.shared_properties.robot_length / 2,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.BIDIRECTIONAL,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_step_back,\n            after_pose_func=self.after_step_back,\n        )\n        self.poses.append(step_back_pose)\n\n    async def before_drop(self):\n        self.logger.info(f\"{self.name}: before_drop\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_drop(self):\n        self.logger.info(f\"{self.name}: after_drop\")\n        await asyncio.sleep(1)\n        self.planner.game_context.score += 20\n\n    async def before_step_back(self):\n        self.logger.info(f\"{self.name}: before_step_back\")\n\n    async def after_step_back(self):\n        self.logger.info(f\"{self.name}: after_step_back\")\n        self.set_avoidance(self.avoidance_backup)\n\n    def weight(self) -&gt; float:\n        return self.custom_weight\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/action_parking/","title":"action_parking","text":""},{"location":"reference/cogip/tools/planner/actions/action_wait/","title":"action_wait","text":""},{"location":"reference/cogip/tools/planner/actions/action_wait/#cogip.tools.planner.actions.action_wait.WaitAction","title":"<code>WaitAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used if no other action is available. Reset recycled attribute of all actions at the end.</p> Source code in <code>cogip/tools/planner/actions/action_wait.py</code> <pre><code>class WaitAction(Action):\n    \"\"\"\n    Action used if no other action is available.\n    Reset recycled attribute of all actions at the end.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: \"Strategy\", delay_seconds: int = 2):\n        super().__init__(\"Wait action\", planner, strategy)\n        self.delay_seconds = delay_seconds\n        self.before_action_func = self.before_wait\n        self.after_action_func = self.after_wait\n\n    def weight(self) -&gt; float:\n        return 1\n\n    async def before_wait(self):\n        self.logger.debug(f\"Robot {self.planner.robot_id}: WaitAction: before action\")\n\n    async def after_wait(self):\n        self.logger.debug(f\"Robot {self.planner.robot_id}: WaitAction: after action\")\n        await asyncio.sleep(self.delay_seconds)\n\n        for action in self.strategy:\n            action.recycled = False\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/camera_calibration/","title":"camera_calibration","text":""},{"location":"reference/cogip/tools/planner/actions/camera_calibration/#cogip.tools.planner.actions.camera_calibration.CameraCalibrationAction","title":"<code>CameraCalibrationAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>This action moves around the front right table marker, and take pictures to compute camera extrinsic parameters (ie, the position of the camera relative to the robot center).</p> Source code in <code>cogip/tools/planner/actions/camera_calibration.py</code> <pre><code>class CameraCalibrationAction(Action):\n    \"\"\"\n    This action moves around the front right table marker, and take pictures to compute\n    camera extrinsic parameters (ie, the position of the camera relative to the robot center).\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"CameraCalibration action\", planner, strategy)\n        self.camera_positions: list[CameraExtrinsicParameters] = []\n        self.after_action_func = self.print_camera_positions\n\n        self.poses.append(\n            Pose(\n                x=-500,\n                y=-1200,\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-240,\n                y=-1200,\n                O=130,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-240,\n                y=-570,\n                O=-130,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-240,\n                y=-440,\n                O=-130,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-500,\n                y=-420,\n                O=-90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-610,\n                y=-510,\n                O=-70,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-710,\n                y=-910,\n                O=0,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-610,\n                y=-1250,\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n    async def calibrate_camera(self):\n        await asyncio.sleep(0.5)\n        if pose := await calibrate_camera(self.planner):\n            self.camera_positions.append(pose)\n        await asyncio.sleep(0.2)\n\n    async def print_camera_positions(self):\n        x = 0\n        y = 0\n        z = 0\n        roll = 0\n        pitch = 0\n        yaw = 0\n        for i, p in enumerate(self.camera_positions):\n            self.logger.info(\n                f\"Camera position {i: 2d}: X={p.x:.0f} Y={p.y:.0f} Z={p.z:.0f}\"\n                f\" Roll={p.roll:.0f} Pitch={p.pitch:.0f} Yaw={p.yaw:.0f}\"\n            )\n            x += p.x\n            y += p.y\n            z += p.z\n            roll += p.roll\n            pitch += p.pitch\n            yaw += p.yaw\n\n        if n := len(self.camera_positions):\n            p = CameraExtrinsicParameters(x=x / n, y=y / n, z=z / n, roll=roll / n, pitch=pitch / n, yaw=yaw / n)\n            self.logger.info(\n                f\"=&gt; Camera position mean: X={p.x:.0f} Y={p.y:.0f} Z={p.z:.0f}\"\n                f\" Roll={p.roll:.0f} Pitch={p.pitch:.0f} Yaw={p.yaw:.0f}\"\n            )\n        else:\n            self.logger.warning(\"No camera position found\")\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/","title":"pami","text":""},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami2Action","title":"<code>Pami2Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 2 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami2Action(Action):\n    \"\"\"\n    PAMI 2 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy, *, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 2 action\", planner, strategy, interruptable=False)\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n        self.wait = wait\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose0 = Pose(\n            **get_relative_pose(\n                self.start_pose,\n                front_offset=self.planner.shared_properties.robot_length,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose0,\n            after_pose_func=self.after_pose0,\n        )\n        self.poses.append(pose0)\n\n        pose1 = AdaptedPose(\n            x=150,\n            y=-720,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        pose2 = AdaptedPose(\n            x=150,\n            y=0,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose2,\n            after_pose_func=self.after_pose2,\n        )\n        self.poses.append(pose2)\n\n        final_pose = AdaptedPose(\n            x=300,\n            y=240,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_final,\n            after_pose_func=self.after_final,\n        )\n        self.poses.append(final_pose)\n\n        if self.planner.shared_properties.table == TableEnum.Training:\n            pose0.x -= 1000\n            pose1.x -= 1000\n            pose2.x -= 1000\n            pose2.y = -380\n            final_pose.x = pose2.x\n            final_pose.y = -180\n\n    async def before_pose0(self):\n        self.logger.info(f\"{self.name}: before_pose0\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose0(self):\n        self.logger.info(f\"{self.name}: after_pose0\")\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n    async def before_pose1(self):\n        self.logger.info(f\"{self.name}: before_pose1\")\n\n    async def after_pose1(self):\n        self.logger.info(f\"{self.name}: after_pose1\")\n\n    async def before_pose2(self):\n        self.logger.info(f\"{self.name}: before_pose2\")\n\n    async def after_pose2(self):\n        self.logger.info(f\"{self.name}: after_pose2\")\n\n    async def before_final(self):\n        self.logger.info(f\"{self.name}: before_final\")\n\n    async def after_final(self):\n        self.logger.info(f\"{self.name}: after_final\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.planner.flag_motor.on()\n        self.strategy.clear()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami3Action","title":"<code>Pami3Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 3 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami3Action(Action):\n    \"\"\"\n    PAMI 3 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy, *, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 3 action\", planner, strategy, interruptable=False)\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n        self.wait = wait\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose1 = Pose(\n            **get_relative_pose(\n                self.start_pose,\n                front_offset=self.planner.shared_properties.robot_length,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        pose2 = AdaptedPose(\n            x=340,\n            y=-850,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose2,\n            after_pose_func=self.after_pose2,\n        )\n        self.poses.append(pose2)\n\n        final_pose = AdaptedPose(\n            x=340,\n            y=-320,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_final,\n            after_pose_func=self.after_final,\n        )\n        self.poses.append(final_pose)\n\n        if self.planner.shared_properties.table == TableEnum.Training:\n            pose1.x -= 1000\n            pose2.x -= 1000\n            final_pose.x -= 1000\n\n    async def before_pose1(self):\n        self.logger.info(f\"{self.name}: before_pose1\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose1(self):\n        self.logger.info(f\"{self.name}: after_pose1\")\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n    async def before_pose2(self):\n        self.logger.info(f\"{self.name}: before_pose2\")\n\n    async def after_pose2(self):\n        self.logger.info(f\"{self.name}: after_pose2\")\n\n    async def before_final(self):\n        self.logger.info(f\"{self.name}: before_final\")\n\n    async def after_final(self):\n        self.logger.info(f\"{self.name}: after_final\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.planner.flag_motor.on()\n        self.strategy.clear()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami4Action","title":"<code>Pami4Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 4 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami4Action(Action):\n    \"\"\"\n    PAMI 4 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy, *, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 4 action\", planner, strategy, interruptable=False)\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n        self.wait = wait\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.logger.info(f\"{self.name}: set avoidance to {new_strategy.name}\")\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose1 = Pose(\n            **get_relative_pose(\n                self.start_pose,\n                front_offset=self.planner.shared_properties.robot_length,\n            ).model_dump(),\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        final_pose = AdaptedPose(\n            x=530,\n            y=-730,\n            O=0,\n            max_speed_linear=100,\n            max_speed_angular=100,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_final,\n            after_pose_func=self.after_final,\n        )\n        self.poses.append(final_pose)\n\n        if self.planner.shared_properties.table == TableEnum.Training:\n            pose1.x -= 1000\n            final_pose.x -= 1000\n\n    async def before_pose1(self):\n        self.logger.info(f\"{self.name}: before_pose1\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose1(self):\n        self.logger.info(f\"{self.name}: after_pose1\")\n        self.set_avoidance(AvoidanceStrategy.AvoidanceCpp)\n\n    async def before_final(self):\n        self.logger.info(f\"{self.name}: before_final\")\n\n    async def after_final(self):\n        self.logger.info(f\"{self.name}: after_final\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.planner.flag_motor.on()\n        self.strategy.clear()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pami/#cogip.tools.planner.actions.pami.Pami5Action","title":"<code>Pami5Action</code>","text":"<p>               Bases: <code>Action</code></p> <p>PAMI 5 action.</p> Source code in <code>cogip/tools/planner/actions/pami.py</code> <pre><code>class Pami5Action(Action):\n    \"\"\"\n    PAMI 5 action.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy, start_delay: int, wait: bool = True):\n        super().__init__(\"PAMI 5 action\", planner, strategy, interruptable=False)\n        self.wait = wait\n        self.before_action_func = self.before_action\n        self.start_delay = start_delay\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.planner.shared_properties.avoidance_strategy = new_strategy.val\n\n    async def before_action(self):\n        self.planner.shared_properties.disable_fixed_obstacles = True\n\n        if self.wait:\n            await self.planner.pami_event.wait()\n\n        self.start_pose = self.pose_current.model_copy()\n\n        pose1 = AdaptedPose(\n            x=self.start_pose.x,\n            y=-300,\n            max_speed_linear=70,\n            max_speed_angular=70,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n        pose2 = AdaptedPose(\n            x=610,\n            y=-300,\n            O=180,\n            max_speed_linear=50,\n            max_speed_angular=50,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n            bypass_final_orientation=False,\n            before_pose_func=self.before_pose2,\n            after_pose_func=self.after_pose2,\n        )\n        if self.planner.shared_properties.table == TableEnum.Training:\n            pose2.x -= 1000\n        self.poses.append(pose2)\n\n    async def before_pose1(self):\n        self.logger.info(f\"{self.name}: before_pose1\")\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        self.planner.led.color = Color(\"lightblue\")\n        await set_countdown_color(self.planner, \"orange\")\n        await asyncio.sleep(self.start_delay)\n        self.planner.led.color = Color(\"green\")\n        await set_countdown_color(self.planner, \"green\")\n\n    async def after_pose1(self):\n        self.logger.info(f\"{self.name}: after_pose1\")\n\n    async def before_pose2(self):\n        self.logger.info(f\"{self.name}: before_pose2\")\n\n    async def after_pose2(self):\n        self.logger.info(f\"{self.name}: after_pose2\")\n        self.planner.led.color = Color(\"red\")\n        await set_countdown_color(self.planner, \"red\")\n        self.strategy.clear()\n        self.planner.shared_properties.disable_fixed_obstacles = False\n        self.planner.flag_motor.on()\n\n    def weight(self) -&gt; float:\n        return 9_999_999.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pid_position_test/","title":"pid_position_test","text":""},{"location":"reference/cogip/tools/planner/actions/pid_position_test/#cogip.tools.planner.actions.pid_position_test.AngularPositionTestAction","title":"<code>AngularPositionTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to move the robot without table. First set start position on 0x0. Them rotate of 180\u00b0 in the same position. Then go back to start position. Do it in loop.</p> Source code in <code>cogip/tools/planner/actions/pid_position_test.py</code> <pre><code>class AngularPositionTestAction(Action):\n    \"\"\"\n    Action used to move the robot without table.\n    First set start position on 0x0.\n    Them rotate of 180\u00b0 in the same position.\n    Then go back to start position.\n    Do it in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"AngularPositionTest action\", planner, strategy)\n        self.angular_distance = 180\n        self.linear_speed = 66\n        self.angular_speed = 66\n        self.motion_direction = MotionDirection.BIDIRECTIONAL\n        self.before_action_func = self.init_start_position\n        self.pose_init = models.Pose(\n            x=-500,\n            y=-300,\n            O=-90,\n        )\n        self.pose_start = Pose(**self.pose_init.model_dump())\n        self.pose_start.after_pose_func = partial(self.append_pose, self.pose_start)\n        self.pose_end = self.pose_start.model_copy(update={\"O\": self.pose_start.O + self.angular_distance})\n        self.pose_end.after_pose_func = partial(self.append_pose, self.pose_end)\n        self.poses.append(self.pose_end)\n        self.poses.append(self.pose_start)\n\n    async def init_start_position(self):\n        await self.planner.set_pose_start(self.pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pid_position_test/#cogip.tools.planner.actions.pid_position_test.LinearPositionTestAction","title":"<code>LinearPositionTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to move the robot without table. First set start position on 0x0. Them move straight forward along 100 cm. Then go back to start position. Do it in loop.</p> Source code in <code>cogip/tools/planner/actions/pid_position_test.py</code> <pre><code>class LinearPositionTestAction(Action):\n    \"\"\"\n    Action used to move the robot without table.\n    First set start position on 0x0.\n    Them move straight forward along 100 cm.\n    Then go back to start position.\n    Do it in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"LinearPositionTest action\", planner, strategy)\n        self.distance = 750\n        self.linear_speed = 66\n        self.angular_speed = 66\n        self.motion_direction = MotionDirection.BIDIRECTIONAL\n        self.before_action_func = self.init_start_position\n        self.pose_init = models.Pose(\n            x=-500,\n            y=-300,\n            O=-90,\n        )\n        self.pose_start = Pose(**self.pose_init.model_dump())\n        self.pose_start.after_pose_func = partial(self.append_pose, self.pose_start)\n        self.pose_end = self.pose_start.model_copy(update={\"y\": self.pose_start.y - self.distance})\n        self.pose_end.after_pose_func = partial(self.append_pose, self.pose_end)\n        self.poses.append(self.pose_end)\n        self.poses.append(self.pose_start)\n\n    async def init_start_position(self):\n        await self.planner.set_pose_start(self.pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/pid_speed_test/","title":"pid_speed_test","text":""},{"location":"reference/cogip/tools/planner/actions/pid_speed_test/#cogip.tools.planner.actions.pid_speed_test.SpeedTestAction","title":"<code>SpeedTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Dummy action for pid calibration. Same dummy pose in loop.</p> Source code in <code>cogip/tools/planner/actions/pid_speed_test.py</code> <pre><code>class SpeedTestAction(Action):\n    \"\"\"\n    Dummy action for pid calibration.\n    Same dummy pose in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"Pid calibration action\", planner, strategy)\n        self.pose = Pose()\n        self.pose.after_pose_func = self.after_pose\n        self.poses = [self.pose]\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n\n    async def after_pose(self):\n        self.poses.append(self.pose)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/strategy/","title":"strategy","text":""},{"location":"reference/cogip/tools/planner/actions/strategy/#cogip.tools.planner.actions.strategy.Strategy","title":"<code>Strategy</code>","text":"<p>               Bases: <code>list[Action]</code></p> <p>List of actions. Just inherits from list for now.</p> Source code in <code>cogip/tools/planner/actions/strategy.py</code> <pre><code>class Strategy(list[Action]):\n    \"\"\"\n    List of actions.\n    Just inherits from list for now.\n    \"\"\"\n\n    evaluated_strategies: list[\"Strategy\"] = []\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__()\n        self.planner = planner\n        self.evaluated_actions: list[Action] = []  # Actions done in the evaluation\n        self.goap_allowed: bool = False  # Allow GOAP evaluation\n        self.can_wait: bool = False  # Use a WaitAction if no other action is possible\n\n    async def get_next_action(self) -&gt; Action | None:\n        \"\"\"\n        Get a next action of the strategy.\n        \"\"\"\n        next_action: Action | None = None\n\n        if self.goap_allowed and self.planner.shared_properties.goap_depth &gt; 0:\n            logger.info(f\"Start GOAP evaluation with depth {self.planner.shared_properties.goap_depth}\")\n            with Timer(verbose=False) as timer:\n                await self.start_evaluation()\n            logger.info(f\"  =&gt; Evaluation time: {timer.results[-1].elapsed():0.3f}s\")\n            logger.info(f\"  =&gt; Evaluated strategies: {len(Strategy.evaluated_strategies)}\")\n\n            # Sort by score, then by first action weight\n            sorted_strategies = sorted(\n                Strategy.evaluated_strategies,\n                key=lambda s: (-s.planner.game_context.score, -s.evaluated_actions[0].weight()),\n            )\n            if len(sorted_strategies) &gt; 0 and len(sorted_strategies[0].evaluated_actions) &gt; 0:\n                next_action = sorted_strategies[0].evaluated_actions[0]\n\n            logger.info(f\"  =&gt; Next action: {next_action.name if next_action else 'None'}\")\n            self.print_evaluations()\n        else:\n            logger.info(\"Start standard evaluation\")\n            with Timer(verbose=False) as timer:\n                sorted_actions = sorted(\n                    [action for action in self if not action.recycled and action.weight() &gt; 0],\n                    key=lambda action: action.weight(),\n                )\n            logger.info(f\"  =&gt; Evaluation time: {timer.results[-1].elapsed():0.3f}s\")\n\n            if len(sorted_actions):\n                next_action = sorted_actions[-1]\n\n            logger.info(f\"  =&gt; Next action: {next_action.name if next_action else 'None'}\")\n\n        if next_action is None and self.can_wait:\n            return WaitAction(self.planner, self)\n\n        if next_action:\n            self.remove(next_action)\n\n        return next_action\n\n    def copy(self) -&gt; \"Strategy\":\n        new_strategy = Strategy(self.planner)\n        new_strategy.goap_allowed = self.goap_allowed\n        new_strategy.can_wait = False\n        for action in self:\n            new_strategy.append(action)\n        new_strategy.evaluated_actions = self.evaluated_actions.copy()\n        return new_strategy\n\n    async def evaluate(self):\n        if len(self.evaluated_actions) &gt;= self.planner.shared_properties.goap_depth:\n            return\n\n        if self.planner.game_context.countdown &lt;= 0:\n            return\n\n        for index in range(len(self)):\n            mock_planner = mock.MockPlanner(self.planner)\n\n            strategy_copy = self.copy()\n            strategy_copy.planner = mock_planner\n\n            action = strategy_copy.pop(index)\n\n            action_planner_backup = action.planner\n            action_strategy_backup = action.strategy\n            action.planner = None\n            action.strategy = None\n            action_copy = copy.deepcopy(action)\n            action.planner = action_planner_backup\n            action.strategy = action_strategy_backup\n            action_copy.planner = mock_planner\n            action_copy.strategy = strategy_copy\n\n            if action_copy.weight() == 0:\n                continue\n\n            # Skip if action was already recycled and no action was done yet\n            if action_copy.recycled and len(strategy_copy.evaluated_actions) == 0:\n                continue\n\n            Strategy.evaluated_strategies.append(strategy_copy)\n\n            await action_copy.evaluate()\n            strategy_copy.evaluated_actions.append(action)\n\n            await strategy_copy.evaluate()\n\n    async def start_evaluation(self):\n        with (\n            patch(\"cogip.tools.planner.actuators.positional_motor_command\", mock.async_no_op),\n            patch(\"cogip.tools.planner.actions.action.Action.logger\", mock.MockDummyClass()),\n            patch(\"asyncio.sleep\", mock.MockAsyncioSleep()),\n        ):\n            Strategy.evaluated_strategies.clear()\n            await self.evaluate()\n\n    def print_evaluations(self, max: int = 10):\n        sorted_strategies = sorted(\n            Strategy.evaluated_strategies,\n            key=lambda s: (\n                -s.planner.game_context.score,\n                -s.evaluated_actions[0].weight(),\n            ),\n        )\n\n        print(\"Evaluated strategies: \", len(Strategy.evaluated_strategies))\n        print(\"Best strategies:\")\n        for n, strategy in enumerate(sorted_strategies[:max]):\n            print(\n                f\"{n + 1:&gt;2}. \"\n                f\"Score: {strategy.planner.game_context.score:&gt; 3} - \"\n                f\"Actions: {', '.join([action.name for action in strategy.evaluated_actions])}\"\n            )\n\n    def __str__(self) -&gt; str:\n        return f\"Strategy({self.__class__.__name__}, [{', '.join([action.name for action in self])}])\"\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/strategy/#cogip.tools.planner.actions.strategy.Strategy.get_next_action","title":"<code>get_next_action()</code>  <code>async</code>","text":"<p>Get a next action of the strategy.</p> Source code in <code>cogip/tools/planner/actions/strategy.py</code> <pre><code>async def get_next_action(self) -&gt; Action | None:\n    \"\"\"\n    Get a next action of the strategy.\n    \"\"\"\n    next_action: Action | None = None\n\n    if self.goap_allowed and self.planner.shared_properties.goap_depth &gt; 0:\n        logger.info(f\"Start GOAP evaluation with depth {self.planner.shared_properties.goap_depth}\")\n        with Timer(verbose=False) as timer:\n            await self.start_evaluation()\n        logger.info(f\"  =&gt; Evaluation time: {timer.results[-1].elapsed():0.3f}s\")\n        logger.info(f\"  =&gt; Evaluated strategies: {len(Strategy.evaluated_strategies)}\")\n\n        # Sort by score, then by first action weight\n        sorted_strategies = sorted(\n            Strategy.evaluated_strategies,\n            key=lambda s: (-s.planner.game_context.score, -s.evaluated_actions[0].weight()),\n        )\n        if len(sorted_strategies) &gt; 0 and len(sorted_strategies[0].evaluated_actions) &gt; 0:\n            next_action = sorted_strategies[0].evaluated_actions[0]\n\n        logger.info(f\"  =&gt; Next action: {next_action.name if next_action else 'None'}\")\n        self.print_evaluations()\n    else:\n        logger.info(\"Start standard evaluation\")\n        with Timer(verbose=False) as timer:\n            sorted_actions = sorted(\n                [action for action in self if not action.recycled and action.weight() &gt; 0],\n                key=lambda action: action.weight(),\n            )\n        logger.info(f\"  =&gt; Evaluation time: {timer.results[-1].elapsed():0.3f}s\")\n\n        if len(sorted_actions):\n            next_action = sorted_actions[-1]\n\n        logger.info(f\"  =&gt; Next action: {next_action.name if next_action else 'None'}\")\n\n    if next_action is None and self.can_wait:\n        return WaitAction(self.planner, self)\n\n    if next_action:\n        self.remove(next_action)\n\n    return next_action\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_align_bottom/","title":"test_align_bottom","text":""},{"location":"reference/cogip/tools/planner/actions/test_align_bottom_banner/","title":"test_align_bottom_banner","text":""},{"location":"reference/cogip/tools/planner/actions/test_approval/","title":"test_approval","text":""},{"location":"reference/cogip/tools/planner/actions/test_back_and_forth/","title":"test_back_and_forth","text":""},{"location":"reference/cogip/tools/planner/actions/test_back_and_forth/#cogip.tools.planner.actions.test_back_and_forth.BackAndForthAction","title":"<code>BackAndForthAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Example action that generate its poses depending of the robot's pose at the beginning of the action. The robot will go from the current position to its opposite position in loop.</p> Source code in <code>cogip/tools/planner/actions/test_back_and_forth.py</code> <pre><code>class BackAndForthAction(Action):\n    \"\"\"\n    Example action that generate its poses depending of the robot's pose\n    at the beginning of the action.\n    The robot will go from the current position to its opposite position in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"BackAndForth action\", planner, strategy)\n        self.before_action_func = self.compute_poses\n\n    async def compute_poses(self) -&gt; None:\n        table = get_table(self.planner.shared_properties.table)\n        x = self.planner.pose_current.x\n        y = table.y_min + table.y_max - self.planner.pose_current.y\n        angle = -self.planner.pose_current.O\n        pose1 = Pose(\n            x=x,\n            y=y,\n            O=angle,\n            max_speed_linear=66,\n            max_speed_angular=66,\n        )\n        pose2 = Pose(x=self.planner.pose_current.x, y=self.planner.pose_current.y, O=self.planner.pose_current.O)\n        pose1.after_pose_func = partial(self.append_pose, pose1)\n        pose2.after_pose_func = partial(self.append_pose, pose2)\n        self.poses.append(pose1)\n        self.poses.append(pose2)\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_drop_banner/","title":"test_drop_banner","text":""},{"location":"reference/cogip/tools/planner/actions/test_game_1/","title":"test_game_1","text":""},{"location":"reference/cogip/tools/planner/actions/test_game_2/","title":"test_game_2","text":""},{"location":"reference/cogip/tools/planner/actions/test_rectangle_alternating/","title":"test_rectangle_alternating","text":"<p>Action to move in a rectangle pattern alternating forward and backward motion.</p>"},{"location":"reference/cogip/tools/planner/actions/test_rectangle_alternating/#cogip.tools.planner.actions.test_rectangle_alternating.TestRectangleAlternatingAction","title":"<code>TestRectangleAlternatingAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action to move the robot in a rectangle pattern, alternating between forward-only and backward-only motion on each side.</p> <p>This demonstrates the MotionDirection enum capabilities.</p> Source code in <code>cogip/tools/planner/actions/test_rectangle_alternating.py</code> <pre><code>class TestRectangleAlternatingAction(Action):\n    \"\"\"\n    Action to move the robot in a rectangle pattern, alternating between\n    forward-only and backward-only motion on each side.\n\n    This demonstrates the MotionDirection enum capabilities.\n    \"\"\"\n\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"TestRectangleAlternating\", planner, strategy)\n        # Coordinates fit within training table: x=[-1000, 0], y=[-1500, 0]\n        self.start_x = -900\n        self.start_y = -1400\n        self.width = 800\n        self.height = 800\n        self.angle = 0\n        self.linear_speed = 50\n        self.angular_speed = 50\n\n        self.before_action_func = self.init_start_position\n\n        # Define the corners with alternating directions\n        self.corners = [\n            # Corner 1: move up, go backward\n            (self.start_x + self.width, self.start_y, self.angle, MotionDirection.BACKWARD_ONLY),\n            # Corner 2: move left, go forward\n            (self.start_x + self.width, self.start_y + self.height, self.angle, MotionDirection.FORWARD_ONLY),\n            # Corner 3: move down, go backward\n            (self.start_x, self.start_y + self.height, self.angle, MotionDirection.BACKWARD_ONLY),\n            # Corner 4: move right, go forward\n            (self.start_x, self.start_y, self.angle, MotionDirection.FORWARD_ONLY),\n            # Diagonal: to opposite corner with bidirectional\n            (self.start_x + self.width, self.start_y + self.height, self.angle, MotionDirection.BIDIRECTIONAL),\n            # Diagonal: back to start with bidirectional\n            (self.start_x, self.start_y, self.angle, MotionDirection.BIDIRECTIONAL),\n        ]\n\n        # Create poses for each corner\n        for i, (x, y, angle, direction) in enumerate(self.corners):\n            pose = Pose(\n                x=x,\n                y=y,\n                O=angle,\n                max_speed_linear=self.linear_speed,\n                max_speed_angular=self.angular_speed,\n                motion_direction=direction,\n            )\n            # Each pose re-appends itself to create infinite loop\n            pose.after_pose_func = partial(self.append_pose, pose)\n            self.poses.append(pose)\n\n    async def init_start_position(self):\n        \"\"\"Initialize robot at starting position.\"\"\"\n        pose_init = models.Pose(\n            x=self.start_x,\n            y=self.start_y,\n            O=self.angle,\n        )\n        await self.planner.set_pose_start(pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        \"\"\"Re-append the pose to continue the loop.\"\"\"\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        \"\"\"Return action weight for priority.\"\"\"\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_rectangle_alternating/#cogip.tools.planner.actions.test_rectangle_alternating.TestRectangleAlternatingAction.append_pose","title":"<code>append_pose(pose)</code>  <code>async</code>","text":"<p>Re-append the pose to continue the loop.</p> Source code in <code>cogip/tools/planner/actions/test_rectangle_alternating.py</code> <pre><code>async def append_pose(self, pose: Pose) -&gt; None:\n    \"\"\"Re-append the pose to continue the loop.\"\"\"\n    self.poses.append(pose)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_rectangle_alternating/#cogip.tools.planner.actions.test_rectangle_alternating.TestRectangleAlternatingAction.init_start_position","title":"<code>init_start_position()</code>  <code>async</code>","text":"<p>Initialize robot at starting position.</p> Source code in <code>cogip/tools/planner/actions/test_rectangle_alternating.py</code> <pre><code>async def init_start_position(self):\n    \"\"\"Initialize robot at starting position.\"\"\"\n    pose_init = models.Pose(\n        x=self.start_x,\n        y=self.start_y,\n        O=self.angle,\n    )\n    await self.planner.set_pose_start(pose_init)\n    self.planner.pose_reached = False\n    self.planner.action = self\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_rectangle_alternating/#cogip.tools.planner.actions.test_rectangle_alternating.TestRectangleAlternatingAction.weight","title":"<code>weight()</code>","text":"<p>Return action weight for priority.</p> Source code in <code>cogip/tools/planner/actions/test_rectangle_alternating.py</code> <pre><code>def weight(self) -&gt; float:\n    \"\"\"Return action weight for priority.\"\"\"\n    return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_rectangle_alternating/#cogip.tools.planner.actions.test_rectangle_alternating.TestRectangleAlternatingStrategy","title":"<code>TestRectangleAlternatingStrategy</code>","text":"<p>               Bases: <code>Strategy</code></p> <p>Strategy to execute the rectangle alternating action.</p> Source code in <code>cogip/tools/planner/actions/test_rectangle_alternating.py</code> <pre><code>class TestRectangleAlternatingStrategy(Strategy):\n    \"\"\"Strategy to execute the rectangle alternating action.\"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__(planner)\n        self.append(TestRectangleAlternatingAction(planner, self))\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_squares/","title":"test_squares","text":""},{"location":"reference/cogip/tools/planner/actions/test_squares/#cogip.tools.planner.actions.test_squares.TestSquaresAction","title":"<code>TestSquaresAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Run in square x times.</p> Source code in <code>cogip/tools/planner/actions/test_squares.py</code> <pre><code>class TestSquaresAction(Action):\n    \"\"\"\n    Run in square x times.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy, *, count: int, size: int):\n        super().__init__(f\"TestSquares action x{count}\", planner, strategy)\n        self.count = count\n        self.size = size\n        self.interruptable = False\n        self.before_action_func = self.before_action\n\n    async def before_action(self):\n        self.logger.info(f\"{self.name}: before_action\")\n        self.planner.shared_properties.avoidance_strategy = AvoidanceStrategy.Disabled.val\n        start_pose = self.pose_current\n        linear_speed = 50\n        angular_speed = 50\n\n        pose1 = Pose(\n            **get_relative_pose(\n                start_pose,\n                front_offset=self.size,\n                angular_offset=90,\n            ).model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n        )\n\n        pose2 = Pose(\n            **get_relative_pose(\n                pose1,\n                front_offset=self.size,\n                angular_offset=90,\n            ).model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n        )\n\n        pose3 = Pose(\n            **get_relative_pose(\n                pose2,\n                front_offset=self.size,\n                angular_offset=90,\n            ).model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n        )\n\n        pose4 = Pose(\n            **start_pose.model_dump(),\n            max_speed_linear=linear_speed,\n            max_speed_angular=angular_speed,\n            motion_direction=MotionDirection.FORWARD_ONLY,\n        )\n\n        for i in range(self.count):\n            self.poses.append(pose1)\n            self.poses.append(pose2)\n            self.poses.append(pose3)\n            self.poses.append(pose4)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_tribunes_1x2/","title":"test_tribunes_1x2","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_1x3/","title":"test_tribunes_1x3","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_2x1/","title":"test_tribunes_2x1","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_2x2/","title":"test_tribunes_2x2","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_2x3/","title":"test_tribunes_2x3","text":""},{"location":"reference/cogip/tools/planner/actions/test_tribunes_4x1/","title":"test_tribunes_4x1","text":""},{"location":"reference/cogip/tools/planner/actions/test_visit_starting_areas/","title":"test_visit_starting_areas","text":""},{"location":"reference/cogip/tools/planner/actions/test_visit_starting_areas/#cogip.tools.planner.actions.test_visit_starting_areas.VisitStartingAreasAction","title":"<code>VisitStartingAreasAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action that goes from the starting position to the next one.</p> Source code in <code>cogip/tools/planner/actions/test_visit_starting_areas.py</code> <pre><code>class VisitStartingAreasAction(Action):\n    \"\"\"\n    Action that goes from the starting position to the next one.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", strategy: Strategy):\n        super().__init__(\"VisitStartingAreas action\", planner, strategy)\n        self.before_action_func = self.compute_poses\n\n    async def compute_poses(self) -&gt; None:\n        start_positions = [p.name for p in StartPositionEnum if self.planner.start_positions.is_valid(p)]\n        start_positions_count = len(start_positions)\n        default_start_position_index = 0\n        for i in range(start_positions_count):\n            start_position = StartPositionEnum((i + 1) % start_positions_count + 1)\n            if start_position == self.planner.shared_properties.start_position:\n                default_start_position_index = i\n            pose = self.planner.start_positions.get(start_position)\n            new_pose = Pose(x=pose.x, y=pose.y, O=pose.O, max_speed_linear=66, max_speed_angular=66)\n            new_pose.after_pose_func = partial(self.append_pose, new_pose)\n            self.poses.append(new_pose)\n\n        self.poses = self.poses[default_start_position_index:] + self.poses[:default_start_position_index]\n        default_start_position = self.poses.pop(0)\n        self.poses.append(default_start_position)\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/utils/","title":"utils","text":""},{"location":"reference/cogip/tools/planner/actions/utils/#cogip.tools.planner.actions.utils.get_relative_pose","title":"<code>get_relative_pose(reference_pose, *, front_offset, side_offset=0.0, angular_offset=0.0)</code>","text":"<p>Get a new pose relative to the reference pose with the specified linear and angular offsets.</p> <p>Parameters:</p> Name Type Description Default <code>reference_pose</code> <code>Pose</code> <p>The reference pose.</p> required <code>front_offset</code> <code>float</code> <p>The offset in the direction of the reference's front.</p> required <code>side_offset</code> <code>float</code> <p>The offset in the direction of the reference's side. Positive is to the left.</p> <code>0.0</code> <code>angular_offset</code> <code>float</code> <p>The angular offset in degrees.</p> <code>0.0</code> Source code in <code>cogip/tools/planner/actions/utils.py</code> <pre><code>def get_relative_pose(\n    reference_pose: models.Pose,\n    *,\n    front_offset: float,\n    side_offset: float = 0.0,\n    angular_offset: float = 0.0,\n) -&gt; models.Pose:\n    \"\"\"\n    Get a new pose relative to the reference pose with the specified linear and angular offsets.\n\n    Args:\n        reference_pose: The reference pose.\n        front_offset: The offset in the direction of the reference's front.\n        side_offset: The offset in the direction of the reference's side. Positive is to the left.\n        angular_offset: The angular offset in degrees.\n    \"\"\"\n    # This function calculates a new pose relative to a reference pose.\n    new_x = (\n        reference_pose.x\n        + front_offset * math.cos(math.radians(reference_pose.O))\n        - side_offset * math.sin(math.radians(reference_pose.O))\n    )\n    new_y = (\n        reference_pose.y\n        + front_offset * math.sin(math.radians(reference_pose.O))\n        + side_offset * math.cos(math.radians(reference_pose.O))\n    )\n    # Normalize the angle to be between 0 and 360 degrees\n    new_angle = (reference_pose.O + angular_offset) % 360\n    return models.Pose(x=new_x, y=new_y, O=new_angle)\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/avoidance/","title":"avoidance","text":""},{"location":"reference/cogip/tools/planner/avoidance/process/","title":"process","text":""},{"location":"reference/cogip/tools/robotcam/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/robotcam/app/","title":"app","text":""},{"location":"reference/cogip/tools/robotcam/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler","title":"<code>CameraHandler</code>","text":"<p>Camera handler.</p> <p>Handle camera initialization.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>class CameraHandler:\n    \"\"\"\n    Camera handler.\n\n    Handle camera initialization.\n    \"\"\"\n\n    _frame_rate: float = 10  # Number of images processed by seconds\n    _exiting: bool = False  # Exit requested if True\n\n    def __init__(self, frame_queue: Queue, stream_queue: Queue):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO client and connect to server.\n        \"\"\"\n        self.settings = Settings()\n        self.frame_queue = frame_queue\n        self.stream_queue = stream_queue\n        self.camera: Camera | None = None\n        self.record_filename: Path | None = None\n        self.record_writer: cv2.VideoWriter | None = None\n\n        self.sio = socketio.Client(logger=False, engineio_logger=False, handle_sigint=False)\n        self.register_sio_events()\n\n        signal.signal(signal.SIGTERM, self.exit_handler)\n        signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n        Thread(\n            target=lambda: polling2.poll(\n                self.sio_connect,\n                step=1,\n                ignore_exceptions=(socketio.exceptions.ConnectionError),\n                poll_forever=True,\n            ),\n            daemon=True,\n        ).start()\n\n    @staticmethod\n    def exit_handler(signum, frame):\n        \"\"\"\n        Function called when TERM signal is received.\n        \"\"\"\n        if CameraHandler._exiting:\n            return\n        CameraHandler._exiting = True\n        raise ExitSignal()\n\n    def sio_connect(self) -&gt; bool:\n        \"\"\"\n        Connect to SocketIO server.\n        Returning True stops polling for connection to succeed.\n        \"\"\"\n        if self._exiting:\n            return True\n\n        self.sio.connect(\n            str(self.settings.socketio_server_url),\n            namespaces=[\"/robotcam\"],\n        )\n        return True\n\n    def open_camera(self):\n        \"\"\"\n        Initialize camera.\n        \"\"\"\n        camera_name = CameraName[self.settings.camera_name]\n        camera_codec = VideoCodec[self.settings.camera_codec]\n        camera_path: Path = camera_name.val\n\n        if not camera_path.exists():\n            logger.error(f\"Camera not found: {camera_path}\")\n            return\n\n        if camera_name == CameraName.rpicam:\n            CameraClass = RPiCamera\n        elif camera_name == CameraName.simcam:\n            CameraClass = SimCamera\n        else:\n            CameraClass = USBCamera\n        self.camera = CameraClass(\n            self.settings.id,\n            camera_name,\n            camera_codec,\n            self.settings.camera_width,\n            self.settings.camera_height,\n            self.settings.stream_width,\n            self.settings.stream_height,\n        )\n\n        self.camera.open()\n\n    def close_camera(self) -&gt; None:\n        \"\"\"\n        Release camera device.\n        \"\"\"\n        if self.camera:\n            try:\n                self.camera.close()\n                logger.info(\"Camera handler: Camera closed.\")\n            except Exception as exc:  # noqa\n                logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n        self.camera = None\n\n    def camera_handler(self) -&gt; None:\n        \"\"\"\n        Read and process frames from camera.\n        \"\"\"\n        interval = 1.0 / self._frame_rate\n\n        try:\n            while not self._exiting:\n                start = time.time()\n\n                if not self.camera:\n                    self.open_camera()\n\n                if not self.camera:\n                    logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                    sleep(1)\n                    continue\n\n                try:\n                    self.process_image()\n                except ExitSignal:\n                    break\n                except Exception as exc:\n                    logger.warning(f\"Unknown exception: {exc}\")\n                    self.close_camera()\n                    sleep(1)\n                    continue\n\n                now = time.time()\n                duration = now - start\n                if duration &gt; interval:\n                    logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n                else:\n                    wait = interval - duration\n                    time.sleep(wait)\n\n        except ExitSignal:\n            CameraHandler._exiting = True\n\n        logger.info(\"Camera handler: Exiting.\")\n\n        self.close_camera()\n        if self.sio.connected:\n            self.sio.disconnect()\n\n        if self.frame_queue:\n            self.frame_queue.cancel_join_thread()\n        if self.stream_queue:\n            self.stream_queue.cancel_join_thread()\n\n    def process_image(self) -&gt; None:\n        \"\"\"\n        Read one frame from camera, process it, send samples to cogip-server\n        and generate image to stream.\n        \"\"\"\n        image_main, image_stream = self.camera.read()\n        if image_main is None:\n            raise Exception(\"Camera handler: Cannot read frame.\")\n\n        # Encode the frame in JPEG format\n        ret, encoded_image = cv2.imencode(\".jpg\", image_main, [int(cv2.IMWRITE_JPEG_QUALITY), 95])\n\n        if not ret:\n            raise Exception(\"Can't encode frame.\")\n\n        frame_data = encoded_image.tobytes()\n\n        if self.frame_queue:\n            if self.frame_queue.full():\n                try:\n                    self.frame_queue.get_nowait()\n                except Empty:\n                    pass\n            try:\n                self.frame_queue.put_nowait(frame_data)\n            except Full:\n                pass\n\n        if image_stream is not None:\n            ret, encoded_stream = cv2.imencode(\".jpg\", image_stream, [int(cv2.IMWRITE_JPEG_QUALITY), 70])\n            if ret:\n                stream_frame_data = encoded_stream.tobytes()\n\n                if self.stream_queue:\n                    if self.stream_queue.full():\n                        try:\n                            self.stream_queue.get_nowait()\n                        except Exception:\n                            pass\n                    try:\n                        self.stream_queue.put_nowait(stream_frame_data)\n                    except Full:\n                        pass\n\n        if self.record_writer:\n            if len(image_main.shape) == 2:\n                image_record = cv2.cvtColor(image_main, cv2.COLOR_GRAY2BGR)\n            else:\n                image_record = image_main\n            self.record_writer.write(image_record)\n\n    def start_video_record(self):\n        if self.record_writer:\n            self.stop_video_record()\n        records_dir = Path.home() / \"records\"\n        records_dir.mkdir(exist_ok=True)\n        # Keep only 20 last records\n        for old_record in sorted(records_dir.glob(\"*.mp4\"))[:-20]:\n            old_record.unlink()\n        timestamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n        self.record_filename = records_dir / f\"robot{self.settings.id}_{timestamp}.mp4\"\n\n        logger.info(f\"Start recording video in {self.record_filename}\")\n        self.record_writer = cv2.VideoWriter(\n            str(self.record_filename),\n            cv2.VideoWriter.fourcc(*\"mp4v\"),\n            self._frame_rate,\n            (self.settings.camera_width, self.settings.camera_height),\n        )\n\n    def stop_video_record(self):\n        if self.record_writer:\n            logger.info(\"Stop recording video\")\n            self.record_writer.release()\n            self.record_filename = None\n            self.record_writer = None\n\n    def register_sio_events(self) -&gt; None:\n        @self.sio.event(namespace=\"/robotcam\")\n        def connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Camera handler: connected to server\")\n            self.sio.emit(\"connected\", namespace=\"/robotcam\")\n\n        @self.sio.event(namespace=\"/robotcam\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            logger.info(\"Camera handler: connection to server failed.\")\n\n        @self.sio.event(namespace=\"/robotcam\")\n        def disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Camera handler: disconnected from server\")\n\n        @self.sio.on(\"start_video_record\", namespace=\"/robotcam\")\n        def start_video_record():\n            self.start_video_record()\n\n        @self.sio.on(\"stop_video_record\", namespace=\"/robotcam\")\n        def stop_video_record():\n            self.stop_video_record()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.__init__","title":"<code>__init__(frame_queue, stream_queue)</code>","text":"<p>Class constructor.</p> <p>Create SocketIO client and connect to server.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def __init__(self, frame_queue: Queue, stream_queue: Queue):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO client and connect to server.\n    \"\"\"\n    self.settings = Settings()\n    self.frame_queue = frame_queue\n    self.stream_queue = stream_queue\n    self.camera: Camera | None = None\n    self.record_filename: Path | None = None\n    self.record_writer: cv2.VideoWriter | None = None\n\n    self.sio = socketio.Client(logger=False, engineio_logger=False, handle_sigint=False)\n    self.register_sio_events()\n\n    signal.signal(signal.SIGTERM, self.exit_handler)\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n    Thread(\n        target=lambda: polling2.poll(\n            self.sio_connect,\n            step=1,\n            ignore_exceptions=(socketio.exceptions.ConnectionError),\n            poll_forever=True,\n        ),\n        daemon=True,\n    ).start()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.camera_handler","title":"<code>camera_handler()</code>","text":"<p>Read and process frames from camera.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def camera_handler(self) -&gt; None:\n    \"\"\"\n    Read and process frames from camera.\n    \"\"\"\n    interval = 1.0 / self._frame_rate\n\n    try:\n        while not self._exiting:\n            start = time.time()\n\n            if not self.camera:\n                self.open_camera()\n\n            if not self.camera:\n                logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                sleep(1)\n                continue\n\n            try:\n                self.process_image()\n            except ExitSignal:\n                break\n            except Exception as exc:\n                logger.warning(f\"Unknown exception: {exc}\")\n                self.close_camera()\n                sleep(1)\n                continue\n\n            now = time.time()\n            duration = now - start\n            if duration &gt; interval:\n                logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n            else:\n                wait = interval - duration\n                time.sleep(wait)\n\n    except ExitSignal:\n        CameraHandler._exiting = True\n\n    logger.info(\"Camera handler: Exiting.\")\n\n    self.close_camera()\n    if self.sio.connected:\n        self.sio.disconnect()\n\n    if self.frame_queue:\n        self.frame_queue.cancel_join_thread()\n    if self.stream_queue:\n        self.stream_queue.cancel_join_thread()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.close_camera","title":"<code>close_camera()</code>","text":"<p>Release camera device.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def close_camera(self) -&gt; None:\n    \"\"\"\n    Release camera device.\n    \"\"\"\n    if self.camera:\n        try:\n            self.camera.close()\n            logger.info(\"Camera handler: Camera closed.\")\n        except Exception as exc:  # noqa\n            logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n    self.camera = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.exit_handler","title":"<code>exit_handler(signum, frame)</code>  <code>staticmethod</code>","text":"<p>Function called when TERM signal is received.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>@staticmethod\ndef exit_handler(signum, frame):\n    \"\"\"\n    Function called when TERM signal is received.\n    \"\"\"\n    if CameraHandler._exiting:\n        return\n    CameraHandler._exiting = True\n    raise ExitSignal()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.open_camera","title":"<code>open_camera()</code>","text":"<p>Initialize camera.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def open_camera(self):\n    \"\"\"\n    Initialize camera.\n    \"\"\"\n    camera_name = CameraName[self.settings.camera_name]\n    camera_codec = VideoCodec[self.settings.camera_codec]\n    camera_path: Path = camera_name.val\n\n    if not camera_path.exists():\n        logger.error(f\"Camera not found: {camera_path}\")\n        return\n\n    if camera_name == CameraName.rpicam:\n        CameraClass = RPiCamera\n    elif camera_name == CameraName.simcam:\n        CameraClass = SimCamera\n    else:\n        CameraClass = USBCamera\n    self.camera = CameraClass(\n        self.settings.id,\n        camera_name,\n        camera_codec,\n        self.settings.camera_width,\n        self.settings.camera_height,\n        self.settings.stream_width,\n        self.settings.stream_height,\n    )\n\n    self.camera.open()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.process_image","title":"<code>process_image()</code>","text":"<p>Read one frame from camera, process it, send samples to cogip-server and generate image to stream.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def process_image(self) -&gt; None:\n    \"\"\"\n    Read one frame from camera, process it, send samples to cogip-server\n    and generate image to stream.\n    \"\"\"\n    image_main, image_stream = self.camera.read()\n    if image_main is None:\n        raise Exception(\"Camera handler: Cannot read frame.\")\n\n    # Encode the frame in JPEG format\n    ret, encoded_image = cv2.imencode(\".jpg\", image_main, [int(cv2.IMWRITE_JPEG_QUALITY), 95])\n\n    if not ret:\n        raise Exception(\"Can't encode frame.\")\n\n    frame_data = encoded_image.tobytes()\n\n    if self.frame_queue:\n        if self.frame_queue.full():\n            try:\n                self.frame_queue.get_nowait()\n            except Empty:\n                pass\n        try:\n            self.frame_queue.put_nowait(frame_data)\n        except Full:\n            pass\n\n    if image_stream is not None:\n        ret, encoded_stream = cv2.imencode(\".jpg\", image_stream, [int(cv2.IMWRITE_JPEG_QUALITY), 70])\n        if ret:\n            stream_frame_data = encoded_stream.tobytes()\n\n            if self.stream_queue:\n                if self.stream_queue.full():\n                    try:\n                        self.stream_queue.get_nowait()\n                    except Exception:\n                        pass\n                try:\n                    self.stream_queue.put_nowait(stream_frame_data)\n                except Full:\n                    pass\n\n    if self.record_writer:\n        if len(image_main.shape) == 2:\n            image_record = cv2.cvtColor(image_main, cv2.COLOR_GRAY2BGR)\n        else:\n            image_record = image_main\n        self.record_writer.write(image_record)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.sio_connect","title":"<code>sio_connect()</code>","text":"<p>Connect to SocketIO server. Returning True stops polling for connection to succeed.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def sio_connect(self) -&gt; bool:\n    \"\"\"\n    Connect to SocketIO server.\n    Returning True stops polling for connection to succeed.\n    \"\"\"\n    if self._exiting:\n        return True\n\n    self.sio.connect(\n        str(self.settings.socketio_server_url),\n        namespaces=[\"/robotcam\"],\n    )\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/main/","title":"main","text":""},{"location":"reference/cogip/tools/robotcam/main/#cogip.tools.robotcam.main.main","title":"<code>main()</code>","text":"<p>Launch COGIP Robot Camera.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-robotcam</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/robotcam/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Launch COGIP Robot Camera.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-robotcam` script using this function as entrypoint.\n    \"\"\"\n    settings = Settings()\n\n    frame_queue = Queue(maxsize=1)\n    stream_queue = Queue(maxsize=1)\n\n    server.set_queues(frame_queue, stream_queue)\n\n    # Start Camera handler process\n    p = Process(target=start_camera_handler, args=(frame_queue, stream_queue))\n    p.start()\n\n    # Start web server\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8100 + settings.id,\n        workers=settings.nb_workers,\n        log_level=\"warning\",\n    )\n\n    p.terminate()\n    p.join()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/","title":"server","text":""},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer","title":"<code>CameraServer</code>","text":"<p>Camera web server.</p> <p>Handle FastAPI server to stream camera video and SocketIO client to send detected samples to server.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>class CameraServer:\n    \"\"\"\n    Camera web server.\n\n    Handle FastAPI server to stream camera video and SocketIO client to send detected samples to server.\n    \"\"\"\n\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application and SocketIO client.\n        \"\"\"\n        self.settings = Settings()\n        CameraServer._exiting = False\n\n        self.frame_queue: Queue | None = None\n        self.stream_queue: Queue | None = None\n        self.last_frame: bytes | None = None\n        self.last_stream_frame: bytes | None = None\n\n        self.app = FastAPI(title=\"COGIP Robot Camera Streamer\", lifespan=self.lifespan, debug=False)\n        self.register_endpoints()\n\n        UvicornServer.handle_exit = self.handle_exit\n\n        self.records_dir = Path.home() / \"records\"\n        self.records_dir.mkdir(exist_ok=True)\n        # Keep only 100 last records\n        for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n            old_record.unlink()\n\n        if self.settings.camera_name == CameraName.rpicam.name:\n            CameraClass = RPiCamera\n        elif self.settings.camera_name == CameraName.simcam.name:\n            CameraClass = SimCamera\n        else:\n            CameraClass = USBCamera\n        self.camera = CameraClass(\n            self.settings.id,\n            CameraName[self.settings.camera_name],\n            VideoCodec[self.settings.camera_codec],\n            self.settings.camera_width,\n            self.settings.camera_height,\n            self.settings.stream_width,\n            self.settings.stream_height,\n        )\n\n        # Load camera intrinsic parameters\n        self.camera_matrix: cv2.typing.MatLike | None = None\n        self.dist_coefs: cv2.typing.MatLike | None = None\n        if not self.camera.intrinsic_params_filename.exists():\n            logger.warning(f\"Camera intrinsic parameters file not found: {self.camera.intrinsic_params_filename}\")\n        else:\n            self.camera_matrix, self.dist_coefs = load_camera_intrinsic_params(self.camera.intrinsic_params_filename)\n\n        # Load camera extrinsic parameters\n        self.extrinsic_params: CameraExtrinsicParameters | None = None\n        if not self.camera.extrinsic_params_filename.exists():\n            logger.warning(f\"Camera extrinsic parameters file not found: {self.camera.extrinsic_params_filename}\")\n        else:\n            self.extrinsic_params = load_camera_extrinsic_params(self.camera.extrinsic_params_filename)\n\n        aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n        parameters = cv2.aruco.DetectorParameters()\n\n        # Speed optimizations\n        # Use a single window size for adaptive thresholding to avoid multiple passes\n        parameters.adaptiveThreshWinSizeMin = 13\n        parameters.adaptiveThreshWinSizeMax = 13\n        parameters.adaptiveThreshWinSizeStep = 1\n\n        # Reduce accuracy of polygonal approximation (faster contour processing)\n        parameters.polygonalApproxAccuracyRate = 0.05  # Default 0.03\n\n        # Disable corner refinement if not strictly necessary (SUBPIX is slow)\n        parameters.cornerRefinementMethod = cv2.aruco.CORNER_REFINE_NONE\n\n        self.detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)\n\n    def set_queues(self, frame_queue: Queue, stream_queue: Queue):\n        self.frame_queue = frame_queue\n        self.stream_queue = stream_queue\n\n        # Start consumer thread\n        self.consumer_thread = Thread(target=self.consume_queues, daemon=True)\n        self.consumer_thread.start()\n\n    def consume_queues(self):\n        while not self._exiting:\n            try:\n                if self.frame_queue and not self.frame_queue.empty():\n                    try:\n                        self.last_frame = self.frame_queue.get_nowait()\n                    except Empty:\n                        pass\n\n                if self.stream_queue and not self.stream_queue.empty():\n                    try:\n                        self.last_stream_frame = self.stream_queue.get_nowait()\n                    except Empty:\n                        pass\n\n                time.sleep(0.01)\n            except Exception:\n                pass\n\n    @asynccontextmanager\n    async def lifespan(self, app: FastAPI):\n        \"\"\"\n        Handle application startup and shutdown events.\n        \"\"\"\n        logger.info(\"Robotcam server starting up...\")\n        try:\n            systemd.daemon.notify(\"READY=1\")\n            logger.info(\"Systemd notified: READY=1\")\n        except Exception as e:\n            logger.error(f\"Failed to notify systemd: {e}\")\n\n        yield\n\n        logger.info(\"Robotcam server shutting down...\")\n        CameraServer._exiting = True\n        if self.consumer_thread:\n            self.consumer_thread.join()\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        CameraServer._exiting = True\n        CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n\n    async def camera_streamer(self):\n        \"\"\"\n        Frame generator.\n        Yield frames produced by [camera_handler][cogip.tools.robotcam.camera.CameraHandler.camera_handler].\n        \"\"\"\n        while not self._exiting:\n            if self.last_stream_frame:\n                yield b\"--frame\\r\\n\"\n                yield b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n                yield self.last_stream_frame\n                yield b\"\\r\\n\"\n\n            await asyncio.sleep(0.1)\n\n    def register_endpoints(self) -&gt; None:\n        @self.app.get(\"/\")\n        def index():\n            \"\"\"\n            Camera stream.\n            \"\"\"\n            stream = self.camera_streamer() if self.last_stream_frame else \"\"\n            return StreamingResponse(stream, media_type=\"multipart/x-mixed-replace;boundary=frame\")\n\n        @self.app.get(\"/detect\", status_code=200)\n        def detect() -&gt; list[dict]:\n            start_time = time.time()\n            if self.last_frame is None:\n                raise HTTPException(status_code=503, detail=\"Camera not ready\")\n\n            jpg_as_np = np.frombuffer(self.last_frame, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=cv2.IMREAD_UNCHANGED)\n\n            if len(frame.shape) == 2:\n                dst = frame\n            else:\n                dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            results = []\n            if marker_ids is not None:\n                for id, corners in zip(marker_ids, marker_corners):\n                    results.append({\"id\": int(id[0]), \"corners\": corners[0].tolist()})\n\n            duration = time.time() - start_time\n            logger.info(f\"Detect endpoint took {duration:.3f}s\")\n\n            return results\n\n        @self.app.get(\"/snapshot\", status_code=200)\n        def snapshot():\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-snapshot\"\n\n            if self.last_frame is None:\n                raise HTTPException(status_code=503, detail=\"Camera not ready\")\n\n            jpg_as_np = np.frombuffer(self.last_frame, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n        @self.app.get(\"/camera_calibration\", status_code=200)\n        def camera_calibration(x: float, y: float, angle: float) -&gt; CameraExtrinsicParameters:\n            if self.last_frame is None:\n                raise HTTPException(status_code=503, detail=\"Camera not ready\")\n\n            jpg_as_np = np.frombuffer(self.last_frame, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=cv2.IMREAD_UNCHANGED)\n\n            if len(frame.shape) == 2:\n                dst = frame\n                frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)\n            else:\n                dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-calibration\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                raise HTTPException(status_code=404, detail=\"No marker found\")\n\n            robot_pose = Pose(x=x, y=y, O=angle)\n\n            # Keep table markers only\n            table_markers = {\n                id[0]: corners for id, corners in zip(marker_ids, marker_corners) if id[0] in [20, 21, 22, 23]\n            }\n\n            if len(table_markers) == 0:\n                raise HTTPException(status_code=404, detail=\"No table marker found\")\n\n            # Compute camera position on table\n            table_camera_tvec, table_camera_rvec_degrees = get_camera_position_on_table(\n                table_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n            )\n\n            # Compute camera position in robot if robot position is given\n            camera_position = get_camera_position_in_robot(\n                robot_pose,\n                table_camera_tvec,\n                table_camera_rvec_degrees,\n            )\n\n            return camera_position\n\n        @self.app.get(\"/robot_position\", status_code=200)\n        def robot_position() -&gt; Pose:\n            if self.last_frame is None:\n                raise HTTPException(status_code=503, detail=\"Camera not ready\")\n\n            jpg_as_np = np.frombuffer(self.last_frame, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=cv2.IMREAD_UNCHANGED)\n\n            if len(frame.shape) == 2:\n                dst = frame\n                frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)\n            else:\n                dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-position\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                raise HTTPException(status_code=404, detail=\"No marker found\")\n\n            # Keep table markers only\n            table_markers = {\n                id[0]: corners for id, corners in zip(marker_ids, marker_corners) if id[0] in [20, 21, 22, 23]\n            }\n\n            if len(table_markers) == 0:\n                raise HTTPException(status_code=404, detail=\"No table marker found\")\n\n            if self.camera_matrix is None or self.dist_coefs is None:\n                raise HTTPException(status_code=503, detail=\"Camera intrinsic parameters not loaded\")\n\n            # Compute camera position on table\n            camera_tvec, camera_rvec_degrees = get_camera_position_on_table(\n                table_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n            )\n\n            # Compute robot position on table\n\n            # 1. Camera in Table frame (Transformation T_ct)\n            # Reconstruct rotation matrix from Euler angles (applying R_flip to match convention)\n            R_ct_flipped = euler_angles_to_rotation_matrix(np.deg2rad(camera_rvec_degrees))\n            R_ct = R_flip @ R_ct_flipped\n            M_ct = make_transform_matrix(R_ct, camera_tvec)\n\n            # 2. Camera in Robot frame (Transformation T_cr)\n            M_cr = extrinsic_params_to_matrix(self.extrinsic_params)\n\n            # 3. Robot in Table frame (Transformation T_rt)\n            # M_rt = M_ct * M_cr^(-1)\n            M_rt = M_ct @ np.linalg.inv(M_cr)\n\n            # Extract results\n            R_rt, T_rt = decompose_transform_matrix(M_rt)\n            robot_angle_degrees = np.rad2deg(np.arctan2(R_rt[1, 0], R_rt[0, 0]))\n\n            logger.info(\n                f\"Robot position: X={T_rt[0]:.0f} Y={T_rt[1]:.0f} Z={T_rt[2]:.0f} Angle={robot_angle_degrees:.0f}\"\n            )\n            return Pose(x=T_rt[0], y=T_rt[1], z=T_rt[2], O=robot_angle_degrees)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application and SocketIO client.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application and SocketIO client.\n    \"\"\"\n    self.settings = Settings()\n    CameraServer._exiting = False\n\n    self.frame_queue: Queue | None = None\n    self.stream_queue: Queue | None = None\n    self.last_frame: bytes | None = None\n    self.last_stream_frame: bytes | None = None\n\n    self.app = FastAPI(title=\"COGIP Robot Camera Streamer\", lifespan=self.lifespan, debug=False)\n    self.register_endpoints()\n\n    UvicornServer.handle_exit = self.handle_exit\n\n    self.records_dir = Path.home() / \"records\"\n    self.records_dir.mkdir(exist_ok=True)\n    # Keep only 100 last records\n    for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n        old_record.unlink()\n\n    if self.settings.camera_name == CameraName.rpicam.name:\n        CameraClass = RPiCamera\n    elif self.settings.camera_name == CameraName.simcam.name:\n        CameraClass = SimCamera\n    else:\n        CameraClass = USBCamera\n    self.camera = CameraClass(\n        self.settings.id,\n        CameraName[self.settings.camera_name],\n        VideoCodec[self.settings.camera_codec],\n        self.settings.camera_width,\n        self.settings.camera_height,\n        self.settings.stream_width,\n        self.settings.stream_height,\n    )\n\n    # Load camera intrinsic parameters\n    self.camera_matrix: cv2.typing.MatLike | None = None\n    self.dist_coefs: cv2.typing.MatLike | None = None\n    if not self.camera.intrinsic_params_filename.exists():\n        logger.warning(f\"Camera intrinsic parameters file not found: {self.camera.intrinsic_params_filename}\")\n    else:\n        self.camera_matrix, self.dist_coefs = load_camera_intrinsic_params(self.camera.intrinsic_params_filename)\n\n    # Load camera extrinsic parameters\n    self.extrinsic_params: CameraExtrinsicParameters | None = None\n    if not self.camera.extrinsic_params_filename.exists():\n        logger.warning(f\"Camera extrinsic parameters file not found: {self.camera.extrinsic_params_filename}\")\n    else:\n        self.extrinsic_params = load_camera_extrinsic_params(self.camera.extrinsic_params_filename)\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    parameters = cv2.aruco.DetectorParameters()\n\n    # Speed optimizations\n    # Use a single window size for adaptive thresholding to avoid multiple passes\n    parameters.adaptiveThreshWinSizeMin = 13\n    parameters.adaptiveThreshWinSizeMax = 13\n    parameters.adaptiveThreshWinSizeStep = 1\n\n    # Reduce accuracy of polygonal approximation (faster contour processing)\n    parameters.polygonalApproxAccuracyRate = 0.05  # Default 0.03\n\n    # Disable corner refinement if not strictly necessary (SUBPIX is slow)\n    parameters.cornerRefinementMethod = cv2.aruco.CORNER_REFINE_NONE\n\n    self.detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.camera_streamer","title":"<code>camera_streamer()</code>  <code>async</code>","text":"<p>Frame generator. Yield frames produced by camera_handler.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>async def camera_streamer(self):\n    \"\"\"\n    Frame generator.\n    Yield frames produced by [camera_handler][cogip.tools.robotcam.camera.CameraHandler.camera_handler].\n    \"\"\"\n    while not self._exiting:\n        if self.last_stream_frame:\n            yield b\"--frame\\r\\n\"\n            yield b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n            yield self.last_stream_frame\n            yield b\"\\r\\n\"\n\n        await asyncio.sleep(0.1)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    CameraServer._exiting = True\n    CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.lifespan","title":"<code>lifespan(app)</code>  <code>async</code>","text":"<p>Handle application startup and shutdown events.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(self, app: FastAPI):\n    \"\"\"\n    Handle application startup and shutdown events.\n    \"\"\"\n    logger.info(\"Robotcam server starting up...\")\n    try:\n        systemd.daemon.notify(\"READY=1\")\n        logger.info(\"Systemd notified: READY=1\")\n    except Exception as e:\n        logger.error(f\"Failed to notify systemd: {e}\")\n\n    yield\n\n    logger.info(\"Robotcam server shutting down...\")\n    CameraServer._exiting = True\n    if self.consumer_thread:\n        self.consumer_thread.join()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/settings/","title":"settings","text":""},{"location":"reference/cogip/tools/scservo/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/scservo/__main__/#cogip.tools.scservo.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SCServo Tools.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-scservo</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/scservo/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SCServo Tools.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-scservo` script using this function as entrypoint.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"reference/cogip/tools/scservo/common/","title":"common","text":""},{"location":"reference/cogip/tools/scservo/ping/","title":"ping","text":""},{"location":"reference/cogip/tools/scservo/read/","title":"read","text":""},{"location":"reference/cogip/tools/scservo/reg_write/","title":"reg_write","text":""},{"location":"reference/cogip/tools/scservo/sync_write/","title":"sync_write","text":""},{"location":"reference/cogip/tools/scservo/wheel/","title":"wheel","text":""},{"location":"reference/cogip/tools/scservo/write/","title":"write","text":""},{"location":"reference/cogip/tools/server/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/server/__main__/#cogip.tools.server.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SocketIO/Web server.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-server</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/server/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SocketIO/Web server.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-server` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/server/app/","title":"app","text":""},{"location":"reference/cogip/tools/server/app/#cogip.tools.server.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return ASGIApp application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/server/app.py</code> <pre><code>def create_app() -&gt; ASGIApp:\n    \"\"\"\n    Create server and return ASGIApp application for uvicorn/gunicorn.\n    \"\"\"\n    server = Server()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/server/context/","title":"context","text":""},{"location":"reference/cogip/tools/server/context/#cogip.tools.server.context.Context","title":"<code>Context</code>  <code>dataclass</code>","text":"<p>Server context class recording variables using in multiple namespaces.</p> <p>Attributes:</p> Name Type Description <code>robot_id</code> <code>int | None</code> <p>Robot ID</p> <code>planner_sid</code> <code>str | None</code> <p>Planner sid</p> <code>copilot_sid</code> <code>str | None</code> <p>Copilot sid</p> <code>detector_sid</code> <code>str | None</code> <p>Detector sid</p> <code>robotcam_sid</code> <code>str | None</code> <p>Robotcam sid</p> <code>beacon_sid</code> <code>str | None</code> <p>Beacon server sid</p> <code>monitor_sid</code> <code>str | None</code> <p>Monitor sid</p> <code>calibration_sid</code> <code>str | None</code> <p>Calibration client sid</p> <code>tool_menus</code> <code>dict[str, ShellMenu]</code> <p>all registered tool menus</p> <code>current_tool_menu</code> <code>str | None</code> <p>name of the currently selected tool menu</p> <code>shell_menu</code> <code>ShellMenu | None</code> <p>last received shell menu</p> <code>virtual</code> <p>Whether robot is virtual or not</p> <code>virtual_planner</code> <p>Whether planner is virtual or not</p> <code>virtual_detector</code> <p>Whether detector is virtual or not</p> <code>robot_added</code> <p>Whether robot has been added or not</p> Source code in <code>cogip/tools/server/context.py</code> <pre><code>@dataclass\nclass Context(metaclass=Singleton):\n    \"\"\"\n    Server context class recording variables using in multiple namespaces.\n\n    Attributes:\n        robot_id:           Robot ID\n        planner_sid:        Planner sid\n        copilot_sid:        Copilot sid\n        detector_sid:       Detector sid\n        robotcam_sid:       Robotcam sid\n        beacon_sid:         Beacon server sid\n        monitor_sid:        Monitor sid\n        calibration_sid:    Calibration client sid\n        tool_menus:         all registered tool menus\n        current_tool_menu:  name of the currently selected tool menu\n        shell_menu:         last received shell menu\n        virtual:            Whether robot is virtual or not\n        virtual_planner:    Whether planner is virtual or not\n        virtual_detector:   Whether detector is virtual or not\n        robot_added:        Whether robot has been added or not\n    \"\"\"\n\n    robot_id: int | None = None\n    planner_sid: str | None = None\n    copilot_sid: str | None = None\n    detector_sid: str | None = None\n    robotcam_sid: str | None = None\n    beacon_sid: str | None = None\n    monitor_sid: str | None = None\n    calibration_sid: str | None = None\n    tool_menus: dict[str, models.ShellMenu] = field(default_factory=dict)\n    current_tool_menu: str | None = None\n    shell_menu: models.ShellMenu | None = None\n    virtual = platform.machine() != \"aarch64\"\n    virtual_planner = False\n    virtual_detector = False\n    robot_added = False\n</code></pre>"},{"location":"reference/cogip/tools/server/server/","title":"server","text":""},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server","title":"<code>Server</code>","text":"Source code in <code>cogip/tools/server/server.py</code> <pre><code>class Server:\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit  # Backup of original exit handler to overload it\n    _shared_memory: SharedMemory | None = None  # Shared memory instance\n    _shared_pose_current_buffer: SharedPoseBuffer | None = None\n    _shared_circle_obstacles: SharedObstacleCircleList | None = None\n    _shared_rectangle_obstacles: SharedObstacleRectangleList | None = None\n    _shared_avoidance_path: SharedPoseOrderList | None = None\n    _shared_avoidance_path_lock: WritePriorityLock | None = None\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Server._shared_avoidance_path = None\n        Server._shared_avoidance_path_lock = None\n        Server._shared_rectangle_obstacles = None\n        Server._shared_circle_obstacles = None\n        Server._shared_pose_current_buffer = None\n        Server._shared_memory = None\n        Server._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO server.\n        \"\"\"\n        self.context = context.Context()\n        self.context.robot_id = int(os.environ[\"ROBOT_ID\"])\n        self.root_menu = models.ShellMenu(name=\"Root Menu\", entries=[])\n        self.context.tool_menus[\"root\"] = self.root_menu\n        self.context.current_tool_menu = \"root\"\n        self.dashboard_updater_loop = AsyncLoop(\n            \"Dashboard updater loop\",\n            float(os.getenv(\"SERVER_DASHBOARD_UPDATE_INTERVAL\", 0.2)),\n            self.update_dashboard,\n        )\n\n        if Server._shared_memory is None:\n            Server._shared_memory = SharedMemory(f\"cogip_{self.context.robot_id}\", owner=True)\n            Server._shared_pose_current_buffer = Server._shared_memory.get_pose_current_buffer()\n            Server._shared_circle_obstacles = Server._shared_memory.get_circle_obstacles()\n            Server._shared_rectangle_obstacles = Server._shared_memory.get_rectangle_obstacles()\n            Server._shared_avoidance_path = Server._shared_memory.get_avoidance_path()\n            Server._shared_avoidance_path_lock = Server._shared_memory.get_lock(LockName.AvoidancePath)\n            Server._shared_avoidance_path_lock.register_consumer()\n\n        self.sio = socketio.AsyncServer(\n            always_connect=False,\n            async_mode=\"asgi\",\n            cors_allowed_origins=\"*\",\n            logger=False,\n            engineio_logger=False,\n        )\n        self.app = socketio.ASGIApp(self.sio, on_startup=notify_systemd)\n        self.sio.register_namespace(namespaces.DashboardNamespace(self))\n        self.sio.register_namespace(namespaces.MonitorNamespace(self))\n        self.sio.register_namespace(namespaces.CopilotNamespace(self))\n        self.sio.register_namespace(namespaces.DetectorNamespace(self))\n        self.sio.register_namespace(namespaces.PlannerNamespace(self))\n        self.sio.register_namespace(namespaces.RobotcamNamespace(self))\n        self.sio.register_namespace(namespaces.BeaconNamespace(self))\n        self.sio.register_namespace(namespaces.FirmwareParametersNamespace(self))\n        self.sio.register_namespace(namespaces.FirmwareTelemetryNamespace(self))\n        self.sio.register_namespace(namespaces.FirmwareCalibrationNamespace(self))\n\n        self.dashboard_updater_loop.start()\n\n        self.new_path_event_task = asyncio.create_task(\n            self.new_path_event_loop(),\n            name=\"Server: Task New Path Event Watcher Loop\",\n        )\n\n        # Overload default Uvicorn exit handler\n        UvicornServer.handle_exit = Server.handle_exit\n\n        @self.sio.event\n        def connect(sid, environ, auth):\n            logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n            raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n        @self.sio.on(\"*\")\n        def catch_all(event, sid, data):\n            logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n\n    async def register_menu(self, namespace: str, data: dict[str, Any]) -&gt; None:\n        if not (name := data.get(\"name\")):\n            logger.warning(f\"register_menu: missing 'name' in data: {data}\")\n            return\n        if not (menu_dict := data.get(\"menu\")):\n            logger.warning(f\"register_menu: missing 'menu' in data: {data}\")\n            return\n        try:\n            menu = models.ShellMenu.model_validate(menu_dict)\n        except ValidationError as exc:\n            logger.warning(f\"register_menu: cannot validate 'menu': {exc}\")\n            return\n\n        ns_name = f\"{namespace}/{name}\"\n        entry = models.MenuEntry(cmd=ns_name, desc=f\"{menu.name} Menu\")\n        if ns_name not in self.context.tool_menus:\n            self.root_menu.entries.append(entry)\n        exit_entry = models.MenuEntry(cmd=\"exit\", desc=\"Exit Menu\")\n        menu.entries.append(exit_entry)\n        self.context.tool_menus[ns_name] = menu\n        await self.sio.emit(\n            \"tool_menu\",\n            self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n            namespace=\"/dashboard\",\n        )\n\n    async def update_dashboard(self):\n        shared_pose_current = Server._shared_pose_current_buffer.last\n        pose_current = {\n            \"x\": shared_pose_current.x,\n            \"y\": shared_pose_current.y,\n            \"O\": shared_pose_current.angle,\n        }\n        await self.sio.emit(\"pose_current\", (self.context.robot_id, pose_current), namespace=\"/dashboard\")\n        obstacles = []\n        obstacles += [\n            {\n                \"x\": obstacle.center.x,\n                \"y\": obstacle.center.y,\n                \"angle\": 0,\n                \"radius\": obstacle.radius,\n                \"bounding_box\": [{\"x\": p.x, \"y\": p.y} for p in obstacle.bounding_box],\n                \"id\": obstacle.id,\n            }\n            for obstacle in Server._shared_circle_obstacles\n        ]\n        obstacles += [\n            {\n                \"x\": obstacle.center.x,\n                \"y\": obstacle.center.y,\n                \"angle\": obstacle.center.angle,\n                \"length_x\": obstacle.length_x,\n                \"length_y\": obstacle.length_y,\n                \"bounding_box\": [{\"x\": p.x, \"y\": p.y} for p in obstacle.bounding_box],\n                \"id\": obstacle.id,\n            }\n            for obstacle in Server._shared_rectangle_obstacles\n        ]\n        await self.sio.emit(\"obstacles\", (self.context.robot_id, obstacles), namespace=\"/dashboard\")\n\n    async def new_path_event_loop(self):\n        logger.info(\"Server: Task New Path Event Watcher Loop started\")\n        try:\n            while True:\n                await asyncio.to_thread(Server._shared_avoidance_path_lock.wait_update)\n                shared_pose_current = Server._shared_pose_current_buffer.last\n                path = [{\"x\": shared_pose_current.x, \"y\": shared_pose_current.y, \"O\": shared_pose_current.angle}]\n                for pose in Server._shared_avoidance_path:\n                    path.append({\"x\": pose.x, \"y\": pose.y, \"O\": pose.angle})\n                if len(path) &gt; 1:\n                    await self.sio.emit(\"pose_order\", (self.context.robot_id, path[1]), namespace=\"/dashboard\")\n                    await self.sio.emit(\"path\", (self.context.robot_id, path), namespace=\"/dashboard\")\n        except asyncio.CancelledError:\n            logger.info(\"Server: Task New Path Event Watcher Loop cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Server: Task New Path Event Watcher Loop: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO server.</p> Source code in <code>cogip/tools/server/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO server.\n    \"\"\"\n    self.context = context.Context()\n    self.context.robot_id = int(os.environ[\"ROBOT_ID\"])\n    self.root_menu = models.ShellMenu(name=\"Root Menu\", entries=[])\n    self.context.tool_menus[\"root\"] = self.root_menu\n    self.context.current_tool_menu = \"root\"\n    self.dashboard_updater_loop = AsyncLoop(\n        \"Dashboard updater loop\",\n        float(os.getenv(\"SERVER_DASHBOARD_UPDATE_INTERVAL\", 0.2)),\n        self.update_dashboard,\n    )\n\n    if Server._shared_memory is None:\n        Server._shared_memory = SharedMemory(f\"cogip_{self.context.robot_id}\", owner=True)\n        Server._shared_pose_current_buffer = Server._shared_memory.get_pose_current_buffer()\n        Server._shared_circle_obstacles = Server._shared_memory.get_circle_obstacles()\n        Server._shared_rectangle_obstacles = Server._shared_memory.get_rectangle_obstacles()\n        Server._shared_avoidance_path = Server._shared_memory.get_avoidance_path()\n        Server._shared_avoidance_path_lock = Server._shared_memory.get_lock(LockName.AvoidancePath)\n        Server._shared_avoidance_path_lock.register_consumer()\n\n    self.sio = socketio.AsyncServer(\n        always_connect=False,\n        async_mode=\"asgi\",\n        cors_allowed_origins=\"*\",\n        logger=False,\n        engineio_logger=False,\n    )\n    self.app = socketio.ASGIApp(self.sio, on_startup=notify_systemd)\n    self.sio.register_namespace(namespaces.DashboardNamespace(self))\n    self.sio.register_namespace(namespaces.MonitorNamespace(self))\n    self.sio.register_namespace(namespaces.CopilotNamespace(self))\n    self.sio.register_namespace(namespaces.DetectorNamespace(self))\n    self.sio.register_namespace(namespaces.PlannerNamespace(self))\n    self.sio.register_namespace(namespaces.RobotcamNamespace(self))\n    self.sio.register_namespace(namespaces.BeaconNamespace(self))\n    self.sio.register_namespace(namespaces.FirmwareParametersNamespace(self))\n    self.sio.register_namespace(namespaces.FirmwareTelemetryNamespace(self))\n    self.sio.register_namespace(namespaces.FirmwareCalibrationNamespace(self))\n\n    self.dashboard_updater_loop.start()\n\n    self.new_path_event_task = asyncio.create_task(\n        self.new_path_event_loop(),\n        name=\"Server: Task New Path Event Watcher Loop\",\n    )\n\n    # Overload default Uvicorn exit handler\n    UvicornServer.handle_exit = Server.handle_exit\n\n    @self.sio.event\n    def connect(sid, environ, auth):\n        logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n        raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n    @self.sio.on(\"*\")\n    def catch_all(event, sid, data):\n        logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n</code></pre>"},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/server/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Server._shared_avoidance_path = None\n    Server._shared_avoidance_path_lock = None\n    Server._shared_rectangle_obstacles = None\n    Server._shared_circle_obstacles = None\n    Server._shared_pose_current_buffer = None\n    Server._shared_memory = None\n    Server._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace","title":"<code>BeaconNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to beacon server.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>class BeaconNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to beacon server.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/beacon\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        if self.context.beacon_sid:\n            message = \"A beacon server is already connected\"\n            logger.error(f\"Beacon verser connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.beacon_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Beacon connected.\")\n\n    def on_disconnect(self, sid):\n        self.context.beacon_sid = None\n        logger.info(\"Beacon disconnected.\")\n\n    async def on_reset(self, sid):\n        \"\"\"\n        Callback on reset message.\n        \"\"\"\n        logger.info(\"[beacon =&gt; planner] reset.\")\n        await self.emit(\"reset\", namespace=\"/planner\")\n\n    async def on_command(self, sid, cmd, *args):\n        \"\"\"\n        Callback on command.\n        \"\"\"\n        logger.info(f\"[beacon =&gt; planner] Command: {cmd}\")\n        await self.emit(\"command\", (cmd, *args), namespace=\"/planner\")\n\n    async def on_wizard(self, sid, message):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        await self.emit(\"wizard\", message, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_command","title":"<code>on_command(sid, cmd, *args)</code>  <code>async</code>","text":"<p>Callback on command.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_command(self, sid, cmd, *args):\n    \"\"\"\n    Callback on command.\n    \"\"\"\n    logger.info(f\"[beacon =&gt; planner] Command: {cmd}\")\n    await self.emit(\"command\", (cmd, *args), namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_reset","title":"<code>on_reset(sid)</code>  <code>async</code>","text":"<p>Callback on reset message.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_reset(self, sid):\n    \"\"\"\n    Callback on reset message.\n    \"\"\"\n    logger.info(\"[beacon =&gt; planner] reset.\")\n    await self.emit(\"reset\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_wizard","title":"<code>on_wizard(sid, message)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_wizard(self, sid, message):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    await self.emit(\"wizard\", message, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace","title":"<code>CopilotNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to copilot.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>class CopilotNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to copilot.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/copilot\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.copilot_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.copilot_sid:\n            message = \"A copilot is already connected\"\n            logger.error(f\"Copilot connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n\n    async def on_connected(self, sid):\n        logger.info(\"Copilot connected.\")\n        self.context.copilot_sid = sid\n        if self.context.planner_sid:\n            await self.emit(\"copilot_connected\", namespace=\"/planner\")\n\n    async def on_disconnect(self, sid):\n        self.context.copilot_sid = None\n        self.context.shell_menu = None\n        await self.emit(\"copilot_disconnected\", namespace=\"/planner\")\n        logger.info(\"Copilot disconnected.\")\n\n    async def on_reset(self, sid) -&gt; None:\n        \"\"\"\n        Callback on reset event.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] reset.\")\n        await self.emit(\"reset\", namespace=\"/planner\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"copilot\", data)\n\n    async def on_pose_reached(self, sid) -&gt; None:\n        \"\"\"\n        Callback on pose reached message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Pose reached.\")\n        await self.emit(\"pose_reached\", namespace=\"/planner\")\n        if self.context.calibration_sid:\n            await self.emit(\"pose_reached\", namespace=\"/calibration\")\n\n    async def on_intermediate_pose_reached(self, sid) -&gt; None:\n        \"\"\"\n        Callback on intermediate pose reached message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Intermediate pose reached.\")\n        await self.emit(\"intermediate_pose_reached\", namespace=\"/planner\")\n\n    async def on_blocked(self, sid) -&gt; None:\n        \"\"\"\n        Callback on blocked message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Blocked.\")\n        await self.emit(\"blocked\", namespace=\"/planner\")\n\n    async def on_menu(self, sid, menu):\n        \"\"\"\n        Callback on menu event.\n        \"\"\"\n        self.context.shell_menu = models.ShellMenu.model_validate(menu)\n        await self.emit(\"shell_menu\", (self.context.robot_id, menu), namespace=\"/dashboard\")\n\n    async def on_state(self, sid, state):\n        \"\"\"\n        Callback on state event.\n        \"\"\"\n        await self.emit(\"state\", (self.context.robot_id, state), namespace=\"/dashboard\")\n\n    async def on_actuator_state(self, sid, actuator_state: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        await self.emit(\"actuator_state\", actuator_state, namespace=\"/planner\")\n        await self.emit(\"actuator_state\", actuator_state, namespace=\"/dashboard\")\n\n    async def on_pid(self, sid, pid: dict[str, Any]):\n        \"\"\"\n        Callback on pid message.\n        \"\"\"\n        await self.emit(\"pid\", pid, namespace=\"/dashboard\")\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n\n    async def on_game_end(self, sid) -&gt; None:\n        \"\"\"\n        Callback on game end message.\n        \"\"\"\n        logger.info(\"[copilot =&gt; planner] Game end.\")\n        await self.emit(\"game_end\", namespace=\"/planner\")\n\n    async def on_get_parameter_response(self, sid, response: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on get_parameter_response message from copilot.\n        Forward to firmware parameter manager.\n        \"\"\"\n        logger.info(f\"[copilot =&gt; parameters] Get response: {response}\")\n        await self.emit(\"get_parameter_response\", response, namespace=\"/parameters\")\n\n    async def on_set_parameter_response(self, sid, response: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on set_parameter_response message from copilot.\n        Forward to firmware parameter manager.\n        \"\"\"\n        logger.info(f\"[copilot =&gt; parameters] Set response: {response}\")\n        await self.emit(\"set_parameter_response\", response, namespace=\"/parameters\")\n\n    async def on_telemetry_data(self, sid, telemetry: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on telemetry_data message from copilot.\n        Forward to telemetry clients.\n        \"\"\"\n        logger.debug(f\"[copilot =&gt; telemetry] Telemetry Data: {telemetry}\")\n        await self.emit(\"telemetry_data\", telemetry, namespace=\"/telemetry\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_actuator_state","title":"<code>on_actuator_state(sid, actuator_state)</code>  <code>async</code>","text":"<p>Callback on actuator_state message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_actuator_state(self, sid, actuator_state: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_state message.\n    \"\"\"\n    await self.emit(\"actuator_state\", actuator_state, namespace=\"/planner\")\n    await self.emit(\"actuator_state\", actuator_state, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_blocked","title":"<code>on_blocked(sid)</code>  <code>async</code>","text":"<p>Callback on blocked message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_blocked(self, sid) -&gt; None:\n    \"\"\"\n    Callback on blocked message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Blocked.\")\n    await self.emit(\"blocked\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_game_end","title":"<code>on_game_end(sid)</code>  <code>async</code>","text":"<p>Callback on game end message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_game_end(self, sid) -&gt; None:\n    \"\"\"\n    Callback on game end message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Game end.\")\n    await self.emit(\"game_end\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_get_parameter_response","title":"<code>on_get_parameter_response(sid, response)</code>  <code>async</code>","text":"<p>Callback on get_parameter_response message from copilot. Forward to firmware parameter manager.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_get_parameter_response(self, sid, response: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on get_parameter_response message from copilot.\n    Forward to firmware parameter manager.\n    \"\"\"\n    logger.info(f\"[copilot =&gt; parameters] Get response: {response}\")\n    await self.emit(\"get_parameter_response\", response, namespace=\"/parameters\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_intermediate_pose_reached","title":"<code>on_intermediate_pose_reached(sid)</code>  <code>async</code>","text":"<p>Callback on intermediate pose reached message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_intermediate_pose_reached(self, sid) -&gt; None:\n    \"\"\"\n    Callback on intermediate pose reached message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Intermediate pose reached.\")\n    await self.emit(\"intermediate_pose_reached\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_menu","title":"<code>on_menu(sid, menu)</code>  <code>async</code>","text":"<p>Callback on menu event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_menu(self, sid, menu):\n    \"\"\"\n    Callback on menu event.\n    \"\"\"\n    self.context.shell_menu = models.ShellMenu.model_validate(menu)\n    await self.emit(\"shell_menu\", (self.context.robot_id, menu), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pid","title":"<code>on_pid(sid, pid)</code>  <code>async</code>","text":"<p>Callback on pid message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pid(self, sid, pid: dict[str, Any]):\n    \"\"\"\n    Callback on pid message.\n    \"\"\"\n    await self.emit(\"pid\", pid, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pose_reached","title":"<code>on_pose_reached(sid)</code>  <code>async</code>","text":"<p>Callback on pose reached message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pose_reached(self, sid) -&gt; None:\n    \"\"\"\n    Callback on pose reached message.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] Pose reached.\")\n    await self.emit(\"pose_reached\", namespace=\"/planner\")\n    if self.context.calibration_sid:\n        await self.emit(\"pose_reached\", namespace=\"/calibration\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"copilot\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_reset","title":"<code>on_reset(sid)</code>  <code>async</code>","text":"<p>Callback on reset event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_reset(self, sid) -&gt; None:\n    \"\"\"\n    Callback on reset event.\n    \"\"\"\n    logger.info(\"[copilot =&gt; planner] reset.\")\n    await self.emit(\"reset\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_set_parameter_response","title":"<code>on_set_parameter_response(sid, response)</code>  <code>async</code>","text":"<p>Callback on set_parameter_response message from copilot. Forward to firmware parameter manager.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_set_parameter_response(self, sid, response: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on set_parameter_response message from copilot.\n    Forward to firmware parameter manager.\n    \"\"\"\n    logger.info(f\"[copilot =&gt; parameters] Set response: {response}\")\n    await self.emit(\"set_parameter_response\", response, namespace=\"/parameters\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_state","title":"<code>on_state(sid, state)</code>  <code>async</code>","text":"<p>Callback on state event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_state(self, sid, state):\n    \"\"\"\n    Callback on state event.\n    \"\"\"\n    await self.emit(\"state\", (self.context.robot_id, state), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_telemetry_data","title":"<code>on_telemetry_data(sid, telemetry)</code>  <code>async</code>","text":"<p>Callback on telemetry_data message from copilot. Forward to telemetry clients.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_telemetry_data(self, sid, telemetry: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on telemetry_data message from copilot.\n    Forward to telemetry clients.\n    \"\"\"\n    logger.debug(f\"[copilot =&gt; telemetry] Telemetry Data: {telemetry}\")\n    await self.emit(\"telemetry_data\", telemetry, namespace=\"/telemetry\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace","title":"<code>DashboardNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to dashboards.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>class DashboardNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to dashboards.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/dashboard\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(\"Dashboard connected.\")\n        await self.emit(\"tool_menu\", self.context.tool_menus[self.context.current_tool_menu].model_dump(), to=sid)\n\n        if self.context.shell_menu:\n            await self.emit(\"shell_menu\", (self.context.robot_id, self.context.shell_menu.model_dump()), to=sid)\n\n        if self.context.virtual_planner:\n            await self.emit(\"virtual\", (self.context.robot_id, self.context.virtual), to=sid)\n\n    def on_disconnect(self, sid):\n        logger.info(\"Dashboard disconnected.\")\n\n    async def on_tool_cmd(self, sid, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on tool command message from dashboard.\n        \"\"\"\n        # Find entry in current menu\n        entry = None\n        for entry in self.context.tool_menus[self.context.current_tool_menu].entries:\n            if entry.cmd == cmd:\n                break\n\n        # Check if it corresponds to a menu or a command\n        if entry and entry.cmd in self.context.tool_menus:\n            # Enter a menu\n            self.context.current_tool_menu = cmd\n            await self.emit(\n                \"tool_menu\",\n                self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                namespace=\"/dashboard\",\n            )\n        else:\n            # Forward command to corresponding namespace\n            if cmd == \"exit\":\n                self.context.current_tool_menu = \"root\"\n                await self.emit(\n                    \"tool_menu\",\n                    self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                    namespace=\"/dashboard\",\n                )\n            else:\n                split_ns = self.context.current_tool_menu.split(\"/\")\n                namespace = split_ns.pop(0)\n                logger.info(f\"[dashboard =&gt; {namespace}] Forwarding command: {cmd}\")\n                await self.emit(\"command\", cmd, namespace=f\"/{namespace}\")\n\n    async def on_config_updated(self, sid, config: dict[str, Any]) -&gt; None:\n        namespace = config.pop(\"namespace\")\n        sio_event = config.pop(\"sio_event\")\n        await self.emit(sio_event, config, namespace=namespace)\n\n    async def on_actuators_start(self, sid):\n        \"\"\"\n        Callback on actuators_start message.\n        \"\"\"\n        await self.emit(\"actuators_start\", namespace=\"/copilot\")\n\n    async def on_actuators_stop(self, sid):\n        \"\"\"\n        Callback on actuators_stop message.\n        \"\"\"\n        await self.emit(\"actuators_stop\", namespace=\"/copilot\")\n\n    async def on_actuator_command(self, sid, data):\n        \"\"\"\n        Callback on actuator_command message.\n        \"\"\"\n        await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n\n    async def on_wizard(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        namespace = data.pop(\"namespace\")\n        await self.emit(\"wizard\", data, namespace=namespace)\n        await self.emit(\"close_wizard\")\n\n    async def on_starter_changed(self, sid, pushed: bool):\n        \"\"\"\n        Callback on starter_changed message.\n        \"\"\"\n        logger.info(f\"[dashboard =&gt; planner] Starter changed: {pushed}\")\n        await self.emit(\"starter_changed\", pushed, namespace=\"/planner\")\n        await self.emit(\"starter_changed\", pushed, namespace=\"/dashboard\", skip_sid=[sid])\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuator_command","title":"<code>on_actuator_command(sid, data)</code>  <code>async</code>","text":"<p>Callback on actuator_command message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuator_command(self, sid, data):\n    \"\"\"\n    Callback on actuator_command message.\n    \"\"\"\n    await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuators_start","title":"<code>on_actuators_start(sid)</code>  <code>async</code>","text":"<p>Callback on actuators_start message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuators_start(self, sid):\n    \"\"\"\n    Callback on actuators_start message.\n    \"\"\"\n    await self.emit(\"actuators_start\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuators_stop","title":"<code>on_actuators_stop(sid)</code>  <code>async</code>","text":"<p>Callback on actuators_stop message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuators_stop(self, sid):\n    \"\"\"\n    Callback on actuators_stop message.\n    \"\"\"\n    await self.emit(\"actuators_stop\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_starter_changed","title":"<code>on_starter_changed(sid, pushed)</code>  <code>async</code>","text":"<p>Callback on starter_changed message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_starter_changed(self, sid, pushed: bool):\n    \"\"\"\n    Callback on starter_changed message.\n    \"\"\"\n    logger.info(f\"[dashboard =&gt; planner] Starter changed: {pushed}\")\n    await self.emit(\"starter_changed\", pushed, namespace=\"/planner\")\n    await self.emit(\"starter_changed\", pushed, namespace=\"/dashboard\", skip_sid=[sid])\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_tool_cmd","title":"<code>on_tool_cmd(sid, cmd)</code>  <code>async</code>","text":"<p>Callback on tool command message from dashboard.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_tool_cmd(self, sid, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on tool command message from dashboard.\n    \"\"\"\n    # Find entry in current menu\n    entry = None\n    for entry in self.context.tool_menus[self.context.current_tool_menu].entries:\n        if entry.cmd == cmd:\n            break\n\n    # Check if it corresponds to a menu or a command\n    if entry and entry.cmd in self.context.tool_menus:\n        # Enter a menu\n        self.context.current_tool_menu = cmd\n        await self.emit(\n            \"tool_menu\",\n            self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n            namespace=\"/dashboard\",\n        )\n    else:\n        # Forward command to corresponding namespace\n        if cmd == \"exit\":\n            self.context.current_tool_menu = \"root\"\n            await self.emit(\n                \"tool_menu\",\n                self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                namespace=\"/dashboard\",\n            )\n        else:\n            split_ns = self.context.current_tool_menu.split(\"/\")\n            namespace = split_ns.pop(0)\n            logger.info(f\"[dashboard =&gt; {namespace}] Forwarding command: {cmd}\")\n            await self.emit(\"command\", cmd, namespace=f\"/{namespace}\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_wizard","title":"<code>on_wizard(sid, data)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_wizard(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    namespace = data.pop(\"namespace\")\n    await self.emit(\"wizard\", data, namespace=namespace)\n    await self.emit(\"close_wizard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace","title":"<code>DetectorNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to detector.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>class DetectorNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to detector.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/detector\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        if self.context.detector_sid:\n            message = \"A detector is already connected\"\n            logger.error(f\"Detector connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n\n        self.context.detector_sid = sid\n\n    async def on_connected(self, sid, virtual: bool):\n        logger.info(f\"Detector connected (virtual={virtual}).\")\n        self.context.virtual_detector = virtual\n        if self.context.planner_sid and self.context.monitor_sid and not self.context.robot_added:\n            await self.emit(\n                \"add_robot\",\n                (self.context.robot_id, self.context.virtual_planner, self.context.virtual_detector),\n                namespace=\"/monitor\",\n            )\n            self.context.robot_added = True\n\n    async def on_disconnect(self, sid):\n        self.context.detector_sid = None\n        logger.info(\"Detector disconnected.\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"detector\", data)\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"detector\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_calibration/","title":"firmware_calibration","text":""},{"location":"reference/cogip/tools/server/namespaces/firmware_calibration/#cogip.tools.server.namespaces.firmware_calibration.FirmwareCalibrationNamespace","title":"<code>FirmwareCalibrationNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to firmware calibration clients. Only one client connection is allowed at a time.</p> Source code in <code>cogip/tools/server/namespaces/firmware_calibration.py</code> <pre><code>class FirmwareCalibrationNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to firmware calibration clients.\n    Only one client connection is allowed at a time.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/calibration\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        if self.context.calibration_sid:\n            message = \"A calibration client is already connected\"\n            logger.error(f\"Calibration connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n\n    async def on_connected(self, sid):\n        logger.info(\"Calibration client connected.\")\n        self.context.calibration_sid = sid\n\n    async def on_disconnect(self, sid):\n        self.context.calibration_sid = None\n        logger.info(\"Calibration client disconnected.\")\n\n    async def on_pose_start(self, sid, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose start (reset robot position).\n        Forward to copilot.\n        \"\"\"\n        logger.info(f\"[calibration =&gt; copilot] Pose start: {pose}\")\n        await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n\n    async def on_pose_order(self, sid, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose order.\n        Forward to pose to copilot and dashboards.\n        \"\"\"\n        logger.info(f\"[calibration =&gt; copilot] Pose order: {pose}\")\n        await self.emit(\"pose_order\", pose, namespace=\"/copilot\")\n        await self.emit(\"pose_order\", (self.context.robot_id, pose), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_calibration/#cogip.tools.server.namespaces.firmware_calibration.FirmwareCalibrationNamespace.on_pose_order","title":"<code>on_pose_order(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose order. Forward to pose to copilot and dashboards.</p> Source code in <code>cogip/tools/server/namespaces/firmware_calibration.py</code> <pre><code>async def on_pose_order(self, sid, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose order.\n    Forward to pose to copilot and dashboards.\n    \"\"\"\n    logger.info(f\"[calibration =&gt; copilot] Pose order: {pose}\")\n    await self.emit(\"pose_order\", pose, namespace=\"/copilot\")\n    await self.emit(\"pose_order\", (self.context.robot_id, pose), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_calibration/#cogip.tools.server.namespaces.firmware_calibration.FirmwareCalibrationNamespace.on_pose_start","title":"<code>on_pose_start(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose start (reset robot position). Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/firmware_calibration.py</code> <pre><code>async def on_pose_start(self, sid, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose start (reset robot position).\n    Forward to copilot.\n    \"\"\"\n    logger.info(f\"[calibration =&gt; copilot] Pose start: {pose}\")\n    await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_parameters/","title":"firmware_parameters","text":""},{"location":"reference/cogip/tools/server/namespaces/firmware_parameters/#cogip.tools.server.namespaces.firmware_parameters.FirmwareParametersNamespace","title":"<code>FirmwareParametersNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to firmware parameter clients. Supports multiple simultaneous client connections.</p> Source code in <code>cogip/tools/server/namespaces/firmware_parameters.py</code> <pre><code>class FirmwareParametersNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to firmware parameter clients.\n    Supports multiple simultaneous client connections.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/parameters\")\n        self.cogip_server = cogip_server\n\n    async def on_connect(self, sid, environ):\n        \"\"\"Allow multiple client connections.\"\"\"\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(f\"Parameter client connected: {sid}\")\n\n    async def on_disconnect(self, sid):\n        logger.info(f\"Parameter client disconnected: {sid}\")\n\n    async def on_get_parameter_value(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on get_parameter_value message.\n        Forward to copilot.\n        \"\"\"\n        logger.info(f\"[parameters =&gt; copilot] Get parameter: {data}\")\n        await self.emit(\"get_parameter_value\", data, namespace=\"/copilot\")\n\n    async def on_set_parameter_value(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on set_parameter_value message.\n        Forward to copilot.\n        \"\"\"\n        logger.info(f\"[parameters =&gt; copilot] Set parameter: {data}\")\n        await self.emit(\"set_parameter_value\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_parameters/#cogip.tools.server.namespaces.firmware_parameters.FirmwareParametersNamespace.on_connect","title":"<code>on_connect(sid, environ)</code>  <code>async</code>","text":"<p>Allow multiple client connections.</p> Source code in <code>cogip/tools/server/namespaces/firmware_parameters.py</code> <pre><code>async def on_connect(self, sid, environ):\n    \"\"\"Allow multiple client connections.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_parameters/#cogip.tools.server.namespaces.firmware_parameters.FirmwareParametersNamespace.on_get_parameter_value","title":"<code>on_get_parameter_value(sid, data)</code>  <code>async</code>","text":"<p>Callback on get_parameter_value message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/firmware_parameters.py</code> <pre><code>async def on_get_parameter_value(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on get_parameter_value message.\n    Forward to copilot.\n    \"\"\"\n    logger.info(f\"[parameters =&gt; copilot] Get parameter: {data}\")\n    await self.emit(\"get_parameter_value\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_parameters/#cogip.tools.server.namespaces.firmware_parameters.FirmwareParametersNamespace.on_set_parameter_value","title":"<code>on_set_parameter_value(sid, data)</code>  <code>async</code>","text":"<p>Callback on set_parameter_value message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/firmware_parameters.py</code> <pre><code>async def on_set_parameter_value(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on set_parameter_value message.\n    Forward to copilot.\n    \"\"\"\n    logger.info(f\"[parameters =&gt; copilot] Set parameter: {data}\")\n    await self.emit(\"set_parameter_value\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_telemetry/","title":"firmware_telemetry","text":""},{"location":"reference/cogip/tools/server/namespaces/firmware_telemetry/#cogip.tools.server.namespaces.firmware_telemetry.FirmwareTelemetryNamespace","title":"<code>FirmwareTelemetryNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to firmware telemetry clients. Supports multiple simultaneous client connections.</p> Source code in <code>cogip/tools/server/namespaces/firmware_telemetry.py</code> <pre><code>class FirmwareTelemetryNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to firmware telemetry clients.\n    Supports multiple simultaneous client connections.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/telemetry\")\n        self.cogip_server = cogip_server\n\n    async def on_connect(self, sid, environ):\n        \"\"\"Allow multiple client connections.\"\"\"\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(f\"Telemetry client connected: {sid}\")\n\n    async def on_disconnect(self, sid):\n        logger.info(f\"Telemetry client disconnected: {sid}\")\n\n    async def on_telemetry_enable(self, sid, data: dict[str, Any] | None = None):\n        \"\"\"\n        Callback on telemetry_enable message.\n        Forward to copilot.\n        \"\"\"\n        logger.info(\"[telemetry =&gt; copilot] Telemetry enable\")\n        await self.emit(\"telemetry_enable\", data or {}, namespace=\"/copilot\")\n\n    async def on_telemetry_disable(self, sid, data: dict[str, Any] | None = None):\n        \"\"\"\n        Callback on telemetry_disable message.\n        Forward to copilot.\n        \"\"\"\n        logger.info(\"[telemetry =&gt; copilot] Telemetry disable\")\n        await self.emit(\"telemetry_disable\", data or {}, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_telemetry/#cogip.tools.server.namespaces.firmware_telemetry.FirmwareTelemetryNamespace.on_connect","title":"<code>on_connect(sid, environ)</code>  <code>async</code>","text":"<p>Allow multiple client connections.</p> Source code in <code>cogip/tools/server/namespaces/firmware_telemetry.py</code> <pre><code>async def on_connect(self, sid, environ):\n    \"\"\"Allow multiple client connections.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_telemetry/#cogip.tools.server.namespaces.firmware_telemetry.FirmwareTelemetryNamespace.on_telemetry_disable","title":"<code>on_telemetry_disable(sid, data=None)</code>  <code>async</code>","text":"<p>Callback on telemetry_disable message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/firmware_telemetry.py</code> <pre><code>async def on_telemetry_disable(self, sid, data: dict[str, Any] | None = None):\n    \"\"\"\n    Callback on telemetry_disable message.\n    Forward to copilot.\n    \"\"\"\n    logger.info(\"[telemetry =&gt; copilot] Telemetry disable\")\n    await self.emit(\"telemetry_disable\", data or {}, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/firmware_telemetry/#cogip.tools.server.namespaces.firmware_telemetry.FirmwareTelemetryNamespace.on_telemetry_enable","title":"<code>on_telemetry_enable(sid, data=None)</code>  <code>async</code>","text":"<p>Callback on telemetry_enable message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/firmware_telemetry.py</code> <pre><code>async def on_telemetry_enable(self, sid, data: dict[str, Any] | None = None):\n    \"\"\"\n    Callback on telemetry_enable message.\n    Forward to copilot.\n    \"\"\"\n    logger.info(\"[telemetry =&gt; copilot] Telemetry enable\")\n    await self.emit(\"telemetry_enable\", data or {}, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/monitor/","title":"monitor","text":""},{"location":"reference/cogip/tools/server/namespaces/monitor/#cogip.tools.server.namespaces.monitor.MonitorNamespace","title":"<code>MonitorNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to monitor.</p> Source code in <code>cogip/tools/server/namespaces/monitor.py</code> <pre><code>class MonitorNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to monitor.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/monitor\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.monitor_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.monitor_sid:\n            message = \"A monitor is already connected\"\n            logger.error(f\"Monitor connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.monitor_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Monitor connected.\")\n        if self.context.planner_sid and self.context.detector_sid and not self.context.robot_added:\n            await self.emit(\n                \"add_robot\",\n                (self.context.robot_id, self.context.virtual_planner, self.context.virtual_detector),\n                namespace=\"/monitor\",\n            )\n            self.context.robot_added = True\n\n    def on_disconnect(self, sid):\n        self.context.monitor_sid = None\n        self.context.robot_added = False\n        logger.info(\"Monitor disconnected.\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/","title":"planner","text":""},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace","title":"<code>PlannerNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to planner.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>class PlannerNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to planner.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/planner\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.connected = False\n        self.context.planner_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.planner_sid:\n            logger.error(\"Planner connection refused: a planner is already connected\")\n            raise ConnectionRefusedError(\"A planner is already connected\")\n\n    async def on_connected(self, sid, virtual: bool):\n        logger.info(f\"Planner connected (virtual={virtual}).\")\n        self.context.planner_sid = sid\n        self.context.virtual_planner = virtual\n        if self.context.copilot_sid:\n            await self.emit(\"copilot_connected\", namespace=\"/planner\")\n        if self.context.monitor_sid and self.context.detector_sid and not self.context.robot_added:\n            await self.emit(\n                \"add_robot\",\n                (self.context.robot_id, self.context.virtual_planner, self.context.virtual_detector),\n                namespace=\"/monitor\",\n            )\n            self.context.robot_added = True\n\n    def on_disconnect(self, sid):\n        self.context.planner_sid = None\n        logger.info(\"Planner disconnected.\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"planner\", data)\n\n    async def on_pose_start(self, sid, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose start.\n        Forward to pose to copilot.\n        \"\"\"\n        logger.info(f\"[planner =&gt; copilot] Pose start: {pose}\")\n        await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n\n    async def on_wizard(self, sid, message: list[dict[str, Any]]):\n        \"\"\"\n        Callback on wizard message.\n        Forward to dashboard.\n        \"\"\"\n        message[\"namespace\"] = \"/planner\"\n        await self.emit(\"wizard\", message, namespace=\"/dashboard\")\n\n    async def on_set_controller(self, sid, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to copilot.\n        \"\"\"\n        await self.emit(\"set_controller\", controller, namespace=\"/copilot\")\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n\n    async def on_cmd_reset(self, sid):\n        \"\"\"\n        Callback on cmd_reset message.\n        \"\"\"\n        await self.emit(\"cmd_reset\", namespace=\"/monitor\")\n\n    async def on_starter_changed(self, sid, pushed: bool):\n        \"\"\"\n        Callback on starter_pushed message.\n        \"\"\"\n        await self.emit(\"starter_changed\", pushed, namespace=\"/dashboard\")\n\n    async def on_close_wizard(self, sid):\n        \"\"\"\n        Callback on close_wizard message.\n        \"\"\"\n        await self.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n    async def on_game_start(self, sid):\n        \"\"\"\n        Callback on game_start message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Game started.\")\n        await self.emit(\"game_start\", namespace=\"/copilot\")\n\n    async def on_game_end(self, sid):\n        \"\"\"\n        Callback on game_end message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Game ended.\")\n        await self.emit(\"game_end\", namespace=\"/copilot\")\n\n    async def on_robot_end(self, sid):\n        \"\"\"\n        Callback on robot_end message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Robot ended.\")\n        await self.emit(\"game_end\", namespace=\"/copilot\")\n\n    async def on_game_reset(self, sid):\n        \"\"\"\n        Callback on game_reset message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Game reset.\")\n        await self.emit(\"game_reset\", namespace=\"/copilot\")\n\n    async def on_score(self, sid, score: int):\n        \"\"\"\n        Callback on score message.\n        \"\"\"\n        await self.emit(\"score\", score, namespace=\"/dashboard\")\n\n    async def on_start_countdown(self, sid, robot_id: int, countdown: int, timestamp: str, color: str | None):\n        \"\"\"\n        Callback on start_countdown message.\n        \"\"\"\n        logger.info(f\"[planner =&gt; beacon] Start countdown: {countdown}.\")\n        await self.emit(\"start_countdown\", (robot_id, countdown, timestamp, color), namespace=\"/beacon\")\n\n    async def on_actuator_command(self, sid, data):\n        \"\"\"\n        Callback on actuator_command message.\n        \"\"\"\n        logger.info(f\"[planner =&gt; copilot] Actuator command: {data}\")\n        await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n\n    async def on_actuator_init(self, sid):\n        \"\"\"\n        Callback on actuator_init message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Actuator init.\")\n        await self.emit(\"actuator_init\", namespace=\"/copilot\")\n\n    async def on_start_video_record(self, sid):\n        \"\"\"\n        Callback on start_video_record message.\n        \"\"\"\n        await self.emit(\"start_video_record\", namespace=\"/robotcam\")\n\n    async def on_stop_video_record(self, sid):\n        \"\"\"\n        Callback on stop_video_record message.\n        \"\"\"\n        await self.emit(\"stop_video_record\", namespace=\"/robotcam\")\n\n    async def on_brake(self, sid):\n        \"\"\"\n        Callback on brake message.\n        \"\"\"\n        logger.info(\"[planner =&gt; copilot] Brake.\")\n        await self.emit(\"brake\", namespace=\"/copilot\")\n\n    async def on_pami_reset(self, sid):\n        \"\"\"\n        Callback on pami_reset message.\n        \"\"\"\n        logger.info(\"[planner =&gt; beacon] PAMI reset.\")\n        await self.emit(\"pami_reset\", namespace=\"/beacon\")\n\n    async def on_pami_camp(self, sid, data):\n        \"\"\"\n        Callback on pami_camp message.\n        \"\"\"\n        await self.emit(\"pami_camp\", data, namespace=\"/beacon\")\n\n    async def on_pami_table(self, sid, data):\n        \"\"\"\n        Callback on pami_table message.\n        \"\"\"\n        await self.emit(\"pami_table\", data, namespace=\"/beacon\")\n\n    async def on_pami_play(self, sid, timestamp: str):\n        \"\"\"\n        Callback on pami_play message.\n        \"\"\"\n        logger.info(\"[planner =&gt; beacon] PAMI play.\")\n        await self.emit(\"pami_play\", timestamp, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_actuator_command","title":"<code>on_actuator_command(sid, data)</code>  <code>async</code>","text":"<p>Callback on actuator_command message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_actuator_command(self, sid, data):\n    \"\"\"\n    Callback on actuator_command message.\n    \"\"\"\n    logger.info(f\"[planner =&gt; copilot] Actuator command: {data}\")\n    await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_actuator_init","title":"<code>on_actuator_init(sid)</code>  <code>async</code>","text":"<p>Callback on actuator_init message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_actuator_init(self, sid):\n    \"\"\"\n    Callback on actuator_init message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Actuator init.\")\n    await self.emit(\"actuator_init\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_brake","title":"<code>on_brake(sid)</code>  <code>async</code>","text":"<p>Callback on brake message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_brake(self, sid):\n    \"\"\"\n    Callback on brake message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Brake.\")\n    await self.emit(\"brake\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_close_wizard","title":"<code>on_close_wizard(sid)</code>  <code>async</code>","text":"<p>Callback on close_wizard message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_close_wizard(self, sid):\n    \"\"\"\n    Callback on close_wizard message.\n    \"\"\"\n    await self.emit(\"close_wizard\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_cmd_reset","title":"<code>on_cmd_reset(sid)</code>  <code>async</code>","text":"<p>Callback on cmd_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_cmd_reset(self, sid):\n    \"\"\"\n    Callback on cmd_reset message.\n    \"\"\"\n    await self.emit(\"cmd_reset\", namespace=\"/monitor\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_end","title":"<code>on_game_end(sid)</code>  <code>async</code>","text":"<p>Callback on game_end message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_end(self, sid):\n    \"\"\"\n    Callback on game_end message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Game ended.\")\n    await self.emit(\"game_end\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_reset","title":"<code>on_game_reset(sid)</code>  <code>async</code>","text":"<p>Callback on game_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_reset(self, sid):\n    \"\"\"\n    Callback on game_reset message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Game reset.\")\n    await self.emit(\"game_reset\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_start","title":"<code>on_game_start(sid)</code>  <code>async</code>","text":"<p>Callback on game_start message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_start(self, sid):\n    \"\"\"\n    Callback on game_start message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Game started.\")\n    await self.emit(\"game_start\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_camp","title":"<code>on_pami_camp(sid, data)</code>  <code>async</code>","text":"<p>Callback on pami_camp message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_camp(self, sid, data):\n    \"\"\"\n    Callback on pami_camp message.\n    \"\"\"\n    await self.emit(\"pami_camp\", data, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_play","title":"<code>on_pami_play(sid, timestamp)</code>  <code>async</code>","text":"<p>Callback on pami_play message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_play(self, sid, timestamp: str):\n    \"\"\"\n    Callback on pami_play message.\n    \"\"\"\n    logger.info(\"[planner =&gt; beacon] PAMI play.\")\n    await self.emit(\"pami_play\", timestamp, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_reset","title":"<code>on_pami_reset(sid)</code>  <code>async</code>","text":"<p>Callback on pami_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_reset(self, sid):\n    \"\"\"\n    Callback on pami_reset message.\n    \"\"\"\n    logger.info(\"[planner =&gt; beacon] PAMI reset.\")\n    await self.emit(\"pami_reset\", namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_table","title":"<code>on_pami_table(sid, data)</code>  <code>async</code>","text":"<p>Callback on pami_table message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_table(self, sid, data):\n    \"\"\"\n    Callback on pami_table message.\n    \"\"\"\n    await self.emit(\"pami_table\", data, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pose_start","title":"<code>on_pose_start(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose start. Forward to pose to copilot.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pose_start(self, sid, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose start.\n    Forward to pose to copilot.\n    \"\"\"\n    logger.info(f\"[planner =&gt; copilot] Pose start: {pose}\")\n    await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"planner\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_robot_end","title":"<code>on_robot_end(sid)</code>  <code>async</code>","text":"<p>Callback on robot_end message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_robot_end(self, sid):\n    \"\"\"\n    Callback on robot_end message.\n    \"\"\"\n    logger.info(\"[planner =&gt; copilot] Robot ended.\")\n    await self.emit(\"game_end\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_score","title":"<code>on_score(sid, score)</code>  <code>async</code>","text":"<p>Callback on score message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_score(self, sid, score: int):\n    \"\"\"\n    Callback on score message.\n    \"\"\"\n    await self.emit(\"score\", score, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_set_controller","title":"<code>on_set_controller(sid, controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_set_controller(self, sid, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to copilot.\n    \"\"\"\n    await self.emit(\"set_controller\", controller, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_start_countdown","title":"<code>on_start_countdown(sid, robot_id, countdown, timestamp, color)</code>  <code>async</code>","text":"<p>Callback on start_countdown message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_start_countdown(self, sid, robot_id: int, countdown: int, timestamp: str, color: str | None):\n    \"\"\"\n    Callback on start_countdown message.\n    \"\"\"\n    logger.info(f\"[planner =&gt; beacon] Start countdown: {countdown}.\")\n    await self.emit(\"start_countdown\", (robot_id, countdown, timestamp, color), namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_start_video_record","title":"<code>on_start_video_record(sid)</code>  <code>async</code>","text":"<p>Callback on start_video_record message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_start_video_record(self, sid):\n    \"\"\"\n    Callback on start_video_record message.\n    \"\"\"\n    await self.emit(\"start_video_record\", namespace=\"/robotcam\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_starter_changed","title":"<code>on_starter_changed(sid, pushed)</code>  <code>async</code>","text":"<p>Callback on starter_pushed message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_starter_changed(self, sid, pushed: bool):\n    \"\"\"\n    Callback on starter_pushed message.\n    \"\"\"\n    await self.emit(\"starter_changed\", pushed, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_stop_video_record","title":"<code>on_stop_video_record(sid)</code>  <code>async</code>","text":"<p>Callback on stop_video_record message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_stop_video_record(self, sid):\n    \"\"\"\n    Callback on stop_video_record message.\n    \"\"\"\n    await self.emit(\"stop_video_record\", namespace=\"/robotcam\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_wizard","title":"<code>on_wizard(sid, message)</code>  <code>async</code>","text":"<p>Callback on wizard message. Forward to dashboard.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_wizard(self, sid, message: list[dict[str, Any]]):\n    \"\"\"\n    Callback on wizard message.\n    Forward to dashboard.\n    \"\"\"\n    message[\"namespace\"] = \"/planner\"\n    await self.emit(\"wizard\", message, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/robotcam/","title":"robotcam","text":""},{"location":"reference/cogip/tools/server/namespaces/robotcam/#cogip.tools.server.namespaces.robotcam.RobotcamNamespace","title":"<code>RobotcamNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to robotcam.</p> Source code in <code>cogip/tools/server/namespaces/robotcam.py</code> <pre><code>class RobotcamNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to robotcam.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/robotcam\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.robotcam_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.robotcam_sid:\n            message = \"A robotcam is already connected\"\n            logger.error(f\"Robotcam connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.robotcam_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Robotcam connected.\")\n\n    def on_disconnect(self, sid):\n        self.context.robotcam_sid = None\n        logger.info(\"Robotcam disconnected.\")\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/server_beacon/__main__/#cogip.tools.server_beacon.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SocketIO beacon server.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-server-beacon</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/server_beacon/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SocketIO beacon server.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-server-beacon` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/app/","title":"app","text":""},{"location":"reference/cogip/tools/server_beacon/app/#cogip.tools.server_beacon.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return ASGIApp application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/server_beacon/app.py</code> <pre><code>def create_app() -&gt; ASGIApp:\n    \"\"\"\n    Create server and return ASGIApp application for uvicorn/gunicorn.\n    \"\"\"\n    server = Server()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/server_beacon/robot/","title":"robot","text":""},{"location":"reference/cogip/tools/server_beacon/server/","title":"server","text":""},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server","title":"<code>Server</code>","text":"Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>class Server:\n    original_uvicorn_exit_handler = UvicornServer.handle_exit\n    exiting: bool = False\n    robots: dict[int, Robot] = {}\n    robot_tasks: set[asyncio.Task] = set()\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO server and robot servers connections\n        \"\"\"\n        UvicornServer.handle_exit = Server.handle_exit\n\n        self.sio = socketio.AsyncServer(\n            always_connect=False,\n            async_mode=\"asgi\",\n            cors_allowed_origins=\"*\",\n            logger=False,\n            engineio_logger=False,\n        )\n        self.app = socketio.ASGIApp(self.sio)\n        self.sio.register_namespace(namespaces.DashboardNamespace(self))\n\n        self.camp = Camp.Colors.blue\n        self.table = TableEnum.Game\n\n        for i in range(1, int(os.environ[\"SERVER_BEACON_MAX_ROBOTS\"]) + 1):\n            robot = Robot(self, i)\n            task = asyncio.create_task(robot.run())\n            Server.robots[i] = robot\n            Server.robot_tasks.add(task)\n            task.add_done_callback(Server.robot_tasks.discard)\n\n        @self.sio.event\n        def connect(sid, environ, auth):\n            logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n            raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n        @self.sio.on(\"*\")\n        def catch_all(event, sid, data):\n            logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Server.exiting = True\n        for _, robot in Server.robots.items():\n            robot.exiting = True\n            robot.sio.reconnection_attempts = -1\n        for task in Server.robot_tasks:\n            task.cancel()\n\n        Server.original_uvicorn_exit_handler(*args, **kwargs)\n\n    async def choose_camp(self):\n        \"\"\"\n        Choose camp command from the menu.\n        Send camp wizard message.\n        \"\"\"\n        await self.sio.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Camp\",\n                \"type\": \"camp\",\n                \"value\": self.camp.name,\n            },\n            namespace=\"/dashboard\",\n        )\n\n    async def choose_table(self):\n        \"\"\"\n        Choose table command from the menu.\n        Send table wizard message.\n        \"\"\"\n        await self.sio.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Table\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in TableEnum],\n                \"value\": self.table.name,\n            },\n            namespace=\"/dashboard\",\n        )\n\n    async def reset_robots(self):\n        for robot_id, robot in self.robots.items():\n            if robot.sio.connected:\n                position: StartPositionEnum | None = None\n                match robot_id:\n                    case 1:\n                        position = StartPositionEnum.Bottom\n                    case 2:\n                        position = StartPositionEnum.PAMI2\n                    case 3:\n                        position = StartPositionEnum.PAMI3\n                    case 4:\n                        position = StartPositionEnum.PAMI4\n                    case 5:\n                        position = StartPositionEnum.PAMI5\n                if position:\n                    await robot.sio.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Choose Start Position\",\n                            \"value\": position.name,\n                        },\n                        namespace=\"/beacon\",\n                    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO server and robot servers connections</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO server and robot servers connections\n    \"\"\"\n    UvicornServer.handle_exit = Server.handle_exit\n\n    self.sio = socketio.AsyncServer(\n        always_connect=False,\n        async_mode=\"asgi\",\n        cors_allowed_origins=\"*\",\n        logger=False,\n        engineio_logger=False,\n    )\n    self.app = socketio.ASGIApp(self.sio)\n    self.sio.register_namespace(namespaces.DashboardNamespace(self))\n\n    self.camp = Camp.Colors.blue\n    self.table = TableEnum.Game\n\n    for i in range(1, int(os.environ[\"SERVER_BEACON_MAX_ROBOTS\"]) + 1):\n        robot = Robot(self, i)\n        task = asyncio.create_task(robot.run())\n        Server.robots[i] = robot\n        Server.robot_tasks.add(task)\n        task.add_done_callback(Server.robot_tasks.discard)\n\n    @self.sio.event\n    def connect(sid, environ, auth):\n        logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n        raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n    @self.sio.on(\"*\")\n    def catch_all(event, sid, data):\n        logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.choose_camp","title":"<code>choose_camp()</code>  <code>async</code>","text":"<p>Choose camp command from the menu. Send camp wizard message.</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>async def choose_camp(self):\n    \"\"\"\n    Choose camp command from the menu.\n    Send camp wizard message.\n    \"\"\"\n    await self.sio.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Camp\",\n            \"type\": \"camp\",\n            \"value\": self.camp.name,\n        },\n        namespace=\"/dashboard\",\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.choose_table","title":"<code>choose_table()</code>  <code>async</code>","text":"<p>Choose table command from the menu. Send table wizard message.</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>async def choose_table(self):\n    \"\"\"\n    Choose table command from the menu.\n    Send table wizard message.\n    \"\"\"\n    await self.sio.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Table\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in TableEnum],\n            \"value\": self.table.name,\n        },\n        namespace=\"/dashboard\",\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Server.exiting = True\n    for _, robot in Server.robots.items():\n        robot.exiting = True\n        robot.sio.reconnection_attempts = -1\n    for task in Server.robot_tasks:\n        task.cancel()\n\n    Server.original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/#cogip.tools.server_beacon.namespaces.dashboard.DashboardNamespace","title":"<code>DashboardNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to Beacon dashboard.</p> Source code in <code>cogip/tools/server_beacon/namespaces/dashboard.py</code> <pre><code>class DashboardNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to Beacon dashboard.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/dashboard\")\n        self.cogip_server = cogip_server\n\n    def on_connect(self, sid, environ):\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(\"Dashboard connected.\")\n        for robot_id, robot in self.cogip_server.robots.items():\n            if robot.sio.connected:\n                await self.cogip_server.sio.emit(\"add_robot\", robot_id, namespace=\"/dashboard\")\n        await self.emit(\n            \"tool_menu\",\n            menu.model_dump(),\n            namespace=\"/dashboard\",\n        )\n\n    def on_disconnect(self, sid):\n        logger.info(\"Dashboard disconnected.\")\n\n    async def on_tool_cmd(self, sid, cmd: str):\n        match cmd:\n            case \"choose_camp\":\n                await self.cogip_server.choose_camp()\n            case \"choose_table\":\n                await self.cogip_server.choose_table()\n            case \"reset\":\n                await self.cogip_server.reset_robots()\n            case \"start\":\n                for _, robot in self.cogip_server.robots.items():\n                    if robot.sio.connected:\n                        await robot.sio.emit(\"command\", \"play\", namespace=\"/beacon\")\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_wizard(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        for _, robot in self.cogip_server.robots.items():\n            if robot.sio.connected:\n                await robot.sio.emit(\"wizard\", data, namespace=\"/beacon\")\n        await self.cogip_server.sio.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n        match data.get(\"name\"):\n            case \"Choose Camp\":\n                self.cogip_server.camp = Camp.Colors[data[\"value\"]]\n            case \"Choose Table\":\n                self.cogip_server.table = TableEnum[data[\"value\"]]\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/#cogip.tools.server_beacon.namespaces.dashboard.DashboardNamespace.on_wizard","title":"<code>on_wizard(sid, data)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server_beacon/namespaces/dashboard.py</code> <pre><code>async def on_wizard(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    for _, robot in self.cogip_server.robots.items():\n        if robot.sio.connected:\n            await robot.sio.emit(\"wizard\", data, namespace=\"/beacon\")\n    await self.cogip_server.sio.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n    match data.get(\"name\"):\n        case \"Choose Camp\":\n            self.cogip_server.camp = Camp.Colors[data[\"value\"]]\n        case \"Choose Table\":\n            self.cogip_server.table = TableEnum[data[\"value\"]]\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/ydlidar_g2/__main__/#cogip.tools.ydlidar_g2.__main__.main","title":"<code>main()</code>","text":"<p>Tool demonstrating usage of ydlidar_g2 C++ driver.</p> <p>During installation of cogip-tools, a script called <code>cogip-ydlidar-g2</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/ydlidar_g2/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Tool demonstrating usage of ydlidar_g2 C++ driver.\n\n    During installation of cogip-tools, a script called `cogip-ydlidar-g2`\n    will be created using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/","title":"gui","text":""},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker","title":"<code>LidarObstacleTracker</code>","text":"Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>class LidarObstacleTracker:\n    def __init__(\n        self,\n        lidar_coords: NDArray,\n        lidar_offset: tuple[float, float],\n        eps: float = 30.0,\n        min_samples: int = 6,\n        update_interval: int = 100,\n    ):\n        \"\"\"\n        Initialize the real-time Lidar obstacle tracker\n\n        Args:\n            lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n            lidar_offset: Lidar offset from robot center\n            eps: DBSCAN clustering parameter\n            min_samples: Minimum points for cluster formation\n            update_interval: Visualization update interval\n        \"\"\"\n        # Use default pose if not provided\n        self.lidar_coords = lidar_coords\n        self.lidar_offset = lidar_offset\n        self.eps = eps\n        self.min_samples = min_samples\n        self.update_interval = update_interval\n        self.view_radius = 2500\n        self.clusters: list[NDArray] = []\n        self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n        # Initialize plot and data containers\n        self.fig, self.ax = plt.subplots(figsize=(10, 10))\n        self.setup_plot()\n\n        # Connect the scroll event to the handler\n        self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n        # Visualization elements\n        self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n        self.cluster_scatters: list[PathCollection] = []\n        self.obstacle_circles: list[Ellipse] = []\n\n        # Robot and Lidar markers\n        self.robot_marker = self.ax.scatter(\n            0,\n            0,\n            c=\"red\",\n            s=100,\n            marker=\"*\",\n            label=\"Robot\",\n        )\n\n        # Calculate Lidar position\n        self.lidar_marker = self.ax.scatter(\n            self.lidar_offset[1],\n            self.lidar_offset[0],\n            c=\"blue\",\n            s=80,\n            marker=\"o\",\n            label=\"Lidar\",\n        )\n\n        # Animation setup\n        self.animation: FuncAnimation | None = None\n\n    def setup_plot(self):\n        \"\"\"Configure the plot appearance with dark theme\"\"\"\n        # Set figure and axes background color\n        self.fig.patch.set_facecolor(\"#2E2E2E\")\n        self.ax.set_facecolor(\"#1E1E1E\")\n\n        # Set labels and title with light colors\n        self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n        self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n        self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n        # Customize grid\n        self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n        # Customize axis appearance\n        self.ax.spines[\"bottom\"].set_color(\"#555555\")\n        self.ax.spines[\"top\"].set_color(\"#555555\")\n        self.ax.spines[\"left\"].set_color(\"#555555\")\n        self.ax.spines[\"right\"].set_color(\"#555555\")\n\n        # Customize tick parameters\n        self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n        # Invert x-axis and set equal aspect ratio\n        self.ax.invert_xaxis()\n        self.ax.axis(\"equal\")\n\n        # Configure legend with dark theme colors\n        self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n        # Set initial view range\n        self.ax.set_xlim((self.view_radius, -self.view_radius))\n        self.ax.set_ylim((-self.view_radius, self.view_radius))\n\n    def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n        \"\"\"\n        Groups points into obstacle clusters using DBSCAN\n\n        Args:\n            points: NDArray of (x, y) points representing detected obstacles\n\n        Returns:\n            List of clusters, each cluster being a set of points belonging to the same obstacle\n        \"\"\"\n        if len(points) == 0:\n            return []\n\n        db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n        labels = db.labels_\n\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n        clusters = []\n        for i in range(n_clusters):\n            cluster_points = points[labels == i]\n            clusters.append(cluster_points)\n\n        return clusters\n\n    def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n        \"\"\"\n        Estimates position and size of obstacles from clusters\n\n        Args:\n            clusters: List of clusters, each cluster being a set of points\n\n        Returns:\n            List of tuples (center_x, center_y, radius) for each obstacle\n        \"\"\"\n        obstacle_properties = []\n\n        for cluster in clusters:\n            center_x = np.mean(cluster[:, 0])\n            center_y = np.mean(cluster[:, 1])\n\n            # Calculate the maximum distance from center in x and y directions\n            # This will be used as the radius of the circle\n            radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n            radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n            radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n            obstacle_properties.append((center_x, center_y, radius))\n\n        return obstacle_properties\n\n    def update_plot(self, frame):\n        \"\"\"Updates the visualization with current data\"\"\"\n        lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n        self.clusters = self.cluster_obstacles(lidar_coords)\n        self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n        # Update points scatter\n        self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n        # Clear previous cluster scatters and obstacle visualizations\n        for scatter in self.cluster_scatters:\n            scatter.remove()\n        self.cluster_scatters = []\n\n        for circle in self.obstacle_circles:\n            circle.remove()\n        self.obstacle_circles = []\n\n        # Create color map for clusters that works well with dark theme\n        colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n        # Draw new clusters\n        for i, cluster in enumerate(self.clusters):\n            scatter = self.ax.scatter(\n                cluster[:, 1],\n                cluster[:, 0],\n                c=[colors[i]],\n                s=20,\n                label=f\"Cluster {i}\" if i == 0 else \"\",\n            )\n            self.cluster_scatters.append(scatter)\n\n        # Draw obstacle circles and labels\n        for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n            # Create ellipse for the obstacle\n            circle = Ellipse(\n                (center_y, center_x),\n                width=radius * 2,\n                height=radius * 2,\n                fill=False,\n                edgecolor=colors[i],\n                linewidth=2,\n                alpha=0.8,\n            )\n            self.ax.add_patch(circle)\n            self.obstacle_circles.append(circle)\n\n        # Redraw the figure\n        self.fig.canvas.draw_idle()\n\n    def start_animation(self):\n        \"\"\"Starts the real-time visualization\"\"\"\n        # Set dark theme for the color map (for clusters)\n        plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n        # Continue with original animation code\n        self.animation = FuncAnimation(\n            self.fig,\n            self.update_plot,\n            interval=self.update_interval,\n            blit=False,\n            cache_frame_data=False,\n        )\n\n    def on_scroll(self, event: MouseEvent):\n        # Ignore if the mouse is not over the axes\n        if event.inaxes != self.ax:\n            return\n\n        # Get the current limits\n        xlim = self.ax.get_xlim()\n        ylim = self.ax.get_ylim()\n\n        # Get mouse position in data coordinates\n        x_data, y_data = event.xdata, event.ydata\n\n        # Calculate zoom factor\n        zoom_factor = 1.1 if event.button == \"down\" else 0.9  # Zoom in/out\n\n        # Calculate new limits maintaining the mouse position as center\n        x_left = x_data - zoom_factor * (x_data - xlim[0])\n        x_right = x_data + zoom_factor * (xlim[1] - x_data)\n        y_bottom = y_data - zoom_factor * (y_data - ylim[0])\n        y_top = y_data + zoom_factor * (ylim[1] - y_data)\n\n        # Limit the zoom range\n        x_left = max(-self.view_radius, x_left)\n        x_right = min(self.view_radius, x_right)\n        y_bottom = max(-self.view_radius, y_bottom)\n        y_top = min(self.view_radius, y_top)\n\n        # Apply the new limits\n        self.ax.set_xlim(x_left, x_right)\n        self.ax.set_ylim(y_bottom, y_top)\n\n        # Redraw the plot\n        plt.draw()\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.__init__","title":"<code>__init__(lidar_coords, lidar_offset, eps=30.0, min_samples=6, update_interval=100)</code>","text":"<p>Initialize the real-time Lidar obstacle tracker</p> <p>Parameters:</p> Name Type Description Default <code>lidar_coords</code> <code>NDArray</code> <p>2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates</p> required <code>lidar_offset</code> <code>tuple[float, float]</code> <p>Lidar offset from robot center</p> required <code>eps</code> <code>float</code> <p>DBSCAN clustering parameter</p> <code>30.0</code> <code>min_samples</code> <code>int</code> <p>Minimum points for cluster formation</p> <code>6</code> <code>update_interval</code> <code>int</code> <p>Visualization update interval</p> <code>100</code> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def __init__(\n    self,\n    lidar_coords: NDArray,\n    lidar_offset: tuple[float, float],\n    eps: float = 30.0,\n    min_samples: int = 6,\n    update_interval: int = 100,\n):\n    \"\"\"\n    Initialize the real-time Lidar obstacle tracker\n\n    Args:\n        lidar_coords: 2D NDArray with shape (MAX_LIDAR_DATA_COUNT, 2) containing x and y global coordinates\n        lidar_offset: Lidar offset from robot center\n        eps: DBSCAN clustering parameter\n        min_samples: Minimum points for cluster formation\n        update_interval: Visualization update interval\n    \"\"\"\n    # Use default pose if not provided\n    self.lidar_coords = lidar_coords\n    self.lidar_offset = lidar_offset\n    self.eps = eps\n    self.min_samples = min_samples\n    self.update_interval = update_interval\n    self.view_radius = 2500\n    self.clusters: list[NDArray] = []\n    self.obstacle_properties: list[tuple[float, float, float, float]] = []\n\n    # Initialize plot and data containers\n    self.fig, self.ax = plt.subplots(figsize=(10, 10))\n    self.setup_plot()\n\n    # Connect the scroll event to the handler\n    self.fig.canvas.mpl_connect(\"scroll_event\", self.on_scroll)\n\n    # Visualization elements\n    self.points_scatter = self.ax.scatter([], [], c=\"gray\", s=5, label=\"Detected Points\")\n    self.cluster_scatters: list[PathCollection] = []\n    self.obstacle_circles: list[Ellipse] = []\n\n    # Robot and Lidar markers\n    self.robot_marker = self.ax.scatter(\n        0,\n        0,\n        c=\"red\",\n        s=100,\n        marker=\"*\",\n        label=\"Robot\",\n    )\n\n    # Calculate Lidar position\n    self.lidar_marker = self.ax.scatter(\n        self.lidar_offset[1],\n        self.lidar_offset[0],\n        c=\"blue\",\n        s=80,\n        marker=\"o\",\n        label=\"Lidar\",\n    )\n\n    # Animation setup\n    self.animation: FuncAnimation | None = None\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.cluster_obstacles","title":"<code>cluster_obstacles(points)</code>","text":"<p>Groups points into obstacle clusters using DBSCAN</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray</code> <p>NDArray of (x, y) points representing detected obstacles</p> required <p>Returns:</p> Type Description <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points belonging to the same obstacle</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def cluster_obstacles(self, points: NDArray) -&gt; list[NDArray]:\n    \"\"\"\n    Groups points into obstacle clusters using DBSCAN\n\n    Args:\n        points: NDArray of (x, y) points representing detected obstacles\n\n    Returns:\n        List of clusters, each cluster being a set of points belonging to the same obstacle\n    \"\"\"\n    if len(points) == 0:\n        return []\n\n    db = DBSCAN(eps=self.eps, min_samples=self.min_samples).fit(points)\n    labels = db.labels_\n\n    n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n\n    clusters = []\n    for i in range(n_clusters):\n        cluster_points = points[labels == i]\n        clusters.append(cluster_points)\n\n    return clusters\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.estimate_obstacle_properties","title":"<code>estimate_obstacle_properties(clusters)</code>","text":"<p>Estimates position and size of obstacles from clusters</p> <p>Parameters:</p> Name Type Description Default <code>clusters</code> <code>list[NDArray]</code> <p>List of clusters, each cluster being a set of points</p> required <p>Returns:</p> Type Description <code>list[tuple[float, float, float]]</code> <p>List of tuples (center_x, center_y, radius) for each obstacle</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def estimate_obstacle_properties(self, clusters: list[NDArray]) -&gt; list[tuple[float, float, float]]:\n    \"\"\"\n    Estimates position and size of obstacles from clusters\n\n    Args:\n        clusters: List of clusters, each cluster being a set of points\n\n    Returns:\n        List of tuples (center_x, center_y, radius) for each obstacle\n    \"\"\"\n    obstacle_properties = []\n\n    for cluster in clusters:\n        center_x = np.mean(cluster[:, 0])\n        center_y = np.mean(cluster[:, 1])\n\n        # Calculate the maximum distance from center in x and y directions\n        # This will be used as the radius of the circle\n        radius_x = np.max(np.abs(cluster[:, 0] - center_x))\n        radius_y = np.max(np.abs(cluster[:, 1] - center_y))\n        radius = max(radius_x, radius_y, 20)  # Minimum radius of 20\n\n        obstacle_properties.append((center_x, center_y, radius))\n\n    return obstacle_properties\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.setup_plot","title":"<code>setup_plot()</code>","text":"<p>Configure the plot appearance with dark theme</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def setup_plot(self):\n    \"\"\"Configure the plot appearance with dark theme\"\"\"\n    # Set figure and axes background color\n    self.fig.patch.set_facecolor(\"#2E2E2E\")\n    self.ax.set_facecolor(\"#1E1E1E\")\n\n    # Set labels and title with light colors\n    self.ax.set_xlabel(\"Y (mm)\", color=\"#CCCCCC\")\n    self.ax.set_ylabel(\"X (mm)\", color=\"#CCCCCC\")\n    self.ax.set_title(\"Real-time Obstacle Detection\", color=\"#FFFFFF\", fontweight=\"bold\")\n\n    # Customize grid\n    self.ax.grid(True, color=\"#555555\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Customize axis appearance\n    self.ax.spines[\"bottom\"].set_color(\"#555555\")\n    self.ax.spines[\"top\"].set_color(\"#555555\")\n    self.ax.spines[\"left\"].set_color(\"#555555\")\n    self.ax.spines[\"right\"].set_color(\"#555555\")\n\n    # Customize tick parameters\n    self.ax.tick_params(axis=\"both\", colors=\"#CCCCCC\")\n\n    # Invert x-axis and set equal aspect ratio\n    self.ax.invert_xaxis()\n    self.ax.axis(\"equal\")\n\n    # Configure legend with dark theme colors\n    self.ax.legend(facecolor=\"#333333\", edgecolor=\"#555555\", labelcolor=\"#CCCCCC\")\n\n    # Set initial view range\n    self.ax.set_xlim((self.view_radius, -self.view_radius))\n    self.ax.set_ylim((-self.view_radius, self.view_radius))\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.start_animation","title":"<code>start_animation()</code>","text":"<p>Starts the real-time visualization</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def start_animation(self):\n    \"\"\"Starts the real-time visualization\"\"\"\n    # Set dark theme for the color map (for clusters)\n    plt.rcParams[\"axes.prop_cycle\"] = plt.cycler(color=plt.cm.plasma(np.linspace(0, 1, 10)))\n\n    # Continue with original animation code\n    self.animation = FuncAnimation(\n        self.fig,\n        self.update_plot,\n        interval=self.update_interval,\n        blit=False,\n        cache_frame_data=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/gui/#cogip.tools.ydlidar_g2.gui.LidarObstacleTracker.update_plot","title":"<code>update_plot(frame)</code>","text":"<p>Updates the visualization with current data</p> Source code in <code>cogip/tools/ydlidar_g2/gui.py</code> <pre><code>def update_plot(self, frame):\n    \"\"\"Updates the visualization with current data\"\"\"\n    lidar_coords = self.lidar_coords[: np.argmax(self.lidar_coords[:, 0] == -1)].copy()\n    self.clusters = self.cluster_obstacles(lidar_coords)\n    self.obstacle_properties = self.estimate_obstacle_properties(self.clusters)\n\n    # Update points scatter\n    self.points_scatter.set_offsets(np.column_stack((lidar_coords[:, 1], lidar_coords[:, 0])))\n\n    # Clear previous cluster scatters and obstacle visualizations\n    for scatter in self.cluster_scatters:\n        scatter.remove()\n    self.cluster_scatters = []\n\n    for circle in self.obstacle_circles:\n        circle.remove()\n    self.obstacle_circles = []\n\n    # Create color map for clusters that works well with dark theme\n    colors = plt.cm.plasma(np.linspace(0, 1, max(1, len(self.clusters))))\n\n    # Draw new clusters\n    for i, cluster in enumerate(self.clusters):\n        scatter = self.ax.scatter(\n            cluster[:, 1],\n            cluster[:, 0],\n            c=[colors[i]],\n            s=20,\n            label=f\"Cluster {i}\" if i == 0 else \"\",\n        )\n        self.cluster_scatters.append(scatter)\n\n    # Draw obstacle circles and labels\n    for i, (center_x, center_y, radius) in enumerate(self.obstacle_properties):\n        # Create ellipse for the obstacle\n        circle = Ellipse(\n            (center_y, center_x),\n            width=radius * 2,\n            height=radius * 2,\n            fill=False,\n            edgecolor=colors[i],\n            linewidth=2,\n            alpha=0.8,\n        )\n        self.ax.add_patch(circle)\n        self.obstacle_circles.append(circle)\n\n    # Redraw the figure\n    self.fig.canvas.draw_idle()\n</code></pre>"},{"location":"reference/cogip/tools/ydlidar_g2/web/","title":"web","text":""},{"location":"reference/cogip/utils/argenum/","title":"argenum","text":""},{"location":"reference/cogip/utils/argenum/#cogip.utils.argenum.ArgEnum","title":"<code>ArgEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>This base class can be used to define Enum argument for Typer. It allows to use the Enum name of the enum in the command line arguments instead the Enum value. To get the Enum value, use <code>ArgEnum.val</code> property instead of <code>ArgEnum.value</code>.</p> <p>This workaround is explained here: https://github.com/tiangolo/typer/issues/151#issuecomment-1755370085. There is a pending merge request here: https://github.com/tiangolo/typer/pull/224.</p> Source code in <code>cogip/utils/argenum.py</code> <pre><code>class ArgEnum(Enum):\n    \"\"\"\n    This base class can be used to define Enum argument for Typer.\n    It allows to use the Enum name of the enum in the command line arguments instead the Enum value.\n    To get the Enum value, use `ArgEnum.val` property instead of `ArgEnum.value`.\n\n    This workaround is explained here: https://github.com/tiangolo/typer/issues/151#issuecomment-1755370085.\n    There is a pending merge request here: https://github.com/tiangolo/typer/pull/224.\n    \"\"\"\n\n    def __init__(self, val):\n        self.val = val\n\n    @property\n    def value(self):\n        return self.name\n\n    def __eq__(self, other: ArgEnum | int | str) -&gt; bool:\n        if isinstance(other, int | str):\n            return self.val == other\n        return super().__eq__(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.val)\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/","title":"asyncloop","text":""},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop","title":"<code>AsyncLoop</code>","text":"<p>This class creates a async task to execute a function in loop and wait after the function until the defined loop interval is reached. A warning is emitted if the function duration is longer than the loop interval.</p> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>class AsyncLoop:\n    \"\"\"\n    This class creates a async task to execute a function in loop and wait after\n    the function until the defined loop interval is reached.\n    A warning is emitted if the function duration is longer than the loop\n    interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        interval: float,\n        func: Callable,\n        logger: bool | logging.Logger = False,\n        args: list[Any] | None = None,\n        kwargs: dict[str, Any] | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: Name to identify the thread in the logs\n            interval: time between each iteration of the loop, in seconds\n            func: function to execute in the loop\n            logger: an optional custom logger\n            args: arguments of the function\n            kwargs: named arguments of the function\n        \"\"\"\n        self._name = name\n        self.interval = interval\n        self._func = func\n        self._args = args or []\n        self._kwargs = kwargs or {}\n        self._logger = logging.getLogger(f\"AsyncLoop: {name}\")\n        self._task: asyncio.Task | None = None\n        self.exit: bool = False\n\n        if not isinstance(logger, bool):\n            self._logger = logger\n        else:\n            if self._logger.level == logging.NOTSET:\n                if logger:\n                    self._logger.setLevel(logging.DEBUG)\n                else:\n                    self._logger.setLevel(logging.INFO)\n\n    async def task(self) -&gt; None:\n        \"\"\"\n        Loop function executed in the task.\n        \"\"\"\n        self._logger.info(\"Task started\")\n\n        try:\n            while not self.exit:\n                start = time.time()\n                await self._func(*self._args, **self._kwargs)\n                now = time.time()\n                duration = now - start\n                if duration &gt; self.interval:\n                    self._logger.warning(f\"Function too long: {duration} &gt; {self.interval}\")\n                else:\n                    wait = self.interval - duration\n                    await asyncio.sleep(wait)\n        except asyncio.CancelledError:\n            raise\n\n    def start(self):\n        if self._task:\n            self._logger.warning(\"Already started\")\n            return\n\n        self.exit = False\n        self._task = asyncio.create_task(self.task(), name=self._name)\n\n    async def stop(self):\n        if not self._task:\n            self._logger.warning(\"Not running\")\n            return\n\n        self._task.cancel()\n        try:\n            await self._task\n        except asyncio.CancelledError:\n            self._logger.info(\"Task cancelled\")\n\n        self._task = None\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop.__init__","title":"<code>__init__(name, interval, func, logger=False, args=None, kwargs=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the thread in the logs</p> required <code>interval</code> <code>float</code> <p>time between each iteration of the loop, in seconds</p> required <code>func</code> <code>Callable</code> <p>function to execute in the loop</p> required <code>logger</code> <code>bool | Logger</code> <p>an optional custom logger</p> <code>False</code> <code>args</code> <code>list[Any] | None</code> <p>arguments of the function</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>named arguments of the function</p> <code>None</code> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    interval: float,\n    func: Callable,\n    logger: bool | logging.Logger = False,\n    args: list[Any] | None = None,\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: Name to identify the thread in the logs\n        interval: time between each iteration of the loop, in seconds\n        func: function to execute in the loop\n        logger: an optional custom logger\n        args: arguments of the function\n        kwargs: named arguments of the function\n    \"\"\"\n    self._name = name\n    self.interval = interval\n    self._func = func\n    self._args = args or []\n    self._kwargs = kwargs or {}\n    self._logger = logging.getLogger(f\"AsyncLoop: {name}\")\n    self._task: asyncio.Task | None = None\n    self.exit: bool = False\n\n    if not isinstance(logger, bool):\n        self._logger = logger\n    else:\n        if self._logger.level == logging.NOTSET:\n            if logger:\n                self._logger.setLevel(logging.DEBUG)\n            else:\n                self._logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop.task","title":"<code>task()</code>  <code>async</code>","text":"<p>Loop function executed in the task.</p> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>async def task(self) -&gt; None:\n    \"\"\"\n    Loop function executed in the task.\n    \"\"\"\n    self._logger.info(\"Task started\")\n\n    try:\n        while not self.exit:\n            start = time.time()\n            await self._func(*self._args, **self._kwargs)\n            now = time.time()\n            duration = now - start\n            if duration &gt; self.interval:\n                self._logger.warning(f\"Function too long: {duration} &gt; {self.interval}\")\n            else:\n                wait = self.interval - duration\n                await asyncio.sleep(wait)\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/","title":"console_ui","text":"<p>Generic Console UI components using Rich.</p> <p>Provides a themed console interface with consistent styling for interactive CLI tools.</p>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI","title":"<code>ConsoleUI</code>","text":"<p>               Bases: <code>Console</code></p> <p>Generic console UI with themed output and async input methods.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>class ConsoleUI(Console):\n    \"\"\"Generic console UI with themed output and async input methods.\"\"\"\n\n    def __init__(self, theme: Theme | None = None):\n        \"\"\"\n        Initialize the console UI.\n\n        Args:\n            theme: Custom Rich theme. If None, uses DEFAULT_THEME.\n        \"\"\"\n        super().__init__(theme=theme or DEFAULT_THEME)\n\n    def show_panel(\n        self,\n        content: str,\n        *,\n        title: str | None = None,\n        subtitle: str | None = None,\n        border_style: str = \"header\",\n    ) -&gt; None:\n        \"\"\"\n        Display a styled panel.\n\n        Args:\n            content: Panel content text\n            title: Optional panel title\n            subtitle: Optional panel subtitle\n            border_style: Border style name from theme\n        \"\"\"\n        self.print(\n            Panel(\n                content,\n                title=f\"[header]{title}[/]\" if title else None,\n                subtitle=f\"[muted]{subtitle}[/]\" if subtitle else None,\n                border_style=border_style,\n                box=ROUNDED,\n                padding=(1, 2),\n            )\n        )\n\n    def show_rule(self, title: str, *, style: str = \"muted\", title_style: str = \"phase\") -&gt; None:\n        \"\"\"\n        Display a horizontal rule with title.\n\n        Args:\n            title: Rule title text\n            style: Line style name from theme\n            title_style: Title style name from theme\n        \"\"\"\n        self.print()\n        self.print(Rule(f\"[{title_style}]{title}[/]\", style=style))\n        self.print()\n\n    def show_success(self, message: str) -&gt; None:\n        \"\"\"Display a success message.\"\"\"\n        self.print(f\"[success]\\u2713 {message}[/]\")\n\n    def show_warning(self, message: str) -&gt; None:\n        \"\"\"Display a warning message.\"\"\"\n        self.print(f\"[warning]\\u26a0 {message}[/]\")\n\n    def show_error(self, message: str) -&gt; None:\n        \"\"\"Display an error message.\"\"\"\n        self.print(f\"[error]\\u2717 {message}[/]\")\n\n    def show_info(self, message: str) -&gt; None:\n        \"\"\"Display an info message.\"\"\"\n        self.print(f\"[muted]\\u2139 {message}[/]\")\n\n    def create_table(\n        self,\n        title: str | None = None,\n        columns: list[tuple[str, dict[str, Any]]] | None = None,\n    ) -&gt; Table:\n        \"\"\"Create a styled table.\n\n        Args:\n            title: Optional table title\n            columns: List of (name, kwargs) tuples for columns.\n                     kwargs are passed to add_column().\n\n        Returns:\n            Configured Table instance ready for add_row() calls.\n        \"\"\"\n        table = Table(\n            title=f\"[phase]{title}[/]\" if title else None,\n            box=ROUNDED,\n            border_style=\"muted\",\n            header_style=\"header\",\n            show_header=True,\n            padding=(0, 1),\n        )\n        if columns:\n            for name, kwargs in columns:\n                table.add_column(name, **kwargs)\n        return table\n\n    def show_key_value_table(\n        self,\n        data: list[tuple[str, str]],\n        title: str | None = None,\n        key_header: str = \"Parameter\",\n        value_header: str = \"Value\",\n    ) -&gt; None:\n        \"\"\"Display a simple key-value table.\n\n        Args:\n            data: List of (key, value) tuples\n            title: Optional table title\n            key_header: Header for key column\n            value_header: Header for value column\n        \"\"\"\n        table = self.create_table(\n            title=title,\n            columns=[\n                (key_header, {\"style\": \"label\"}),\n                (value_header, {\"style\": \"value\", \"justify\": \"right\"}),\n            ],\n        )\n        for key, value in data:\n            table.add_row(key, value)\n        self.print(table)\n\n    def show_comparison_table(\n        self,\n        data: list[tuple[str, str, str]],\n        title: str | None = None,\n        key_header: str = \"Parameter\",\n        before_header: str = \"Previous\",\n        after_header: str = \"New\",\n    ) -&gt; None:\n        \"\"\"Display a before/after comparison table.\n\n        Args:\n            data: List of (key, before_value, after_value) tuples\n            title: Optional table title\n            key_header: Header for key column\n            before_header: Header for before column\n            after_header: Header for after column\n        \"\"\"\n        table = self.create_table(\n            title=title,\n            columns=[\n                (key_header, {\"style\": \"label\"}),\n                (before_header, {\"style\": \"muted\"}),\n                (after_header, {\"style\": \"value\"}),\n            ],\n        )\n        for key, before, after in data:\n            table.add_row(key, before, after)\n        self.print(table)\n\n    async def get_string(self, prompt: str, *, default: str | None = None) -&gt; str:\n        \"\"\"\n        Get string input from user.\n\n        Args:\n            prompt: Prompt message to display\n            default: Default value. If None, input is required.\n        \"\"\"\n        kwargs: dict[str, Any] = {\"console\": self}\n        if default is not None:\n            kwargs[\"default\"] = default\n        return await asyncio.to_thread(lambda: Prompt.ask(f\"[prompt]{prompt}[/]\", **kwargs))\n\n    async def get_integer(self, prompt: str, *, default: int | None = None) -&gt; int:\n        \"\"\"\n        Get integer input from user.\n\n        Displays a confirmation message with the chosen value.\n\n        Args:\n            prompt: Prompt message to display\n            default: Default value. If None, input is required.\n        \"\"\"\n        kwargs: dict[str, Any] = {\"console\": self}\n        if default is not None:\n            kwargs[\"default\"] = default\n        value = await asyncio.to_thread(lambda: IntPrompt.ask(f\"[prompt]{prompt}[/]\", **kwargs))\n        self.show_info(f\"Chosen: {value}\")\n        return value\n\n    async def get_float(self, prompt: str, *, default: float | None = None) -&gt; float:\n        \"\"\"\n        Get float input from user.\n\n        Args:\n            prompt: Prompt message to display\n            default: Default value. If None, input is required.\n        \"\"\"\n        kwargs: dict[str, Any] = {\"console\": self}\n        if default is not None:\n            kwargs[\"default\"] = default\n        return await asyncio.to_thread(lambda: FloatPrompt.ask(f\"[prompt]{prompt}[/]\", **kwargs))\n\n    async def confirm(self, message: str, *, default: bool = True) -&gt; bool:\n        \"\"\"\n        Ask for confirmation.\n\n        Args:\n            message: Confirmation message to display\n            default: Default value when user presses Enter\n        \"\"\"\n        return await asyncio.to_thread(lambda: Confirm.ask(f\"[header]{message}[/]\", default=default, console=self))\n\n    async def wait_for_enter(self, message: str) -&gt; None:\n        \"\"\"\n        Wait for user to press Enter.\n\n        Args:\n            message: Message to display before waiting\n        \"\"\"\n        await asyncio.to_thread(lambda: self.input(f\"[prompt]{message}[/] [muted][[Enter]][/] \"))\n\n    def create_progress_tracker(\n        self,\n        columns: list[ProgressColumn] | None = None,\n    ) -&gt; CustomProgressTracker:\n        \"\"\"\n        Create a progress tracker with manual lifecycle control.\n\n        Features:\n        - Custom display columns\n        - Custom updatable fields\n        - Manual start/update/stop control\n\n        Args:\n            columns: Custom Rich Progress columns. If None, uses default columns\n                    (spinner, description, bar, percentage, elapsed time).\n\n        Returns:\n            CustomProgressTracker instance (call .start() to begin tracking)\n        \"\"\"\n        return CustomProgressTracker(self, columns)\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.__init__","title":"<code>__init__(theme=None)</code>","text":"<p>Initialize the console UI.</p> <p>Parameters:</p> Name Type Description Default <code>theme</code> <code>Theme | None</code> <p>Custom Rich theme. If None, uses DEFAULT_THEME.</p> <code>None</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def __init__(self, theme: Theme | None = None):\n    \"\"\"\n    Initialize the console UI.\n\n    Args:\n        theme: Custom Rich theme. If None, uses DEFAULT_THEME.\n    \"\"\"\n    super().__init__(theme=theme or DEFAULT_THEME)\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.confirm","title":"<code>confirm(message, *, default=True)</code>  <code>async</code>","text":"<p>Ask for confirmation.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Confirmation message to display</p> required <code>default</code> <code>bool</code> <p>Default value when user presses Enter</p> <code>True</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>async def confirm(self, message: str, *, default: bool = True) -&gt; bool:\n    \"\"\"\n    Ask for confirmation.\n\n    Args:\n        message: Confirmation message to display\n        default: Default value when user presses Enter\n    \"\"\"\n    return await asyncio.to_thread(lambda: Confirm.ask(f\"[header]{message}[/]\", default=default, console=self))\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.create_progress_tracker","title":"<code>create_progress_tracker(columns=None)</code>","text":"<p>Create a progress tracker with manual lifecycle control.</p> <p>Features: - Custom display columns - Custom updatable fields - Manual start/update/stop control</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>list[ProgressColumn] | None</code> <p>Custom Rich Progress columns. If None, uses default columns     (spinner, description, bar, percentage, elapsed time).</p> <code>None</code> <p>Returns:</p> Type Description <code>CustomProgressTracker</code> <p>CustomProgressTracker instance (call .start() to begin tracking)</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def create_progress_tracker(\n    self,\n    columns: list[ProgressColumn] | None = None,\n) -&gt; CustomProgressTracker:\n    \"\"\"\n    Create a progress tracker with manual lifecycle control.\n\n    Features:\n    - Custom display columns\n    - Custom updatable fields\n    - Manual start/update/stop control\n\n    Args:\n        columns: Custom Rich Progress columns. If None, uses default columns\n                (spinner, description, bar, percentage, elapsed time).\n\n    Returns:\n        CustomProgressTracker instance (call .start() to begin tracking)\n    \"\"\"\n    return CustomProgressTracker(self, columns)\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.create_table","title":"<code>create_table(title=None, columns=None)</code>","text":"<p>Create a styled table.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>Optional table title</p> <code>None</code> <code>columns</code> <code>list[tuple[str, dict[str, Any]]] | None</code> <p>List of (name, kwargs) tuples for columns.      kwargs are passed to add_column().</p> <code>None</code> <p>Returns:</p> Type Description <code>Table</code> <p>Configured Table instance ready for add_row() calls.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def create_table(\n    self,\n    title: str | None = None,\n    columns: list[tuple[str, dict[str, Any]]] | None = None,\n) -&gt; Table:\n    \"\"\"Create a styled table.\n\n    Args:\n        title: Optional table title\n        columns: List of (name, kwargs) tuples for columns.\n                 kwargs are passed to add_column().\n\n    Returns:\n        Configured Table instance ready for add_row() calls.\n    \"\"\"\n    table = Table(\n        title=f\"[phase]{title}[/]\" if title else None,\n        box=ROUNDED,\n        border_style=\"muted\",\n        header_style=\"header\",\n        show_header=True,\n        padding=(0, 1),\n    )\n    if columns:\n        for name, kwargs in columns:\n            table.add_column(name, **kwargs)\n    return table\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.get_float","title":"<code>get_float(prompt, *, default=None)</code>  <code>async</code>","text":"<p>Get float input from user.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>Prompt message to display</p> required <code>default</code> <code>float | None</code> <p>Default value. If None, input is required.</p> <code>None</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>async def get_float(self, prompt: str, *, default: float | None = None) -&gt; float:\n    \"\"\"\n    Get float input from user.\n\n    Args:\n        prompt: Prompt message to display\n        default: Default value. If None, input is required.\n    \"\"\"\n    kwargs: dict[str, Any] = {\"console\": self}\n    if default is not None:\n        kwargs[\"default\"] = default\n    return await asyncio.to_thread(lambda: FloatPrompt.ask(f\"[prompt]{prompt}[/]\", **kwargs))\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.get_integer","title":"<code>get_integer(prompt, *, default=None)</code>  <code>async</code>","text":"<p>Get integer input from user.</p> <p>Displays a confirmation message with the chosen value.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>Prompt message to display</p> required <code>default</code> <code>int | None</code> <p>Default value. If None, input is required.</p> <code>None</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>async def get_integer(self, prompt: str, *, default: int | None = None) -&gt; int:\n    \"\"\"\n    Get integer input from user.\n\n    Displays a confirmation message with the chosen value.\n\n    Args:\n        prompt: Prompt message to display\n        default: Default value. If None, input is required.\n    \"\"\"\n    kwargs: dict[str, Any] = {\"console\": self}\n    if default is not None:\n        kwargs[\"default\"] = default\n    value = await asyncio.to_thread(lambda: IntPrompt.ask(f\"[prompt]{prompt}[/]\", **kwargs))\n    self.show_info(f\"Chosen: {value}\")\n    return value\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.get_string","title":"<code>get_string(prompt, *, default=None)</code>  <code>async</code>","text":"<p>Get string input from user.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>Prompt message to display</p> required <code>default</code> <code>str | None</code> <p>Default value. If None, input is required.</p> <code>None</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>async def get_string(self, prompt: str, *, default: str | None = None) -&gt; str:\n    \"\"\"\n    Get string input from user.\n\n    Args:\n        prompt: Prompt message to display\n        default: Default value. If None, input is required.\n    \"\"\"\n    kwargs: dict[str, Any] = {\"console\": self}\n    if default is not None:\n        kwargs[\"default\"] = default\n    return await asyncio.to_thread(lambda: Prompt.ask(f\"[prompt]{prompt}[/]\", **kwargs))\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_comparison_table","title":"<code>show_comparison_table(data, title=None, key_header='Parameter', before_header='Previous', after_header='New')</code>","text":"<p>Display a before/after comparison table.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[tuple[str, str, str]]</code> <p>List of (key, before_value, after_value) tuples</p> required <code>title</code> <code>str | None</code> <p>Optional table title</p> <code>None</code> <code>key_header</code> <code>str</code> <p>Header for key column</p> <code>'Parameter'</code> <code>before_header</code> <code>str</code> <p>Header for before column</p> <code>'Previous'</code> <code>after_header</code> <code>str</code> <p>Header for after column</p> <code>'New'</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_comparison_table(\n    self,\n    data: list[tuple[str, str, str]],\n    title: str | None = None,\n    key_header: str = \"Parameter\",\n    before_header: str = \"Previous\",\n    after_header: str = \"New\",\n) -&gt; None:\n    \"\"\"Display a before/after comparison table.\n\n    Args:\n        data: List of (key, before_value, after_value) tuples\n        title: Optional table title\n        key_header: Header for key column\n        before_header: Header for before column\n        after_header: Header for after column\n    \"\"\"\n    table = self.create_table(\n        title=title,\n        columns=[\n            (key_header, {\"style\": \"label\"}),\n            (before_header, {\"style\": \"muted\"}),\n            (after_header, {\"style\": \"value\"}),\n        ],\n    )\n    for key, before, after in data:\n        table.add_row(key, before, after)\n    self.print(table)\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_error","title":"<code>show_error(message)</code>","text":"<p>Display an error message.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_error(self, message: str) -&gt; None:\n    \"\"\"Display an error message.\"\"\"\n    self.print(f\"[error]\\u2717 {message}[/]\")\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_info","title":"<code>show_info(message)</code>","text":"<p>Display an info message.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_info(self, message: str) -&gt; None:\n    \"\"\"Display an info message.\"\"\"\n    self.print(f\"[muted]\\u2139 {message}[/]\")\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_key_value_table","title":"<code>show_key_value_table(data, title=None, key_header='Parameter', value_header='Value')</code>","text":"<p>Display a simple key-value table.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[tuple[str, str]]</code> <p>List of (key, value) tuples</p> required <code>title</code> <code>str | None</code> <p>Optional table title</p> <code>None</code> <code>key_header</code> <code>str</code> <p>Header for key column</p> <code>'Parameter'</code> <code>value_header</code> <code>str</code> <p>Header for value column</p> <code>'Value'</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_key_value_table(\n    self,\n    data: list[tuple[str, str]],\n    title: str | None = None,\n    key_header: str = \"Parameter\",\n    value_header: str = \"Value\",\n) -&gt; None:\n    \"\"\"Display a simple key-value table.\n\n    Args:\n        data: List of (key, value) tuples\n        title: Optional table title\n        key_header: Header for key column\n        value_header: Header for value column\n    \"\"\"\n    table = self.create_table(\n        title=title,\n        columns=[\n            (key_header, {\"style\": \"label\"}),\n            (value_header, {\"style\": \"value\", \"justify\": \"right\"}),\n        ],\n    )\n    for key, value in data:\n        table.add_row(key, value)\n    self.print(table)\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_panel","title":"<code>show_panel(content, *, title=None, subtitle=None, border_style='header')</code>","text":"<p>Display a styled panel.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Panel content text</p> required <code>title</code> <code>str | None</code> <p>Optional panel title</p> <code>None</code> <code>subtitle</code> <code>str | None</code> <p>Optional panel subtitle</p> <code>None</code> <code>border_style</code> <code>str</code> <p>Border style name from theme</p> <code>'header'</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_panel(\n    self,\n    content: str,\n    *,\n    title: str | None = None,\n    subtitle: str | None = None,\n    border_style: str = \"header\",\n) -&gt; None:\n    \"\"\"\n    Display a styled panel.\n\n    Args:\n        content: Panel content text\n        title: Optional panel title\n        subtitle: Optional panel subtitle\n        border_style: Border style name from theme\n    \"\"\"\n    self.print(\n        Panel(\n            content,\n            title=f\"[header]{title}[/]\" if title else None,\n            subtitle=f\"[muted]{subtitle}[/]\" if subtitle else None,\n            border_style=border_style,\n            box=ROUNDED,\n            padding=(1, 2),\n        )\n    )\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_rule","title":"<code>show_rule(title, *, style='muted', title_style='phase')</code>","text":"<p>Display a horizontal rule with title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Rule title text</p> required <code>style</code> <code>str</code> <p>Line style name from theme</p> <code>'muted'</code> <code>title_style</code> <code>str</code> <p>Title style name from theme</p> <code>'phase'</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_rule(self, title: str, *, style: str = \"muted\", title_style: str = \"phase\") -&gt; None:\n    \"\"\"\n    Display a horizontal rule with title.\n\n    Args:\n        title: Rule title text\n        style: Line style name from theme\n        title_style: Title style name from theme\n    \"\"\"\n    self.print()\n    self.print(Rule(f\"[{title_style}]{title}[/]\", style=style))\n    self.print()\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_success","title":"<code>show_success(message)</code>","text":"<p>Display a success message.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_success(self, message: str) -&gt; None:\n    \"\"\"Display a success message.\"\"\"\n    self.print(f\"[success]\\u2713 {message}[/]\")\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.show_warning","title":"<code>show_warning(message)</code>","text":"<p>Display a warning message.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def show_warning(self, message: str) -&gt; None:\n    \"\"\"Display a warning message.\"\"\"\n    self.print(f\"[warning]\\u26a0 {message}[/]\")\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.ConsoleUI.wait_for_enter","title":"<code>wait_for_enter(message)</code>  <code>async</code>","text":"<p>Wait for user to press Enter.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to display before waiting</p> required Source code in <code>cogip/utils/console_ui.py</code> <pre><code>async def wait_for_enter(self, message: str) -&gt; None:\n    \"\"\"\n    Wait for user to press Enter.\n\n    Args:\n        message: Message to display before waiting\n    \"\"\"\n    await asyncio.to_thread(lambda: self.input(f\"[prompt]{message}[/] [muted][[Enter]][/] \"))\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.CustomProgressTracker","title":"<code>CustomProgressTracker</code>","text":"<p>Progress tracker with manual lifecycle and custom columns/fields.</p> <p>Features: - Manual start/update/stop control - Custom Rich columns - Custom task fields that can be updated</p> Example <p>tracker = console.create_progress_tracker(columns=[     SpinnerColumn(),     TextColumn(\"{task.description}\"),     BarColumn(),     TextColumn(\"Status: {task.fields[status]}\"), ]) tracker.start(\"Processing\", total=100, status=\"starting\") for i in range(100):     tracker.update(completed=i, status=f\"item {i}\") tracker.stop()</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>class CustomProgressTracker:\n    \"\"\"\n    Progress tracker with manual lifecycle and custom columns/fields.\n\n    Features:\n    - Manual start/update/stop control\n    - Custom Rich columns\n    - Custom task fields that can be updated\n\n    Example:\n        tracker = console.create_progress_tracker(columns=[\n            SpinnerColumn(),\n            TextColumn(\"{task.description}\"),\n            BarColumn(),\n            TextColumn(\"Status: {task.fields[status]}\"),\n        ])\n        tracker.start(\"Processing\", total=100, status=\"starting\")\n        for i in range(100):\n            tracker.update(completed=i, status=f\"item {i}\")\n        tracker.stop()\n    \"\"\"\n\n    def __init__(\n        self,\n        console: Console,\n        columns: list[ProgressColumn] | None = None,\n    ):\n        \"\"\"\n        Initialize the progress tracker.\n\n        Args:\n            console: Console instance for output\n            columns: Custom Rich Progress columns. If None, uses default columns.\n        \"\"\"\n        self._console = console\n        self._columns = columns or [\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            BarColumn(),\n            TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n            TimeElapsedColumn(),\n        ]\n        self._progress: Progress | None = None\n        self._task_id: TaskID | None = None\n\n    def start(\n        self,\n        description: str,\n        total: float = 100,\n        **fields: float,\n    ) -&gt; None:\n        \"\"\"\n        Start the progress display.\n\n        Args:\n            description: Task description\n            total: Total value for 100% completion (default: 100 for percentage)\n            **fields: Custom fields to display\n        \"\"\"\n        if self._progress is not None:\n            raise RuntimeError(\"Progress already started. Call stop() first.\")\n\n        self._progress = Progress(*self._columns, console=self._console)\n        self._progress.start()\n        self._task_id = self._progress.add_task(description, total=total, **fields)\n\n    def update(\n        self,\n        *,\n        completed: float | None = None,\n        description: str | None = None,\n        **fields: float,\n    ) -&gt; None:\n        \"\"\"\n        Update progress state.\n\n        Args:\n            completed: Current completion value (0 to total)\n            description: New description (optional)\n            **fields: Updated custom field values\n        \"\"\"\n        if self._progress is None or self._task_id is None:\n            return\n\n        self._progress.update(\n            self._task_id,\n            completed=completed,\n            description=description,\n            **fields,\n        )\n\n    def stop(self, complete: bool = True) -&gt; None:\n        \"\"\"\n        Stop the progress display.\n\n        Args:\n            complete: If True, set progress to 100% before stopping\n        \"\"\"\n        if self._progress is None:\n            return\n\n        if complete and self._task_id is not None:\n            self._progress.update(self._task_id, completed=self._progress.tasks[self._task_id].total)\n\n        self._progress.stop()\n        self._progress = None\n        self._task_id = None\n\n    @property\n    def is_active(self) -&gt; bool:\n        \"\"\"Check if progress is currently active.\"\"\"\n        return self._progress is not None\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.CustomProgressTracker.is_active","title":"<code>is_active</code>  <code>property</code>","text":"<p>Check if progress is currently active.</p>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.CustomProgressTracker.__init__","title":"<code>__init__(console, columns=None)</code>","text":"<p>Initialize the progress tracker.</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>Console</code> <p>Console instance for output</p> required <code>columns</code> <code>list[ProgressColumn] | None</code> <p>Custom Rich Progress columns. If None, uses default columns.</p> <code>None</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def __init__(\n    self,\n    console: Console,\n    columns: list[ProgressColumn] | None = None,\n):\n    \"\"\"\n    Initialize the progress tracker.\n\n    Args:\n        console: Console instance for output\n        columns: Custom Rich Progress columns. If None, uses default columns.\n    \"\"\"\n    self._console = console\n    self._columns = columns or [\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n        TimeElapsedColumn(),\n    ]\n    self._progress: Progress | None = None\n    self._task_id: TaskID | None = None\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.CustomProgressTracker.start","title":"<code>start(description, total=100, **fields)</code>","text":"<p>Start the progress display.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Task description</p> required <code>total</code> <code>float</code> <p>Total value for 100% completion (default: 100 for percentage)</p> <code>100</code> <code>**fields</code> <code>float</code> <p>Custom fields to display</p> <code>{}</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def start(\n    self,\n    description: str,\n    total: float = 100,\n    **fields: float,\n) -&gt; None:\n    \"\"\"\n    Start the progress display.\n\n    Args:\n        description: Task description\n        total: Total value for 100% completion (default: 100 for percentage)\n        **fields: Custom fields to display\n    \"\"\"\n    if self._progress is not None:\n        raise RuntimeError(\"Progress already started. Call stop() first.\")\n\n    self._progress = Progress(*self._columns, console=self._console)\n    self._progress.start()\n    self._task_id = self._progress.add_task(description, total=total, **fields)\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.CustomProgressTracker.stop","title":"<code>stop(complete=True)</code>","text":"<p>Stop the progress display.</p> <p>Parameters:</p> Name Type Description Default <code>complete</code> <code>bool</code> <p>If True, set progress to 100% before stopping</p> <code>True</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def stop(self, complete: bool = True) -&gt; None:\n    \"\"\"\n    Stop the progress display.\n\n    Args:\n        complete: If True, set progress to 100% before stopping\n    \"\"\"\n    if self._progress is None:\n        return\n\n    if complete and self._task_id is not None:\n        self._progress.update(self._task_id, completed=self._progress.tasks[self._task_id].total)\n\n    self._progress.stop()\n    self._progress = None\n    self._task_id = None\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.CustomProgressTracker.update","title":"<code>update(*, completed=None, description=None, **fields)</code>","text":"<p>Update progress state.</p> <p>Parameters:</p> Name Type Description Default <code>completed</code> <code>float | None</code> <p>Current completion value (0 to total)</p> <code>None</code> <code>description</code> <code>str | None</code> <p>New description (optional)</p> <code>None</code> <code>**fields</code> <code>float</code> <p>Updated custom field values</p> <code>{}</code> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>def update(\n    self,\n    *,\n    completed: float | None = None,\n    description: str | None = None,\n    **fields: float,\n) -&gt; None:\n    \"\"\"\n    Update progress state.\n\n    Args:\n        completed: Current completion value (0 to total)\n        description: New description (optional)\n        **fields: Updated custom field values\n    \"\"\"\n    if self._progress is None or self._task_id is None:\n        return\n\n    self._progress.update(\n        self._task_id,\n        completed=completed,\n        description=description,\n        **fields,\n    )\n</code></pre>"},{"location":"reference/cogip/utils/console_ui/#cogip.utils.console_ui.demo","title":"<code>demo()</code>  <code>async</code>","text":"<p>Demonstrate ConsoleUI features.</p> Source code in <code>cogip/utils/console_ui.py</code> <pre><code>async def demo() -&gt; None:\n    \"\"\"Demonstrate ConsoleUI features.\"\"\"\n    ui = ConsoleUI()\n\n    # Welcome panel\n    ui.show_panel(\n        \"This demo showcases all features of the ConsoleUI class.\\n\"\n        \"Follow the prompts to see each feature in action.\",\n        title=\"Console UI Demo\",\n        subtitle=\"Interactive demonstration\",\n    )\n\n    # Status messages\n    ui.show_rule(\"Status Messages\")\n    ui.show_success(\"Operation completed successfully\")\n    ui.show_warning(\"This is a warning message\")\n    ui.show_error(\"This is an error message\")\n    ui.show_info(\"This is an informational message\")\n\n    # Key-value table\n    ui.show_rule(\"Key-Value Table\")\n    ui.show_key_value_table(\n        [\n            (\"Robot ID\", \"1\"),\n            (\"Wheel diameter\", \"60.0 mm\"),\n            (\"Encoder resolution\", \"4096 ticks\"),\n            (\"Max speed\", \"1000 mm/s\"),\n        ],\n        title=\"Robot Configuration\",\n    )\n\n    # Comparison table\n    ui.show_rule(\"Comparison Table\")\n    ui.show_comparison_table(\n        [\n            (\"Left wheel\", \"59.8 mm\", \"60.2 mm\"),\n            (\"Right wheel\", \"60.1 mm\", \"59.9 mm\"),\n            (\"Track width\", \"280.0 mm\", \"281.5 mm\"),\n        ],\n        title=\"Calibration Results\",\n        before_header=\"Before\",\n        after_header=\"After\",\n    )\n\n    # Custom table\n    ui.show_rule(\"Custom Table\")\n    table = ui.create_table(\n        title=\"Sensor Readings\",\n        columns=[\n            (\"Sensor\", {\"style\": \"label\"}),\n            (\"Value\", {\"style\": \"value\", \"justify\": \"right\"}),\n            (\"Status\", {\"style\": \"success\", \"justify\": \"center\"}),\n        ],\n    )\n    table.add_row(\"Temperature\", \"25.3\u00b0C\", \"OK\")\n    table.add_row(\"Battery\", \"12.4V\", \"OK\")\n    table.add_row(\"Distance\", \"150 mm\", \"OK\")\n    ui.print(table)\n\n    # Interactive inputs\n    ui.show_rule(\"Interactive Inputs\")\n\n    robot_name = await ui.get_string(\"Robot name\", default=\"PAMI\")\n    ui.show_info(f\"Configuring robot: {robot_name}\")\n\n    robot_id = await ui.get_integer(\"Robot ID (1-4)\", default=1)\n    ui.show_info(f\"Robot ID set to: {robot_id}\")\n\n    wheel_diameter = await ui.get_float(\"Wheel diameter (mm)\", default=60.0)\n    ui.show_info(f\"Wheel diameter: {wheel_diameter:.1f} mm\")\n\n    confirmed = await ui.confirm(\"Do you want to continue?\", default=True)\n    if confirmed:\n        ui.show_success(\"Continuing...\")\n    else:\n        ui.show_warning(\"Cancelled by user\")\n\n    # Progress tracker demo\n    ui.show_rule(\"Progress Tracker Demo\")\n    tracker = ui.create_progress_tracker()\n    tracker.start(\"[info]Processing items[/]\", total=10)\n    for i in range(10):\n        time.sleep(0.3)\n        tracker.update(completed=i + 1)\n    tracker.stop()\n    ui.show_success(\"Progress tracker demo complete\")\n\n    # Final panel\n    await ui.wait_for_enter(\"Press Enter to exit\")\n    ui.show_panel(\n        \"[success]All features demonstrated successfully![/]\",\n        title=\"Demo Complete\",\n        border_style=\"success\",\n    )\n</code></pre>"},{"location":"reference/cogip/utils/fnv1a/","title":"fnv1a","text":"<p>FNV-1a hash implementation for firmware key hashing.</p>"},{"location":"reference/cogip/utils/fnv1a/#cogip.utils.fnv1a.fnv1a_hash","title":"<code>fnv1a_hash(string)</code>  <code>cached</code>","text":"<p>Compute FNV-1a 32-bit hash of a string.</p> <p>This matches the firmware's hash implementation used for parameter and telemetry keys. Results are cached to avoid recomputing hashes for previously seen strings.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to hash.</p> required <p>Returns:</p> Type Description <code>int</code> <p>32-bit FNV-1a hash value.</p> Example <p>hex(fnv1a_hash(\"parameter\")) '0x100b'</p> Source code in <code>cogip/utils/fnv1a.py</code> <pre><code>@cache\ndef fnv1a_hash(string: str) -&gt; int:\n    \"\"\"\n    Compute FNV-1a 32-bit hash of a string.\n\n    This matches the firmware's hash implementation used for parameter\n    and telemetry keys. Results are cached to avoid recomputing hashes\n    for previously seen strings.\n\n    Args:\n        string: The string to hash.\n\n    Returns:\n        32-bit FNV-1a hash value.\n\n    Example:\n        &gt;&gt;&gt; hex(fnv1a_hash(\"parameter\"))\n        '0x100b'\n    \"\"\"\n    FNV_OFFSET_BASIS = 0x811C9DC5\n    FNV_PRIME = 0x01000193\n\n    hash_value = FNV_OFFSET_BASIS\n\n    for byte in string.encode(\"utf-8\"):\n        hash_value ^= byte\n        hash_value = (hash_value * FNV_PRIME) &amp; 0xFFFFFFFF\n\n    return hash_value\n</code></pre>"},{"location":"reference/cogip/utils/lidartablemodel/","title":"lidartablemodel","text":""},{"location":"reference/cogip/utils/lidartablemodel/#cogip.utils.lidartablemodel.LidarTableModel","title":"<code>LidarTableModel</code>","text":"<p>               Bases: <code>QAbstractTableModel</code></p> <p>Model class providing access to data to update the table view.</p> Source code in <code>cogip/utils/lidartablemodel.py</code> <pre><code>class LidarTableModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Model class providing access to data to update the table view.\n    \"\"\"\n\n    headers = [\"Angle\", \"Distance\", \"Intensity\"]\n\n    def __init__(\n        self,\n        angle_values: list[float],\n        distance_values: list[int],\n        intensity_values: list[int],\n        distance_color: QtGui.QColor,\n        intensity_color: QtGui.QColor,\n        nb_angles: int = 360,\n    ):\n        \"\"\"Class constructor\n\n        Arguments:\n            angle_values: angle values list\n            distance_values: distance values list\n            intensity_values: intensity values list\n            distance_color: distance color\n            intensity_color: intensity color\n            nb_angles: number of angles\n        \"\"\"\n        super().__init__()\n        self.angle_values = angle_values\n        self.distance_values = distance_values\n        self.intensity_values = intensity_values\n        self.distance_color = distance_color\n        self.intensity_color = intensity_color\n        self.nb_angles = nb_angles\n\n    def rowCount(self, parent):\n        return self.nb_angles\n\n    def columnCount(self, parent):\n        return 3\n\n    def data(self, index, role):\n        row, column = index.row(), index.column()\n\n        if role == QtCore.Qt.BackgroundRole:\n            if column == 0:\n                return QtGui.QColor(\"lightgray\")\n            if column == 1:\n                return self.distance_color\n            if column == 2:\n                return self.intensity_color\n            return None\n\n        if role == QtCore.Qt.TextAlignmentRole:\n            return QtCore.Qt.AlignRight\n\n        if role == QtCore.Qt.DisplayRole:\n            if column == 0:\n                return self.angle_values[row]\n            if column == 1:\n                return self.distance_values[row]\n            if column == 2:\n                return self.intensity_values[row]\n            return None\n\n        return None\n\n    def headerData(self, section, orientation, role):\n        if role == QtCore.Qt.BackgroundRole:\n            return QtGui.QColor(\"lightgray\")\n\n        if role == QtCore.Qt.FontRole:\n            font = QtWidgets.QApplication.font()\n            font.setPointSize(font.pointSize() - 2)\n            return font\n\n        if role != QtCore.Qt.DisplayRole or orientation != QtCore.Qt.Horizontal:\n            return None\n        return self.headers[section]\n</code></pre>"},{"location":"reference/cogip/utils/lidartablemodel/#cogip.utils.lidartablemodel.LidarTableModel.__init__","title":"<code>__init__(angle_values, distance_values, intensity_values, distance_color, intensity_color, nb_angles=360)</code>","text":"<p>Class constructor</p> <p>Parameters:</p> Name Type Description Default <code>angle_values</code> <code>list[float]</code> <p>angle values list</p> required <code>distance_values</code> <code>list[int]</code> <p>distance values list</p> required <code>intensity_values</code> <code>list[int]</code> <p>intensity values list</p> required <code>distance_color</code> <code>QColor</code> <p>distance color</p> required <code>intensity_color</code> <code>QColor</code> <p>intensity color</p> required <code>nb_angles</code> <code>int</code> <p>number of angles</p> <code>360</code> Source code in <code>cogip/utils/lidartablemodel.py</code> <pre><code>def __init__(\n    self,\n    angle_values: list[float],\n    distance_values: list[int],\n    intensity_values: list[int],\n    distance_color: QtGui.QColor,\n    intensity_color: QtGui.QColor,\n    nb_angles: int = 360,\n):\n    \"\"\"Class constructor\n\n    Arguments:\n        angle_values: angle values list\n        distance_values: distance values list\n        intensity_values: intensity values list\n        distance_color: distance color\n        intensity_color: intensity color\n        nb_angles: number of angles\n    \"\"\"\n    super().__init__()\n    self.angle_values = angle_values\n    self.distance_values = distance_values\n    self.intensity_values = intensity_values\n    self.distance_color = distance_color\n    self.intensity_color = intensity_color\n    self.nb_angles = nb_angles\n</code></pre>"},{"location":"reference/cogip/utils/logger/","title":"logger","text":""},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger","title":"<code>Logger</code>","text":"<p>A Python class that integrates with C++ logging functionality. This class manages a Python logger and connects it to C++ logging streams.</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>class Logger:\n    \"\"\"\n    A Python class that integrates with C++ logging functionality.\n    This class manages a Python logger and connects it to C++ logging streams.\n    \"\"\"\n\n    def __init__(self, name: str, *, level: int = logging.INFO, enable_cpp: bool = True):\n        \"\"\"\n        Initialize the logger with a specific name and level.\n\n        Args:\n            name: Name of the logger (appears in log output)\n            level: Minimum logging level\n            enable_cpp: If True, enables C++ logging integration\n        \"\"\"\n        self.name = name\n        self.is_destroyed = False  # Flag to track destruction\n\n        # Create the Python logger\n        self.logger = logging.getLogger(name)\n        self.logger.setLevel(level)\n\n        # Prevent the log messages from being handled by parent loggers\n        self.logger.propagate = False\n\n        # Remove existing handlers if any\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n\n        formatter = logging.Formatter(\"[%(asctime)s][%(name)s][%(threadName)s] %(levelname)s: %(message)s\")\n\n        # Add console handler\n        console_handler = logging.StreamHandler()\n        console_handler.setFormatter(formatter)\n        self.logger.addHandler(console_handler)\n\n        # Add file handler\n        # Check if user has root permissions\n        if os.geteuid() == 0:\n            # If user has root permissions, like on Raspberry Pi,\n            # use /var/log/cogip to allow log persistence\n            log_dir = Path(\"/var/log/cogip\")\n        else:\n            # If user does not have root permissions, like in Docker stack,\n            # use /tmp since no persistent storage is required\n            log_dir = Path(\"/tmp/cogip-logs\")\n        log_dir.mkdir(parents=True, exist_ok=True)\n        robot_id = os.getenv(\"ROBOT_ID\", \"X\")\n        file_handler = logging.handlers.RotatingFileHandler(\n            log_dir / f\"robot{robot_id}-{name}.log\",\n            maxBytes=10 * 1024 * 1024,\n            backupCount=5,\n        )\n        file_handler.setLevel(level)\n        file_handler.setFormatter(formatter)\n        self.logger.addHandler(file_handler)\n\n        # Add syslog handler\n        if Path(\"/dev/log\").exists():\n            syslog_handler = logging.handlers.SysLogHandler(address=\"/dev/log\")\n            syslog_handler.setLevel(level)\n            syslog_handler.setFormatter(formatter)\n            self.logger.addHandler(syslog_handler)\n\n        if enable_cpp:\n            self.enable_cpp_logging()\n\n        atexit.register(self.cleanup)  # Register cleanup function\n\n    def __del__(self):\n        self.cleanup()\n\n    def enable_cpp_logging(self):\n        \"\"\"Enable C++ logging integration.\"\"\"\n        if not self.is_destroyed:\n            cpp_logger.set_logger_callback(self.log_callback)\n\n    def cleanup(self):\n        \"\"\"Cleanup function to unregister the callback.\"\"\"\n        if not self.is_destroyed:\n            self.is_destroyed = True\n            cpp_logger.unset_logger_callback()  # Unregister the callback\n\n    def log_callback(self, message: str, level: cpp_logger.LogLevel):\n        \"\"\"\n        Callback function for C++ logging.\n        Routes C++ log messages to the appropriate Python logger method.\n\n        Args:\n            message: The log message from C++\n            level: Logging level from C++\n        \"\"\"\n        # Avoid processing if the logger is destroyed\n        if self.is_destroyed:\n            return\n        if not message:\n            return\n        logger_func = getattr(self.logger, level.name.lower(), self.logger.info)\n        logger_func(f\"[C++] {message}\")\n\n    def debug(self, message):\n        \"\"\"Log a debug message from Python\"\"\"\n        self.logger.debug(message)\n\n    def info(self, message):\n        \"\"\"Log an info message from Python\"\"\"\n        self.logger.info(message)\n\n    def warning(self, message):\n        \"\"\"Log a warning message from Python\"\"\"\n        self.logger.warning(message)\n\n    def error(self, message):\n        \"\"\"Log an error message from Python\"\"\"\n        self.logger.error(message)\n\n    def setLevel(self, level: int):\n        \"\"\"\n        Set the logging level for the logger.\n\n        Args:\n            level: The logging level to set\n        \"\"\"\n        self.logger.setLevel(level)\n        for handler in self.logger.handlers:\n            handler.setLevel(level)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.__init__","title":"<code>__init__(name, *, level=logging.INFO, enable_cpp=True)</code>","text":"<p>Initialize the logger with a specific name and level.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the logger (appears in log output)</p> required <code>level</code> <code>int</code> <p>Minimum logging level</p> <code>INFO</code> <code>enable_cpp</code> <code>bool</code> <p>If True, enables C++ logging integration</p> <code>True</code> Source code in <code>cogip/utils/logger.py</code> <pre><code>def __init__(self, name: str, *, level: int = logging.INFO, enable_cpp: bool = True):\n    \"\"\"\n    Initialize the logger with a specific name and level.\n\n    Args:\n        name: Name of the logger (appears in log output)\n        level: Minimum logging level\n        enable_cpp: If True, enables C++ logging integration\n    \"\"\"\n    self.name = name\n    self.is_destroyed = False  # Flag to track destruction\n\n    # Create the Python logger\n    self.logger = logging.getLogger(name)\n    self.logger.setLevel(level)\n\n    # Prevent the log messages from being handled by parent loggers\n    self.logger.propagate = False\n\n    # Remove existing handlers if any\n    for handler in self.logger.handlers[:]:\n        self.logger.removeHandler(handler)\n\n    formatter = logging.Formatter(\"[%(asctime)s][%(name)s][%(threadName)s] %(levelname)s: %(message)s\")\n\n    # Add console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    self.logger.addHandler(console_handler)\n\n    # Add file handler\n    # Check if user has root permissions\n    if os.geteuid() == 0:\n        # If user has root permissions, like on Raspberry Pi,\n        # use /var/log/cogip to allow log persistence\n        log_dir = Path(\"/var/log/cogip\")\n    else:\n        # If user does not have root permissions, like in Docker stack,\n        # use /tmp since no persistent storage is required\n        log_dir = Path(\"/tmp/cogip-logs\")\n    log_dir.mkdir(parents=True, exist_ok=True)\n    robot_id = os.getenv(\"ROBOT_ID\", \"X\")\n    file_handler = logging.handlers.RotatingFileHandler(\n        log_dir / f\"robot{robot_id}-{name}.log\",\n        maxBytes=10 * 1024 * 1024,\n        backupCount=5,\n    )\n    file_handler.setLevel(level)\n    file_handler.setFormatter(formatter)\n    self.logger.addHandler(file_handler)\n\n    # Add syslog handler\n    if Path(\"/dev/log\").exists():\n        syslog_handler = logging.handlers.SysLogHandler(address=\"/dev/log\")\n        syslog_handler.setLevel(level)\n        syslog_handler.setFormatter(formatter)\n        self.logger.addHandler(syslog_handler)\n\n    if enable_cpp:\n        self.enable_cpp_logging()\n\n    atexit.register(self.cleanup)  # Register cleanup function\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.cleanup","title":"<code>cleanup()</code>","text":"<p>Cleanup function to unregister the callback.</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def cleanup(self):\n    \"\"\"Cleanup function to unregister the callback.\"\"\"\n    if not self.is_destroyed:\n        self.is_destroyed = True\n        cpp_logger.unset_logger_callback()  # Unregister the callback\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.debug","title":"<code>debug(message)</code>","text":"<p>Log a debug message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def debug(self, message):\n    \"\"\"Log a debug message from Python\"\"\"\n    self.logger.debug(message)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.enable_cpp_logging","title":"<code>enable_cpp_logging()</code>","text":"<p>Enable C++ logging integration.</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def enable_cpp_logging(self):\n    \"\"\"Enable C++ logging integration.\"\"\"\n    if not self.is_destroyed:\n        cpp_logger.set_logger_callback(self.log_callback)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.error","title":"<code>error(message)</code>","text":"<p>Log an error message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def error(self, message):\n    \"\"\"Log an error message from Python\"\"\"\n    self.logger.error(message)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.info","title":"<code>info(message)</code>","text":"<p>Log an info message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def info(self, message):\n    \"\"\"Log an info message from Python\"\"\"\n    self.logger.info(message)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.log_callback","title":"<code>log_callback(message, level)</code>","text":"<p>Callback function for C++ logging. Routes C++ log messages to the appropriate Python logger method.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The log message from C++</p> required <code>level</code> <code>LogLevel</code> <p>Logging level from C++</p> required Source code in <code>cogip/utils/logger.py</code> <pre><code>def log_callback(self, message: str, level: cpp_logger.LogLevel):\n    \"\"\"\n    Callback function for C++ logging.\n    Routes C++ log messages to the appropriate Python logger method.\n\n    Args:\n        message: The log message from C++\n        level: Logging level from C++\n    \"\"\"\n    # Avoid processing if the logger is destroyed\n    if self.is_destroyed:\n        return\n    if not message:\n        return\n    logger_func = getattr(self.logger, level.name.lower(), self.logger.info)\n    logger_func(f\"[C++] {message}\")\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.setLevel","title":"<code>setLevel(level)</code>","text":"<p>Set the logging level for the logger.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The logging level to set</p> required Source code in <code>cogip/utils/logger.py</code> <pre><code>def setLevel(self, level: int):\n    \"\"\"\n    Set the logging level for the logger.\n\n    Args:\n        level: The logging level to set\n    \"\"\"\n    self.logger.setLevel(level)\n    for handler in self.logger.handlers:\n        handler.setLevel(level)\n</code></pre>"},{"location":"reference/cogip/utils/logger/#cogip.utils.logger.Logger.warning","title":"<code>warning(message)</code>","text":"<p>Log a warning message from Python</p> Source code in <code>cogip/utils/logger.py</code> <pre><code>def warning(self, message):\n    \"\"\"Log a warning message from Python\"\"\"\n    self.logger.warning(message)\n</code></pre>"},{"location":"reference/cogip/utils/mock/","title":"mock","text":""},{"location":"reference/cogip/utils/singleton/","title":"singleton","text":""},{"location":"reference/cogip/utils/singleton/#cogip.utils.singleton.Singleton","title":"<code>Singleton</code>","text":"<p>               Bases: <code>type</code></p> <p>Meta class used to declare singleton</p> <p>Example:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Data(metaclass=Singleton):\n    name: str = \"\"\n\n\ndata = Data()\nprint(data)            # output: Data(name='')\ndata.name = \"foo\"\nprint(data)            # output: Data(name='foo')\nprint(Data())          # output: Data(name='foo')\nprint(data is Data())  # output: True\n</code></pre> Source code in <code>cogip/utils/singleton.py</code> <pre><code>class Singleton(type):\n    \"\"\"\n    Meta class used to declare singleton\n\n    Example:\n\n        from dataclasses import dataclass\n\n\n        @dataclass\n        class Data(metaclass=Singleton):\n            name: str = \"\"\n\n\n        data = Data()\n        print(data)            # output: Data(name='')\n        data.name = \"foo\"\n        print(data)            # output: Data(name='foo')\n        print(Data())          # output: Data(name='foo')\n        print(data is Data())  # output: True\n    \"\"\"\n\n    _instance = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instance:\n            cls._instance[cls] = super().__call__(*args, **kwargs)\n        return cls._instance[cls]\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/","title":"threadloop","text":""},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop","title":"<code>ThreadLoop</code>","text":"<p>This class creates a thread to execute a function in loop and wait after the function until the defined loop interval is reached. A warning is emitted if the function duration is longer than the loop interval.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>class ThreadLoop:\n    \"\"\"\n    This class creates a thread to execute a function in loop and wait after\n    the function until the defined loop interval is reached.\n    A warning is emitted if the function duration is longer than the loop\n    interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        interval: float,\n        func: Callable,\n        logger: bool | logging.Logger = False,\n        args: list[Any] | None = None,\n        kwargs: dict[str, Any] | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: Name to identify the thread in the logs\n            interval: time between each iteration of the loop, in seconds\n                      if 0, the function is supposed to have its own sleep time.\n                      if &lt; 0, like 0 but always display a loop duration\n            func: function to execute in the loop\n            logger: an optional custom logger\n            args: arguments of the function\n            kwargs: named arguments of the function\n        \"\"\"\n        self._name = name\n        self._interval = interval\n        self._func = func\n        self._args = args or []\n        self._kwargs = kwargs or {}\n        self._thread = threading.Thread(target=self.repeat)\n        self._cancel = False\n        self._logger = logging.getLogger(f\"ThreadLoop: {name}\")\n\n        if not isinstance(logger, bool):\n            self._logger = logger\n        else:\n            if self._logger.level == logging.NOTSET:\n                if logger:\n                    self._logger.setLevel(logging.INFO)\n                else:\n                    self._logger.setLevel(logging.ERROR)\n                self._logger.addHandler(logging.StreamHandler())\n\n    @property\n    def interval(self) -&gt; float:\n        return self._interval\n\n    @interval.setter\n    def interval(self, value: float) -&gt; None:\n        self._interval = value\n\n    def repeat(self) -&gt; None:\n        \"\"\"\n        Loop function executed in the thread.\n        \"\"\"\n        while not self._cancel:\n            start = time.time()\n            self._func(*self._args, **self._kwargs)\n            now = time.time()\n            duration = now - start\n            if self._interval &gt; 0:\n                if duration &gt; self._interval:\n                    self._logger.warning(f\"Function too long: {duration} &gt; {self._interval}\")\n                else:\n                    wait = self._interval - duration\n                    time.sleep(wait)\n            elif self._interval &lt; 0:\n                self._logger.info(f\"Function duration: {duration}\")\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the thread loop.\n        \"\"\"\n        if self._thread.is_alive():\n            self._logger.warning(f\"Already {'canceled' if self._cancel else 'running'}\")\n            return\n        if self._cancel:\n            self._thread = threading.Thread(target=self.repeat)\n            self._cancel = False\n        self._thread.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the thread loop.\n        \"\"\"\n        self._logger.debug(\"Stopping...\")\n        if self._thread.is_alive():\n            self._cancel = True\n            try:\n                self._thread.join()\n            except KeyboardInterrupt:\n                pass\n            self._logger.debug(\"Stopped.\")\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.__init__","title":"<code>__init__(name, interval, func, logger=False, args=None, kwargs=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the thread in the logs</p> required <code>interval</code> <code>float</code> <p>time between each iteration of the loop, in seconds       if 0, the function is supposed to have its own sleep time.       if &lt; 0, like 0 but always display a loop duration</p> required <code>func</code> <code>Callable</code> <p>function to execute in the loop</p> required <code>logger</code> <code>bool | Logger</code> <p>an optional custom logger</p> <code>False</code> <code>args</code> <code>list[Any] | None</code> <p>arguments of the function</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>named arguments of the function</p> <code>None</code> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    interval: float,\n    func: Callable,\n    logger: bool | logging.Logger = False,\n    args: list[Any] | None = None,\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: Name to identify the thread in the logs\n        interval: time between each iteration of the loop, in seconds\n                  if 0, the function is supposed to have its own sleep time.\n                  if &lt; 0, like 0 but always display a loop duration\n        func: function to execute in the loop\n        logger: an optional custom logger\n        args: arguments of the function\n        kwargs: named arguments of the function\n    \"\"\"\n    self._name = name\n    self._interval = interval\n    self._func = func\n    self._args = args or []\n    self._kwargs = kwargs or {}\n    self._thread = threading.Thread(target=self.repeat)\n    self._cancel = False\n    self._logger = logging.getLogger(f\"ThreadLoop: {name}\")\n\n    if not isinstance(logger, bool):\n        self._logger = logger\n    else:\n        if self._logger.level == logging.NOTSET:\n            if logger:\n                self._logger.setLevel(logging.INFO)\n            else:\n                self._logger.setLevel(logging.ERROR)\n            self._logger.addHandler(logging.StreamHandler())\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.repeat","title":"<code>repeat()</code>","text":"<p>Loop function executed in the thread.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def repeat(self) -&gt; None:\n    \"\"\"\n    Loop function executed in the thread.\n    \"\"\"\n    while not self._cancel:\n        start = time.time()\n        self._func(*self._args, **self._kwargs)\n        now = time.time()\n        duration = now - start\n        if self._interval &gt; 0:\n            if duration &gt; self._interval:\n                self._logger.warning(f\"Function too long: {duration} &gt; {self._interval}\")\n            else:\n                wait = self._interval - duration\n                time.sleep(wait)\n        elif self._interval &lt; 0:\n            self._logger.info(f\"Function duration: {duration}\")\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.start","title":"<code>start()</code>","text":"<p>Start the thread loop.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the thread loop.\n    \"\"\"\n    if self._thread.is_alive():\n        self._logger.warning(f\"Already {'canceled' if self._cancel else 'running'}\")\n        return\n    if self._cancel:\n        self._thread = threading.Thread(target=self.repeat)\n        self._cancel = False\n    self._thread.start()\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.stop","title":"<code>stop()</code>","text":"<p>Stop the thread loop.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the thread loop.\n    \"\"\"\n    self._logger.debug(\"Stopping...\")\n    if self._thread.is_alive():\n        self._cancel = True\n        try:\n            self._thread.join()\n        except KeyboardInterrupt:\n            pass\n        self._logger.debug(\"Stopped.\")\n</code></pre>"},{"location":"usage/beaconcam/","title":"Beaconcam","text":"<p>Not yet available.</p>"},{"location":"usage/camera/","title":"Camera","text":"<p>The <code>Camera</code> tool provides different commands to get information about cameras, calibrate them and detect Aruco tags.</p> <p>Use <code>--help</code> argument to show available commands:</p> <pre><code>$ cogip-camera --help\nUsage: cogip-camera [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -d, --debug           Turn on debug messages\n                        env var: COGIP_DEBUG, CAMERA_DEBUG\n\n  --help                Show this message and exit.\n\nCommands:\n  calibrate  Calibrate camera using images captured by the 'capture' command\n  capture    Capture images to be used by the 'calibrate' command\n  charuco    Display charuco board to check if is corresponds to the board used for calibration\n  detect     Detect Aruco tags and estimate their positions\n  info       Get properties of connected cameras\n</code></pre>"},{"location":"usage/camera/#info-command","title":"Info Command","text":"<p>Display properties of connected cameras.</p> <p>If a camera name is provided, only display properties of this camera and preview its video stream. Codec, width and height arguments apply only in this context.</p> <pre><code>$ cogip-camera info --help\nUsage: cogip-camera info [OPTIONS]\n\n  Get properties of connected cameras\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]   Name of the camera (all if not specified)\n                              env var: CAMERA_NAME\n\n  --camera-codec [mjpg|yuyv]  Camera video codec\n                              env var: CAMERA_CODEC\n                              default: yuyv\n\n  --camera-width INTEGER      Camera frame width\n                              env var: CAMERA_WIDTH\n                              default: 1920\n\n  --camera-height INTEGER     Camera frame height\n                              env var: CAMERA_HEIGHT\n                              default: 1080\n\n  --help                      Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#charuco-command","title":"Charuco Command","text":"<p>Display charuco board to check if is corresponds to the board used for calibration. Same parameters must be used with the <code>capture</code> and <code>calibrate</code> commands.</p> <pre><code>$ cogip-camera charuco --help\nUsage: cogip-camera charuco [OPTIONS]\n\n  Display charuco board to check if is corresponds to the board used for calibration\n\nOptions:\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: no-charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#capture-command","title":"Capture Command","text":"<p>Capture images to be used by the <code>calibrate</code> command.</p> <p>Use <code>--max-frames</code> and <code>--capture-interval</code> options to customize the number of images to capture and the frequency of capture.</p> <p>To be valid for calibration, the images must contained a charuco board with different orientations on each image. Use <code>--charuco-*</code> options to configure the Charuco board used for calibration.</p> <p>The captured images will be displayed after charuco board detection.</p> <p>The Charuco board generated for detection is also displayed for comparison with the board on images.</p> <p>Images are stored in <code>cameras/&lt;robot_id&gt;/&lt;camera_name&gt;_&lt;camera_codec&gt;_&lt;camera_width&gt;x&lt;camera_height&gt;/images</code>.</p> <pre><code>$ cogip-camera capture --help\nUsage: cogip-camera capture [OPTIONS]\n\n  Capture images to be used by the 'calibrate' command\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 1920\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 1080\n\n  --max-frames INTEGER            Maximum number of frames to read before exiting\n                                  env var: CAMERA_MAX_FRAMES\n                                  default: 120\n\n  --capture-interval INTEGER      Capture an image every 'capture_interval' frames\n                                  env var: CAMERA_CAPTURE_INTERVAL\n                                  default: 10\n\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#calibrate-command","title":"Calibrate Command","text":"<p>Generate intrinsic calibration parameters using images recorded by the <code>capture</code> command.</p> <p>The parameter file is written in <code>cameras/&lt;robot_id&gt;/&lt;camera_name&gt;_&lt;camera_codec&gt;_&lt;camera_width&gt;x&lt;camera_height&gt;/params.yaml</code>.</p> <pre><code>$ cogip-camera calibrate --help\nUsage: cogip-camera calibrate [OPTIONS]\n\n  Calibrate camera using images captured by the 'capture' command\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 1920\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 1080\n\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#detect-command","title":"Detect Command","text":"<p>Detect Aruco tags and estimate their positions.</p> <pre><code>$ cogip-camera detect --help\nUsage: cogip-camera detect [OPTIONS]\n\n  Detect Aruco tags and estimate their positions\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 1920\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 1080\n\n  --robot-position INTEGER        Define the robot position\n                                  env var: CAMERA_ROBOT_POSITION\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/cansend/","title":"cansend","text":"<p>Helper tool to send CAN command on a CAN bus using COGIP messages.</p> <p>Use <code>--help</code> argument to show available commands:</p> <pre><code>$ cogip-cansend --help\nUsage: cogip-cansend [OPTIONS]\n\nOptions:\n  -c, --can-channel TEXT      CAN channel connected to STM32 modules\n                              env var: CANSEND_CAN_CHANNEL\n                              default: vcan0\n\n  -b, --can-bitrate INTEGER   CAN bitrate\n                              env var: CANSEND_CAN_BITRATE\n                              default: 500000\n\n  -B, --data-bitrate INTEGER  CAN FD data bitrate\n                              env var: CANSEND_CANFD_DATA_BITRATE\n                              default: 1000000\n\n  -c, --commands FILENAME     YAML file containing\n                              env var: CANSEND_COMMANDS\n                              default: 1000000\n\n  --help                      Show this message and exit.\n</code></pre> <p>The list of commands to send is provided using a YAML file.</p> <p>The commands are defined in <code>cogip/models/actuators.py</code>, like PositionalActuatorCommand.</p> <p>Enum attributes can be specified by their name or value.</p> <p>Example:</p> <pre><code>- kind: 0\n  id: LXSERVO_LEFT_CART\n  command: 100\n\n- kind: POSITIONAL\n  id: 2\n  command: 1\n</code></pre>"},{"location":"usage/copilot/","title":"Copilot","text":"<p>The <code>Copilot</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates with <code>mcu-firmware</code> on the robot's STM32 over a serial port using Protobuf messages.</p> <p>It communicates on the <code>/copilot</code> namespace of the SocketIO server running on the central beacon over Wifi.</p>"},{"location":"usage/copilot/#data-flow","title":"Data Flow","text":""},{"location":"usage/copilot/#run-copilot","title":"Run Copilot","text":"<pre><code>$ cogip-copilot\n</code></pre>"},{"location":"usage/copilot/#parameters","title":"Parameters","text":"<p><code>Copilot</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-copilot --help\nUsage: cogip-copilot [OPTIONS]\n\nOptions:\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, COPILOT_ID\n                                  default: 1; x&gt;=1\n\n  -p, --serial-port PATH          Serial port connected to STM32 device\n                                  env var: COPILOT_SERIAL_PORT\n                                  default: /dev/ttyUSB0\n\n  -b, --serial-baudrate INTEGER   Baud rate\n                                  env var: COPILOT_BAUD_RATE\n                                  default: 230400\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, COPILOT_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, COPILOT_DEBUG\n</code></pre>"},{"location":"usage/dashboard/","title":"Dashboard","text":"<p>The <code>Dashboard</code> is a web site displayed on the touchscreens embedded in the robots and on the beacon.</p> <p>The web server can also be accessed from any devices (PC, smartphones) connected to the same network.</p> <p>The web server listen on port <code>8080 + robot_id</code>, ie <code>8080</code> on beacon and <code>8081</code> on robot 1.</p> <p></p>"},{"location":"usage/dashboard/#data-flow","title":"Data Flow","text":""},{"location":"usage/detector/","title":"Detector","text":"<p>The <code>Detector</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates on the <code>/detector</code> namespace of the SocketIO server running on the central beacon over Wifi.</p> <p>It builds dynamic obstacles used by <code>Monitor</code>/<code>Dashboards</code> for display and by <code>mcu-firmware</code> to compute avoidance path.</p> <p><code>Detector</code> can operate in monitoring or emulation mode.</p>"},{"location":"usage/detector/#monitoring-mode","title":"Monitoring Mode","text":"<p>Read data from lidar connected on a serial port of the Raspberry Pi. This is the default mode when a Lidar is connected, since the YDLidar SDK automatically detects the serial port to use.</p>"},{"location":"usage/detector/#emulation-mode","title":"Emulation Mode","text":"<p>Ask the <code>Monitor</code> to emulate the Lidar which sends its data through the SocketIO server. The emulation mode is enabled if no Lidar is detected at startup. In case of a false detection, use the <code>--emulation</code> option.</p>"},{"location":"usage/detector/#data-flow","title":"Data Flow","text":""},{"location":"usage/detector/#run-detector","title":"Run Detector","text":"<pre><code>$ cogip-detector\n</code></pre>"},{"location":"usage/detector/#parameters","title":"Parameters","text":"<p><code>Detector</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-detector --help\nUsage: cogip-detector [OPTIONS]\n\nOptions:\n  -i, --robot-id INTEGER RANGE    Robot ID.\n                                  env var: ROBOT_ID, DETECTOR_ID\n                                  default: 1; x&gt;=1\n\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  -p, --lidar-port PATH           Serial port connected to the Lidar\n                                  env var: DETECTOR_LIDAR_PORT\n                                  default: None (autodetect)\n\n  --min-distance INTEGER          Minimum distance to detect an obstacle\n                                  env var: DETECTOR_MIN_DISTANCE\n                                  default: 150\n\n  --max-distance INTEGER          Maximum distance to detect an obstacle\n                                  env var: DETECTOR_MAX_DISTANCE\n                                  default: 2500\n\n  --min-intensity INTEGER         Minimum intensity to detect an obstacle\n                                  env var: DETECTOR_MIN_INTENSITY\n                                  default: 0; x&gt;=1; x&lt;=255\n\n  --refresh-interval FLOAT        Interval between each update of the obstacle list (in seconds)\n                                  env var: DETECTOR_REFRESH_INTERVAL\n                                  default: 0.1; x&gt;=-1.0; x&lt;=2.0\n\n  --sensor-delay INTEGER          Delay to compensate the delay between sensor data fetch and obstacle positions computation.\n                                  Unit is the index of pose current to get in the past\n                                  env var: DETECTOR_SENSOR_DELAY\n                                  default: 0; x&gt;=0; x&lt;=100\n\n  --cluster-min-samples INTEGER RANGE\n                                  Minimum number of samples to form a cluster\n                                  env var: DETECTOR_CLUSTER_MIN_SAMPLES\n                                  default: 4; 1&lt;=x&lt;=20\n\n  --cluster-eps FLOAT RANGE       Maximum distance between two samples to form a cluster (mm)\n                                  env var: DETECTOR_CLUSTER_EPS\n                                  default: 40.0; 1.0&lt;=x&lt;=100.0\n\n  -g, --gui                       Launch the GUI.\n                                  env var: DETECTOR_GUI\n\n  -w, --web                       Launch the web server.\n                                  env var: DETECTOR_WEB\n\n  -r, --reload                    Reload app on source file changes.\n                                  env var: COGIP_RELOAD, DETECTOR_RELOAD\n\n  -d, --debug                     Turn on debug messages.\n                                  env var: COGIP_DEBUG, DETECTOR_DEBUG\n</code></pre>"},{"location":"usage/monitor/","title":"Monitor","text":"<p>The <code>Monitor</code> is used to monitor the robot behavior during the game.</p> <p>It communicates on the <code>/monitor</code> and <code>/dashboard</code> namespaces of the SocketIO server from the <code>cogip-server</code> tool.</p> <p>In emulation mode, it also uses Shared Memory to write Lidar data and read dynamic obstacles.</p> <p>Only one <code>Monitor</code> can be connected to the SocketIO server at the same time.</p> <p>It can also provide fake Lidar data to <code>Detector</code> in emulation mode.</p> <p>The monitor provides a graphical interface, featuring:</p> <ul> <li> <p>a 3D view of the table and the robot</p> </li> <li> <p>a menu giving access to the tools menus</p> </li> <li> <p>a button to add virtual obstacles (in orange) which can be moved and resized</p> </li> <li> <p>save and load virtual obstacles using JSON files</p> </li> <li> <p>visualization of LIDAR (red dots) sensors detections</p> </li> <li> <p>visualization of fix and dynamic obstacles (in transparent red)</p> </li> <li> <p>different artifacts depending of current game rules</p> </li> </ul> <p></p>"},{"location":"usage/monitor/#data-flow","title":"Data Flow","text":""},{"location":"usage/monitor/#run-monitor","title":"Run Monitor","text":"<p>To connect the <code>Monitor</code> to the <code>Server</code> running on the same development PC, run:</p> <pre><code>cogip-monitor http://localhost:8091\n</code></pre> <p>To connect the <code>Monitor</code> to the <code>Server</code> running on the Raspberry Pi in the robot, run:</p> <pre><code>cogip-monitor http://robot1:8091\n</code></pre> <p>Adapt URL and port depending on <code>Server</code> configuration</p>"},{"location":"usage/monitor/#command-line-options","title":"Command line options","text":"<pre><code>$ cogip-monitor --help\nUsage: cogip-monitor [URL]\n\n  Launch COGIP Monitor.\n\nArguments:\n  [URL]        Socket.IO Server URL\n               env var: COGIP_SOCKETIO_SERVER_URL\n               default: http://localhost:8091\n</code></pre>"},{"location":"usage/planner/","title":"Planner","text":"<p>The <code>Planner</code> tool is running on the Raspberry Pi embedded in the central beacon.</p> <p>It is in charge computing the strategy and giving orders to the robot during the game.</p> <p>It communicates on the <code>/planner</code> namespace of the SocketIO server.</p>"},{"location":"usage/planner/#data-flow","title":"Data Flow","text":""},{"location":"usage/planner/#run-planner","title":"Run Planner","text":"<pre><code>$ cogip-planner\n</code></pre>"},{"location":"usage/planner/#parameters","title":"Parameters","text":"<p><code>Planner</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-planner --help\nUsage: cogip-planner [OPTIONS]\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID\n                                  default: 1; x&gt;=1\n\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  --obstacle-radius INTEGER       Radius of a dynamic obstacle\n                                  env var: PLANNER_OBSTACLE_RADIUS\n                                  default: 500\n\n  --obstacle-bb-margin FLOAT      Obstacle bounding box margin in percent of the radius\n                                  env var: PLANNER_OBSTACLE_BB_MARGIN\n                                  default: 0.2\n\n  --obstacle-bb-vertices INTEGER  Number of obstacle bounding box vertices\n                                  env var: PLANNER_OBSTACLE_BB_VERTICES\n                                  default: 6\n\n  --obstacle-updater-interval FLOAT\n                                  Interval between each obstacles list update (in seconds)\n                                  env var: PLANNER_OBSTACLE_UPDATER_INTERVAL\n                                  default: 0.2\n\n  --path-refresh-interval FLOAT   Interval between each update of robot paths (in seconds)\n                                  env var: PLANNER_PATH_REFRESH_INTERVAL\n                                  default: 0.2\n\n  -bd, --bypass-detector          Use perfect obstacles from monitor instead of detected obstacles by Lidar\n                                  env var: PLANNER_BYPASS_DETECTOR\n                                  default: False\n\n  -sp, --scservos-port PATH       SC Servos serial port\n                                  env var: PLANNER_SCSERVOS_PORT\n                                  default: None\n\n  -sb, --scservos-baud-rate INTEGER\n                                  SC Servos baud rate (usually 921600 or 1000000)\n                                  env var: PLANNER_SCSERVOS_BAUD_RATE\n                                  default: 921600\n\n  -df, --scservos-baud-rate       Disable fixed obstacles. Useful to work on Lidar obstacles and avoidance.\n                                  env var: PLANNER_DISABLE_FIXED_OBSTACLES\n                                  default: False\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, PLANNER_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, PLANNER_DEBUG\n</code></pre>"},{"location":"usage/replay/","title":"Replay","text":"<p>The replay tool is used to replay a game from a trace file.</p> <p></p> <p>After installation (see Install), the replay tool is launched with:</p> <pre><code>$ cogip-replay\n</code></pre> <p>The replay tool is used to replay a game from a trace file.</p>"},{"location":"usage/replay/#command-line-options","title":"Command line options","text":"<pre><code>$ $ cogip-replay --help\nUsage: cogip-replay [OPTIONS] [TRACE_FILE]\n\n  Starts replay.\n\nArguments:\n  [TRACE_FILE]\n\nOptions:\n  --help                          Show this message and exit.\n</code></pre> <p>The trace file can be given on the command line or loaded from the UI.</p>"},{"location":"usage/robotcam/","title":"RobotCam","text":"<p>The <code>RobotCam</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates on the <code>/robotcam</code> namespace of the SocketIO server running on the central beacon over Wifi.</p> <p>It handles the robot camera, detect game elements using Aruco markers and stream the video to a web server.</p> <p>The web server listen on port <code>8100 + robot_id</code>, ie <code>8100</code> on the beacon or <code>8101</code> on robot 1.</p>"},{"location":"usage/robotcam/#run-robotcam","title":"Run RobotCam","text":"<pre><code>$ cogip-robocam\n</code></pre>"},{"location":"usage/robotcam/#parameters","title":"Parameters","text":"<p>RobotCam default parameters can be modified using environment variables. All variables can be defined in the <code>.env</code> file.</p> <p>Example of <code>.env</code> file with all default values:</p> <pre><code># Socket.IO Server URL\nCOGIP_SOCKETIO_SERVER_URL=\"http://localhost:8091\"\n\n# Robot ID\nROBOTCAM_ID=1\n\n# Camera name\nROBOTCAM_CAMERA_NAME=\"hbv\"\n\n# Camera frame width\nROBOTCAM_CAMERA_WIDTH=640\n\n# Camera frame height\nROBOTCAM_CAMERA_HEIGHT=480\n\n# Camera video codec\nROBOTCAM_CAMERA_CODEC=\"yuyv\"\n\n# Number of uvicorn workers (ignored if launched by gunicorn)\nROBOTCAM_NB_WORKERS=1\n\n# Size of the shared memory storing the last frame to stream on server\n# (size for a frame in BMP format, black and white, 640x480 pixels)\nROBOTCAM_FRAME_SIZE=308316\n</code></pre>"},{"location":"usage/server/","title":"Server","text":"<p>The <code>Server</code> tool is running on the Raspberry Pi embedded in a robot.</p> <p>It implements a Socket.IO server on which all other tools from robot and central beacon are connected on their own namespace. This server is only used to redirect messages from a tool to another.</p> <p>The Socket.IO server listen on port <code>8090 + robot_id</code>, ie <code>8091</code> on robot 1.</p>"},{"location":"usage/server/#run-server","title":"Run Server","text":"<pre><code>$ cogip-server\n</code></pre>"},{"location":"usage/server/#parameters","title":"Parameters","text":"<p><code>Server</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-server --help\nUsage: cogip-server [OPTIONS]\n\n  --id , -i INTEGER RANGE         Robot ID\n                                  env var: ROBOT_ID, SERVER_ID\n                                  default: 0; 0&lt;=x&lt;=9\n\n  --dashboard_update_interval FLOAT RANGE\n                                  Interval between messages to dashboard (in seconds)\n                                  env var: SERVER_DASHBOARD_UPDATE_INTERVAL\n                                  default: 0.2\n\n  --record-dir PATH               Directory where games will be recorded\n                                  env var: SERVER_RECORD_DIR\n                                  default: /var/tmp/cogip\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, PLANNER_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, PLANNER_DEBUG\n</code></pre>"},{"location":"usage/server_beacon/","title":"Beacon Server","text":"<p>The <code>Beacon Server</code> tool is running on the Raspberry Pi embedded in the central beacon.</p> <p>It implements a Socket.IO server connected to the <code>Beacon Dashboard</code>.</p> <p>The Socket.IO server listens on port <code>8090</code>.</p> <p>It also implements Socket.IO clients connected to the Socket.IO server of each robot.</p> <p>Socket.IO clients consider that robot hostnames are <code>robot1</code> to <code>robotN</code>, resolved by the DNS server or defined in <code>/etc/hosts</code> and their ports are <code>8090 + robot_id</code>.</p>"},{"location":"usage/server_beacon/#run-server","title":"Run Server","text":"<pre><code>$ cogip-server-beacon\n</code></pre>"},{"location":"usage/server_beacon/#parameters","title":"Parameters","text":"<p><code>Beacon Server</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-server --help\nUsage: cogip-server [OPTIONS]\n\n  --max-robots                    Maximum number of robots to detect (from 1 to max)\n                                  env var: SERVER_BEACON_MAX_ROBOTS\n                                  default: 4; x&gt;=1\n\n  --record-dir PATH               Directory where games will be recorded\n                                  env var: SERVER_BEACON_RECORD_DIR\n                                  default: /var/tmp/cogip\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, SERVER_BEACON_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, SERVER_BEACON_DEBUG\n</code></pre>"}]}